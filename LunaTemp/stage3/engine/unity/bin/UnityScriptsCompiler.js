if ( TRACE ) { TRACE( JSON.parse( '["AnimatedButton#onClick#get","AnimatedButton#onClick#set","AnimatedButton#init","AnimatedButton#OnPointerDown","AnimatedButton#Press","AnimatedButton#OnClickAction","AnimatedButton#OnPointerUp","AnimatedButton#OnPointerClick","AudioClipsHolder#init","AudioClipsHolder#Start","AudioClipsHolder#TryGetAudioClip","AudioManager#Awake","AudioManager#PlayWinSound","AudioManager#PlayContifieSound","AudioManager#winUI","AudioManager#PlayWoodDestroySound","AutoDestroy#init","AutoDestroy#OnEnable","AutoDestroy#DestroyObj","Bar#HasDone#get","Bar#HasDone#set","Bar#init","Bar#Start","Bar#SetState","Bar#SetState$1","Bar#AddBolt","Bar#RemoveBolt","Bar#FixedUpdate","Bar#Done","Bar#GetAmountBolt","Bar#Explosion","Bar#OnCollisionEnter2D","Bar#Init","Bar#Simulate","Bar#OnTriggerEnter2D","Bar#Destroy$1","BarHole#OnValidate","BarHole#Start","BarHole#ActiveGraphic","BarHole#Match","BoardHole#Start","BoardHole#Unlock","BoardHole#Reward","Bolt#init","Bolt#OnValidate","Bolt#Start","Bolt#Screw","Bolt#UnScrew","Bolt#MoveTo","Bolt#MoveToCoroutine","Bolt#Position","Bolt#Lock","Bolt#Unlock","Bolt#Explosion","CameraDistanceConfig#Awake","CameraDistanceConfig#SaveData","CameraDistanceConfig#ResizeCamera","Singleton$1#Instance#get","Singleton$1#init","Singleton$1#init","Singleton$1#Awake","DG.Tweening.DOTweenCYInstruction.WaitForCompletion#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForCompletion#ctor","DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops#ctor","DG.Tweening.DOTweenCYInstruction.WaitForKill#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForKill#ctor","DG.Tweening.DOTweenCYInstruction.WaitForPosition#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForPosition#ctor","DG.Tweening.DOTweenCYInstruction.WaitForRewind#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForRewind#ctor","DG.Tweening.DOTweenCYInstruction.WaitForStart#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForStart#ctor","DG.Tweening.DOTweenModuleAudio#DOFade","DG.Tweening.DOTweenModuleAudio#DOPitch","DG.Tweening.DOTweenModuleAudio#DOSetFloat","DG.Tweening.DOTweenModuleAudio#DOComplete","DG.Tweening.DOTweenModuleAudio#DOKill","DG.Tweening.DOTweenModuleAudio#DOFlip","DG.Tweening.DOTweenModuleAudio#DOGoto","DG.Tweening.DOTweenModuleAudio#DOPause","DG.Tweening.DOTweenModuleAudio#DOPlay","DG.Tweening.DOTweenModuleAudio#DOPlayBackwards","DG.Tweening.DOTweenModuleAudio#DOPlayForward","DG.Tweening.DOTweenModuleAudio#DORestart","DG.Tweening.DOTweenModuleAudio#DORewind","DG.Tweening.DOTweenModuleAudio#DOSmoothRewind","DG.Tweening.DOTweenModuleAudio#DOTogglePause","DG.Tweening.DOTweenModulePhysics#DOMove","DG.Tweening.DOTweenModulePhysics#DOMoveX","DG.Tweening.DOTweenModulePhysics#DOMoveY","DG.Tweening.DOTweenModulePhysics#DOMoveZ","DG.Tweening.DOTweenModulePhysics#DORotate","DG.Tweening.DOTweenModulePhysics#DOLookAt","DG.Tweening.DOTweenModulePhysics#DOJump","DG.Tweening.DOTweenModulePhysics#DOPath","DG.Tweening.DOTweenModulePhysics#DOPath$1","DG.Tweening.DOTweenModulePhysics#DOLocalPath","DG.Tweening.DOTweenModulePhysics#DOLocalPath$1","DG.Tweening.DOTweenModulePhysics2D#DOMove","DG.Tweening.DOTweenModulePhysics2D#DOMoveX","DG.Tweening.DOTweenModulePhysics2D#DOMoveY","DG.Tweening.DOTweenModulePhysics2D#DORotate","DG.Tweening.DOTweenModulePhysics2D#DOJump","DG.Tweening.DOTweenModulePhysics2D#DOPath","DG.Tweening.DOTweenModulePhysics2D#DOPath$1","DG.Tweening.DOTweenModulePhysics2D#DOLocalPath","DG.Tweening.DOTweenModulePhysics2D#DOLocalPath$1","DG.Tweening.DOTweenModuleSprite#DOColor","DG.Tweening.DOTweenModuleSprite#DOFade","DG.Tweening.DOTweenModuleSprite#DOGradientColor","DG.Tweening.DOTweenModuleSprite#DOBlendableColor","DG.Tweening.DOTweenModuleUI#DOFade","DG.Tweening.DOTweenModuleUI#DOFade$1","DG.Tweening.DOTweenModuleUI#DOFade$2","DG.Tweening.DOTweenModuleUI#DOFade$3","DG.Tweening.DOTweenModuleUI#DOFade$4","DG.Tweening.DOTweenModuleUI#DOColor","DG.Tweening.DOTweenModuleUI#DOColor$1","DG.Tweening.DOTweenModuleUI#DOColor$2","DG.Tweening.DOTweenModuleUI#DOColor$3","DG.Tweening.DOTweenModuleUI#DOFillAmount","DG.Tweening.DOTweenModuleUI#DOGradientColor","DG.Tweening.DOTweenModuleUI#DOFlexibleSize","DG.Tweening.DOTweenModuleUI#DOMinSize","DG.Tweening.DOTweenModuleUI#DOPreferredSize","DG.Tweening.DOTweenModuleUI#DOScale","DG.Tweening.DOTweenModuleUI#DOAnchorPos","DG.Tweening.DOTweenModuleUI#DOAnchorPosX","DG.Tweening.DOTweenModuleUI#DOAnchorPosY","DG.Tweening.DOTweenModuleUI#DOAnchorPos3D","DG.Tweening.DOTweenModuleUI#DOAnchorPos3DX","DG.Tweening.DOTweenModuleUI#DOAnchorPos3DY","DG.Tweening.DOTweenModuleUI#DOAnchorPos3DZ","DG.Tweening.DOTweenModuleUI#DOAnchorMax","DG.Tweening.DOTweenModuleUI#DOAnchorMin","DG.Tweening.DOTweenModuleUI#DOPivot","DG.Tweening.DOTweenModuleUI#DOPivotX","DG.Tweening.DOTweenModuleUI#DOPivotY","DG.Tweening.DOTweenModuleUI#DOSizeDelta","DG.Tweening.DOTweenModuleUI#DOPunchAnchorPos","DG.Tweening.DOTweenModuleUI#DOShakeAnchorPos","DG.Tweening.DOTweenModuleUI#DOShakeAnchorPos$1","DG.Tweening.DOTweenModuleUI#DOJumpAnchorPos","DG.Tweening.DOTweenModuleUI#DONormalizedPos","DG.Tweening.DOTweenModuleUI#DOHorizontalNormalizedPos","DG.Tweening.DOTweenModuleUI#DOVerticalNormalizedPos","DG.Tweening.DOTweenModuleUI#DOValue","DG.Tweening.DOTweenModuleUI#DOCounter","DG.Tweening.DOTweenModuleUI#DOText","DG.Tweening.DOTweenModuleUI#DOBlendableColor","DG.Tweening.DOTweenModuleUI#DOBlendableColor$1","DG.Tweening.DOTweenModuleUI#DOBlendableColor$2","DG.Tweening.DOTweenModuleUI#DOShapeCircle","DG.Tweening.DOTweenModuleUI.Utils#SwitchToRectTransform","DG.Tweening.DOTweenModuleUnityVersion#DOGradientColor","DG.Tweening.DOTweenModuleUnityVersion#DOGradientColor$1","DG.Tweening.DOTweenModuleUnityVersion#WaitForCompletion","DG.Tweening.DOTweenModuleUnityVersion#WaitForRewind","DG.Tweening.DOTweenModuleUnityVersion#WaitForKill","DG.Tweening.DOTweenModuleUnityVersion#WaitForElapsedLoops","DG.Tweening.DOTweenModuleUnityVersion#WaitForPosition","DG.Tweening.DOTweenModuleUnityVersion#WaitForStart","DG.Tweening.DOTweenModuleUnityVersion#DOOffset","DG.Tweening.DOTweenModuleUnityVersion#DOTiling","DG.Tweening.DOTweenModuleUtils#Init","DG.Tweening.DOTweenModuleUtils#Preserver","DG.Tweening.DOTweenModuleUtils.Physics#SetOrientationOnPath","DG.Tweening.DOTweenModuleUtils.Physics#HasRigidbody2D","DG.Tweening.DOTweenModuleUtils.Physics#HasRigidbody","DG.Tweening.DOTweenModuleUtils.Physics#CreateDOTweenPathTween","GameplayVariables#init","Hint#init","Hint#Start","Hint#ActivateDeactivateObject","Hint#Update","IngameTutorial#Awake","IngameTutorial#Start","IngameTutorial#SetTutorial","IngameTutorial#Update","Key#Active","LevelController#init","LevelController#Awake","LevelController#Start","LevelController#ScrewBar","LevelController#CheckOutMove","LevelController#Update","LevelController#UpdateState","LevelController#RecycleLevel","LevelController.StateBar#init","LevelController.StateBar#ctor","LevelController.StateBoardHole#ctor","LevelController.StateBolt#init","LevelController.StateBolt#ctor","LoadEndcard#Awake","LoadEndcard#loadscene77","LoadingManager#Start","LoadingManager#RegisterPurchaseComplete","LoadingManager#LoadSceneStart","LoadingManager#LoadData","LoadingManager#LoadAsyncGame","LoadingManager#PressedRetryBtn","ObjectPool#instance#get","ObjectPool#init","ObjectPool#CreateStartupPools","ObjectPool#CreatePool$1","ObjectPool#CreatePool","ObjectPool#Spawn$3","ObjectPool#Spawn$5","ObjectPool#Spawn$2","ObjectPool#Spawn$4","ObjectPool#Spawn$1","ObjectPool#Spawn","ObjectPool#Spawn$9","ObjectPool#Spawn$8","ObjectPool#Spawn$11","ObjectPool#Spawn$7","ObjectPool#Spawn$10","ObjectPool#Spawn$6","ObjectPool#Recycle$1","ObjectPool#Recycle","ObjectPool#Recycle$2","ObjectPool#RecycleAll$2","ObjectPool#RecycleAll$1","ObjectPool#RecycleAll","ObjectPool#IsSpawned","ObjectPool#CountPooled$1","ObjectPool#CountPooled","ObjectPool#CountSpawned$1","ObjectPool#CountSpawned","ObjectPool#CountAllPooled","ObjectPool#GetPooled$1","ObjectPool#GetPooled","ObjectPool#GetSpawned$1","ObjectPool#GetSpawned","ObjectPool#DestroyPooled","ObjectPool#DestroyPooled$1","ObjectPool#DestroyAll","ObjectPool#DestroyAll$1","ObjectPool#init","ObjectPool#Awake","ObjectPool#Start","ObjectPoolExtensions#CreatePool$2","ObjectPoolExtensions#CreatePool$3","ObjectPoolExtensions#CreatePool","ObjectPoolExtensions#CreatePool$1","ObjectPoolExtensions#Spawn$3","ObjectPoolExtensions#Spawn$5","ObjectPoolExtensions#Spawn$2","ObjectPoolExtensions#Spawn$4","ObjectPoolExtensions#Spawn$1","ObjectPoolExtensions#Spawn","ObjectPoolExtensions#Spawn$9","ObjectPoolExtensions#Spawn$11","ObjectPoolExtensions#Spawn$8","ObjectPoolExtensions#Spawn$10","ObjectPoolExtensions#Spawn$7","ObjectPoolExtensions#Spawn$6","ObjectPoolExtensions#Recycle$1","ObjectPoolExtensions#Recycle","ObjectPoolExtensions#RecycleAll$1","ObjectPoolExtensions#RecycleAll","ObjectPoolExtensions#CountPooled$1","ObjectPoolExtensions#CountPooled","ObjectPoolExtensions#CountSpawned$1","ObjectPoolExtensions#CountSpawned","ObjectPoolExtensions#GetSpawned$5","ObjectPoolExtensions#GetSpawned$4","ObjectPoolExtensions#GetSpawned$3","ObjectPoolExtensions#GetSpawned$2","ObjectPoolExtensions#GetSpawned$1","ObjectPoolExtensions#GetSpawned","ObjectPoolExtensions#GetPooled$5","ObjectPoolExtensions#GetPooled$4","ObjectPoolExtensions#GetPooled$3","ObjectPoolExtensions#GetPooled$2","ObjectPoolExtensions#GetPooled$1","ObjectPoolExtensions#GetPooled","ObjectPoolExtensions#DestroyPooled","ObjectPoolExtensions#DestroyPooled$1","ObjectPoolExtensions#DestroyAll","ObjectPoolExtensions#DestroyAll$1","Saw#Start","Saw#OnTriggerEnter2D","Saw#DeactiveAnimation","Saw#OnTriggerExit2D","SharpJson.JsonDecoder#DecodeText","SharpJson.JsonDecoder#ctor","SharpJson.JsonDecoder#Decode","SharpJson.JsonDecoder#ParseObject","SharpJson.JsonDecoder#ParseArray","SharpJson.JsonDecoder#ParseValue","SharpJson.JsonDecoder#TriggerError","SharpJson.JsonDecoder#EvalLexer","SharpJson.Lexer#NextToken","SharpJson.Lexer#hasError#get","SharpJson.Lexer#init","SharpJson.Lexer#ctor","SharpJson.Lexer#Reset","SharpJson.Lexer#ParseString","SharpJson.Lexer#GetNumberString","SharpJson.Lexer#ParseFloatNumber","SharpJson.Lexer#ParseDoubleNumber","SharpJson.Lexer#GetLastIndexOfNumber","SharpJson.Lexer#SkipWhiteSpaces","SharpJson.Lexer#LookAhead","SharpJson.Lexer#NextToken","ShuffleExtension#Shuffle","ShuffleExtension#Shuffle$1","SoundManager#init","SoundManager#InitInstance","SoundManager#init","SoundManager#LoadAudioHolder","SoundManager#Start","SoundManager#Update","SoundManager#OnDestroy","SoundManager#OnMusicChanged","SoundManager#PlayBGMusic","SoundManager#LoadMusicClip","SoundManager#StopBGMusic","SoundManager#ResumeBGMusic","SoundManager#SetBGVol","SoundManager#GetBGVol","SoundManager#PlayOrderedBgm","SoundManager#StopOrderedBgm","SoundManager#DoPlayOrderedBgm","SoundManager#GetCatchedAudioClip","SoundManager#PauseSoundMedium","SoundManager#UnpauseSoundMedium","SoundManager#StopSoundMedium","SoundManager#PlaySoundMedium","SoundManager#PlaySound","SoundManager#PlaySound$1","SoundManager#PlaySoundDelay","SoundManager#SetStartTime","Spine.Timeline#Search","Spine.Timeline#Search$1","Spine.Timeline#PropertyIds#get","Spine.Timeline#Frames#get","Spine.Timeline#FrameEntries#get","Spine.Timeline#FrameCount#get","Spine.Timeline#Duration#get","Spine.Timeline#ctor","Spine.Animation#Timelines#get","Spine.Animation#Timelines#set","Spine.Animation#Duration#get","Spine.Animation#Duration#set","Spine.Animation#Name#get","Spine.Animation#ctor","Spine.Animation#SetTimelines","Spine.Animation#HasTimeline","Spine.Animation#Apply","Spine.Animation#toString","Spine.AnimationState#init","Spine.AnimationState#ApplyRotateTimeline","Spine.AnimationState#TimeScale#get","Spine.AnimationState#TimeScale#set","Spine.AnimationState#Data#get","Spine.AnimationState#Data#set","Spine.AnimationState#Tracks#get","Spine.AnimationState#init","Spine.AnimationState#ctor","Spine.AnimationState#OnStart","Spine.AnimationState#OnInterrupt","Spine.AnimationState#OnEnd","Spine.AnimationState#OnDispose","Spine.AnimationState#OnComplete","Spine.AnimationState#OnEvent","Spine.AnimationState#AssignEventSubscribersFrom","Spine.AnimationState#AddEventSubscribersFrom","Spine.AnimationState#Update","Spine.AnimationState#UpdateMixingFrom","Spine.AnimationState#Apply","Spine.AnimationState#ApplyEventTimelinesOnly","Spine.AnimationState#ApplyMixingFrom","Spine.AnimationState#ApplyMixingFromEventTimelinesOnly","Spine.AnimationState#ApplyAttachmentTimeline","Spine.AnimationState#SetAttachment","Spine.AnimationState#QueueEvents","Spine.AnimationState#ClearTracks","Spine.AnimationState#ClearTrack","Spine.AnimationState#SetCurrent","Spine.AnimationState#SetAnimation$1","Spine.AnimationState#SetAnimation","Spine.AnimationState#AddAnimation$1","Spine.AnimationState#AddAnimation","Spine.AnimationState#SetEmptyAnimation","Spine.AnimationState#AddEmptyAnimation","Spine.AnimationState#SetEmptyAnimations","Spine.AnimationState#ExpandToIndex","Spine.AnimationState#NewTrackEntry","Spine.AnimationState#ClearNext","Spine.AnimationState#AnimationsChanged","Spine.AnimationState#ComputeHold","Spine.AnimationState#GetCurrent","Spine.AnimationState#ClearListenerNotifications","Spine.AnimationState#toString","Spine.AnimationStateData#SkeletonData#get","Spine.AnimationStateData#DefaultMix#get","Spine.AnimationStateData#DefaultMix#set","Spine.AnimationStateData#init","Spine.AnimationStateData#ctor","Spine.AnimationStateData#SetMix$1","Spine.AnimationStateData#SetMix","Spine.AnimationStateData#GetMix","Spine.AnimationStateData.AnimationPair#getDefaultValue","Spine.AnimationStateData.AnimationPair#$ctor1","Spine.AnimationStateData.AnimationPair#ctor","Spine.AnimationStateData.AnimationPair#toString","Spine.AnimationStateData.AnimationPair#getHashCode","Spine.AnimationStateData.AnimationPair#equals","Spine.AnimationStateData.AnimationPair#$clone","Spine.TextureRegion#OriginalWidth#get","Spine.TextureRegion#OriginalHeight#get","Spine.AtlasPage#init","Spine.AtlasPage#Clone","Spine.Attachment#$ctor1","Spine.Attachment#ctor","Spine.Attachment#toString","Spine.BoneData#Index#get","Spine.BoneData#Name#get","Spine.BoneData#Parent#get","Spine.BoneData#Length#get","Spine.BoneData#Length#set","Spine.BoneData#X#get","Spine.BoneData#X#set","Spine.BoneData#Y#get","Spine.BoneData#Y#set","Spine.BoneData#Rotation#get","Spine.BoneData#Rotation#set","Spine.BoneData#ScaleX#get","Spine.BoneData#ScaleX#set","Spine.BoneData#ScaleY#get","Spine.BoneData#ScaleY#set","Spine.BoneData#ShearX#get","Spine.BoneData#ShearX#set","Spine.BoneData#ShearY#get","Spine.BoneData#ShearY#set","Spine.BoneData#Inherit#get","Spine.BoneData#Inherit#set","Spine.BoneData#SkinRequired#get","Spine.BoneData#SkinRequired#set","Spine.BoneData#init","Spine.BoneData#ctor","Spine.BoneData#toString","Spine.BoneMatrix#CalculateSetupWorld","Spine.BoneMatrix#GetInheritedInternal","Spine.BoneMatrix#getDefaultValue","Spine.BoneMatrix#$ctor2","Spine.BoneMatrix#$ctor1","Spine.BoneMatrix#ctor","Spine.BoneMatrix#TransformMatrix","Spine.BoneMatrix#getHashCode","Spine.BoneMatrix#equals","Spine.BoneMatrix#$clone","Spine.ConstraintData#Name#get","Spine.ConstraintData#Order#get","Spine.ConstraintData#Order#set","Spine.ConstraintData#SkinRequired#get","Spine.ConstraintData#SkinRequired#set","Spine.ConstraintData#ctor","Spine.ConstraintData#toString","Spine.Event#Data#get","Spine.Event#Time#get","Spine.Event#Int#get","Spine.Event#Int#set","Spine.Event#Float#get","Spine.Event#Float#set","Spine.Event#String#get","Spine.Event#String#set","Spine.Event#Volume#get","Spine.Event#Volume#set","Spine.Event#Balance#get","Spine.Event#Balance#set","Spine.Event#ctor","Spine.Event#toString","Spine.EventData#Name#get","Spine.EventData#ctor","Spine.EventData#toString","Spine.EventQueue#init","Spine.EventQueue#ctor","Spine.EventQueue#Start","Spine.EventQueue#Interrupt","Spine.EventQueue#End","Spine.EventQueue#Dispose","Spine.EventQueue#Complete","Spine.EventQueue#Event","Spine.EventQueue#Drain","Spine.EventQueue#Clear","Spine.EventQueue.EventQueueEntry#getDefaultValue","Spine.EventQueue.EventQueueEntry#$ctor1","Spine.EventQueue.EventQueueEntry#ctor","Spine.EventQueue.EventQueueEntry#getHashCode","Spine.EventQueue.EventQueueEntry#equals","Spine.EventQueue.EventQueueEntry#$clone","Spine.ExposedList$1#init","Spine.ExposedList$1#CheckMatch","Spine.ExposedList$1#Capacity#get","Spine.ExposedList$1#Capacity#set","Spine.ExposedList$1#ctor","Spine.ExposedList$1#$ctor2","Spine.ExposedList$1#$ctor3","Spine.ExposedList$1#$ctor1","Spine.ExposedList$1#Add","Spine.ExposedList$1#GrowIfNeeded","Spine.ExposedList$1#Resize","Spine.ExposedList$1#EnsureCapacity","Spine.ExposedList$1#CheckRange","Spine.ExposedList$1#AddCollection","Spine.ExposedList$1#AddEnumerable","Spine.ExposedList$1#AddRange","Spine.ExposedList$1#AddRange$1","Spine.ExposedList$1#BinarySearch","Spine.ExposedList$1#BinarySearch$1","Spine.ExposedList$1#BinarySearch$2","Spine.ExposedList$1#Clear","Spine.ExposedList$1#Contains","Spine.ExposedList$1#ConvertAll","Spine.ExposedList$1#CopyTo","Spine.ExposedList$1#CopyTo$1","Spine.ExposedList$1#CopyTo$2","Spine.ExposedList$1#Exists","Spine.ExposedList$1#Find","Spine.ExposedList$1#FindAll","Spine.ExposedList$1#FindAllList","Spine.ExposedList$1#FindIndex$2","Spine.ExposedList$1#FindIndex$1","Spine.ExposedList$1#FindIndex","Spine.ExposedList$1#GetIndex","Spine.ExposedList$1#FindLast","Spine.ExposedList$1#FindLastIndex$2","Spine.ExposedList$1#FindLastIndex$1","Spine.ExposedList$1#FindLastIndex","Spine.ExposedList$1#GetLastIndex","Spine.ExposedList$1#ForEach","Spine.ExposedList$1#GetEnumerator","Spine.ExposedList$1#System$Collections$Generic$IEnumerable$1$GetEnumerator","Spine.ExposedList$1#System$Collections$IEnumerable$GetEnumerator","Spine.ExposedList$1#GetRange","Spine.ExposedList$1#IndexOf","Spine.ExposedList$1#IndexOf$1","Spine.ExposedList$1#IndexOf$2","Spine.ExposedList$1#Shift","Spine.ExposedList$1#CheckIndex","Spine.ExposedList$1#Insert","Spine.ExposedList$1#CheckCollection","Spine.ExposedList$1#InsertRange","Spine.ExposedList$1#InsertCollection","Spine.ExposedList$1#InsertEnumeration","Spine.ExposedList$1#LastIndexOf","Spine.ExposedList$1#LastIndexOf$1","Spine.ExposedList$1#LastIndexOf$2","Spine.ExposedList$1#Remove","Spine.ExposedList$1#RemoveAll","Spine.ExposedList$1#RemoveAt","Spine.ExposedList$1#Pop","Spine.ExposedList$1#RemoveRange","Spine.ExposedList$1#Reverse","Spine.ExposedList$1#Reverse$1","Spine.ExposedList$1#Sort","Spine.ExposedList$1#Sort$1","Spine.ExposedList$1#Sort$2","Spine.ExposedList$1#Sort$3","Spine.ExposedList$1#ToArray","Spine.ExposedList$1#TrimExcess","Spine.ExposedList$1#TrueForAll","Spine.ExposedList$1.Enumerator#getDefaultValue","Spine.ExposedList$1.Enumerator#Current#get","Spine.ExposedList$1.Enumerator#System$Collections$IEnumerator$Current#get","Spine.ExposedList$1.Enumerator#init","Spine.ExposedList$1.Enumerator#$ctor1","Spine.ExposedList$1.Enumerator#ctor","Spine.ExposedList$1.Enumerator#Dispose","Spine.ExposedList$1.Enumerator#VerifyState","Spine.ExposedList$1.Enumerator#moveNext","Spine.ExposedList$1.Enumerator#System$Collections$IEnumerator$reset","Spine.ExposedList$1.Enumerator#getHashCode","Spine.ExposedList$1.Enumerator#equals","Spine.ExposedList$1.Enumerator#$clone","Spine.HashSetExtensions#AddAll","Spine.IInterpolation#init","Spine.IInterpolation#Apply","Spine.InheritEnum#init","Spine.Json#Deserialize","Spine.MathUtils#init","Spine.MathUtils#Sin","Spine.MathUtils#Cos","Spine.MathUtils#SinDeg","Spine.MathUtils#CosDeg","Spine.MathUtils#Atan2Deg","Spine.MathUtils#Atan2","Spine.MathUtils#Clamp","Spine.MathUtils#RandomTriangle","Spine.MathUtils#RandomTriangle$1","Spine.Polygon#ctor","Spine.Pool$1#Count#get","Spine.Pool$1#ctor","Spine.Pool$1#Obtain","Spine.Pool$1#Free","Spine.Pool$1#Clear","Spine.Pool$1#Reset","Spine.Sequence#init","Spine.Sequence#Start#get","Spine.Sequence#Start#set","Spine.Sequence#Digits#get","Spine.Sequence#Digits#set","Spine.Sequence#SetupIndex#get","Spine.Sequence#SetupIndex#set","Spine.Sequence#Regions#get","Spine.Sequence#Id#get","Spine.Sequence#$ctor1","Spine.Sequence#ctor","Spine.Sequence#Apply","Spine.Sequence#GetPath","Spine.Skeleton#init","Spine.Skeleton#SortReset","Spine.Skeleton#Data#get","Spine.Skeleton#Bones#get","Spine.Skeleton#UpdateCacheList#get","Spine.Skeleton#Slots#get","Spine.Skeleton#DrawOrder#get","Spine.Skeleton#IkConstraints#get","Spine.Skeleton#PathConstraints#get","Spine.Skeleton#PhysicsConstraints#get","Spine.Skeleton#TransformConstraints#get","Spine.Skeleton#Skin#get","Spine.Skeleton#Skin#set","Spine.Skeleton#R#get","Spine.Skeleton#R#set","Spine.Skeleton#G#get","Spine.Skeleton#G#set","Spine.Skeleton#B#get","Spine.Skeleton#B#set","Spine.Skeleton#A#get","Spine.Skeleton#A#set","Spine.Skeleton#X#get","Spine.Skeleton#X#set","Spine.Skeleton#Y#get","Spine.Skeleton#Y#set","Spine.Skeleton#ScaleX#get","Spine.Skeleton#ScaleX#set","Spine.Skeleton#ScaleY#get","Spine.Skeleton#ScaleY#set","Spine.Skeleton#FlipX#get","Spine.Skeleton#FlipX#set","Spine.Skeleton#FlipY#get","Spine.Skeleton#FlipY#set","Spine.Skeleton#Time#get","Spine.Skeleton#Time#set","Spine.Skeleton#RootBone#get","Spine.Skeleton#init","Spine.Skeleton#$ctor1","Spine.Skeleton#ctor","Spine.Skeleton#UpdateCache","Spine.Skeleton#SortIkConstraint","Spine.Skeleton#SortTransformConstraint","Spine.Skeleton#SortPathConstraint","Spine.Skeleton#SortPathConstraintAttachment$1","Spine.Skeleton#SortPathConstraintAttachment","Spine.Skeleton#SortPhysicsConstraint","Spine.Skeleton#SortBone","Spine.Skeleton#UpdateWorldTransform","Spine.Skeleton#UpdateWorldTransform$1","Spine.Skeleton#PhysicsTranslate","Spine.Skeleton#PhysicsRotate","Spine.Skeleton#Update","Spine.Skeleton#SetToSetupPose","Spine.Skeleton#SetBonesToSetupPose","Spine.Skeleton#SetSlotsToSetupPose","Spine.Skeleton#FindBone","Spine.Skeleton#FindSlot","Spine.Skeleton#SetSkin$1","Spine.Skeleton#SetSkin","Spine.Skeleton#GetAttachment$1","Spine.Skeleton#GetAttachment","Spine.Skeleton#SetAttachment","Spine.Skeleton#FindIkConstraint","Spine.Skeleton#FindTransformConstraint","Spine.Skeleton#FindPathConstraint","Spine.Skeleton#FindPhysicsConstraint","Spine.Skeleton#GetBounds","Spine.Skeleton#toString","Spine.SkeletonLoader#Scale#get","Spine.SkeletonLoader#Scale#set","Spine.SkeletonLoader#init","Spine.SkeletonLoader#ctor","Spine.SkeletonLoader#$ctor1","Spine.SkeletonBinary.LinkedMesh#ctor","Spine.SkeletonBinary.SkeletonInput#init","Spine.SkeletonBinary.SkeletonInput#ctor","Spine.SkeletonBinary.SkeletonInput#Read","Spine.SkeletonBinary.SkeletonInput#ReadUByte","Spine.SkeletonBinary.SkeletonInput#ReadSByte","Spine.SkeletonBinary.SkeletonInput#ReadBoolean","Spine.SkeletonBinary.SkeletonInput#ReadFloat","Spine.SkeletonBinary.SkeletonInput#ReadInt","Spine.SkeletonBinary.SkeletonInput#ReadInt$1","Spine.SkeletonBinary.SkeletonInput#ReadLong","Spine.SkeletonBinary.SkeletonInput#ReadString","Spine.SkeletonBinary.SkeletonInput#ReadStringRef","Spine.SkeletonBinary.SkeletonInput#ReadFully","Spine.SkeletonBinary.SkeletonInput#GetVersionString","Spine.SkeletonBinary.SkeletonInput#GetVersionStringOld3X","Spine.SkeletonBounds#MinX#get","Spine.SkeletonBounds#MinX#set","Spine.SkeletonBounds#MinY#get","Spine.SkeletonBounds#MinY#set","Spine.SkeletonBounds#MaxX#get","Spine.SkeletonBounds#MaxX#set","Spine.SkeletonBounds#MaxY#get","Spine.SkeletonBounds#MaxY#set","Spine.SkeletonBounds#Width#get","Spine.SkeletonBounds#Height#get","Spine.SkeletonBounds#init","Spine.SkeletonBounds#ctor","Spine.SkeletonBounds#Update","Spine.SkeletonBounds#AabbCompute","Spine.SkeletonBounds#AabbContainsPoint","Spine.SkeletonBounds#AabbIntersectsSegment","Spine.SkeletonBounds#AabbIntersectsSkeleton","Spine.SkeletonBounds#ContainsPoint$1","Spine.SkeletonBounds#ContainsPoint","Spine.SkeletonBounds#IntersectsSegment","Spine.SkeletonBounds#IntersectsSegment$1","Spine.SkeletonBounds#GetPolygon","Spine.SkeletonClipping#MakeClockwise","Spine.SkeletonClipping#ClippedVertices#get","Spine.SkeletonClipping#ClippedTriangles#get","Spine.SkeletonClipping#ClippedUVs#get","Spine.SkeletonClipping#IsClipping#get","Spine.SkeletonClipping#init","Spine.SkeletonClipping#ClipStart","Spine.SkeletonClipping#ClipEnd$1","Spine.SkeletonClipping#ClipEnd","Spine.SkeletonClipping#ClipTriangles","Spine.SkeletonClipping#ClipTriangles$1","Spine.SkeletonClipping#Clip","Spine.SkeletonData#Name#get","Spine.SkeletonData#Name#set","Spine.SkeletonData#Bones#get","Spine.SkeletonData#Slots#get","Spine.SkeletonData#Skins#get","Spine.SkeletonData#Skins#set","Spine.SkeletonData#DefaultSkin#get","Spine.SkeletonData#DefaultSkin#set","Spine.SkeletonData#Events#get","Spine.SkeletonData#Events#set","Spine.SkeletonData#Animations#get","Spine.SkeletonData#Animations#set","Spine.SkeletonData#IkConstraints#get","Spine.SkeletonData#IkConstraints#set","Spine.SkeletonData#TransformConstraints#get","Spine.SkeletonData#TransformConstraints#set","Spine.SkeletonData#PathConstraints#get","Spine.SkeletonData#PathConstraints#set","Spine.SkeletonData#PhysicsConstraints#get","Spine.SkeletonData#PhysicsConstraints#set","Spine.SkeletonData#X#get","Spine.SkeletonData#X#set","Spine.SkeletonData#Y#get","Spine.SkeletonData#Y#set","Spine.SkeletonData#Width#get","Spine.SkeletonData#Width#set","Spine.SkeletonData#Height#get","Spine.SkeletonData#Height#set","Spine.SkeletonData#ReferenceScale#get","Spine.SkeletonData#ReferenceScale#set","Spine.SkeletonData#Version#get","Spine.SkeletonData#Version#set","Spine.SkeletonData#Hash#get","Spine.SkeletonData#Hash#set","Spine.SkeletonData#ImagesPath#get","Spine.SkeletonData#ImagesPath#set","Spine.SkeletonData#AudioPath#get","Spine.SkeletonData#AudioPath#set","Spine.SkeletonData#Fps#get","Spine.SkeletonData#Fps#set","Spine.SkeletonData#init","Spine.SkeletonData#FindBone","Spine.SkeletonData#FindSlot","Spine.SkeletonData#FindSkin","Spine.SkeletonData#FindEvent","Spine.SkeletonData#FindAnimation","Spine.SkeletonData#FindIkConstraint","Spine.SkeletonData#FindTransformConstraint","Spine.SkeletonData#FindPathConstraint","Spine.SkeletonData#FindPhysicsConstraint","Spine.SkeletonData#toString","Spine.SkeletonJson.LinkedMesh#ctor","Spine.Skin#Name#get","Spine.Skin#Attachments#get","Spine.Skin#Bones#get","Spine.Skin#Constraints#get","Spine.Skin#init","Spine.Skin#ctor","Spine.Skin#SetAttachment","Spine.Skin#AddSkin","Spine.Skin#CopySkin","Spine.Skin#GetAttachment","Spine.Skin#RemoveAttachment","Spine.Skin#GetAttachments","Spine.Skin#Clear","Spine.Skin#toString","Spine.Skin#AttachAll","Spine.Skin.SkinEntry#getDefaultValue","Spine.Skin.SkinEntry#SlotIndex#get","Spine.Skin.SkinEntry#Name#get","Spine.Skin.SkinEntry#Attachment#get","Spine.Skin.SkinEntry#$ctor1","Spine.Skin.SkinEntry#ctor","Spine.Skin.SkinEntry#getHashCode","Spine.Skin.SkinEntry#equals","Spine.Skin.SkinEntry#$clone","Spine.Skin.SkinKey#getDefaultValue","Spine.Skin.SkinKey#$ctor1","Spine.Skin.SkinKey#ctor","Spine.Skin.SkinKey#getHashCode","Spine.Skin.SkinKey#equals","Spine.Skin.SkinKey#$clone","Spine.Slot#Data#get","Spine.Slot#Bone#get","Spine.Slot#Skeleton#get","Spine.Slot#R#get","Spine.Slot#R#set","Spine.Slot#G#get","Spine.Slot#G#set","Spine.Slot#B#get","Spine.Slot#B#set","Spine.Slot#A#get","Spine.Slot#A#set","Spine.Slot#R2#get","Spine.Slot#R2#set","Spine.Slot#G2#get","Spine.Slot#G2#set","Spine.Slot#B2#get","Spine.Slot#B2#set","Spine.Slot#HasSecondColor#get","Spine.Slot#HasSecondColor#set","Spine.Slot#Attachment#get","Spine.Slot#Attachment#set","Spine.Slot#SequenceIndex#get","Spine.Slot#SequenceIndex#set","Spine.Slot#Deform#get","Spine.Slot#Deform#set","Spine.Slot#init","Spine.Slot#$ctor1","Spine.Slot#ctor","Spine.Slot#ClampColor","Spine.Slot#ClampSecondColor","Spine.Slot#SetToSetupPose","Spine.Slot#toString","Spine.SlotData#Index#get","Spine.SlotData#Name#get","Spine.SlotData#BoneData#get","Spine.SlotData#R#get","Spine.SlotData#R#set","Spine.SlotData#G#get","Spine.SlotData#G#set","Spine.SlotData#B#get","Spine.SlotData#B#set","Spine.SlotData#A#get","Spine.SlotData#A#set","Spine.SlotData#R2#get","Spine.SlotData#R2#set","Spine.SlotData#G2#get","Spine.SlotData#G2#set","Spine.SlotData#B2#get","Spine.SlotData#B2#set","Spine.SlotData#HasSecondColor#get","Spine.SlotData#HasSecondColor#set","Spine.SlotData#AttachmentName#get","Spine.SlotData#AttachmentName#set","Spine.SlotData#BlendMode#get","Spine.SlotData#BlendMode#set","Spine.SlotData#init","Spine.SlotData#ctor","Spine.SlotData#toString","Spine.SpineSkeletonExtensions#IsWeighted","Spine.SpineSkeletonExtensions#InheritsRotation","Spine.SpineSkeletonExtensions#InheritsScale","Spine.Triangulator#IsConcave","Spine.Triangulator#PositiveArea","Spine.Triangulator#Winding","Spine.Triangulator#init","Spine.Triangulator#Triangulate","Spine.Triangulator#Decompose","Spine.Unity.ActivateBasedOnFlipDirection#init","Spine.Unity.ActivateBasedOnFlipDirection#Start","Spine.Unity.ActivateBasedOnFlipDirection#FixedUpdate","Spine.Unity.ActivateBasedOnFlipDirection#HandleFlip","Spine.Unity.ActivateBasedOnFlipDirection#ResetJointPositions","Spine.Unity.ActivateBasedOnFlipDirection#CompensateMovementAfterFlipX","Spine.Unity.AnimationTools.TimelineExtensions#Evaluate$1","Spine.Unity.AnimationTools.TimelineExtensions#Evaluate$2","Spine.Unity.AnimationTools.TimelineExtensions#Evaluate","Spine.Unity.AnimationTools.TimelineExtensions#EvaluateTranslateXYMix","Spine.Unity.AnimationTools.TimelineExtensions#EvaluateRotateMix","Spine.Unity.AnimationTools.TimelineExtensions#FindTranslateTimelineForBone","Spine.Unity.AnimationTools.TimelineExtensions#FindTimelineForBone","Spine.Unity.AnimationTools.TimelineExtensions#FindTransformConstraintTimeline","Spine.Unity.AtlasAssetBase#TextureLoadingMode#get","Spine.Unity.AtlasAssetBase#TextureLoadingMode#set","Spine.Unity.AtlasAssetBase#OnDemandTextureLoader#get","Spine.Unity.AtlasAssetBase#OnDemandTextureLoader#set","Spine.Unity.AtlasAssetBase#init","Spine.Unity.AtlasAssetBase#BeginCustomTextureLoading","Spine.Unity.AtlasAssetBase#EndCustomTextureLoading","Spine.Unity.AtlasAssetBase#RequireTexturesLoaded","Spine.Unity.AtlasAssetBase#RequireTextureLoaded","Spine.Unity.AttachmentTools.AtlasUtilities#init","Spine.Unity.AttachmentTools.AtlasUtilities#Init","Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion$2","Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion$3","Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion","Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion$1","Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion$4","Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegionPMAClone$2","Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegionPMAClone$3","Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegionPMAClone","Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegionPMAClone$1","Spine.Unity.AttachmentTools.AtlasUtilities#ToSpineAtlasPage","Spine.Unity.AttachmentTools.AtlasUtilities#GetRepackedAttachments","Spine.Unity.AttachmentTools.AtlasUtilities#GetRepackedAttachments$1","Spine.Unity.AttachmentTools.AtlasUtilities#AddRegionTexturesToPack","Spine.Unity.AttachmentTools.AtlasUtilities#GetRepackedSkin","Spine.Unity.AttachmentTools.AtlasUtilities#GetRepackedSkin$1","Spine.Unity.AttachmentTools.AtlasUtilities#ToSprite","Spine.Unity.AttachmentTools.AtlasUtilities#ClearCache","Spine.Unity.AttachmentTools.AtlasUtilities#ToTexture","Spine.Unity.AttachmentTools.AtlasUtilities#ToTexture$1","Spine.Unity.AttachmentTools.AtlasUtilities#GetClone","Spine.Unity.AttachmentTools.AtlasUtilities#CopyTexture","Spine.Unity.AttachmentTools.AtlasUtilities#CopyTextureApplyPMA","Spine.Unity.AttachmentTools.AtlasUtilities#IsRenderable","Spine.Unity.AttachmentTools.AtlasUtilities#SpineUnityFlipRect","Spine.Unity.AttachmentTools.AtlasUtilities#GetUnityRect","Spine.Unity.AttachmentTools.AtlasUtilities#GetUnityRect$1","Spine.Unity.AttachmentTools.AtlasUtilities#GetSpineAtlasRect","Spine.Unity.AttachmentTools.AtlasUtilities#UVRectToTextureRect","Spine.Unity.AttachmentTools.AtlasUtilities#TextureRectToUVRect","Spine.Unity.AttachmentTools.AtlasUtilities#UVRectToAtlasRegion","Spine.Unity.AttachmentTools.AtlasUtilities#GetMainTexture","Spine.Unity.AttachmentTools.AtlasUtilities#GetTexture$1","Spine.Unity.AttachmentTools.AtlasUtilities#GetTexture","Spine.Unity.AttachmentTools.AtlasUtilities#CopyTextureAttributesFrom","Spine.Unity.AttachmentTools.AtlasUtilities#InverseLerp","Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#getDefaultValue","Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#$ctor1","Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#ctor","Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#getHashCode","Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#equals","Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#$clone","Spine.Unity.AttachmentTools.AttachmentCloneExtensions#GetRemappedClone$1","Spine.Unity.AttachmentTools.AttachmentCloneExtensions#GetRemappedClone","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachment$2","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachment$1","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachment","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachmentPMAClone$1","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachmentPMAClone","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetScale$1","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetScale","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetPositionOffset$1","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetPositionOffset","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetRotation","Spine.Unity.BlendModeMaterials#init","Spine.Unity.BlendModeMaterials#CreateAndAssignMaterials","Spine.Unity.BlendModeMaterials#CreateAndAssignMaterials$1","Spine.Unity.BlendModeMaterials#CreateForRegion","Spine.Unity.BlendModeMaterials#CreateReplacementMaterial","Spine.Unity.BlendModeMaterials#RequiresBlendModeMaterials#get","Spine.Unity.BlendModeMaterials#RequiresBlendModeMaterials#set","Spine.Unity.BlendModeMaterials#init","Spine.Unity.BlendModeMaterials#BlendModeForMaterial","Spine.Unity.BlendModeMaterials#UpdateBlendmodeMaterialsRequiredState","Spine.Unity.BlendModeMaterials#ApplyMaterials","Spine.Unity.BlendModeMaterials#CloneAtlasRegionWithMaterial","Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#init","Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#CloneAtlasRegionWithMaterial","Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#GetAtlasPageWithMaterial","Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#Dispose","Spine.Unity.BoneFollower#SkeletonRenderer#get","Spine.Unity.BoneFollower#SkeletonRenderer#set","Spine.Unity.BoneFollower#init","Spine.Unity.BoneFollower#SetBone","Spine.Unity.BoneFollower#Awake","Spine.Unity.BoneFollower#HandleRebuildRenderer","Spine.Unity.BoneFollower#Initialize","Spine.Unity.BoneFollower#OnDestroy","Spine.Unity.BoneFollower#LateUpdate","Spine.Unity.BoneFollowerGraphic#SkeletonGraphic#get","Spine.Unity.BoneFollowerGraphic#SkeletonGraphic#set","Spine.Unity.BoneFollowerGraphic#init","Spine.Unity.BoneFollowerGraphic#SetBone","Spine.Unity.BoneFollowerGraphic#Awake","Spine.Unity.BoneFollowerGraphic#Initialize","Spine.Unity.BoneFollowerGraphic#LateUpdate","Spine.Unity.BoundingBoxFollower#init","Spine.Unity.BoundingBoxFollower#Slot#get","Spine.Unity.BoundingBoxFollower#CurrentAttachment#get","Spine.Unity.BoundingBoxFollower#CurrentAttachmentName#get","Spine.Unity.BoundingBoxFollower#CurrentCollider#get","Spine.Unity.BoundingBoxFollower#IsTrigger#get","Spine.Unity.BoundingBoxFollower#init","Spine.Unity.BoundingBoxFollower#Start","Spine.Unity.BoundingBoxFollower#OnEnable","Spine.Unity.BoundingBoxFollower#HandleRebuild","Spine.Unity.BoundingBoxFollower#Initialize","Spine.Unity.BoundingBoxFollower#AddCollidersForSkin","Spine.Unity.BoundingBoxFollower#OnDisable","Spine.Unity.BoundingBoxFollower#ClearState","Spine.Unity.BoundingBoxFollower#DisposeExcessCollidersAfter","Spine.Unity.BoundingBoxFollower#LateUpdate","Spine.Unity.BoundingBoxFollower#MatchAttachment","Spine.Unity.BoundingBoxFollowerGraphic#init","Spine.Unity.BoundingBoxFollowerGraphic#Slot#get","Spine.Unity.BoundingBoxFollowerGraphic#CurrentAttachment#get","Spine.Unity.BoundingBoxFollowerGraphic#CurrentAttachmentName#get","Spine.Unity.BoundingBoxFollowerGraphic#CurrentCollider#get","Spine.Unity.BoundingBoxFollowerGraphic#IsTrigger#get","Spine.Unity.BoundingBoxFollowerGraphic#init","Spine.Unity.BoundingBoxFollowerGraphic#Start","Spine.Unity.BoundingBoxFollowerGraphic#OnEnable","Spine.Unity.BoundingBoxFollowerGraphic#HandleRebuild","Spine.Unity.BoundingBoxFollowerGraphic#Initialize","Spine.Unity.BoundingBoxFollowerGraphic#AddCollidersForSkin","Spine.Unity.BoundingBoxFollowerGraphic#OnDisable","Spine.Unity.BoundingBoxFollowerGraphic#ClearState","Spine.Unity.BoundingBoxFollowerGraphic#DisposeExcessCollidersAfter","Spine.Unity.BoundingBoxFollowerGraphic#LateUpdate","Spine.Unity.BoundingBoxFollowerGraphic#MatchAttachment","Spine.Unity.DoubleBuffered$1#init","Spine.Unity.DoubleBuffered$1#GetCurrent","Spine.Unity.DoubleBuffered$1#GetNext","Spine.Unity.EventDataReferenceAsset#init","Spine.Unity.EventDataReferenceAsset#op_Implicit","Spine.Unity.EventDataReferenceAsset#EventData#get","Spine.Unity.EventDataReferenceAsset#Initialize","Spine.Unity.ISpineComponentExtensions#IsNullOrDestroyed","Spine.Unity.MeshGenerator#init","Spine.Unity.MeshGenerator#GenerateSingleSubmeshInstruction","Spine.Unity.MeshGenerator#RequiresMultipleSubmeshesByDrawOrder","Spine.Unity.MeshGenerator#GenerateSkeletonRendererInstruction","Spine.Unity.MeshGenerator#TryReplaceMaterials","Spine.Unity.MeshGenerator#SolveTangents2DEnsureSize","Spine.Unity.MeshGenerator#SolveTangents2DTriangles","Spine.Unity.MeshGenerator#SolveTangents2DBuffer","Spine.Unity.MeshGenerator#FillMeshLocal$1","Spine.Unity.MeshGenerator#FillMeshLocal","Spine.Unity.MeshGenerator#UV2#get","Spine.Unity.MeshGenerator#UV3#get","Spine.Unity.MeshGenerator#VertexCount#get","Spine.Unity.MeshGenerator#Buffers#get","Spine.Unity.MeshGenerator#SkeletonClipping#get","Spine.Unity.MeshGenerator#init","Spine.Unity.MeshGenerator#ctor","Spine.Unity.MeshGenerator#SubmeshIndexCount","Spine.Unity.MeshGenerator#Begin","Spine.Unity.MeshGenerator#AddSubmesh","Spine.Unity.MeshGenerator#BuildMesh","Spine.Unity.MeshGenerator#BuildMeshWithArrays","Spine.Unity.MeshGenerator#ScaleVertexData","Spine.Unity.MeshGenerator#ScaleAndOffsetVertexData","Spine.Unity.MeshGenerator#GetMeshBounds","Spine.Unity.MeshGenerator#AddAttachmentTintBlack","Spine.Unity.MeshGenerator#PrepareOptionalUVBuffer","Spine.Unity.MeshGenerator#ResizeOptionalUVBuffer","Spine.Unity.MeshGenerator#FillVertexData","Spine.Unity.MeshGenerator#FillLateVertexData","Spine.Unity.MeshGenerator#FillTriangles","Spine.Unity.MeshGenerator#EnsureVertexCapacity","Spine.Unity.MeshGenerator#TrimExcess","Spine.Unity.MeshGenerator.Settings#Default#get","Spine.Unity.MeshGenerator.Settings#getDefaultValue","Spine.Unity.MeshGenerator.Settings#ctor","Spine.Unity.MeshGenerator.Settings#getHashCode","Spine.Unity.MeshGenerator.Settings#equals","Spine.Unity.MeshGenerator.Settings#$clone","Spine.Unity.MeshGeneratorBuffers#getDefaultValue","Spine.Unity.MeshGeneratorBuffers#uv2Buffer#get","Spine.Unity.MeshGeneratorBuffers#uv3Buffer#get","Spine.Unity.MeshGeneratorBuffers#ctor","Spine.Unity.MeshGeneratorBuffers#getHashCode","Spine.Unity.MeshGeneratorBuffers#equals","Spine.Unity.MeshGeneratorBuffers#$clone","Spine.Unity.MeshRendererBuffers#init","Spine.Unity.MeshRendererBuffers#Initialize","Spine.Unity.MeshRendererBuffers#GetUpdatedSharedMaterialsArray","Spine.Unity.MeshRendererBuffers#MaterialsChangedInLastUpdate","Spine.Unity.MeshRendererBuffers#UpdateSharedMaterials","Spine.Unity.MeshRendererBuffers#GetNextMesh","Spine.Unity.MeshRendererBuffers#Clear","Spine.Unity.MeshRendererBuffers#Dispose","Spine.Unity.MeshRendererBuffers.SmartMesh#init","Spine.Unity.MeshRendererBuffers.SmartMesh#Clear","Spine.Unity.MeshRendererBuffers.SmartMesh#Dispose","Spine.Unity.OnDemandTextureLoader#addTextureRequested","Spine.Unity.OnDemandTextureLoader#removeTextureRequested","Spine.Unity.OnDemandTextureLoader#addTextureLoaded","Spine.Unity.OnDemandTextureLoader#removeTextureLoaded","Spine.Unity.OnDemandTextureLoader#addTextureLoadFailed","Spine.Unity.OnDemandTextureLoader#removeTextureLoadFailed","Spine.Unity.OnDemandTextureLoader#addTextureUnloaded","Spine.Unity.OnDemandTextureLoader#removeTextureUnloaded","Spine.Unity.OnDemandTextureLoader#HasNullMainTexturesAssigned","Spine.Unity.OnDemandTextureLoader#OnTextureRequested","Spine.Unity.OnDemandTextureLoader#OnTextureLoaded","Spine.Unity.OnDemandTextureLoader#OnTextureLoadFailed","Spine.Unity.OnDemandTextureLoader#OnTextureUnloaded","Spine.Unity.SkeletonDataAsset#CreateRuntimeInstance","Spine.Unity.SkeletonDataAsset#CreateRuntimeInstance$1","Spine.Unity.SkeletonDataAsset#ReadSkeletonData","Spine.Unity.SkeletonDataAsset#ReadSkeletonData$1","Spine.Unity.SkeletonDataAsset#IsLoaded#get","Spine.Unity.SkeletonDataAsset#init","Spine.Unity.SkeletonDataAsset#Reset","Spine.Unity.SkeletonDataAsset#SetupRuntimeBlendModeMaterials","Spine.Unity.SkeletonDataAsset#Clear","Spine.Unity.SkeletonDataAsset#GetAnimationStateData","Spine.Unity.SkeletonDataAsset#GetSkeletonData","Spine.Unity.SkeletonDataAsset#InitializeWithData","Spine.Unity.SkeletonDataAsset#FillStateData","Spine.Unity.SkeletonDataAsset#GetAtlasArray","Spine.Unity.SkeletonDataCompatibility.CompatibilityProblemInfo#DescriptionString","Spine.Unity.SkeletonExtensions#init","Spine.Unity.SkeletonExtensions#GetColor$2","Spine.Unity.SkeletonExtensions#GetColor$1","Spine.Unity.SkeletonExtensions#GetColor","Spine.Unity.SkeletonExtensions#GetColor$3","Spine.Unity.SkeletonExtensions#GetColorTintBlack","Spine.Unity.SkeletonExtensions#SetColor$4","Spine.Unity.SkeletonExtensions#SetColor$5","Spine.Unity.SkeletonExtensions#SetColor$6","Spine.Unity.SkeletonExtensions#SetColor$7","Spine.Unity.SkeletonExtensions#SetColor$2","Spine.Unity.SkeletonExtensions#SetColor$3","Spine.Unity.SkeletonExtensions#SetColor","Spine.Unity.SkeletonExtensions#SetColor$1","Spine.Unity.SkeletonExtensions#SetLocalScale","Spine.Unity.SkeletonExtensions#GetMatrix4x4","Spine.Unity.SkeletonExtensions#SetLocalPosition","Spine.Unity.SkeletonExtensions#SetLocalPosition$1","Spine.Unity.SkeletonExtensions#GetLocalPosition","Spine.Unity.SkeletonExtensions#GetSkeletonSpacePosition","Spine.Unity.SkeletonExtensions#GetSkeletonSpacePosition$1","Spine.Unity.SkeletonExtensions#GetWorldPosition","Spine.Unity.SkeletonExtensions#GetWorldPosition$1","Spine.Unity.SkeletonExtensions#GetWorldPosition$2","Spine.Unity.SkeletonExtensions#GetWorldPosition$4","Spine.Unity.SkeletonExtensions#GetWorldPosition$3","Spine.Unity.SkeletonExtensions#GetQuaternion","Spine.Unity.SkeletonExtensions#GetLocalQuaternion","Spine.Unity.SkeletonExtensions#GetLocalScale","Spine.Unity.SkeletonExtensions#GetWorldToLocalMatrix","Spine.Unity.SkeletonExtensions#WorldToLocal","Spine.Unity.SkeletonExtensions#SetPositionSkeletonSpace","Spine.Unity.SkeletonExtensions#GetMaterial","Spine.Unity.SkeletonExtensions#GetLocalVertices","Spine.Unity.SkeletonExtensions#GetWorldVertices","Spine.Unity.SkeletonGraphicCustomMaterials#init","Spine.Unity.SkeletonGraphicCustomMaterials#SetCustomMaterialOverrides","Spine.Unity.SkeletonGraphicCustomMaterials#RemoveCustomMaterialOverrides","Spine.Unity.SkeletonGraphicCustomMaterials#SetCustomTextureOverrides","Spine.Unity.SkeletonGraphicCustomMaterials#RemoveCustomTextureOverrides","Spine.Unity.SkeletonGraphicCustomMaterials#OnEnable","Spine.Unity.SkeletonGraphicCustomMaterials#OnDisable","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#inherits","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#getDefaultValue","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#ctor","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#equalsT","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#getHashCode","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#$clone","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#inherits","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#getDefaultValue","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#ctor","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#equalsT","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#getHashCode","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#$clone","Spine.Unity.SkeletonMecanim.MecanimTranslator#init","Spine.Unity.SkeletonMecanim.MecanimTranslator#AnimationTime","Spine.Unity.SkeletonMecanim.MecanimTranslator#ToSpineAnimationTime","Spine.Unity.SkeletonMecanim.MecanimTranslator#Animator#get","Spine.Unity.SkeletonMecanim.MecanimTranslator#MecanimLayerCount#get","Spine.Unity.SkeletonMecanim.MecanimTranslator#MecanimLayerNames#get","Spine.Unity.SkeletonMecanim.MecanimTranslator#init","Spine.Unity.SkeletonMecanim.MecanimTranslator#addOnClipApplied","Spine.Unity.SkeletonMecanim.MecanimTranslator#removeOnClipApplied","Spine.Unity.SkeletonMecanim.MecanimTranslator#Initialize","Spine.Unity.SkeletonMecanim.MecanimTranslator#ApplyAnimation","Spine.Unity.SkeletonMecanim.MecanimTranslator#ApplyInterruptionAnimation","Spine.Unity.SkeletonMecanim.MecanimTranslator#OnClipAppliedCallback","Spine.Unity.SkeletonMecanim.MecanimTranslator#Apply","Spine.Unity.SkeletonMecanim.MecanimTranslator#GetActiveAnimationAndTime","Spine.Unity.SkeletonMecanim.MecanimTranslator#InitClipInfosForLayers","Spine.Unity.SkeletonMecanim.MecanimTranslator#ClearClipInfosForLayers","Spine.Unity.SkeletonMecanim.MecanimTranslator#GetMixMode","Spine.Unity.SkeletonMecanim.MecanimTranslator#GetStateUpdatesFromAnimator","Spine.Unity.SkeletonMecanim.MecanimTranslator#GetAnimatorClipInfos","Spine.Unity.SkeletonMecanim.MecanimTranslator#GetAnimatorStateInfos","Spine.Unity.SkeletonMecanim.MecanimTranslator#GetAnimation","Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer#init","Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer#equals2","Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer#getHashCode2","Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos#init","Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer#init","Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer#equals2","Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer#getHashCode2","Spine.Unity.SkeletonRootMotionBase#RootMotionBone#get","Spine.Unity.SkeletonRootMotionBase#UsesRigidbody#get","Spine.Unity.SkeletonRootMotionBase#PreviousRigidbodyRootMotion2D#get","Spine.Unity.SkeletonRootMotionBase#PreviousRigidbodyRootMotion3D#get","Spine.Unity.SkeletonRootMotionBase#AdditionalRigidbody2DMovement#get","Spine.Unity.SkeletonRootMotionBase#AdditionalRigidbody2DMovement#set","Spine.Unity.SkeletonRootMotionBase#SkeletonAnimationUsesFixedUpdate#get","Spine.Unity.SkeletonRootMotionBase#AdditionalScale#get","Spine.Unity.SkeletonRootMotionBase#TargetSkeletonComponent#get","Spine.Unity.SkeletonRootMotionBase#TargetSkeletonAnimationComponent#get","Spine.Unity.SkeletonRootMotionBase#init","Spine.Unity.SkeletonRootMotionBase#Reset","Spine.Unity.SkeletonRootMotionBase#Start","Spine.Unity.SkeletonRootMotionBase#InitializeOnRebuild","Spine.Unity.SkeletonRootMotionBase#Initialize","Spine.Unity.SkeletonRootMotionBase#FixedUpdate","Spine.Unity.SkeletonRootMotionBase#PhysicsUpdate","Spine.Unity.SkeletonRootMotionBase#OnDisable","Spine.Unity.SkeletonRootMotionBase#FindRigidbodyComponent","Spine.Unity.SkeletonRootMotionBase#CalculateAnimationsRotationDelta","Spine.Unity.SkeletonRootMotionBase#SetRootMotionBone","Spine.Unity.SkeletonRootMotionBase#AdjustRootMotionToDistance","Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotion","Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotion$1","Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotionRotation","Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotionRotation$1","Spine.Unity.SkeletonRootMotionBase#ApplyConstraintToPos","Spine.Unity.SkeletonRootMotionBase#ApplyConstraintToRotation","Spine.Unity.SkeletonRootMotionBase#UpdateLastConstraintPos","Spine.Unity.SkeletonRootMotionBase#UpdateLastConstraintRotation","Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotionInfo","Spine.Unity.SkeletonRootMotionBase#GetConstraintLastPosIndex","Spine.Unity.SkeletonRootMotionBase#FindTransformConstraintsAffectingBone","Spine.Unity.SkeletonRootMotionBase#GetTimelineMovementDelta","Spine.Unity.SkeletonRootMotionBase#GatherTopLevelBones","Spine.Unity.SkeletonRootMotionBase#HandleUpdateLocal","Spine.Unity.SkeletonRootMotionBase#ApplyRootMotion","Spine.Unity.SkeletonRootMotionBase#ApplyTransformConstraints","Spine.Unity.SkeletonRootMotionBase#GetScaleAffectingRootMotion","Spine.Unity.SkeletonRootMotionBase#GetScaleAffectingRootMotion$1","Spine.Unity.SkeletonRootMotionBase#GetSkeletonSpaceMovementDelta","Spine.Unity.SkeletonRootMotionBase#GetSkeletonSpaceRotationDelta","Spine.Unity.SkeletonRootMotionBase#SetEffectiveBoneOffsetsTo","Spine.Unity.SkeletonRootMotionBase#ClearEffectiveBoneOffsets","Spine.Unity.SkeletonRootMotionBase#ClearRigidbodyTempMovement","Spine.Unity.SkeletonPartsRenderer#NewPartsRendererGameObject","Spine.Unity.SkeletonPartsRenderer#MeshGenerator#get","Spine.Unity.SkeletonPartsRenderer#MeshRenderer#get","Spine.Unity.SkeletonPartsRenderer#MeshFilter#get","Spine.Unity.SkeletonPartsRenderer#init","Spine.Unity.SkeletonPartsRenderer#LazyIntialize","Spine.Unity.SkeletonPartsRenderer#OnDestroy","Spine.Unity.SkeletonPartsRenderer#ClearMesh","Spine.Unity.SkeletonPartsRenderer#RenderParts","Spine.Unity.SkeletonPartsRenderer#SetPropertyBlock","Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials#AnyMaterialCreated#get","Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials#init","Spine.Unity.SkeletonRendererCustomMaterials#init","Spine.Unity.SkeletonRendererCustomMaterials#SetCustomSlotMaterials","Spine.Unity.SkeletonRendererCustomMaterials#RemoveCustomSlotMaterials","Spine.Unity.SkeletonRendererCustomMaterials#SetCustomMaterialOverrides","Spine.Unity.SkeletonRendererCustomMaterials#RemoveCustomMaterialOverrides","Spine.Unity.SkeletonRendererCustomMaterials#OnEnable","Spine.Unity.SkeletonRendererCustomMaterials#OnDisable","Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#inherits","Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#getDefaultValue","Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#ctor","Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#equalsT","Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#getHashCode","Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#$clone","Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#inherits","Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#getDefaultValue","Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#ctor","Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#equalsT","Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#getHashCode","Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#$clone","Spine.Unity.SkeletonRendererInstruction#GeometryNotEqual","Spine.Unity.SkeletonRendererInstruction#init","Spine.Unity.SkeletonRendererInstruction#Clear","Spine.Unity.SkeletonRendererInstruction#Dispose","Spine.Unity.SkeletonRendererInstruction#SetWithSubset","Spine.Unity.SkeletonRendererInstruction#Set","Spine.Unity.SkeletonRenderSeparator#init","Spine.Unity.SkeletonRenderSeparator#AddToSkeletonRenderer","Spine.Unity.SkeletonRenderSeparator#SkeletonRenderer#get","Spine.Unity.SkeletonRenderSeparator#SkeletonRenderer#set","Spine.Unity.SkeletonRenderSeparator#init","Spine.Unity.SkeletonRenderSeparator#AddPartsRenderer","Spine.Unity.SkeletonRenderSeparator#OnEnable","Spine.Unity.SkeletonRenderSeparator#Update","Spine.Unity.SkeletonRenderSeparator#OnDisable","Spine.Unity.SkeletonRenderSeparator#UpdateVisibility","Spine.Unity.SkeletonRenderSeparator#HandleRender","Spine.Unity.SkeletonRenderSeparator#ClearPartsRendererMeshes","Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#getDefaultValue","Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#init","Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#ctor","Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#getHashCode","Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#equals","Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#$clone","Spine.Unity.SkeletonSubmeshGraphic#SetMaterialDirty","Spine.Unity.SkeletonSubmeshGraphic#SetVerticesDirty","Spine.Unity.SkeletonSubmeshGraphic#OnPopulateMesh","Spine.Unity.SkeletonSubmeshGraphic#OnDisable","Spine.Unity.SkeletonSubmeshGraphic#OnEnable","Spine.Unity.SkeletonUtility#AddBoundingBoxGameObject","Spine.Unity.SkeletonUtility#AddBoundingBoxGameObject$1","Spine.Unity.SkeletonUtility#AddBoundingBoxAsComponent","Spine.Unity.SkeletonUtility#SetColliderPointsLocal","Spine.Unity.SkeletonUtility#GetBoundingBoxBounds","Spine.Unity.SkeletonUtility#AddBoneRigidbody2D","Spine.Unity.SkeletonUtility#SkeletonComponent#get","Spine.Unity.SkeletonUtility#Skeleton#get","Spine.Unity.SkeletonUtility#IsValid#get","Spine.Unity.SkeletonUtility#PositionScale#get","Spine.Unity.SkeletonUtility#PositionOffset#get","Spine.Unity.SkeletonUtility#init","Spine.Unity.SkeletonUtility#Update","Spine.Unity.SkeletonUtility#UpdateToMeshScaleAndOffset","Spine.Unity.SkeletonUtility#ResubscribeEvents","Spine.Unity.SkeletonUtility#ResubscribeIndependentEvents","Spine.Unity.SkeletonUtility#ResubscribeDependentEvents","Spine.Unity.SkeletonUtility#OnEnable","Spine.Unity.SkeletonUtility#Start","Spine.Unity.SkeletonUtility#OnDisable","Spine.Unity.SkeletonUtility#HandleRendererReset$1","Spine.Unity.SkeletonUtility#HandleRendererReset","Spine.Unity.SkeletonUtility#RegisterBone","Spine.Unity.SkeletonUtility#UnregisterBone","Spine.Unity.SkeletonUtility#RegisterConstraint","Spine.Unity.SkeletonUtility#UnregisterConstraint","Spine.Unity.SkeletonUtility#CollectBones","Spine.Unity.SkeletonUtility#UpdateLocal","Spine.Unity.SkeletonUtility#UpdateWorld","Spine.Unity.SkeletonUtility#UpdateComplete","Spine.Unity.SkeletonUtility#UpdateAllBones","Spine.Unity.SkeletonUtility#GetBoneRoot","Spine.Unity.SkeletonUtility#SpawnRoot","Spine.Unity.SkeletonUtility#SpawnHierarchy","Spine.Unity.SkeletonUtility#SpawnBoneRecursively","Spine.Unity.SkeletonUtility#SpawnBone","Spine.Unity.SkeletonUtilityBone#BoneTransformModeIncompatible","Spine.Unity.SkeletonUtilityBone#IncompatibleTransformMode#get","Spine.Unity.SkeletonUtilityBone#init","Spine.Unity.SkeletonUtilityBone#Reset","Spine.Unity.SkeletonUtilityBone#OnEnable","Spine.Unity.SkeletonUtilityBone#HandleOnReset","Spine.Unity.SkeletonUtilityBone#OnDisable","Spine.Unity.SkeletonUtilityBone#DoUpdate","Spine.Unity.SkeletonUtilityBone#AddBoundingBox","Spine.Unity.SkeletonUtilityConstraint#OnEnable","Spine.Unity.SkeletonUtilityConstraint#OnDisable","Spine.Unity.SpineAttributeBase#init","Spine.Unity.SpineAtlasRegion#ctor","Spine.Unity.SpineAttachment.Hierarchy#getDefaultValue","Spine.Unity.SpineAttachment.Hierarchy#$ctor1","Spine.Unity.SpineAttachment.Hierarchy#ctor","Spine.Unity.SpineAttachment.Hierarchy#getHashCode","Spine.Unity.SpineAttachment.Hierarchy#equals","Spine.Unity.SpineAttachment.Hierarchy#$clone","Spine.Unity.SpineMesh#init","Spine.Unity.SpineMesh#NewSkeletonMesh","Spine.Unity.SubmeshInstruction#getDefaultValue","Spine.Unity.SubmeshInstruction#SlotCount#get","Spine.Unity.SubmeshInstruction#ctor","Spine.Unity.SubmeshInstruction#toString","Spine.Unity.SubmeshInstruction#getHashCode","Spine.Unity.SubmeshInstruction#equals","Spine.Unity.SubmeshInstruction#$clone","Spine.Unity.WaitForSpineAnimation#System$Collections$IEnumerator$Current#get","Spine.Unity.WaitForSpineAnimation#init","Spine.Unity.WaitForSpineAnimation#ctor","Spine.Unity.WaitForSpineAnimation#NowWaitFor","Spine.Unity.WaitForSpineAnimation#System$Collections$IEnumerator$moveNext","Spine.Unity.WaitForSpineAnimation#System$Collections$IEnumerator$reset","Spine.Unity.WaitForSpineAnimation#SafeSubscribe","Spine.Unity.WaitForSpineAnimation#HandleComplete","Spine.Unity.WaitForSpineEvent#WillUnsubscribeAfterFiring#get","Spine.Unity.WaitForSpineEvent#WillUnsubscribeAfterFiring#set","Spine.Unity.WaitForSpineEvent#System$Collections$IEnumerator$Current#get","Spine.Unity.WaitForSpineEvent#init","Spine.Unity.WaitForSpineEvent#ctor","Spine.Unity.WaitForSpineEvent#$ctor2","Spine.Unity.WaitForSpineEvent#$ctor1","Spine.Unity.WaitForSpineEvent#$ctor3","Spine.Unity.WaitForSpineEvent#Subscribe","Spine.Unity.WaitForSpineEvent#SubscribeByName","Spine.Unity.WaitForSpineEvent#HandleAnimationStateEventByName","Spine.Unity.WaitForSpineEvent#HandleAnimationStateEvent","Spine.Unity.WaitForSpineEvent#NowWaitFor","Spine.Unity.WaitForSpineEvent#NowWaitFor$1","Spine.Unity.WaitForSpineEvent#Clear","Spine.Unity.WaitForSpineEvent#System$Collections$IEnumerator$moveNext","Spine.Unity.WaitForSpineEvent#System$Collections$IEnumerator$reset","Spine.Unity.WaitForSpineTrackEntryEnd#System$Collections$IEnumerator$Current#get","Spine.Unity.WaitForSpineTrackEntryEnd#init","Spine.Unity.WaitForSpineTrackEntryEnd#ctor","Spine.Unity.WaitForSpineTrackEntryEnd#HandleEnd","Spine.Unity.WaitForSpineTrackEntryEnd#SafeSubscribe","Spine.Unity.WaitForSpineTrackEntryEnd#NowWaitFor","Spine.Unity.WaitForSpineTrackEntryEnd#System$Collections$IEnumerator$moveNext","Spine.Unity.WaitForSpineTrackEntryEnd#System$Collections$IEnumerator$reset","store#click","UIFollowObject#Update","UserConfig#Instance#get","UserConfig#CurLevel#get","UserConfig#CurLevel#set","UserConfig#RetendDay#get","UserConfig#RetendDay#set","UserConfig#DayPlayed#get","UserConfig#DayPlayed#set","UserConfig#Sound#get","UserConfig#Sound#set","UserConfig#Music#get","UserConfig#Music#set","UserConfig#Vibrate#get","UserConfig#Vibrate#set","UserConfig#BestLevel#get","UserConfig#BestLevel#set","UserConfig#Coin#get","UserConfig#Coin#set","UserConfig#Rate#get","UserConfig#Rate#set","UserConfig#HasAds#get","UserConfig#HasAds#set","UserConfig#DailyLogin#get","UserConfig#DailyLogin#set","UserConfig#TotalSpend#get","UserConfig#TotalSpend#set","UserConfig#TotalEarn#get","UserConfig#TotalEarn#set","UserConfig#WinLevel#get","UserConfig#WinLevel#set","UserConfig#AmountInter#get","UserConfig#AmountInter#set","UserConfig#AmountBomb#get","UserConfig#AmountBomb#set","UserConfig#AmountScrewdrive#get","UserConfig#AmountScrewdrive#set","UserConfig#LevelShowRemoveAds#get","UserConfig#LevelShowRemoveAds#set","UserConfig#init","UserConfig#Init","UserConfig#CanShowDailyBonus","UserConfig#HasTurnOffInternet","Vibration#init","Vibration#Vibrate","Vibration#Vibrate$1","Vibration#Vibrate$2","Vibration#HasVibrator","Vibration#Cancel","Vibration#isAndroid","wall#OnTriggerEnter2D","CameraResize#inherits","CameraResize#Start","CameraResize#ResizeCamera","GameManager#inherits","GameManager#init","GameManager#init","GameManager#Start","GameManager#EndGame","GameManager#OnWin","GameManager#LoadAsset","GameManager#InstantiatePrefab","Spine.CurveTimeline#init","Spine.CurveTimeline#ctor","Spine.CurveTimeline#SetLinear","Spine.CurveTimeline#SetStepped","Spine.CurveTimeline#GetCurveType","Spine.CurveTimeline#Shrink","Spine.CurveTimeline#SetBezier","Spine.CurveTimeline#GetBezierValue","Spine.AnimationStateData.AnimationPairComparer#init","Spine.AnimationStateData.AnimationPairComparer#System$Collections$Generic$IEqualityComparer$1$Spine$AnimationStateData$AnimationPair$equals2","Spine.AnimationStateData.AnimationPairComparer#System$Collections$Generic$IEqualityComparer$1$Spine$AnimationStateData$AnimationPair$getHashCode2","Spine.AtlasRegion#packedWidth#get","Spine.AtlasRegion#packedWidth#set","Spine.AtlasRegion#packedHeight#get","Spine.AtlasRegion#packedHeight#set","Spine.AtlasRegion#OriginalWidth#get","Spine.AtlasRegion#OriginalHeight#get","Spine.AtlasRegion#Clone","Spine.AtlasAttachmentLoader#ctor","Spine.AtlasAttachmentLoader#LoadSequence","Spine.AtlasAttachmentLoader#NewRegionAttachment","Spine.AtlasAttachmentLoader#NewMeshAttachment","Spine.AtlasAttachmentLoader#NewBoundingBoxAttachment","Spine.AtlasAttachmentLoader#NewPathAttachment","Spine.AtlasAttachmentLoader#NewPointAttachment","Spine.AtlasAttachmentLoader#NewClippingAttachment","Spine.AtlasAttachmentLoader#FindRegion","Spine.AttachmentTimeline#SlotIndex#get","Spine.AttachmentTimeline#AttachmentNames#get","Spine.AttachmentTimeline#ctor","Spine.AttachmentTimeline#SetFrame","Spine.AttachmentTimeline#Apply","Spine.AttachmentTimeline#SetAttachment","Spine.Bone#Data#get","Spine.Bone#Skeleton#get","Spine.Bone#Parent#get","Spine.Bone#Children#get","Spine.Bone#Active#get","Spine.Bone#X#get","Spine.Bone#X#set","Spine.Bone#Y#get","Spine.Bone#Y#set","Spine.Bone#Rotation#get","Spine.Bone#Rotation#set","Spine.Bone#ScaleX#get","Spine.Bone#ScaleX#set","Spine.Bone#ScaleY#get","Spine.Bone#ScaleY#set","Spine.Bone#ShearX#get","Spine.Bone#ShearX#set","Spine.Bone#ShearY#get","Spine.Bone#ShearY#set","Spine.Bone#Inherit#get","Spine.Bone#Inherit#set","Spine.Bone#AppliedRotation#get","Spine.Bone#AppliedRotation#set","Spine.Bone#AX#get","Spine.Bone#AX#set","Spine.Bone#AY#get","Spine.Bone#AY#set","Spine.Bone#AScaleX#get","Spine.Bone#AScaleX#set","Spine.Bone#AScaleY#get","Spine.Bone#AScaleY#set","Spine.Bone#AShearX#get","Spine.Bone#AShearX#set","Spine.Bone#AShearY#get","Spine.Bone#AShearY#set","Spine.Bone#A#get","Spine.Bone#A#set","Spine.Bone#B#get","Spine.Bone#B#set","Spine.Bone#C#get","Spine.Bone#C#set","Spine.Bone#D#get","Spine.Bone#D#set","Spine.Bone#WorldX#get","Spine.Bone#WorldX#set","Spine.Bone#WorldY#get","Spine.Bone#WorldY#set","Spine.Bone#WorldRotationX#get","Spine.Bone#WorldRotationY#get","Spine.Bone#WorldScaleX#get","Spine.Bone#WorldScaleY#get","Spine.Bone#init","Spine.Bone#$ctor1","Spine.Bone#ctor","Spine.Bone#Update","Spine.Bone#UpdateWorldTransform","Spine.Bone#UpdateWorldTransform$1","Spine.Bone#SetToSetupPose","Spine.Bone#UpdateAppliedTransform","Spine.Bone#WorldToLocal","Spine.Bone#LocalToWorld","Spine.Bone#WorldToParent","Spine.Bone#ParentToWorld","Spine.Bone#WorldToLocalRotation","Spine.Bone#LocalToWorldRotation","Spine.Bone#RotateWorld","Spine.Bone#toString","Spine.VertexAttachment#init","Spine.VertexAttachment#Id#get","Spine.VertexAttachment#Bones#get","Spine.VertexAttachment#Bones#set","Spine.VertexAttachment#Vertices#get","Spine.VertexAttachment#Vertices#set","Spine.VertexAttachment#WorldVerticesLength#get","Spine.VertexAttachment#WorldVerticesLength#set","Spine.VertexAttachment#TimelineAttachment#get","Spine.VertexAttachment#TimelineAttachment#set","Spine.VertexAttachment#$ctor1","Spine.VertexAttachment#ctor","Spine.VertexAttachment#ComputeWorldVertices$1","Spine.VertexAttachment#ComputeWorldVertices","Spine.DrawOrderTimeline#init","Spine.DrawOrderTimeline#DrawOrders#get","Spine.DrawOrderTimeline#ctor","Spine.DrawOrderTimeline#SetFrame","Spine.DrawOrderTimeline#Apply","Spine.EventTimeline#init","Spine.EventTimeline#Events#get","Spine.EventTimeline#ctor","Spine.EventTimeline#SetFrame","Spine.EventTimeline#Apply","Spine.IkConstraint#Apply$1","Spine.IkConstraint#Apply","Spine.IkConstraint#Bones#get","Spine.IkConstraint#Target#get","Spine.IkConstraint#Target#set","Spine.IkConstraint#Mix#get","Spine.IkConstraint#Mix#set","Spine.IkConstraint#Softness#get","Spine.IkConstraint#Softness#set","Spine.IkConstraint#BendDirection#get","Spine.IkConstraint#BendDirection#set","Spine.IkConstraint#Compress#get","Spine.IkConstraint#Compress#set","Spine.IkConstraint#Stretch#get","Spine.IkConstraint#Stretch#set","Spine.IkConstraint#Active#get","Spine.IkConstraint#Data#get","Spine.IkConstraint#init","Spine.IkConstraint#$ctor1","Spine.IkConstraint#ctor","Spine.IkConstraint#SetToSetupPose","Spine.IkConstraint#Update","Spine.IkConstraint#toString","Spine.IkConstraintData#Bones#get","Spine.IkConstraintData#Target#get","Spine.IkConstraintData#Target#set","Spine.IkConstraintData#Mix#get","Spine.IkConstraintData#Mix#set","Spine.IkConstraintData#Softness#get","Spine.IkConstraintData#Softness#set","Spine.IkConstraintData#BendDirection#get","Spine.IkConstraintData#BendDirection#set","Spine.IkConstraintData#Compress#get","Spine.IkConstraintData#Compress#set","Spine.IkConstraintData#Stretch#get","Spine.IkConstraintData#Stretch#set","Spine.IkConstraintData#Uniform#get","Spine.IkConstraintData#Uniform#set","Spine.IkConstraintData#init","Spine.IkConstraintData#ctor","Spine.InheritTimeline#init","Spine.InheritTimeline#BoneIndex#get","Spine.InheritTimeline#FrameEntries#get","Spine.InheritTimeline#ctor","Spine.InheritTimeline#SetFrame","Spine.InheritTimeline#Apply","Spine.PathConstraint#init","Spine.PathConstraint#ArraysFill","Spine.PathConstraint#AddBeforePosition","Spine.PathConstraint#AddAfterPosition","Spine.PathConstraint#AddCurvePosition","Spine.PathConstraint#Position#get","Spine.PathConstraint#Position#set","Spine.PathConstraint#Spacing#get","Spine.PathConstraint#Spacing#set","Spine.PathConstraint#MixRotate#get","Spine.PathConstraint#MixRotate#set","Spine.PathConstraint#MixX#get","Spine.PathConstraint#MixX#set","Spine.PathConstraint#MixY#get","Spine.PathConstraint#MixY#set","Spine.PathConstraint#Bones#get","Spine.PathConstraint#Target#get","Spine.PathConstraint#Target#set","Spine.PathConstraint#Active#get","Spine.PathConstraint#Data#get","Spine.PathConstraint#init","Spine.PathConstraint#$ctor1","Spine.PathConstraint#ctor","Spine.PathConstraint#SetToSetupPose","Spine.PathConstraint#Update","Spine.PathConstraint#ComputeWorldPositions","Spine.PathConstraint#toString","Spine.PathConstraintData#Bones#get","Spine.PathConstraintData#Target#get","Spine.PathConstraintData#Target#set","Spine.PathConstraintData#PositionMode#get","Spine.PathConstraintData#PositionMode#set","Spine.PathConstraintData#SpacingMode#get","Spine.PathConstraintData#SpacingMode#set","Spine.PathConstraintData#RotateMode#get","Spine.PathConstraintData#RotateMode#set","Spine.PathConstraintData#OffsetRotation#get","Spine.PathConstraintData#OffsetRotation#set","Spine.PathConstraintData#Position#get","Spine.PathConstraintData#Position#set","Spine.PathConstraintData#Spacing#get","Spine.PathConstraintData#Spacing#set","Spine.PathConstraintData#RotateMix#get","Spine.PathConstraintData#RotateMix#set","Spine.PathConstraintData#MixX#get","Spine.PathConstraintData#MixX#set","Spine.PathConstraintData#MixY#get","Spine.PathConstraintData#MixY#set","Spine.PathConstraintData#init","Spine.PathConstraintData#ctor","Spine.PhysicsConstraint#Bone#get","Spine.PhysicsConstraint#Bone#set","Spine.PhysicsConstraint#Inertia#get","Spine.PhysicsConstraint#Inertia#set","Spine.PhysicsConstraint#Strength#get","Spine.PhysicsConstraint#Strength#set","Spine.PhysicsConstraint#Damping#get","Spine.PhysicsConstraint#Damping#set","Spine.PhysicsConstraint#MassInverse#get","Spine.PhysicsConstraint#MassInverse#set","Spine.PhysicsConstraint#Wind#get","Spine.PhysicsConstraint#Wind#set","Spine.PhysicsConstraint#Gravity#get","Spine.PhysicsConstraint#Gravity#set","Spine.PhysicsConstraint#Mix#get","Spine.PhysicsConstraint#Mix#set","Spine.PhysicsConstraint#Active#get","Spine.PhysicsConstraint#Data#get","Spine.PhysicsConstraint#init","Spine.PhysicsConstraint#$ctor1","Spine.PhysicsConstraint#ctor","Spine.PhysicsConstraint#Reset","Spine.PhysicsConstraint#SetToSetupPose","Spine.PhysicsConstraint#Translate","Spine.PhysicsConstraint#Rotate","Spine.PhysicsConstraint#Update","Spine.PhysicsConstraint#getData","Spine.PhysicsConstraint#toString","Spine.PhysicsConstraintData#Bone#get","Spine.PhysicsConstraintData#Step#get","Spine.PhysicsConstraintData#Step#set","Spine.PhysicsConstraintData#X#get","Spine.PhysicsConstraintData#X#set","Spine.PhysicsConstraintData#Y#get","Spine.PhysicsConstraintData#Y#set","Spine.PhysicsConstraintData#Rotate#get","Spine.PhysicsConstraintData#Rotate#set","Spine.PhysicsConstraintData#ScaleX#get","Spine.PhysicsConstraintData#ScaleX#set","Spine.PhysicsConstraintData#ShearX#get","Spine.PhysicsConstraintData#ShearX#set","Spine.PhysicsConstraintData#Limit#get","Spine.PhysicsConstraintData#Limit#set","Spine.PhysicsConstraintData#Inertia#get","Spine.PhysicsConstraintData#Inertia#set","Spine.PhysicsConstraintData#Strength#get","Spine.PhysicsConstraintData#Strength#set","Spine.PhysicsConstraintData#Damping#get","Spine.PhysicsConstraintData#Damping#set","Spine.PhysicsConstraintData#MassInverse#get","Spine.PhysicsConstraintData#MassInverse#set","Spine.PhysicsConstraintData#Wind#get","Spine.PhysicsConstraintData#Wind#set","Spine.PhysicsConstraintData#Gravity#get","Spine.PhysicsConstraintData#Gravity#set","Spine.PhysicsConstraintData#Mix#get","Spine.PhysicsConstraintData#Mix#set","Spine.PhysicsConstraintData#InertiaGlobal#get","Spine.PhysicsConstraintData#InertiaGlobal#set","Spine.PhysicsConstraintData#StrengthGlobal#get","Spine.PhysicsConstraintData#StrengthGlobal#set","Spine.PhysicsConstraintData#DampingGlobal#get","Spine.PhysicsConstraintData#DampingGlobal#set","Spine.PhysicsConstraintData#MassGlobal#get","Spine.PhysicsConstraintData#MassGlobal#set","Spine.PhysicsConstraintData#WindGlobal#get","Spine.PhysicsConstraintData#WindGlobal#set","Spine.PhysicsConstraintData#GravityGlobal#get","Spine.PhysicsConstraintData#GravityGlobal#set","Spine.PhysicsConstraintData#MixGlobal#get","Spine.PhysicsConstraintData#MixGlobal#set","Spine.PhysicsConstraintData#ctor","Spine.PhysicsConstraintResetTimeline#init","Spine.PhysicsConstraintResetTimeline#PhysicsConstraintIndex#get","Spine.PhysicsConstraintResetTimeline#FrameCount#get","Spine.PhysicsConstraintResetTimeline#ctor","Spine.PhysicsConstraintResetTimeline#SetFrame","Spine.PhysicsConstraintResetTimeline#Apply","Spine.PointAttachment#X#get","Spine.PointAttachment#X#set","Spine.PointAttachment#Y#get","Spine.PointAttachment#Y#set","Spine.PointAttachment#Rotation#get","Spine.PointAttachment#Rotation#set","Spine.PointAttachment#$ctor1","Spine.PointAttachment#ctor","Spine.PointAttachment#ComputeWorldPosition","Spine.PointAttachment#ComputeWorldRotation","Spine.PointAttachment#Copy","Spine.Pow#ctor","Spine.Pow#Apply$1","Spine.RegionAttachment#init","Spine.RegionAttachment#X#get","Spine.RegionAttachment#X#set","Spine.RegionAttachment#Y#get","Spine.RegionAttachment#Y#set","Spine.RegionAttachment#Rotation#get","Spine.RegionAttachment#Rotation#set","Spine.RegionAttachment#ScaleX#get","Spine.RegionAttachment#ScaleX#set","Spine.RegionAttachment#ScaleY#get","Spine.RegionAttachment#ScaleY#set","Spine.RegionAttachment#Width#get","Spine.RegionAttachment#Width#set","Spine.RegionAttachment#Height#get","Spine.RegionAttachment#Height#set","Spine.RegionAttachment#R#get","Spine.RegionAttachment#R#set","Spine.RegionAttachment#G#get","Spine.RegionAttachment#G#set","Spine.RegionAttachment#B#get","Spine.RegionAttachment#B#set","Spine.RegionAttachment#A#get","Spine.RegionAttachment#A#set","Spine.RegionAttachment#Region#get","Spine.RegionAttachment#Region#set","Spine.RegionAttachment#Offset#get","Spine.RegionAttachment#UVs#get","Spine.RegionAttachment#Sequence#get","Spine.RegionAttachment#Sequence#set","Spine.RegionAttachment#init","Spine.RegionAttachment#$ctor1","Spine.RegionAttachment#ctor","Spine.RegionAttachment#UpdateRegion","Spine.RegionAttachment#ComputeWorldVertices","Spine.RegionAttachment#Copy","Spine.SequenceTimeline#init","Spine.SequenceTimeline#FrameEntries#get","Spine.SequenceTimeline#SlotIndex#get","Spine.SequenceTimeline#Attachment#get","Spine.SequenceTimeline#ctor","Spine.SequenceTimeline#SetFrame","Spine.SequenceTimeline#Apply","Spine.SkeletonBinary#init","Spine.SkeletonBinary#GetVersionString","Spine.SkeletonBinary#init","Spine.SkeletonBinary#$ctor1","Spine.SkeletonBinary#ctor","Spine.SkeletonBinary#ReadSkeletonData","Spine.SkeletonBinary#ReadSkeletonData$1","Spine.SkeletonBinary#ReadSkin","Spine.SkeletonBinary#ReadAttachment","Spine.SkeletonBinary#ReadSequence","Spine.SkeletonBinary#ReadVertices","Spine.SkeletonBinary#ReadFloatArray","Spine.SkeletonBinary#ReadShortArray","Spine.SkeletonBinary#ReadAnimation","Spine.SkeletonBinary#ReadTimeline","Spine.SkeletonBinary#ReadTimeline$1","Spine.SkeletonBinary#SetBezier","Spine.SkeletonJson#ReadSequence","Spine.SkeletonJson#ReadTimeline","Spine.SkeletonJson#ReadTimeline$1","Spine.SkeletonJson#ReadCurve","Spine.SkeletonJson#SetBezier","Spine.SkeletonJson#GetFloatArray","Spine.SkeletonJson#GetIntArray","Spine.SkeletonJson#GetFloat","Spine.SkeletonJson#GetInt$1","Spine.SkeletonJson#GetInt","Spine.SkeletonJson#GetBoolean","Spine.SkeletonJson#GetString","Spine.SkeletonJson#ToColor","Spine.SkeletonJson#init","Spine.SkeletonJson#$ctor1","Spine.SkeletonJson#ctor","Spine.SkeletonJson#ReadSkeletonData","Spine.SkeletonJson#ReadSkeletonData$1","Spine.SkeletonJson#ReadAttachment","Spine.SkeletonJson#ReadVertices","Spine.SkeletonJson#FindSlotIndex","Spine.SkeletonJson#ReadAnimation","Spine.Skin.SkinKeyComparer#init","Spine.Skin.SkinKeyComparer#System$Collections$Generic$IEqualityComparer$1$Spine$Skin$SkinKey$equals2","Spine.Skin.SkinKeyComparer#System$Collections$Generic$IEqualityComparer$1$Spine$Skin$SkinKey$getHashCode2","Spine.TrackEntry#inherits","Spine.TrackEntry#TrackIndex#get","Spine.TrackEntry#Animation#get","Spine.TrackEntry#Loop#get","Spine.TrackEntry#Loop#set","Spine.TrackEntry#Delay#get","Spine.TrackEntry#Delay#set","Spine.TrackEntry#TrackTime#get","Spine.TrackEntry#TrackTime#set","Spine.TrackEntry#TrackEnd#get","Spine.TrackEntry#TrackEnd#set","Spine.TrackEntry#TrackComplete#get","Spine.TrackEntry#AnimationStart#get","Spine.TrackEntry#AnimationStart#set","Spine.TrackEntry#AnimationEnd#get","Spine.TrackEntry#AnimationEnd#set","Spine.TrackEntry#AnimationLast#get","Spine.TrackEntry#AnimationLast#set","Spine.TrackEntry#AnimationTime#get","Spine.TrackEntry#TimeScale#get","Spine.TrackEntry#TimeScale#set","Spine.TrackEntry#Alpha#get","Spine.TrackEntry#Alpha#set","Spine.TrackEntry#InterruptAlpha#get","Spine.TrackEntry#EventThreshold#get","Spine.TrackEntry#EventThreshold#set","Spine.TrackEntry#AlphaAttachmentThreshold#get","Spine.TrackEntry#AlphaAttachmentThreshold#set","Spine.TrackEntry#MixAttachmentThreshold#get","Spine.TrackEntry#MixAttachmentThreshold#set","Spine.TrackEntry#MixDrawOrderThreshold#get","Spine.TrackEntry#MixDrawOrderThreshold#set","Spine.TrackEntry#Next#get","Spine.TrackEntry#Previous#get","Spine.TrackEntry#WasApplied#get","Spine.TrackEntry#IsNextReady#get","Spine.TrackEntry#IsComplete#get","Spine.TrackEntry#MixTime#get","Spine.TrackEntry#MixTime#set","Spine.TrackEntry#MixDuration#get","Spine.TrackEntry#MixDuration#set","Spine.TrackEntry#MixBlend#get","Spine.TrackEntry#MixBlend#set","Spine.TrackEntry#MixingFrom#get","Spine.TrackEntry#MixingTo#get","Spine.TrackEntry#HoldPrevious#get","Spine.TrackEntry#HoldPrevious#set","Spine.TrackEntry#Reverse#get","Spine.TrackEntry#Reverse#set","Spine.TrackEntry#ShortestRotation#get","Spine.TrackEntry#ShortestRotation#set","Spine.TrackEntry#IsEmptyAnimation#get","Spine.TrackEntry#init","Spine.TrackEntry#OnStart","Spine.TrackEntry#OnInterrupt","Spine.TrackEntry#OnEnd","Spine.TrackEntry#OnDispose","Spine.TrackEntry#OnComplete","Spine.TrackEntry#OnEvent","Spine.TrackEntry#Reset","Spine.TrackEntry#SetMixDuration","Spine.TrackEntry#ResetRotationDirections","Spine.TrackEntry#toString","Spine.TrackEntry#AllowImmediateQueue","Spine.TransformConstraint#Bones#get","Spine.TransformConstraint#Target#get","Spine.TransformConstraint#Target#set","Spine.TransformConstraint#MixRotate#get","Spine.TransformConstraint#MixRotate#set","Spine.TransformConstraint#MixX#get","Spine.TransformConstraint#MixX#set","Spine.TransformConstraint#MixY#get","Spine.TransformConstraint#MixY#set","Spine.TransformConstraint#MixScaleX#get","Spine.TransformConstraint#MixScaleX#set","Spine.TransformConstraint#MixScaleY#get","Spine.TransformConstraint#MixScaleY#set","Spine.TransformConstraint#MixShearY#get","Spine.TransformConstraint#MixShearY#set","Spine.TransformConstraint#Active#get","Spine.TransformConstraint#Data#get","Spine.TransformConstraint#$ctor1","Spine.TransformConstraint#ctor","Spine.TransformConstraint#SetToSetupPose","Spine.TransformConstraint#Update","Spine.TransformConstraint#ApplyAbsoluteWorld","Spine.TransformConstraint#ApplyRelativeWorld","Spine.TransformConstraint#ApplyAbsoluteLocal","Spine.TransformConstraint#ApplyRelativeLocal","Spine.TransformConstraint#toString","Spine.TransformConstraintData#Bones#get","Spine.TransformConstraintData#Target#get","Spine.TransformConstraintData#Target#set","Spine.TransformConstraintData#MixRotate#get","Spine.TransformConstraintData#MixRotate#set","Spine.TransformConstraintData#MixX#get","Spine.TransformConstraintData#MixX#set","Spine.TransformConstraintData#MixY#get","Spine.TransformConstraintData#MixY#set","Spine.TransformConstraintData#MixScaleX#get","Spine.TransformConstraintData#MixScaleX#set","Spine.TransformConstraintData#MixScaleY#get","Spine.TransformConstraintData#MixScaleY#set","Spine.TransformConstraintData#MixShearY#get","Spine.TransformConstraintData#MixShearY#set","Spine.TransformConstraintData#OffsetRotation#get","Spine.TransformConstraintData#OffsetRotation#set","Spine.TransformConstraintData#OffsetX#get","Spine.TransformConstraintData#OffsetX#set","Spine.TransformConstraintData#OffsetY#get","Spine.TransformConstraintData#OffsetY#set","Spine.TransformConstraintData#OffsetScaleX#get","Spine.TransformConstraintData#OffsetScaleX#set","Spine.TransformConstraintData#OffsetScaleY#get","Spine.TransformConstraintData#OffsetScaleY#set","Spine.TransformConstraintData#OffsetShearY#get","Spine.TransformConstraintData#OffsetShearY#set","Spine.TransformConstraintData#Relative#get","Spine.TransformConstraintData#Relative#set","Spine.TransformConstraintData#Local#get","Spine.TransformConstraintData#Local#set","Spine.TransformConstraintData#init","Spine.TransformConstraintData#ctor","Spine.Unity.BlendModeMaterialsAsset#ApplyMaterials","Spine.Unity.BlendModeMaterialsAsset#init","Spine.Unity.BlendModeMaterialsAsset#Apply","Spine.Unity.MaterialsTextureLoader#ctor","Spine.Unity.MaterialsTextureLoader#Load","Spine.Unity.MaterialsTextureLoader#Unload","Spine.Unity.NoOpTextureLoader#Load","Spine.Unity.NoOpTextureLoader#Unload","Spine.Unity.RegionlessAttachmentLoader#EmptyRegion#get","Spine.Unity.RegionlessAttachmentLoader#NewRegionAttachment","Spine.Unity.RegionlessAttachmentLoader#NewMeshAttachment","Spine.Unity.RegionlessAttachmentLoader#NewBoundingBoxAttachment","Spine.Unity.RegionlessAttachmentLoader#NewPathAttachment","Spine.Unity.RegionlessAttachmentLoader#NewPointAttachment","Spine.Unity.RegionlessAttachmentLoader#NewClippingAttachment","Spine.Unity.SkeletonMecanimRootMotion#init","Spine.Unity.SkeletonMecanimRootMotion#SkeletonMecanim#get","Spine.Unity.SkeletonMecanimRootMotion#init","Spine.Unity.SkeletonMecanimRootMotion#GetRemainingRootMotion","Spine.Unity.SkeletonMecanimRootMotion#GetRootMotionInfo","Spine.Unity.SkeletonMecanimRootMotion#Reset","Spine.Unity.SkeletonMecanimRootMotion#Initialize","Spine.Unity.SkeletonMecanimRootMotion#OnClipApplied","Spine.Unity.SkeletonMecanimRootMotion#CalculateAnimationsMovementDelta","Spine.Unity.SkeletonMecanimRootMotion#CalculateAnimationsRotationDelta","Spine.Unity.SkeletonRootMotion#init","Spine.Unity.SkeletonRootMotion#AdditionalScale#get","Spine.Unity.SkeletonRootMotion#init","Spine.Unity.SkeletonRootMotion#GetRemainingRootMotion","Spine.Unity.SkeletonRootMotion#GetRootMotionInfo","Spine.Unity.SkeletonRootMotion#Reset","Spine.Unity.SkeletonRootMotion#Initialize","Spine.Unity.SkeletonRootMotion#CalculateAnimationsMovementDelta","Spine.Unity.SkeletonRootMotion#CalculateAnimationsRotationDelta","Spine.Unity.SkeletonRootMotion#ApplyMixAlphaToDelta$1","Spine.Unity.SkeletonRootMotion#ApplyMixAlphaToDelta","Spine.Unity.SkeletonRootMotion#GetMixAlpha","Spine.Unity.SpineAnimation#ctor","Spine.Unity.SpineAtlasAsset#CreateRuntimeInstance","Spine.Unity.SpineAtlasAsset#CreateRuntimeInstance$1","Spine.Unity.SpineAtlasAsset#CreateRuntimeInstance$2","Spine.Unity.SpineAtlasAsset#IsLoaded#get","Spine.Unity.SpineAtlasAsset#Materials#get","Spine.Unity.SpineAtlasAsset#MaterialCount#get","Spine.Unity.SpineAtlasAsset#PrimaryMaterial#get","Spine.Unity.SpineAtlasAsset#Reset","Spine.Unity.SpineAtlasAsset#Clear","Spine.Unity.SpineAtlasAsset#GetAtlas","Spine.Unity.SpineAtlasAsset#GenerateMesh","Spine.Unity.SpineAttachment#getHierarchy","Spine.Unity.SpineAttachment#getAttachment","Spine.Unity.SpineAttachment#getAttachment$1","Spine.Unity.SpineAttachment#init","Spine.Unity.SpineAttachment#ctor","Spine.Unity.SpineBone#getBone","Spine.Unity.SpineBone#getBoneData","Spine.Unity.SpineBone#ctor","Spine.Unity.SpineEvent#init","Spine.Unity.SpineEvent#ctor","Spine.Unity.SpineIkConstraint#ctor","Spine.Unity.SpinePathConstraint#ctor","Spine.Unity.SpineSkin#init","Spine.Unity.SpineSkin#ctor","Spine.Unity.SpineSlot#init","Spine.Unity.SpineSlot#ctor","Spine.Unity.SpineSpriteAtlasAsset#CreateRuntimeInstance","Spine.Unity.SpineSpriteAtlasAsset#AccessPackedTexture","Spine.Unity.SpineSpriteAtlasAsset#AccessPackedSprites","Spine.Unity.SpineSpriteAtlasAsset#IsLoaded#get","Spine.Unity.SpineSpriteAtlasAsset#Materials#get","Spine.Unity.SpineSpriteAtlasAsset#MaterialCount#get","Spine.Unity.SpineSpriteAtlasAsset#PrimaryMaterial#get","Spine.Unity.SpineSpriteAtlasAsset#Reset","Spine.Unity.SpineSpriteAtlasAsset#Clear","Spine.Unity.SpineSpriteAtlasAsset#GetAtlas","Spine.Unity.SpineSpriteAtlasAsset#AssignRegionsFromSavedRegions","Spine.Unity.SpineSpriteAtlasAsset#LoadAtlas","Spine.Unity.SpineTransformConstraint#ctor","Spine.Unity.WaitForSpineAnimationComplete#ctor","Spine.Unity.WaitForSpineAnimationComplete#NowWaitFor$1","Spine.Unity.WaitForSpineAnimationEnd#ctor","Spine.Unity.WaitForSpineAnimationEnd#NowWaitFor$1","Spine.CurveTimeline1#init","Spine.CurveTimeline1#FrameEntries#get","Spine.CurveTimeline1#ctor","Spine.CurveTimeline1#SetFrame","Spine.CurveTimeline1#GetCurveValue","Spine.CurveTimeline1#GetRelativeValue","Spine.CurveTimeline1#GetAbsoluteValue","Spine.CurveTimeline1#GetAbsoluteValue$1","Spine.CurveTimeline1#GetScaleValue","Spine.Atlas#ReadEntry","Spine.Atlas#Regions#get","Spine.Atlas#Pages#get","Spine.Atlas#init","Spine.Atlas#ctor","Spine.Atlas#$ctor1","Spine.Atlas#GetEnumerator","Spine.Atlas#System$Collections$IEnumerable$GetEnumerator","Spine.Atlas#FlipV","Spine.Atlas#FindRegion","Spine.Atlas#Dispose","Spine.BoundingBoxAttachment#$ctor1","Spine.BoundingBoxAttachment#ctor","Spine.BoundingBoxAttachment#Copy","Spine.ClippingAttachment#EndSlot#get","Spine.ClippingAttachment#EndSlot#set","Spine.ClippingAttachment#$ctor1","Spine.ClippingAttachment#ctor","Spine.ClippingAttachment#Copy","Spine.CurveTimeline2#init","Spine.CurveTimeline2#FrameEntries#get","Spine.CurveTimeline2#ctor","Spine.CurveTimeline2#SetFrame","Spine.DeformTimeline#SlotIndex#get","Spine.DeformTimeline#Attachment#get","Spine.DeformTimeline#Vertices#get","Spine.DeformTimeline#ctor","Spine.DeformTimeline#SetFrame","Spine.DeformTimeline#setBezier","Spine.DeformTimeline#GetCurvePercent","Spine.DeformTimeline#Apply","Spine.IkConstraintTimeline#init","Spine.IkConstraintTimeline#FrameEntries#get","Spine.IkConstraintTimeline#IkConstraintIndex#get","Spine.IkConstraintTimeline#ctor","Spine.IkConstraintTimeline#SetFrame","Spine.IkConstraintTimeline#Apply","Spine.MeshAttachment#Region#get","Spine.MeshAttachment#Region#set","Spine.MeshAttachment#HullLength#get","Spine.MeshAttachment#HullLength#set","Spine.MeshAttachment#RegionUVs#get","Spine.MeshAttachment#RegionUVs#set","Spine.MeshAttachment#UVs#get","Spine.MeshAttachment#UVs#set","Spine.MeshAttachment#Triangles#get","Spine.MeshAttachment#Triangles#set","Spine.MeshAttachment#R#get","Spine.MeshAttachment#R#set","Spine.MeshAttachment#G#get","Spine.MeshAttachment#G#set","Spine.MeshAttachment#B#get","Spine.MeshAttachment#B#set","Spine.MeshAttachment#A#get","Spine.MeshAttachment#A#set","Spine.MeshAttachment#Path#get","Spine.MeshAttachment#Path#set","Spine.MeshAttachment#Sequence#get","Spine.MeshAttachment#Sequence#set","Spine.MeshAttachment#ParentMesh#get","Spine.MeshAttachment#ParentMesh#set","Spine.MeshAttachment#init","Spine.MeshAttachment#$ctor1","Spine.MeshAttachment#ctor","Spine.MeshAttachment#UpdateRegion","Spine.MeshAttachment#ComputeWorldVertices","Spine.MeshAttachment#NewLinkedMesh","Spine.MeshAttachment#Copy","Spine.PathAttachment#Lengths#get","Spine.PathAttachment#Lengths#set","Spine.PathAttachment#Closed#get","Spine.PathAttachment#Closed#set","Spine.PathAttachment#ConstantSpeed#get","Spine.PathAttachment#ConstantSpeed#set","Spine.PathAttachment#$ctor1","Spine.PathAttachment#ctor","Spine.PathAttachment#Copy","Spine.PathConstraintMixTimeline#init","Spine.PathConstraintMixTimeline#FrameEntries#get","Spine.PathConstraintMixTimeline#PathConstraintIndex#get","Spine.PathConstraintMixTimeline#ctor","Spine.PathConstraintMixTimeline#SetFrame","Spine.PathConstraintMixTimeline#Apply","Spine.PowOut#ctor","Spine.PowOut#Apply$1","Spine.RGB2Timeline#init","Spine.RGB2Timeline#FrameEntries#get","Spine.RGB2Timeline#SlotIndex#get","Spine.RGB2Timeline#ctor","Spine.RGB2Timeline#SetFrame","Spine.RGB2Timeline#Apply","Spine.RGBA2Timeline#init","Spine.RGBA2Timeline#FrameEntries#get","Spine.RGBA2Timeline#SlotIndex#get","Spine.RGBA2Timeline#ctor","Spine.RGBA2Timeline#SetFrame","Spine.RGBA2Timeline#Apply","Spine.RGBATimeline#init","Spine.RGBATimeline#FrameEntries#get","Spine.RGBATimeline#SlotIndex#get","Spine.RGBATimeline#ctor","Spine.RGBATimeline#SetFrame","Spine.RGBATimeline#Apply","Spine.RGBTimeline#init","Spine.RGBTimeline#FrameEntries#get","Spine.RGBTimeline#SlotIndex#get","Spine.RGBTimeline#ctor","Spine.RGBTimeline#SetFrame","Spine.RGBTimeline#Apply","Spine.TransformConstraintTimeline#init","Spine.TransformConstraintTimeline#FrameEntries#get","Spine.TransformConstraintTimeline#TransformConstraintIndex#get","Spine.TransformConstraintTimeline#ctor","Spine.TransformConstraintTimeline#SetFrame","Spine.TransformConstraintTimeline#Apply","Spine.TransformConstraintTimeline#GetCurveValue","Spine.Unity.AnimationReferenceAsset#init","Spine.Unity.AnimationReferenceAsset#op_Implicit","Spine.Unity.AnimationReferenceAsset#SkeletonDataAsset#get","Spine.Unity.AnimationReferenceAsset#Animation#get","Spine.Unity.AnimationReferenceAsset#Clear","Spine.Unity.AnimationReferenceAsset#Initialize","Spine.Unity.PointFollower#SkeletonRenderer#get","Spine.Unity.PointFollower#SkeletonComponent#get","Spine.Unity.PointFollower#IsValid#get","Spine.Unity.PointFollower#init","Spine.Unity.PointFollower#Initialize","Spine.Unity.PointFollower#HandleRebuildRenderer","Spine.Unity.PointFollower#UpdateReferences","Spine.Unity.PointFollower#OnDestroy","Spine.Unity.PointFollower#LateUpdate","Spine.Unity.SkeletonRenderer#init","Spine.Unity.SkeletonRenderer#NewSpineGameObject","Spine.Unity.SkeletonRenderer#AddSpineComponent","Spine.Unity.SkeletonRenderer#UpdateMode#get","Spine.Unity.SkeletonRenderer#UpdateMode#set","Spine.Unity.SkeletonRenderer#CustomMaterialOverride#get","Spine.Unity.SkeletonRenderer#CustomSlotMaterials#get","Spine.Unity.SkeletonRenderer#SkeletonClipping#get","Spine.Unity.SkeletonRenderer#Skeleton#get","Spine.Unity.SkeletonRenderer#PhysicsPositionInheritanceFactor#get","Spine.Unity.SkeletonRenderer#PhysicsPositionInheritanceFactor#set","Spine.Unity.SkeletonRenderer#PhysicsRotationInheritanceFactor#get","Spine.Unity.SkeletonRenderer#PhysicsRotationInheritanceFactor#set","Spine.Unity.SkeletonRenderer#PhysicsMovementRelativeTo#get","Spine.Unity.SkeletonRenderer#PhysicsMovementRelativeTo#set","Spine.Unity.SkeletonRenderer#SkeletonDataAsset#get","Spine.Unity.SkeletonRenderer#init","Spine.Unity.SkeletonRenderer#addGenerateMeshOverride","Spine.Unity.SkeletonRenderer#removeGenerateMeshOverride","Spine.Unity.SkeletonRenderer#ResetLastPosition","Spine.Unity.SkeletonRenderer#ResetLastRotation","Spine.Unity.SkeletonRenderer#ResetLastPositionAndRotation","Spine.Unity.SkeletonRenderer#SetMeshSettings","Spine.Unity.SkeletonRenderer#Awake","Spine.Unity.SkeletonRenderer#OnDisable","Spine.Unity.SkeletonRenderer#OnDestroy","Spine.Unity.SkeletonRenderer#ClearState","Spine.Unity.SkeletonRenderer#EnsureMeshGeneratorCapacity","Spine.Unity.SkeletonRenderer#Initialize","Spine.Unity.SkeletonRenderer#ApplyTransformMovementToPhysics","Spine.Unity.SkeletonRenderer#GetPhysicsTransformPosition","Spine.Unity.SkeletonRenderer#GetPhysicsTransformRotation","Spine.Unity.SkeletonRenderer#UpdateWorldTransform","Spine.Unity.SkeletonRenderer#LateUpdate","Spine.Unity.SkeletonRenderer#LateUpdateMesh","Spine.Unity.SkeletonRenderer#OnBecameVisible","Spine.Unity.SkeletonRenderer#OnBecameInvisible","Spine.Unity.SkeletonRenderer#FindAndApplySeparatorSlots$1","Spine.Unity.SkeletonRenderer#FindAndApplySeparatorSlots","Spine.Unity.SkeletonRenderer#ReapplySeparatorSlotNames","Spine.Unity.SkeletonRenderer#AssignSpriteMaskMaterials","Spine.Unity.SkeletonRenderer#InitSpriteMaskMaterialsInsideMask","Spine.Unity.SkeletonRenderer#InitSpriteMaskMaterialsOutsideMask","Spine.Unity.SkeletonRenderer#InitSpriteMaskMaterialsForMaskType","Spine.Unity.SkeletonRenderer#HandleOnDemandLoading","Spine.Unity.SkeletonRenderer#SetMaterialSettingsToFixDrawOrder","Spine.Unity.SkeletonGraphic#init","Spine.Unity.SkeletonGraphic#NewSkeletonGraphicGameObject","Spine.Unity.SkeletonGraphic#AddSkeletonGraphicComponent","Spine.Unity.SkeletonGraphic#SetRectTransformSize$1","Spine.Unity.SkeletonGraphic#SetRectTransformSize","Spine.Unity.SkeletonGraphic#SkeletonDataAsset#get","Spine.Unity.SkeletonGraphic#color#get","Spine.Unity.SkeletonGraphic#color#set","Spine.Unity.SkeletonGraphic#MeshScale#get","Spine.Unity.SkeletonGraphic#MeshOffset#get","Spine.Unity.SkeletonGraphic#UpdateMode#get","Spine.Unity.SkeletonGraphic#UpdateMode#set","Spine.Unity.SkeletonGraphic#SeparatorParts#get","Spine.Unity.SkeletonGraphic#CustomTextureOverride#get","Spine.Unity.SkeletonGraphic#CustomMaterialOverride#get","Spine.Unity.SkeletonGraphic#OverrideTexture#get","Spine.Unity.SkeletonGraphic#OverrideTexture#set","Spine.Unity.SkeletonGraphic#mainTexture#get","Spine.Unity.SkeletonGraphic#Skeleton#get","Spine.Unity.SkeletonGraphic#Skeleton#set","Spine.Unity.SkeletonGraphic#SkeletonData#get","Spine.Unity.SkeletonGraphic#IsValid#get","Spine.Unity.SkeletonGraphic#AnimationState#get","Spine.Unity.SkeletonGraphic#PhysicsPositionInheritanceFactor#get","Spine.Unity.SkeletonGraphic#PhysicsPositionInheritanceFactor#set","Spine.Unity.SkeletonGraphic#PhysicsRotationInheritanceFactor#get","Spine.Unity.SkeletonGraphic#PhysicsRotationInheritanceFactor#set","Spine.Unity.SkeletonGraphic#PhysicsMovementRelativeTo#get","Spine.Unity.SkeletonGraphic#PhysicsMovementRelativeTo#set","Spine.Unity.SkeletonGraphic#MeshGenerator#get","Spine.Unity.SkeletonGraphic#SkeletonClipping#get","Spine.Unity.SkeletonGraphic#MeshesMultipleCanvasRenderers#get","Spine.Unity.SkeletonGraphic#MaterialsMultipleCanvasRenderers#get","Spine.Unity.SkeletonGraphic#TexturesMultipleCanvasRenderers#get","Spine.Unity.SkeletonGraphic#UpdateTiming#get","Spine.Unity.SkeletonGraphic#UpdateTiming#set","Spine.Unity.SkeletonGraphic#UnscaledTime#get","Spine.Unity.SkeletonGraphic#UnscaledTime#set","Spine.Unity.SkeletonGraphic#init","Spine.Unity.SkeletonGraphic#addAssignMeshOverrideSingleRenderer","Spine.Unity.SkeletonGraphic#removeAssignMeshOverrideSingleRenderer","Spine.Unity.SkeletonGraphic#addAssignMeshOverrideMultipleRenderers","Spine.Unity.SkeletonGraphic#removeAssignMeshOverrideMultipleRenderers","Spine.Unity.SkeletonGraphic#Awake","Spine.Unity.SkeletonGraphic#OnDestroy","Spine.Unity.SkeletonGraphic#Rebuild","Spine.Unity.SkeletonGraphic#OnDisable","Spine.Unity.SkeletonGraphic#Update","Spine.Unity.SkeletonGraphic#Update$1","Spine.Unity.SkeletonGraphic#FixedUpdate","Spine.Unity.SkeletonGraphic#SyncSubmeshGraphicsWithCanvasRenderers","Spine.Unity.SkeletonGraphic#UpdateAnimationStatus","Spine.Unity.SkeletonGraphic#ApplyTransformMovementToPhysics","Spine.Unity.SkeletonGraphic#GetPhysicsTransformPosition","Spine.Unity.SkeletonGraphic#GetPhysicsTransformRotation","Spine.Unity.SkeletonGraphic#ApplyAnimation","Spine.Unity.SkeletonGraphic#AfterAnimationApplied","Spine.Unity.SkeletonGraphic#UpdateWorldTransform","Spine.Unity.SkeletonGraphic#LateUpdate","Spine.Unity.SkeletonGraphic#OnCullStateChanged","Spine.Unity.SkeletonGraphic#OnBecameVisible","Spine.Unity.SkeletonGraphic#OnBecameInvisible","Spine.Unity.SkeletonGraphic#ReapplySeparatorSlotNames","Spine.Unity.SkeletonGraphic#ResetLastPosition","Spine.Unity.SkeletonGraphic#ResetLastRotation","Spine.Unity.SkeletonGraphic#ResetLastPositionAndRotation","Spine.Unity.SkeletonGraphic#GetLastMesh","Spine.Unity.SkeletonGraphic#MatchRectTransformWithBounds","Spine.Unity.SkeletonGraphic#MatchRectTransformSingleRenderer","Spine.Unity.SkeletonGraphic#MatchRectTransformMultipleRenderers","Spine.Unity.SkeletonGraphic#SetRectTransformBounds","Spine.Unity.SkeletonGraphic#Clear","Spine.Unity.SkeletonGraphic#TrimRenderers","Spine.Unity.SkeletonGraphic#Initialize","Spine.Unity.SkeletonGraphic#PrepareInstructionsAndRenderers","Spine.Unity.SkeletonGraphic#UpdateMesh","Spine.Unity.SkeletonGraphic#UpdateMeshToInstructions","Spine.Unity.SkeletonGraphic#HasMultipleSubmeshInstructions","Spine.Unity.SkeletonGraphic#InitMeshBuffers","Spine.Unity.SkeletonGraphic#DisposeMeshBuffers","Spine.Unity.SkeletonGraphic#UpdateMeshSingleCanvasRenderer","Spine.Unity.SkeletonGraphic#UpdateMaterialsMultipleCanvasRenderers","Spine.Unity.SkeletonGraphic#UpdateMeshMultipleCanvasRenderers","Spine.Unity.SkeletonGraphic#HandleOnDemandLoading","Spine.Unity.SkeletonGraphic#EnsureCanvasRendererCount","Spine.Unity.SkeletonGraphic#PrepareRendererGameObjects","Spine.Unity.SkeletonGraphic#DisableUnusedCanvasRenderers","Spine.Unity.SkeletonGraphic#EnsureMeshesCount","Spine.Unity.SkeletonGraphic#EnsureUsedTexturesAndMaterialsCount","Spine.Unity.SkeletonGraphic#DestroyMeshes","Spine.Unity.SkeletonGraphic#EnsureSeparatorPartCount","Spine.Unity.SkeletonGraphic#UpdateSeparatorPartParents","Spine.Unity.SkeletonGraphic#GetLayoutScale","Spine.Unity.SkeletonGraphic#GetEffectiveLayoutMode","Spine.Unity.SkeletonGraphic#GetCurrentRectSize","Spine.AlphaTimeline#SlotIndex#get","Spine.AlphaTimeline#ctor","Spine.AlphaTimeline#Apply","Spine.PathConstraintPositionTimeline#PathConstraintIndex#get","Spine.PathConstraintPositionTimeline#ctor","Spine.PathConstraintPositionTimeline#Apply","Spine.PathConstraintSpacingTimeline#PathConstraintIndex#get","Spine.PathConstraintSpacingTimeline#ctor","Spine.PathConstraintSpacingTimeline#Apply","Spine.PhysicsConstraintTimeline#PhysicsConstraintIndex#get","Spine.PhysicsConstraintTimeline#ctor","Spine.PhysicsConstraintTimeline#Apply","Spine.RotateTimeline#BoneIndex#get","Spine.RotateTimeline#ctor","Spine.RotateTimeline#Apply","Spine.ScaleTimeline#BoneIndex#get","Spine.ScaleTimeline#ctor","Spine.ScaleTimeline#Apply","Spine.ScaleXTimeline#BoneIndex#get","Spine.ScaleXTimeline#ctor","Spine.ScaleXTimeline#Apply","Spine.ScaleYTimeline#BoneIndex#get","Spine.ScaleYTimeline#ctor","Spine.ScaleYTimeline#Apply","Spine.ShearTimeline#BoneIndex#get","Spine.ShearTimeline#ctor","Spine.ShearTimeline#Apply","Spine.ShearXTimeline#BoneIndex#get","Spine.ShearXTimeline#ctor","Spine.ShearXTimeline#Apply","Spine.ShearYTimeline#BoneIndex#get","Spine.ShearYTimeline#ctor","Spine.ShearYTimeline#Apply","Spine.TranslateTimeline#BoneIndex#get","Spine.TranslateTimeline#ctor","Spine.TranslateTimeline#Apply","Spine.TranslateTimeline#GetCurveValue","Spine.TranslateXTimeline#BoneIndex#get","Spine.TranslateXTimeline#ctor","Spine.TranslateXTimeline#Apply","Spine.TranslateYTimeline#BoneIndex#get","Spine.TranslateYTimeline#ctor","Spine.TranslateYTimeline#Apply","Spine.Unity.SkeletonAnimation#AddToGameObject","Spine.Unity.SkeletonAnimation#NewSkeletonAnimationGameObject","Spine.Unity.SkeletonAnimation#AnimationState#get","Spine.Unity.SkeletonAnimation#UpdateTiming#get","Spine.Unity.SkeletonAnimation#UpdateTiming#set","Spine.Unity.SkeletonAnimation#UnscaledTime#get","Spine.Unity.SkeletonAnimation#UnscaledTime#set","Spine.Unity.SkeletonAnimation#AnimationName#get","Spine.Unity.SkeletonAnimation#AnimationName#set","Spine.Unity.SkeletonAnimation#init","Spine.Unity.SkeletonAnimation#addOnAnimationRebuild","Spine.Unity.SkeletonAnimation#removeOnAnimationRebuild","Spine.Unity.SkeletonAnimation#addBeforeApply","Spine.Unity.SkeletonAnimation#removeBeforeApply","Spine.Unity.SkeletonAnimation#addUpdateLocal","Spine.Unity.SkeletonAnimation#removeUpdateLocal","Spine.Unity.SkeletonAnimation#addUpdateWorld","Spine.Unity.SkeletonAnimation#removeUpdateWorld","Spine.Unity.SkeletonAnimation#addUpdateComplete","Spine.Unity.SkeletonAnimation#removeUpdateComplete","Spine.Unity.SkeletonAnimation#ClearState","Spine.Unity.SkeletonAnimation#Initialize","Spine.Unity.SkeletonAnimation#Update$1","Spine.Unity.SkeletonAnimation#Update","Spine.Unity.SkeletonAnimation#FixedUpdate","Spine.Unity.SkeletonAnimation#UpdateAnimationStatus","Spine.Unity.SkeletonAnimation#ApplyAnimation","Spine.Unity.SkeletonAnimation#AfterAnimationApplied","Spine.Unity.SkeletonAnimation#LateUpdate","Spine.Unity.SkeletonAnimation#OnBecameVisible","Spine.Unity.SkeletonMecanim#Translator#get","Spine.Unity.SkeletonMecanim#UpdateTiming#get","Spine.Unity.SkeletonMecanim#UpdateTiming#set","Spine.Unity.SkeletonMecanim#init","Spine.Unity.SkeletonMecanim#addOnAnimationRebuild","Spine.Unity.SkeletonMecanim#removeOnAnimationRebuild","Spine.Unity.SkeletonMecanim#addBeforeApply","Spine.Unity.SkeletonMecanim#removeBeforeApply","Spine.Unity.SkeletonMecanim#addUpdateLocal","Spine.Unity.SkeletonMecanim#removeUpdateLocal","Spine.Unity.SkeletonMecanim#addUpdateWorld","Spine.Unity.SkeletonMecanim#removeUpdateWorld","Spine.Unity.SkeletonMecanim#addUpdateComplete","Spine.Unity.SkeletonMecanim#removeUpdateComplete","Spine.Unity.SkeletonMecanim#Initialize","Spine.Unity.SkeletonMecanim#Update","Spine.Unity.SkeletonMecanim#Update$1","Spine.Unity.SkeletonMecanim#FixedUpdate","Spine.Unity.SkeletonMecanim#UpdateAnimation","Spine.Unity.SkeletonMecanim#ApplyAnimation","Spine.Unity.SkeletonMecanim#AfterAnimationApplied","Spine.Unity.SkeletonMecanim#LateUpdate","Spine.Unity.SkeletonMecanim#OnBecameVisible","Spine.PhysicsConstraintDampingTimeline#ctor","Spine.PhysicsConstraintDampingTimeline#Setup","Spine.PhysicsConstraintDampingTimeline#Get","Spine.PhysicsConstraintDampingTimeline#Set","Spine.PhysicsConstraintDampingTimeline#Global","Spine.PhysicsConstraintGravityTimeline#ctor","Spine.PhysicsConstraintGravityTimeline#Setup","Spine.PhysicsConstraintGravityTimeline#Get","Spine.PhysicsConstraintGravityTimeline#Set","Spine.PhysicsConstraintGravityTimeline#Global","Spine.PhysicsConstraintInertiaTimeline#ctor","Spine.PhysicsConstraintInertiaTimeline#Setup","Spine.PhysicsConstraintInertiaTimeline#Get","Spine.PhysicsConstraintInertiaTimeline#Set","Spine.PhysicsConstraintInertiaTimeline#Global","Spine.PhysicsConstraintMassTimeline#ctor","Spine.PhysicsConstraintMassTimeline#Setup","Spine.PhysicsConstraintMassTimeline#Get","Spine.PhysicsConstraintMassTimeline#Set","Spine.PhysicsConstraintMassTimeline#Global","Spine.PhysicsConstraintMixTimeline#ctor","Spine.PhysicsConstraintMixTimeline#Setup","Spine.PhysicsConstraintMixTimeline#Get","Spine.PhysicsConstraintMixTimeline#Set","Spine.PhysicsConstraintMixTimeline#Global","Spine.PhysicsConstraintStrengthTimeline#ctor","Spine.PhysicsConstraintStrengthTimeline#Setup","Spine.PhysicsConstraintStrengthTimeline#Get","Spine.PhysicsConstraintStrengthTimeline#Set","Spine.PhysicsConstraintStrengthTimeline#Global","Spine.PhysicsConstraintWindTimeline#ctor","Spine.PhysicsConstraintWindTimeline#Setup","Spine.PhysicsConstraintWindTimeline#Get","Spine.PhysicsConstraintWindTimeline#Set","Spine.PhysicsConstraintWindTimeline#Global"]' ) ); }
/**
 * @version 1.0.9026.22764
 * @copyright anton
 * @compiler Bridge.NET 17.9.42-luna
 */
Bridge.assembly("UnityScriptsCompiler", function ($asm, globals) {
    "use strict";

    /*AnimatedButton start.*/
    Bridge.define("AnimatedButton", {
        inherits: [UnityEngine.EventSystems.UIBehaviour,UnityEngine.EventSystems.IPointerDownHandler,UnityEngine.EventSystems.IPointerUpHandler,UnityEngine.EventSystems.IPointerClickHandler],
        fields: {
            interactable: false,
            m_OnClick: null,
            tf: null,
            isCLicked: false
        },
        props: {
            onClick: {
                get: function () {
if ( TRACE ) { TRACE( "AnimatedButton#onClick#get", this ); }

                    return this.m_OnClick;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "AnimatedButton#onClick#set", this ); }

                    this.m_OnClick = value;
                }
            }
        },
        alias: [
            "OnPointerDown", "UnityEngine$EventSystems$IPointerDownHandler$OnPointerDown",
            "OnPointerUp", "UnityEngine$EventSystems$IPointerUpHandler$OnPointerUp",
            "OnPointerClick", "UnityEngine$EventSystems$IPointerClickHandler$OnPointerClick"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "AnimatedButton#init", this ); }

                this.interactable = true;
                this.m_OnClick = new AnimatedButton.ButtonClickedEvent();
            }
        },
        methods: {
            /*AnimatedButton.OnPointerDown start.*/
            OnPointerDown: function (eventData) {
if ( TRACE ) { TRACE( "AnimatedButton#OnPointerDown", this ); }

                if (eventData.button !== UnityEngine.EventSystems.PointerEventData.InputButton.Left || !this.interactable) {
                    return;
                }

                if (UnityEngine.Component.op_Inequality(this.tf, null) && !this.isCLicked) {
                    this.tf.localScale = this.tf.localScale.$clone().clone().scale( 0.9 );
                }

                this.isCLicked = true;
            },
            /*AnimatedButton.OnPointerDown end.*/

            /*AnimatedButton.Press start.*/
            Press: function () {
if ( TRACE ) { TRACE( "AnimatedButton#Press", this ); }

                if (!this.IsActive()) {
                    return;
                }
                this.OnClickAction();
            },
            /*AnimatedButton.Press end.*/

            /*AnimatedButton.OnClickAction start.*/
            OnClickAction: function () {
if ( TRACE ) { TRACE( "AnimatedButton#OnClickAction", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(SoundManager.instance, null)) {
                    SoundManager.instance.PlaySound("Button");
                }
                this.m_OnClick.Invoke();
            },
            /*AnimatedButton.OnClickAction end.*/

            /*AnimatedButton.OnPointerUp start.*/
            OnPointerUp: function (eventData) {
if ( TRACE ) { TRACE( "AnimatedButton#OnPointerUp", this ); }

                if (!this.interactable) {
                    return;
                }

                if (UnityEngine.Component.op_Inequality(this.tf, null) && this.isCLicked) {
                    this.tf.localScale = this.tf.localScale.$clone().scale( 1.0 / ( 0.9 ) );
                }
                this.isCLicked = false;
            },
            /*AnimatedButton.OnPointerUp end.*/

            /*AnimatedButton.OnPointerClick start.*/
            OnPointerClick: function (eventData) {
if ( TRACE ) { TRACE( "AnimatedButton#OnPointerClick", this ); }

                if (!this.interactable) {
                    return;
                }
                this.Press();
            },
            /*AnimatedButton.OnPointerClick end.*/


        }
    });
    /*AnimatedButton end.*/

    /*AnimatedButton+ButtonClickedEvent start.*/
    Bridge.define("AnimatedButton.ButtonClickedEvent", {
        inherits: [UnityEngine.Events.UnityEvent],
        $kind: 1002
    });
    /*AnimatedButton+ButtonClickedEvent end.*/

    /*AudioClipsHolder start.*/
    Bridge.define("AudioClipsHolder", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            audioPool: null,
            soundList: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "AudioClipsHolder#init", this ); }

                this.soundList = new (System.Collections.Generic.List$1(UnityEngine.AudioClip)).ctor();
            }
        },
        methods: {
            /*AudioClipsHolder.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "AudioClipsHolder#Start", this ); }

                this.audioPool = new (System.Collections.Generic.Dictionary$2(System.String,UnityEngine.AudioClip)).ctor();
                for (var i = 0; i < this.soundList.Count; i = (i + 1) | 0) {
                    if (this.soundList.getItem(i) != null) {
                        this.audioPool.add(this.soundList.getItem(i).name, this.soundList.getItem(i));
                    }
                }
            },
            /*AudioClipsHolder.Start end.*/

            /*AudioClipsHolder.TryGetAudioClip start.*/
            TryGetAudioClip: function (name) {
if ( TRACE ) { TRACE( "AudioClipsHolder#TryGetAudioClip", this ); }

                var value = { };
                if (this.audioPool.tryGetValue(name, value)) {
                    return value.v;
                }
                return null;
            },
            /*AudioClipsHolder.TryGetAudioClip end.*/


        }
    });
    /*AudioClipsHolder end.*/

    /*AudioManager start.*/
    Bridge.define("AudioManager", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                instance: null
            }
        },
        fields: {
            win: null,
            contifie: null,
            broken: null,
            winui: null
        },
        methods: {
            /*AudioManager.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "AudioManager#Awake", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(AudioManager.instance, null)) {
                    AudioManager.instance = this;
                    /* DontDestroyOnLoad(gameObject);*/
                } else {
                    /* Destroy(gameObject);*/
                }
            },
            /*AudioManager.Awake end.*/

            /*AudioManager.PlayWinSound start.*/
            PlayWinSound: function () {
if ( TRACE ) { TRACE( "AudioManager#PlayWinSound", this ); }

                this.win.Play();
            },
            /*AudioManager.PlayWinSound end.*/

            /*AudioManager.PlayContifieSound start.*/
            PlayContifieSound: function () {
if ( TRACE ) { TRACE( "AudioManager#PlayContifieSound", this ); }

                this.contifie.Play();
            },
            /*AudioManager.PlayContifieSound end.*/

            /*AudioManager.winUI start.*/
            winUI: function () {
if ( TRACE ) { TRACE( "AudioManager#winUI", this ); }

                this.winui.SetActive(true);
            },
            /*AudioManager.winUI end.*/

            /*AudioManager.PlayWoodDestroySound start.*/
            PlayWoodDestroySound: function () {
if ( TRACE ) { TRACE( "AudioManager#PlayWoodDestroySound", this ); }

                this.broken.Play();
            },
            /*AudioManager.PlayWoodDestroySound end.*/


        }
    });
    /*AudioManager end.*/

    /*AutoDestroy start.*/
    Bridge.define("AutoDestroy", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            delay: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "AutoDestroy#init", this ); }

                this.delay = 2;
            }
        },
        methods: {
            /*AutoDestroy.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "AutoDestroy#OnEnable", this ); }

                this.Invoke("DestroyObj", this.delay);
            },
            /*AutoDestroy.OnEnable end.*/

            /*AutoDestroy.DestroyObj start.*/
            DestroyObj: function () {
if ( TRACE ) { TRACE( "AutoDestroy#DestroyObj", this ); }

                ObjectPoolExtensions.Recycle(this.gameObject);
            },
            /*AutoDestroy.DestroyObj end.*/


        }
    });
    /*AutoDestroy end.*/

    /*Bar start.*/
    Bridge.define("Bar", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            configCenterOfMass: false,
            minusgravity: false,
            centerOfMass: null,
            screwed: false,
            ready: false,
            barHoles: null,
            bolts: null,
            col2D: null,
            rigid2D: null,
            hingleJoint2D: null,
            state: 0,
            timeCount: 0,
            hasDone: false
        },
        props: {
            HasDone: {
                get: function () {
if ( TRACE ) { TRACE( "Bar#HasDone#get", this ); }

                    return this.hasDone;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Bar#HasDone#set", this ); }

                    this.hasDone = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Bar#init", this ); }

                this.centerOfMass = new UnityEngine.Vector3();
                this.minusgravity = false;
                this.bolts = new (System.Collections.Generic.List$1(Bolt)).ctor();
                this.state = -1;
                this.timeCount = 0;
            }
        },
        methods: {
            /*Bar.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Bar#Start", this ); }

                this.col2D = this.GetComponent(UnityEngine.Collider2D);
                this.rigid2D = this.GetComponent(UnityEngine.Rigidbody2D);
                this.barHoles = this.GetComponentsInChildren(BarHole);
                this.hingleJoint2D = this.GetComponent(UnityEngine.HingeJoint2D);


                if (this.configCenterOfMass) {
                    this.rigid2D.centerOfMass = UnityEngine.Vector2.FromVector3(this.centerOfMass.$clone());
                } else {
                    if (this.transform.localEulerAngles.z === 90) {
                        if (this.transform.localPosition.x > 0) {
                            this.rigid2D.centerOfMass = new pc.Vec2( 0, -0.1 );
                        } else {
                            this.rigid2D.centerOfMass = new pc.Vec2( 0, 0.1 );
                        }
                    } else if (this.transform.localEulerAngles.z === 270) {
                        if (this.transform.localPosition.x > 0) {
                            this.rigid2D.centerOfMass = new pc.Vec2( 0, 0.1 );
                        } else {
                            this.rigid2D.centerOfMass = new pc.Vec2( 0, -0.1 );
                        }
                    }
                }

                this.rigid2D.bodyType = UnityEngine.RigidbodyType2D.Static;
                this.rigid2D.gravityScale = 1;
                this.state = -1;

                this.Invoke("Simulate", 0.1);
            },
            /*Bar.Start end.*/

            /*Bar.SetState start.*/
            SetState: function (amountBolt, connectedRigid2D) {
if ( TRACE ) { TRACE( "Bar#SetState", this ); }

                switch (amountBolt) {
                    case 0: 
                        if (this.state !== 0) {
                            this.ready = true;
                            this.state = 0;
                            this.rigid2D.bodyType = UnityEngine.RigidbodyType2D.Dynamic;
                            if (!this.minusgravity) {
                                this.rigid2D.gravityScale = 2.0;
                            } else {
                                this.rigid2D.gravityScale = -0.5;
                            }
                            this.hingleJoint2D.enabled = false;
                        }
                        break;
                    case 1: 
                        this.ready = true;
                        this.state = 1;
                        this.rigid2D.bodyType = UnityEngine.RigidbodyType2D.Dynamic;
                        if (!this.minusgravity) {
                            this.rigid2D.gravityScale = 2.0;
                        } else {
                            this.rigid2D.gravityScale = -0.5;
                        }
                        this.rigid2D.WakeUp();
                        this.hingleJoint2D.enabled = true;
                        var anchorPos = this.transform.InverseTransformPoint(connectedRigid2D.transform.position);
                        var spriteRenderer = this.transform.GetChild(0).GetComponent(UnityEngine.SpriteRenderer);
                        if (UnityEngine.Component.op_Inequality(spriteRenderer, null) && spriteRenderer.drawMode === UnityEngine.SpriteDrawMode.Sliced) {
                            if (anchorPos.length() < 0.1 && this.transform.localEulerAngles.z !== 90 && this.transform.localEulerAngles.z !== 270) {
                                if (this.transform.localEulerAngles.z > 0 && this.transform.localEulerAngles.z < 180) {
                                    this.rigid2D.centerOfMass = new pc.Vec2( -0.1, 0 );
                                } else {
                                    this.rigid2D.centerOfMass = new pc.Vec2( 0.1, 0 );
                                }
                            }
                        }
                        this.hingleJoint2D.connectedBody = connectedRigid2D;
                        this.hingleJoint2D.anchor = UnityEngine.Vector2.FromVector3(anchorPos.$clone());
                        this.hingleJoint2D.connectedAnchor = pc.Vec2.ZERO.clone();
                        break;
                    default: 
                        this.ready = false;
                        if (this.state !== 2) {
                            this.state = 2;
                            this.rigid2D.bodyType = UnityEngine.RigidbodyType2D.Static;
                            if (!this.minusgravity) {
                                this.rigid2D.gravityScale = 2.0;
                            } else {
                                this.rigid2D.gravityScale = -0.5;
                            }
                            this.hingleJoint2D.enabled = false;
                        }
                        break;
                }
            },
            /*Bar.SetState end.*/

            /*Bar.SetState$1 start.*/
            SetState$1: function (amountBolt, connectedRigid2D, newPos) {
if ( TRACE ) { TRACE( "Bar#SetState$1", this ); }

                switch (amountBolt) {
                    case 0: 
                        if (this.state !== 0) {
                            this.ready = true;
                            this.state = 0;
                            this.rigid2D.bodyType = UnityEngine.RigidbodyType2D.Dynamic;
                            if (!this.minusgravity) {
                                this.rigid2D.gravityScale = 2.0;
                            } else {
                                this.rigid2D.gravityScale = -0.5;
                            }
                            this.hingleJoint2D.enabled = false;
                        }
                        break;
                    case 1: 
                        this.ready = true;
                        this.state = 1;
                        this.rigid2D.bodyType = UnityEngine.RigidbodyType2D.Dynamic;
                        if (!this.minusgravity) {
                            this.rigid2D.gravityScale = 2.0;
                        } else {
                            this.rigid2D.gravityScale = -0.5;
                        }
                        this.hingleJoint2D.enabled = true;
                        this.hingleJoint2D.connectedBody = connectedRigid2D;
                        this.hingleJoint2D.anchor = UnityEngine.Vector2.FromVector3(this.transform.InverseTransformPoint(newPos));
                        this.hingleJoint2D.connectedAnchor = pc.Vec2.ZERO.clone();
                        break;
                    default: 
                        if (this.state !== 2) {
                            this.ready = false;
                            this.state = 2;
                            this.rigid2D.bodyType = UnityEngine.RigidbodyType2D.Static;
                            if (!this.minusgravity) {
                                this.rigid2D.gravityScale = 2.0;
                            } else {
                                this.rigid2D.gravityScale = -0.5;
                            }
                            this.hingleJoint2D.enabled = false;
                        }
                        break;
                }
            },
            /*Bar.SetState$1 end.*/

            /*Bar.AddBolt start.*/
            AddBolt: function (bolt, newPos) {
if ( TRACE ) { TRACE( "Bar#AddBolt", this ); }

                //Debug.Log("AddBolt");
                if (this.bolts.Count === 0) {
                    this.bolts.add(bolt);
                    this.SetState$1(1, bolt.transform.GetComponent(UnityEngine.Rigidbody2D), newPos);
                } else if (this.bolts.Count === 1) {
                    if (UnityEngine.MonoBehaviour.op_Inequality(this.bolts.getItem(0), bolt)) {
                        this.bolts.add(bolt);
                        this.SetState(2, null);
                    }
                } else {
                    this.bolts.add(bolt);
                }
            },
            /*Bar.AddBolt end.*/

            /*Bar.RemoveBolt start.*/
            RemoveBolt: function (bolt) {
if ( TRACE ) { TRACE( "Bar#RemoveBolt", this ); }

                //Debug.Log("RemoveBolt");

                if (!this.bolts.contains(bolt)) {
                    return;
                }

                if (this.bolts.Count === 2) {
                    this.bolts.remove(bolt);
                    this.SetState(1, this.bolts.getItem(0).transform.GetComponent(UnityEngine.Rigidbody2D));
                } else if (this.bolts.Count === 1) {
                    this.bolts.remove(bolt);
                    this.SetState(0, null);
                } else {
                    this.bolts.remove(bolt);
                }
            },
            /*Bar.RemoveBolt end.*/

            /*Bar.FixedUpdate start.*/
            FixedUpdate: function () {
if ( TRACE ) { TRACE( "Bar#FixedUpdate", this ); }

                if (this.state === 0) {
                    if (Math.abs(this.transform.localEulerAngles.z) < 0.05 || Math.abs(Math.abs(this.transform.localEulerAngles.z) - 180.0) < 0.05 || Math.abs(Math.abs(this.transform.localEulerAngles.z) - 360) < 0.05) {
                        var velocity = this.rigid2D.velocity.length();
                        if (velocity > 0.05) {
                            if (this.timeCount < 2) {
                                this.timeCount += UnityEngine.Time.fixedDeltaTime;
                            } else {
                                if (velocity < 1.0) {
                                    this.rigid2D.velocity = new pc.Vec2().lerp( this.rigid2D.velocity, this.rigid2D.velocity.clone().normalize(), UnityEngine.Time.fixedDeltaTime );
                                }
                            }
                        }
                    } else {
                        this.timeCount = 0;
                    }
                } else {
                    this.timeCount = 0;
                }
            },
            /*Bar.FixedUpdate end.*/

            /*Bar.Done start.*/
            Done: function () {
if ( TRACE ) { TRACE( "Bar#Done", this ); }

                this.hasDone = true;
                this.gameObject.SetActive(false);
            },
            /*Bar.Done end.*/

            /*Bar.GetAmountBolt start.*/
            GetAmountBolt: function () {
if ( TRACE ) { TRACE( "Bar#GetAmountBolt", this ); }

                this.bolts.clear();
                var count = 0;
                for (var i = 0; i < this.barHoles.length; i = (i + 1) | 0) {
                    var temp = UnityEngine.Physics2D.OverlapCircle$2(UnityEngine.Vector2.FromVector3(this.barHoles[i].transform.position), 0.1, UnityEngine.LayerMask.op_Implicit(Singleton$1(GameManager).Instance.layerBolt.$clone()));
                    if (UnityEngine.Component.op_Inequality(temp, null)) {
                        count = (count + 1) | 0;
                        this.bolts.add(temp.GetComponent(Bolt));
                    }
                }
                return count;
            },
            /*Bar.GetAmountBolt end.*/

            /*Bar.Explosion start.*/
            Explosion: function () {
if ( TRACE ) { TRACE( "Bar#Explosion", this ); }

                for (var i = 0; i < this.barHoles.length; i = (i + 1) | 0) {
                    var temp = UnityEngine.Physics2D.OverlapCircle$2(UnityEngine.Vector2.FromVector3(this.barHoles[i].transform.position), 0.1, UnityEngine.LayerMask.op_Implicit(Singleton$1(GameManager).Instance.layerBolt.$clone()));
                    if (UnityEngine.Component.op_Inequality(temp, null)) {
                        temp.GetComponent(Bolt).Explosion();
                    }
                }
            },
            /*Bar.Explosion end.*/

            /*Bar.OnCollisionEnter2D start.*/
            OnCollisionEnter2D: function (collision) {
if ( TRACE ) { TRACE( "Bar#OnCollisionEnter2D", this ); }

                if (this.ready && this.rigid2D.velocity.lengthSq() > 0.5) {
                    var amount = 0;
                    var collider2Ds = UnityEngine.Physics2D.OverlapCircleAll(UnityEngine.Vector2.FromVector3(collision.transform.position), 0.5, UnityEngine.LayerMask.op_Implicit(Singleton$1(GameManager).Instance.layerBar.$clone()));
                    for (var i = 0; i < collider2Ds.length; i = (i + 1) | 0) {
                        if (UnityEngine.GameObject.op_Inequality(collider2Ds[i].gameObject, this.gameObject)) {
                            amount = (amount + 1) | 0;
                        }
                    }

                    if (amount === collider2Ds.length) {
                        //kengg.Play();
                    }
                }

            },
            /*Bar.OnCollisionEnter2D end.*/

            /*Bar.Init start.*/
            Init: function (position, angle, actived) {
if ( TRACE ) { TRACE( "Bar#Init", this ); }

                this.transform.localPosition = UnityEngine.Vector3.FromVector2(position.$clone());
                this.transform.localEulerAngles = angle.$clone();
                this.gameObject.SetActive(actived);
                if (actived) {
                    this.hasDone = false;
                }

                this.Invoke("Simulate", 0.02);
            },
            /*Bar.Init end.*/

            /*Bar.Simulate start.*/
            Simulate: function () {
if ( TRACE ) { TRACE( "Bar#Simulate", this ); }

                var amountBolt = this.GetAmountBolt();
                if (this.bolts.Count === 1) {
                    this.SetState(amountBolt, this.bolts.getItem(0).GetComponent(UnityEngine.Rigidbody2D));
                } else {
                    this.SetState(amountBolt, null);
                }
            },
            /*Bar.Simulate end.*/

            /*Bar.OnTriggerEnter2D start.*/
            OnTriggerEnter2D: function (collision) {
if ( TRACE ) { TRACE( "Bar#OnTriggerEnter2D", this ); }

                if (collision.CompareTag("Wall")) {
                    if (!this.screwed) {
                        this.screwed = true;
                        LevelController.Instance.ScrewBar();
                        this.Invoke("Destroy", 0.5);
                    }
                } else if (collision.CompareTag("Key")) {
                    collision.GetComponent(Key).Active();
                }
            },
            /*Bar.OnTriggerEnter2D end.*/

            /*Bar.Destroy$1 start.*/
            Destroy$1: function () {
if ( TRACE ) { TRACE( "Bar#Destroy$1", this ); }

                this.gameObject.SetActive(false);
            },
            /*Bar.Destroy$1 end.*/


        },
        overloads: {
            "SetState(int, Rigidbody2D, Vector3)": "SetState$1",
            "Destroy()": "Destroy$1"
        }
    });
    /*Bar end.*/

    /*BarHole start.*/
    Bridge.define("BarHole", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            graphic: null,
            spriteMask: null,
            bar: null
        },
        methods: {
            /*BarHole.OnValidate start.*/
            OnValidate: function () {
if ( TRACE ) { TRACE( "BarHole#OnValidate", this ); }
 },
            /*BarHole.OnValidate end.*/

            /*BarHole.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "BarHole#Start", this ); }

                this.bar = this.transform.parent.GetComponent(Bar);
            },
            /*BarHole.Start end.*/

            /*BarHole.ActiveGraphic start.*/
            ActiveGraphic: function (active) {
if ( TRACE ) { TRACE( "BarHole#ActiveGraphic", this ); }

                if (UnityEngine.GameObject.op_Equality(this.graphic, null)) {
                    this.graphic = this.transform.GetChild(0).gameObject;
                }

                if (UnityEngine.Component.op_Equality(this.spriteMask, null)) {
                    this.spriteMask = this.GetComponent(UnityEngine.SpriteMask);
                    if (UnityEngine.Component.op_Equality(this.spriteMask, null)) {
                        this.spriteMask = this.graphic.GetComponent(UnityEngine.SpriteMask);
                    }
                }
                this.spriteMask.enabled = active;
                this.graphic.SetActive(active);
            },
            /*BarHole.ActiveGraphic end.*/

            /*BarHole.Match start.*/
            Match: function (bar) {
if ( TRACE ) { TRACE( "BarHole#Match", this ); }

                return UnityEngine.MonoBehaviour.op_Equality(this.bar, bar);
            },
            /*BarHole.Match end.*/


        }
    });
    /*BarHole end.*/

    /*BoardHole start.*/
    Bridge.define("BoardHole", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            lockObj: null,
            rewardObj: null,
            locked: false,
            isReward: false
        },
        methods: {
            /*BoardHole.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "BoardHole#Start", this ); }

                if (this.locked) {
                    this.lockObj.SetActive(true);
                } else {
                    this.lockObj.SetActive(false);
                }

                /* if (RemoteConfig.Instance.AllowRewardHole)
                {
                   if (isReward)
                   {
                       rewardObj.SetActive(true);
                   }
                   else
                   {
                       rewardObj.SetActive(false);
                   }
                }
                else
                {
                   gameObject.SetActive(false);
                }*/
            },
            /*BoardHole.Start end.*/

            /*BoardHole.Unlock start.*/
            Unlock: function () {
if ( TRACE ) { TRACE( "BoardHole#Unlock", this ); }

                this.locked = false;
                this.lockObj.SetActive(false);
            },
            /*BoardHole.Unlock end.*/

            /*BoardHole.Reward start.*/
            Reward: function () {
if ( TRACE ) { TRACE( "BoardHole#Reward", this ); }

                this.isReward = false;
                this.rewardObj.SetActive(false);
            },
            /*BoardHole.Reward end.*/


        }
    });
    /*BoardHole end.*/

    /*Bolt start.*/
    Bridge.define("Bolt", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            isFallingScrew: false,
            screwBoard: false,
            hand1: null,
            hand1portrait: null,
            hand2: null,
            handlandscape: null,
            tutorial2: null,
            oldspr: null,
            newspr: null,
            isScrewed: false,
            locked: false,
            col2D: null,
            rigid2D: null,
            meshRenderer: null,
            moveto: false,
            count: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Bolt#init", this ); }

                this.isFallingScrew = true;
                this.screwBoard = false;
                this.isScrewed = false;
                this.moveto = false;
                this.count = 0;
            }
        },
        methods: {
            /*Bolt.OnValidate start.*/
            OnValidate: function () {
if ( TRACE ) { TRACE( "Bolt#OnValidate", this ); }

                // if (locked)
                // {
                //     lockObj.SetActive(true);
                // }
                // else
                // {
                //     lockObj.SetActive(false);
                // }
            },
            /*Bolt.OnValidate end.*/

            /*Bolt.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Bolt#Start", this ); }

                // if (locked)
                // {
                //     lockObj.SetActive(true);
                // }
                // else
                // {
                //     lockObj.SetActive(false);
                // }

                //anim.AnimationState.SetAnimation(0, "bolt_screw_idle2", true);
                this.col2D = this.GetComponent(UnityEngine.Collider2D);
                this.rigid2D = this.GetComponent(UnityEngine.Rigidbody2D);
                //meshRenderer = anim.gameObject.GetComponent<MeshRenderer>();
            },
            /*Bolt.Start end.*/

            /*Bolt.Screw start.*/
            Screw: function () {
if ( TRACE ) { TRACE( "Bolt#Screw", this ); }

                this.isScrewed = true;
                Vibration.Vibrate$1(System.Int64(50));
                this.hand1.SetActive(false);

                if (!this.isFallingScrew) {
                    this.hand2.SetActive(true);
                }
                //meshRenderer.sortingOrder = 1;
                this.oldspr.enabled = false;
                this.newspr.enabled = true;
                /* anim.AnimationState.SetAnimation(0, "bolt_screw_out", false);
                anim.AnimationState.AddAnimation(0, "bolt_screw_idle", true, 0);*/
                // graphicTF.DOLocalMove(new Vector3(0, 1, -2), 0.25f).SetEase(Ease.Linear);
                // graphicTF.DOLocalRotate(new Vector3(0, 90, -50), 0.25f).SetEase(Ease.Linear);
                // meshTF.DOLocalRotate(new Vector3(0, 359, 0), 0.25f, RotateMode.FastBeyond360).SetEase(Ease.Linear).OnComplete(() =>
                // {
                //     hand1.SetActive(false);
                //     hand1portrait.SetActive(false);
                //     hand2.SetActive(true);
                //     handlandscape.SetActive(true);
                //     meshTF.localEulerAngles = Vector3.zero;
                // });
            },
            /*Bolt.Screw end.*/

            /*Bolt.UnScrew start.*/
            UnScrew: function () {
if ( TRACE ) { TRACE( "Bolt#UnScrew", this ); }

                this.isScrewed = false;
                Vibration.Vibrate$1(System.Int64(50));
                //meshRenderer.sortingOrder = 0;
                this.hand2.SetActive(false);
                this.tutorial2.SetActive(false);
                this.oldspr.enabled = true;
                this.newspr.enabled = false;
                /* anim.AnimationState.SetAnimation(0, "bolt_screw_in", false);
                anim.AnimationState.AddAnimation(0, "bolt_screw_idle2", true, 0);*/
                // graphicTF.DOLocalMove(Vector3.zero, 0.25f).SetEase(Ease.Linear);
                // graphicTF.DOLocalRotate(new Vector3(0, 90, -90), 0.25f).SetEase(Ease.Linear);
                // meshTF.DOLocalRotate(new Vector3(0, -359, 0), 0.25f, RotateMode.FastBeyond360).SetEase(Ease.Linear).OnComplete(() =>
                // {
                //     hand2.SetActive(false);
                //     handlandscape.SetActive(false);
                //     hand1.SetActive(true);
                //     hand1portrait.SetActive(true);
                //     tutorial2.SetActive(false);
                //     //StartCoroutine(showFail());
                //     meshTF.localEulerAngles = Vector3.zero;
                // });
                // Debug.Log("Unscrew");
                LevelController.Instance.CheckOutMove();
            },
            /*Bolt.UnScrew end.*/

            /*Bolt.MoveTo start.*/
            MoveTo: function (boardHole) {
if ( TRACE ) { TRACE( "Bolt#MoveTo", this ); }

                var $t, $t1;
                this.count = (this.count + 1) | 0;
                this.moveto = true;

                if (!this.isFallingScrew && UnityEngine.MonoBehaviour.op_Inequality(boardHole, null)) {
                    this.transform.position = boardHole.transform.position.$clone();
                    this.UnScrew();
                } else {
                    this.col2D.enabled = false;
                    DG.Tweening.TweenSettingsExtensions.SetDelay(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetRelative$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOMoveY(this.transform, -30, 1.0), true), DG.Tweening.Ease.Linear), Bridge.fn.bind(this, function () {
                        this.gameObject.SetActive(false);
                    })), 0.1);
                }

                if (this.count === 12) {
                    LevelController.Instance.store.SetActive(true);
                }
                if (LevelController.Instance.fullSlot) {
                    if (LevelController.Instance.currentBolt.screwBoard) {
                        LevelController.Instance.currentBolt.screwBoard = false;
                        ($t = LevelController.Instance).numScrewOnBar = ($t.numScrewOnBar + 1) | 0;
                        //Debug.Log(LevelController.Instance.numScrewOnBar);
                    }
                } else {
                    if (!LevelController.Instance.currentBolt.screwBoard) {
                        LevelController.Instance.currentBolt.screwBoard = true;
                        ($t1 = LevelController.Instance).numScrewOnBar = ($t1.numScrewOnBar - 1) | 0;
                        //Debug.Log(LevelController.Instance.numScrewOnBar);
                    }
                }
            },
            /*Bolt.MoveTo end.*/

            /*Bolt.MoveToCoroutine start.*/
            MoveToCoroutine: function (boardHole) {
if ( TRACE ) { TRACE( "Bolt#MoveToCoroutine", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    this.transform.position = boardHole.transform.position.$clone();
                                        $enumerator.current = null;
                                        $step = 1;
                                        return true;
                                }
                                case 1: {
                                    // Đến đích
                                        //Debug.Log("Bolt moved to board hole: " + boardHole.name);

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*Bolt.MoveToCoroutine end.*/

            /*Bolt.Position start.*/
            Position: function () {
if ( TRACE ) { TRACE( "Bolt#Position", this ); }

                return this.transform.position.$clone();
            },
            /*Bolt.Position end.*/

            /*Bolt.Lock start.*/
            Lock: function () {
if ( TRACE ) { TRACE( "Bolt#Lock", this ); }

                this.locked = true;
                //lockObj.SetActive(true);
            },
            /*Bolt.Lock end.*/

            /*Bolt.Unlock start.*/
            Unlock: function () {
if ( TRACE ) { TRACE( "Bolt#Unlock", this ); }

                this.locked = false;
                //lockObj.SetActive(false);
            },
            /*Bolt.Unlock end.*/

            /*Bolt.Explosion start.*/
            Explosion: function () {
if ( TRACE ) { TRACE( "Bolt#Explosion", this ); }

                this.gameObject.SetActive(false);
            },
            /*Bolt.Explosion end.*/


        }
    });
    /*Bolt end.*/

    /*CameraDistanceConfig start.*/
    Bridge.define("CameraDistanceConfig", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            mainCamera: null,
            configCameraSizes: null
        },
        methods: {
            /*CameraDistanceConfig.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "CameraDistanceConfig#Awake", this ); }

                this.ResizeCamera();
            },
            /*CameraDistanceConfig.Awake end.*/

            /*CameraDistanceConfig.SaveData start.*/
            SaveData: function () {
if ( TRACE ) { TRACE( "CameraDistanceConfig#SaveData", this ); }

                var $t;
                var ratio = (Bridge.Int.div(UnityEngine.Screen.height, UnityEngine.Screen.width)) | 0;
                this.configCameraSizes.add(($t = new ConfigCameraSize(), $t.ratio = ratio, $t.size = this.mainCamera.orthographicSize, $t));
            },
            /*CameraDistanceConfig.SaveData end.*/

            /*CameraDistanceConfig.ResizeCamera start.*/
            ResizeCamera: function () {
if ( TRACE ) { TRACE( "CameraDistanceConfig#ResizeCamera", this ); }

                var $t;
                var ratio = (Bridge.Int.div(UnityEngine.Screen.height, UnityEngine.Screen.width)) | 0;
                $t = Bridge.getEnumerator(this.configCameraSizes);
                try {
                    while ($t.moveNext()) {
                        var item = $t.Current;
                        if (item.ratio === ratio) {
                            this.mainCamera.orthographicSize = item.size;
                            return;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*CameraDistanceConfig.ResizeCamera end.*/


        }
    });
    /*CameraDistanceConfig end.*/

    /*Singleton$1 start.*/
    Bridge.define("Singleton$1", function (T) { return {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                instance: Bridge.getDefaultValue(T)
            },
            props: {
                Instance: {
                    get: function () {
if ( TRACE ) { TRACE( "Singleton$1#Instance#get", this ); }

                        if (Bridge.rValue(Singleton$1(T).instance) == null) {
                            Singleton$1(T).instance = Bridge.rValue(UnityEngine.Object.FindObjectOfType(T));
                            if (Bridge.rValue(Singleton$1(T).instance) == null) {
                                var obj = new UnityEngine.GameObject.ctor();
                                obj.name = Bridge.Reflection.getTypeName(T);
                                Singleton$1(T).instance = Bridge.rValue(obj.AddComponent(T));
                            }
                        }
                        return Bridge.rValue(Singleton$1(T).instance);
                    }
                }
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Singleton$1#init", this ); }

                    this.instance = Bridge.getDefaultValue(T);
                }
            }
        },
        fields: {
            canDestroyOnLoad: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Singleton$1#init", this ); }

                this.canDestroyOnLoad = false;
            }
        },
        methods: {
            /*Singleton$1.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Singleton$1#Awake", this ); }

                if (Bridge.rValue(Singleton$1(T).instance) == null) {
                    Singleton$1(T).instance = Bridge.as(this, T);
                    if (!this.canDestroyOnLoad) {
                        UnityEngine.Object.DontDestroyOnLoad(this.gameObject);
                    }
                } else {
                    UnityEngine.MonoBehaviour.Destroy(this.gameObject);
                }
            },
            /*Singleton$1.Awake end.*/


        }
    }; });
    /*Singleton$1 end.*/

    /*ConfigCameraSize start.*/
    Bridge.define("ConfigCameraSize", {
        fields: {
            ratio: 0,
            size: 0
        }
    });
    /*ConfigCameraSize end.*/

    /*DG.Tweening.DOTweenCYInstruction start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction");
    /*DG.Tweening.DOTweenCYInstruction end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForCompletion start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForCompletion", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: 1002,
        fields: {
            t: null
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForCompletion#keepWaiting#get", this ); }

                    return this.t.active && !DG.Tweening.TweenExtensions.IsComplete(this.t);
                }
            }
        },
        ctors: {
            ctor: function (tween) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForCompletion#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForCompletion end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForElapsedLoops start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: 1002,
        fields: {
            t: null,
            elapsedLoops: 0
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops#keepWaiting#get", this ); }

                    return this.t.active && DG.Tweening.TweenExtensions.CompletedLoops(this.t) < this.elapsedLoops;
                }
            }
        },
        ctors: {
            ctor: function (tween, elapsedLoops) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
                this.elapsedLoops = elapsedLoops;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForElapsedLoops end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForKill start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForKill", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: 1002,
        fields: {
            t: null
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForKill#keepWaiting#get", this ); }

                    return this.t.active;
                }
            }
        },
        ctors: {
            ctor: function (tween) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForKill#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForKill end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForPosition start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForPosition", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: 1002,
        fields: {
            t: null,
            position: 0
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForPosition#keepWaiting#get", this ); }

                    return this.t.active && this.t.position * (((DG.Tweening.TweenExtensions.CompletedLoops(this.t) + 1) | 0)) < this.position;
                }
            }
        },
        ctors: {
            ctor: function (tween, position) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForPosition#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
                this.position = position;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForPosition end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForRewind start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForRewind", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: 1002,
        fields: {
            t: null
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForRewind#keepWaiting#get", this ); }

                    return this.t.active && (!this.t.playedOnce || this.t.position * (((DG.Tweening.TweenExtensions.CompletedLoops(this.t) + 1) | 0)) > 0);
                }
            }
        },
        ctors: {
            ctor: function (tween) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForRewind#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForRewind end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForStart start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForStart", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: 1002,
        fields: {
            t: null
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForStart#keepWaiting#get", this ); }

                    return this.t.active && !this.t.playedOnce;
                }
            }
        },
        ctors: {
            ctor: function (tween) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForStart#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForStart end.*/

    /*DG.Tweening.DOTweenModuleAudio start.*/
    Bridge.define("DG.Tweening.DOTweenModuleAudio", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleAudio.DOFade:static start.*/
                /**
                 * Tweens an AudioSource's volume to the given value.
                 Also stores the AudioSource as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.AudioSource}           target      
                 * @param   {number}                            endValue    The end value to reach (0 to 1)
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOFade", this ); }

                    if (endValue < 0) {
                        endValue = 0;
                    } else {
                        if (endValue > 1) {
                            endValue = 1;
                        }
                    }
                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.volume;
                    }, function (x) {
                        target.volume = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleAudio.DOFade:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOPitch:static start.*/
                /**
                 * Tweens an AudioSource's pitch to the given value.
                 Also stores the AudioSource as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.AudioSource}           target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPitch: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOPitch", this ); }

                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.pitch;
                    }, function (x) {
                        target.pitch = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleAudio.DOPitch:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOSetFloat:static start.*/
                /**
                 * Tweens an AudioMixer's exposed float to the given value.
                 Also stores the AudioMixer as the tween's target so it can be used for filtered operations.
                 Note that you need to manually expose a float in an AudioMixerGroup in order to be able to tween it from an AudioMixer.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}      target       
                 * @param   {string}                            floatName    Name given to the exposed float to set
                 * @param   {number}                            endValue     The end value to reach
                 * @param   {number}                            duration     The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOSetFloat: function (target, floatName, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOSetFloat", this ); }

                    var t = DG.Tweening.DOTween.To$4(function () {
                        var currVal = { };
                        target.GetFloat(floatName, currVal);
                        return currVal.v;
                    }, function (x) {
                        target.SetFloat(floatName, x);
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleAudio.DOSetFloat:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOComplete:static start.*/
                /**
                 * Completes all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens completed
                 (meaning the tweens that don't have infinite loops and were not already complete)
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target           
                 * @param   {boolean}                         withCallbacks    For Sequences only: if TRUE also internal Sequence callbacks will be fired,
                 otherwise they will be ignored
                 * @return  {number}
                 */
                DOComplete: function (target, withCallbacks) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOComplete", this ); }

                    if (withCallbacks === void 0) { withCallbacks = false; }
                    return DG.Tweening.DOTween.Complete(target, withCallbacks);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOComplete:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOKill:static start.*/
                /**
                 * Kills all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens killed.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target      
                 * @param   {boolean}                         complete    If TRUE completes the tween before killing it
                 * @return  {number}
                 */
                DOKill: function (target, complete) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOKill", this ); }

                    if (complete === void 0) { complete = false; }
                    return DG.Tweening.DOTween.Kill(target, complete);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOKill:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOFlip:static start.*/
                /**
                 * Flips the direction (backwards if it was going forward or viceversa) of all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens flipped.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DOFlip: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOFlip", this ); }

                    return DG.Tweening.DOTween.Flip(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOFlip:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOGoto:static start.*/
                /**
                 * Sends to the given position all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens involved.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target     
                 * @param   {number}                          to         Time position to reach
                 (if higher than the whole tween duration the tween will simply reach its end)
                 * @param   {boolean}                         andPlay    If TRUE will play the tween after reaching the given position, otherwise it will pause it
                 * @return  {number}
                 */
                DOGoto: function (target, to, andPlay) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOGoto", this ); }

                    if (andPlay === void 0) { andPlay = false; }
                    return DG.Tweening.DOTween.Goto(target, to, andPlay);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOGoto:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOPause:static start.*/
                /**
                 * Pauses all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens paused.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DOPause: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOPause", this ); }

                    return DG.Tweening.DOTween.Pause(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOPause:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOPlay:static start.*/
                /**
                 * Plays all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens played.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DOPlay: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOPlay", this ); }

                    return DG.Tweening.DOTween.Play(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOPlay:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOPlayBackwards:static start.*/
                /**
                 * Plays backwards all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens played.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DOPlayBackwards: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOPlayBackwards", this ); }

                    return DG.Tweening.DOTween.PlayBackwards(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOPlayBackwards:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOPlayForward:static start.*/
                /**
                 * Plays forward all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens played.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DOPlayForward: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOPlayForward", this ); }

                    return DG.Tweening.DOTween.PlayForward(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOPlayForward:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DORestart:static start.*/
                /**
                 * Restarts all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens restarted.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DORestart: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DORestart", this ); }

                    return DG.Tweening.DOTween.Restart(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DORestart:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DORewind:static start.*/
                /**
                 * Rewinds all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens rewinded.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DORewind: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DORewind", this ); }

                    return DG.Tweening.DOTween.Rewind(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DORewind:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOSmoothRewind:static start.*/
                /**
                 * Smoothly rewinds all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens rewinded.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DOSmoothRewind: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOSmoothRewind", this ); }

                    return DG.Tweening.DOTween.SmoothRewind(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOSmoothRewind:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOTogglePause:static start.*/
                /**
                 * Toggles the paused state (plays if it was paused, pauses if it was playing) of all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens involved.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DOTogglePause: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOTogglePause", this ); }

                    return DG.Tweening.DOTween.TogglePause(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOTogglePause:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleAudio end.*/

    /*DG.Tweening.DOTweenModulePhysics start.*/
    Bridge.define("DG.Tweening.DOTweenModulePhysics", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModulePhysics.DOMove:static start.*/
                /**
                 * Tweens a Rigidbody's position to the given value.
                 Also stores the rigidbody as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target      
                 * @param   {UnityEngine.Vector3}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMove: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOMove", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$13(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOMove:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOMoveX:static start.*/
                /**
                 * Tweens a Rigidbody's X position to the given value.
                 Also stores the rigidbody as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMoveX: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOMoveX", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec3( endValue, 0, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.X, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOMoveX:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOMoveY:static start.*/
                /**
                 * Tweens a Rigidbody's Y position to the given value.
                 Also stores the rigidbody as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMoveY: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOMoveY", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec3( 0, endValue, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.Y, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOMoveY:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOMoveZ:static start.*/
                /**
                 * Tweens a Rigidbody's Z position to the given value.
                 Also stores the rigidbody as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMoveZ: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOMoveZ", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec3( 0, 0, endValue ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.Z, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOMoveZ:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DORotate:static start.*/
                /**
                 * Tweens a Rigidbody's rotation to the given value.
                 Also stores the rigidbody as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target      
                 * @param   {UnityEngine.Vector3}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {DG.Tweening.RotateMode}            mode        Rotation mode
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DORotate: function (target, endValue, duration, mode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DORotate", this ); }

                    if (mode === void 0) { mode = 0; }
                    var t = DG.Tweening.DOTween.To$9(function () {
                        return target.rotation;
                    }, Bridge.fn.cacheBind(target, target.MoveRotation), endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions), t, target);
                    t.plugOptions.rotateMode = mode;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DORotate:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOLookAt:static start.*/
                /**
                 * Tweens a Rigidbody's rotation so that it will look towards the given position.
                 Also stores the rigidbody as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target            
                 * @param   {UnityEngine.Vector3}               towards           The position to look at
                 * @param   {number}                            duration          The duration of the tween
                 * @param   {DG.Tweening.AxisConstraint}        axisConstraint    Eventual axis constraint for the rotation
                 * @param   {?UnityEngine.Vector3}              up                The vector that defines in which direction up is (default: Vector3.up)
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOLookAt: function (target, towards, duration, axisConstraint, up) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOLookAt", this ); }

                    if (axisConstraint === void 0) { axisConstraint = 0; }
                    if (up === void 0) { up = null; }
                    var t = DG.Tweening.Core.Extensions.SetSpecialStartupMode(DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions), DG.Tweening.DOTween.To$9(function () {
                        return target.rotation;
                    }, Bridge.fn.cacheBind(target, target.MoveRotation), towards.$clone(), duration), target), DG.Tweening.Core.Enums.SpecialStartupMode.SetLookAt);
                    t.plugOptions.axisConstraint = axisConstraint;
                    t.plugOptions.up = (pc.Vec3.equals( up, null )) ? pc.Vec3.UP.clone() : System.Nullable.getValue(up);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOLookAt:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOJump:static start.*/
                /**
                 * Tweens a Rigidbody's position to the given value, while also applying a jump effect along the Y axis.
                 Returns a Sequence instead of a Tweener.
                 Also stores the Rigidbody as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}    target       
                 * @param   {UnityEngine.Vector3}      endValue     The end value to reach
                 * @param   {number}                   jumpPower    Power of the jump (the max height of the jump is represented by this plus the final Y offset)
                 * @param   {number}                   numJumps     Total number of jumps
                 * @param   {number}                   duration     The duration of the tween
                 * @param   {boolean}                  snapping     If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Sequence}
                 */
                DOJump: function (target, endValue, jumpPower, numJumps, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOJump", this ); }

                    if (snapping === void 0) { snapping = false; }
                    if (numJumps < 1) {
                        numJumps = 1;
                    }
                    var startPosY = 0;
                    var offsetY = -1;
                    var offsetYSet = false;
                    var s = DG.Tweening.DOTween.Sequence();
                    var yTween = DG.Tweening.TweenSettingsExtensions.OnStart(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetLoops$1(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetRelative(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec3( 0, jumpPower, 0 ), duration / (Bridge.Int.mul(numJumps, 2))), DG.Tweening.AxisConstraint.Y, snapping), DG.Tweening.Ease.OutQuad)), Bridge.Int.mul(numJumps, 2), DG.Tweening.LoopType.Yoyo), function () {
                        startPosY = target.position.y;
                    });
                    DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.Join(DG.Tweening.TweenSettingsExtensions.Join(DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec3( endValue.x, 0, 0 ), duration), DG.Tweening.AxisConstraint.X, snapping), DG.Tweening.Ease.Linear)), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec3( 0, 0, endValue.z ), duration), DG.Tweening.AxisConstraint.Z, snapping), DG.Tweening.Ease.Linear)), yTween), target), DG.Tweening.DOTween.defaultEaseType);
                    DG.Tweening.TweenSettingsExtensions.OnUpdate(DG.Tweening.Tween, yTween, function () {
                        if (!offsetYSet) {
                            offsetYSet = true;
                            offsetY = s.isRelative ? endValue.y : endValue.y - startPosY;
                        }
                        var pos = target.position.$clone();
                        pos.y += DG.Tweening.DOVirtual.EasedValue(0, offsetY, DG.Tweening.TweenExtensions.ElapsedPercentage(yTween), DG.Tweening.Ease.OutQuad);
                        target.MovePosition(pos);
                    });
                    return s;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOJump:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOPath:static start.*/
                /**
                 * Tweens a Rigidbody's position through the given path waypoints, using the chosen path algorithm.
                 Also stores the Rigidbody as the tween's target so it can be used for filtered operations.
                 <p>NOTE: to tween a rigidbody correctly it should be set to kinematic at least while being tweened.</p><p>BEWARE: doesn't work on Windows Phone store (waiting for Unity to fix their own bug).
                 If you plan to publish there you should use a regular transform.DOPath.</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target        
                 * @param   {Array.<UnityEngine.Vector3>}       path          The waypoints to go through
                 * @param   {number}                            duration      The duration of the tween
                 * @param   {DG.Tweening.PathType}              pathType      The type of path: Linear (straight path), CatmullRom (curved CatmullRom path) or CubicBezier (curved with control points)
                 * @param   {DG.Tweening.PathMode}              pathMode      The path mode: 3D, side-scroller 2D, top-down 2D
                 * @param   {number}                            resolution    The resolution of the path (useless in case of Linear paths): higher resolutions make for more detailed curved paths but are more expensive.
                 Defaults to 10, but a value of 5 is usually enough if you don't have dramatic long curves between waypoints
                 * @param   {?UnityEngine.Color}                gizmoColor    The color of the path (shown when gizmos are active in the Play panel and the tween is running)
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPath: function (target, path, duration, pathType, pathMode, resolution, gizmoColor) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOPath", this ); }

                    if (pathType === void 0) { pathType = 0; }
                    if (pathMode === void 0) { pathMode = 1; }
                    if (resolution === void 0) { resolution = 10; }
                    if (gizmoColor === void 0) { gizmoColor = null; }
                    if (resolution < 1) {
                        resolution = 1;
                    }
                    var t = DG.Tweening.TweenSettingsExtensions.SetUpdate$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new DG.Tweening.Plugins.Core.PathCore.Path.$ctor1(pathType, path, resolution, System.Nullable.lift1("$clone", gizmoColor)), duration), target), DG.Tweening.UpdateType.Fixed);

                    t.plugOptions.isRigidbody = true;
                    t.plugOptions.mode = pathMode;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOPath:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOPath$1:static start.*/
                DOPath$1: function (target, path, duration, pathMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOPath$1", this ); }

                    if (pathMode === void 0) { pathMode = 1; }
                    var t = DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), path, duration), target);

                    t.plugOptions.isRigidbody = true;
                    t.plugOptions.mode = pathMode;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOPath$1:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOLocalPath:static start.*/
                /**
                 * Tweens a Rigidbody's localPosition through the given path waypoints, using the chosen path algorithm.
                 Also stores the Rigidbody as the tween's target so it can be used for filtered operations
                 <p>NOTE: to tween a rigidbody correctly it should be set to kinematic at least while being tweened.</p><p>BEWARE: doesn't work on Windows Phone store (waiting for Unity to fix their own bug).
                 If you plan to publish there you should use a regular transform.DOLocalPath.</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target        
                 * @param   {Array.<UnityEngine.Vector3>}       path          The waypoint to go through
                 * @param   {number}                            duration      The duration of the tween
                 * @param   {DG.Tweening.PathType}              pathType      The type of path: Linear (straight path), CatmullRom (curved CatmullRom path) or CubicBezier (curved with control points)
                 * @param   {DG.Tweening.PathMode}              pathMode      The path mode: 3D, side-scroller 2D, top-down 2D
                 * @param   {number}                            resolution    The resolution of the path: higher resolutions make for more detailed curved paths but are more expensive.
                 Defaults to 10, but a value of 5 is usually enough if you don't have dramatic long curves between waypoints
                 * @param   {?UnityEngine.Color}                gizmoColor    The color of the path (shown when gizmos are active in the Play panel and the tween is running)
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOLocalPath: function (target, path, duration, pathType, pathMode, resolution, gizmoColor) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOLocalPath", this ); }

                    if (pathType === void 0) { pathType = 0; }
                    if (pathMode === void 0) { pathMode = 1; }
                    if (resolution === void 0) { resolution = 10; }
                    if (gizmoColor === void 0) { gizmoColor = null; }
                    if (resolution < 1) {
                        resolution = 1;
                    }
                    var trans = target.transform;
                    var t = DG.Tweening.TweenSettingsExtensions.SetUpdate$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return trans.localPosition;
                    }, function (x) {
                        target.MovePosition(UnityEngine.Component.op_Equality(trans.parent, null) ? x.$clone() : trans.parent.TransformPoint$1(x));
                    }, new DG.Tweening.Plugins.Core.PathCore.Path.$ctor1(pathType, path, resolution, System.Nullable.lift1("$clone", gizmoColor)), duration), target), DG.Tweening.UpdateType.Fixed);

                    t.plugOptions.isRigidbody = true;
                    t.plugOptions.mode = pathMode;
                    t.plugOptions.useLocalPosition = true;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOLocalPath:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOLocalPath$1:static start.*/
                DOLocalPath$1: function (target, path, duration, pathMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOLocalPath$1", this ); }

                    if (pathMode === void 0) { pathMode = 1; }
                    var trans = target.transform;
                    var t = DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return trans.localPosition;
                    }, function (x) {
                        target.MovePosition(UnityEngine.Component.op_Equality(trans.parent, null) ? x.$clone() : trans.parent.TransformPoint$1(x));
                    }, path, duration), target);

                    t.plugOptions.isRigidbody = true;
                    t.plugOptions.mode = pathMode;
                    t.plugOptions.useLocalPosition = true;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOLocalPath$1:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModulePhysics end.*/

    /*DG.Tweening.DOTweenModulePhysics2D start.*/
    Bridge.define("DG.Tweening.DOTweenModulePhysics2D", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModulePhysics2D.DOMove:static start.*/
                /**
                 * Tweens a Rigidbody2D's position to the given value.
                 Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics2D
                 * @memberof DG.Tweening.DOTweenModulePhysics2D
                 * @param   {UnityEngine.Rigidbody2D}           target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMove: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOMove", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOMove:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DOMoveX:static start.*/
                /**
                 * Tweens a Rigidbody2D's X position to the given value.
                 Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics2D
                 * @memberof DG.Tweening.DOTweenModulePhysics2D
                 * @param   {UnityEngine.Rigidbody2D}           target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMoveX: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOMoveX", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec2( endValue, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.X, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOMoveX:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DOMoveY:static start.*/
                /**
                 * Tweens a Rigidbody2D's Y position to the given value.
                 Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics2D
                 * @memberof DG.Tweening.DOTweenModulePhysics2D
                 * @param   {UnityEngine.Rigidbody2D}           target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMoveY: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOMoveY", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec2( 0, endValue ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.Y, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOMoveY:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DORotate:static start.*/
                /**
                 * Tweens a Rigidbody2D's rotation to the given value.
                 Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics2D
                 * @memberof DG.Tweening.DOTweenModulePhysics2D
                 * @param   {UnityEngine.Rigidbody2D}           target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DORotate: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DORotate", this ); }

                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.rotation;
                    }, Bridge.fn.cacheBind(target, target.MoveRotation), endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DORotate:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DOJump:static start.*/
                /**
                 * Tweens a Rigidbody2D's position to the given value, while also applying a jump effect along the Y axis.
                 Returns a Sequence instead of a Tweener.
                 Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations.
                 <p>IMPORTANT: a rigidbody2D can't be animated in a jump arc using MovePosition, so the tween will directly set the position</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics2D
                 * @memberof DG.Tweening.DOTweenModulePhysics2D
                 * @param   {UnityEngine.Rigidbody2D}    target       
                 * @param   {UnityEngine.Vector2}        endValue     The end value to reach
                 * @param   {number}                     jumpPower    Power of the jump (the max height of the jump is represented by this plus the final Y offset)
                 * @param   {number}                     numJumps     Total number of jumps
                 * @param   {number}                     duration     The duration of the tween
                 * @param   {boolean}                    snapping     If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Sequence}
                 */
                DOJump: function (target, endValue, jumpPower, numJumps, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOJump", this ); }

                    if (snapping === void 0) { snapping = false; }
                    if (numJumps < 1) {
                        numJumps = 1;
                    }
                    var startPosY = 0;
                    var offsetY = -1;
                    var offsetYSet = false;
                    var s = DG.Tweening.DOTween.Sequence();
                    var yTween = DG.Tweening.TweenSettingsExtensions.OnStart(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetLoops$1(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetRelative(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(DG.Tweening.DOTween.To$11(function () {
                        return target.position;
                    }, function (x) {
                        target.position = x.$clone();
                    }, new pc.Vec2( 0, jumpPower ), duration / (Bridge.Int.mul(numJumps, 2))), DG.Tweening.AxisConstraint.Y, snapping), DG.Tweening.Ease.OutQuad)), Bridge.Int.mul(numJumps, 2), DG.Tweening.LoopType.Yoyo), function () {
                        startPosY = target.position.y;
                    });
                    DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.Join(DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(DG.Tweening.DOTween.To$11(function () {
                        return target.position;
                    }, function (x) {
                        target.position = x.$clone();
                    }, new pc.Vec2( endValue.x, 0 ), duration), DG.Tweening.AxisConstraint.X, snapping), DG.Tweening.Ease.Linear)), yTween), target), DG.Tweening.DOTween.defaultEaseType);
                    DG.Tweening.TweenSettingsExtensions.OnUpdate(DG.Tweening.Tween, yTween, function () {
                        if (!offsetYSet) {
                            offsetYSet = true;
                            offsetY = s.isRelative ? endValue.y : endValue.y - startPosY;
                        }
                        var pos = UnityEngine.Vector3.FromVector2(target.position.$clone());
                        pos.y += DG.Tweening.DOVirtual.EasedValue(0, offsetY, DG.Tweening.TweenExtensions.ElapsedPercentage(yTween), DG.Tweening.Ease.OutQuad);
                        target.MovePosition$1(pos);
                    });
                    return s;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOJump:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DOPath:static start.*/
                /**
                 * Tweens a Rigidbody2D's position through the given path waypoints, using the chosen path algorithm.
                 Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations.
                 <p>NOTE: to tween a Rigidbody2D correctly it should be set to kinematic at least while being tweened.</p><p>BEWARE: doesn't work on Windows Phone store (waiting for Unity to fix their own bug).
                 If you plan to publish there you should use a regular transform.DOPath.</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics2D
                 * @memberof DG.Tweening.DOTweenModulePhysics2D
                 * @param   {UnityEngine.Rigidbody2D}           target        
                 * @param   {Array.<UnityEngine.Vector2>}       path          The waypoints to go through
                 * @param   {number}                            duration      The duration of the tween
                 * @param   {DG.Tweening.PathType}              pathType      The type of path: Linear (straight path), CatmullRom (curved CatmullRom path) or CubicBezier (curved with control points)
                 * @param   {DG.Tweening.PathMode}              pathMode      The path mode: 3D, side-scroller 2D, top-down 2D
                 * @param   {number}                            resolution    The resolution of the path (useless in case of Linear paths): higher resolutions make for more detailed curved paths but are more expensive.
                 Defaults to 10, but a value of 5 is usually enough if you don't have dramatic long curves between waypoints
                 * @param   {?UnityEngine.Color}                gizmoColor    The color of the path (shown when gizmos are active in the Play panel and the tween is running)
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPath: function (target, path, duration, pathType, pathMode, resolution, gizmoColor) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOPath", this ); }

                    if (pathType === void 0) { pathType = 0; }
                    if (pathMode === void 0) { pathMode = 1; }
                    if (resolution === void 0) { resolution = 10; }
                    if (gizmoColor === void 0) { gizmoColor = null; }
                    if (resolution < 1) {
                        resolution = 1;
                    }
                    var len = path.length;
                    var path3D = System.Array.init(len, function (){
                        return new UnityEngine.Vector3();
                    }, UnityEngine.Vector3);
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        path3D[i] = UnityEngine.Vector3.FromVector2(path[i].$clone());
                    }
                    var t = DG.Tweening.TweenSettingsExtensions.SetUpdate$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return UnityEngine.Vector3.FromVector2(target.position);
                    }, function (x) {
                        target.MovePosition$1(x);
                    }, new DG.Tweening.Plugins.Core.PathCore.Path.$ctor1(pathType, path3D, resolution, System.Nullable.lift1("$clone", gizmoColor)), duration), target), DG.Tweening.UpdateType.Fixed);

                    t.plugOptions.isRigidbody2D = true;
                    t.plugOptions.mode = pathMode;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOPath:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DOPath$1:static start.*/
                DOPath$1: function (target, path, duration, pathMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOPath$1", this ); }

                    if (pathMode === void 0) { pathMode = 1; }
                    var t = DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return UnityEngine.Vector3.FromVector2(target.position);
                    }, function (x) {
                        target.MovePosition$1(x);
                    }, path, duration), target);

                    t.plugOptions.isRigidbody2D = true;
                    t.plugOptions.mode = pathMode;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOPath$1:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DOLocalPath:static start.*/
                /**
                 * Tweens a Rigidbody2D's localPosition through the given path waypoints, using the chosen path algorithm.
                 Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations
                 <p>NOTE: to tween a Rigidbody2D correctly it should be set to kinematic at least while being tweened.</p><p>BEWARE: doesn't work on Windows Phone store (waiting for Unity to fix their own bug).
                 If you plan to publish there you should use a regular transform.DOLocalPath.</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics2D
                 * @memberof DG.Tweening.DOTweenModulePhysics2D
                 * @param   {UnityEngine.Rigidbody2D}           target        
                 * @param   {Array.<UnityEngine.Vector2>}       path          The waypoint to go through
                 * @param   {number}                            duration      The duration of the tween
                 * @param   {DG.Tweening.PathType}              pathType      The type of path: Linear (straight path), CatmullRom (curved CatmullRom path) or CubicBezier (curved with control points)
                 * @param   {DG.Tweening.PathMode}              pathMode      The path mode: 3D, side-scroller 2D, top-down 2D
                 * @param   {number}                            resolution    The resolution of the path: higher resolutions make for more detailed curved paths but are more expensive.
                 Defaults to 10, but a value of 5 is usually enough if you don't have dramatic long curves between waypoints
                 * @param   {?UnityEngine.Color}                gizmoColor    The color of the path (shown when gizmos are active in the Play panel and the tween is running)
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOLocalPath: function (target, path, duration, pathType, pathMode, resolution, gizmoColor) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOLocalPath", this ); }

                    if (pathType === void 0) { pathType = 0; }
                    if (pathMode === void 0) { pathMode = 1; }
                    if (resolution === void 0) { resolution = 10; }
                    if (gizmoColor === void 0) { gizmoColor = null; }
                    if (resolution < 1) {
                        resolution = 1;
                    }
                    var len = path.length;
                    var path3D = System.Array.init(len, function (){
                        return new UnityEngine.Vector3();
                    }, UnityEngine.Vector3);
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        path3D[i] = UnityEngine.Vector3.FromVector2(path[i].$clone());
                    }
                    var trans = target.transform;
                    var t = DG.Tweening.TweenSettingsExtensions.SetUpdate$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return trans.localPosition;
                    }, function (x) {
                        target.MovePosition$1(UnityEngine.Component.op_Equality(trans.parent, null) ? x.$clone() : trans.parent.TransformPoint$1(x));
                    }, new DG.Tweening.Plugins.Core.PathCore.Path.$ctor1(pathType, path3D, resolution, System.Nullable.lift1("$clone", gizmoColor)), duration), target), DG.Tweening.UpdateType.Fixed);

                    t.plugOptions.isRigidbody2D = true;
                    t.plugOptions.mode = pathMode;
                    t.plugOptions.useLocalPosition = true;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOLocalPath:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DOLocalPath$1:static start.*/
                DOLocalPath$1: function (target, path, duration, pathMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOLocalPath$1", this ); }

                    if (pathMode === void 0) { pathMode = 1; }
                    var trans = target.transform;
                    var t = DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return trans.localPosition;
                    }, function (x) {
                        target.MovePosition$1(UnityEngine.Component.op_Equality(trans.parent, null) ? x.$clone() : trans.parent.TransformPoint$1(x));
                    }, path, duration), target);

                    t.plugOptions.isRigidbody2D = true;
                    t.plugOptions.mode = pathMode;
                    t.plugOptions.useLocalPosition = true;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOLocalPath$1:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModulePhysics2D end.*/

    /*DG.Tweening.DOTweenModuleSprite start.*/
    Bridge.define("DG.Tweening.DOTweenModuleSprite", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleSprite.DOColor:static start.*/
                /**
                 * Tweens a SpriteRenderer's color to the given value.
                 Also stores the spriteRenderer as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleSprite
                 * @memberof DG.Tweening.DOTweenModuleSprite
                 * @param   {UnityEngine.SpriteRenderer}        target      
                 * @param   {UnityEngine.Color}                 endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOColor: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleSprite#DOColor", this ); }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleSprite.DOColor:static end.*/

                /*DG.Tweening.DOTweenModuleSprite.DOFade:static start.*/
                /**
                 * Tweens a Material's alpha color to the given value.
                 Also stores the spriteRenderer as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleSprite
                 * @memberof DG.Tweening.DOTweenModuleSprite
                 * @param   {UnityEngine.SpriteRenderer}        target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleSprite#DOFade", this ); }

                    var t = DG.Tweening.DOTween.ToAlpha(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleSprite.DOFade:static end.*/

                /*DG.Tweening.DOTweenModuleSprite.DOGradientColor:static start.*/
                /**
                 * Tweens a SpriteRenderer's color using the given gradient
                 (NOTE 1: only uses the colors of the gradient, not the alphas - NOTE 2: creates a Sequence, not a Tweener).
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleSprite
                 * @memberof DG.Tweening.DOTweenModuleSprite
                 * @param   {UnityEngine.SpriteRenderer}    target      
                 * @param   {pc.ColorGradient}              gradient    The gradient to use
                 * @param   {number}                        duration    The duration of the tween
                 * @return  {DG.Tweening.Sequence}
                 */
                DOGradientColor: function (target, gradient, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleSprite#DOGradientColor", this ); }

                    var s = DG.Tweening.DOTween.Sequence();
                    var colors = gradient.colorKeys;
                    var len = colors.length;
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        var c = colors[i];
                        if (i === 0 && c.time <= 0) {
                            target.color = c.color.$clone();
                            continue;
                        }
                        var colorDuration = i === ((len - 1) | 0) ? duration - DG.Tweening.TweenExtensions.Duration(s, false) : duration * (i === 0 ? c.time : c.time - colors[((i - 1) | 0)].time);
                        DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.DOTweenModuleSprite.DOColor(target, c.color.$clone(), colorDuration), DG.Tweening.Ease.Linear));
                    }
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, s, target);
                    return s;
                },
                /*DG.Tweening.DOTweenModuleSprite.DOGradientColor:static end.*/

                /*DG.Tweening.DOTweenModuleSprite.DOBlendableColor:static start.*/
                /**
                 * Tweens a SpriteRenderer's color to the given value,
                 in a way that allows other DOBlendableColor tweens to work together on the same target,
                 instead than fight each other as multiple DOColor would do.
                 Also stores the SpriteRenderer as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleSprite
                 * @memberof DG.Tweening.DOTweenModuleSprite
                 * @param   {UnityEngine.SpriteRenderer}    target      
                 * @param   {UnityEngine.Color}             endValue    The value to tween to
                 * @param   {number}                        duration    The duration of the tween
                 * @return  {DG.Tweening.Tweener}
                 */
                DOBlendableColor: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleSprite#DOBlendableColor", this ); }

                    var $t;
                    endValue = ($t = target.color, new pc.Color( endValue.r - $t.r, endValue.g - $t.g, endValue.b - $t.b, endValue.a - $t.a ));
                    var to = new pc.Color( 0, 0, 0, 0 );
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.Core.Extensions.Blendable(UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions, DG.Tweening.DOTween.To$8(function () {
                        return to;
                    }, function (x) {
                        var $t1;
                        var diff = new pc.Color( x.r - to.r, x.g - to.g, x.b - to.b, x.a - to.a );
                        to = x.$clone();
                        target.color = ($t1 = target.color.$clone(), new pc.Color( $t1.r + diff.$clone().r, $t1.g + diff.$clone().g, $t1.b + diff.$clone().b, $t1.a + diff.$clone().a ));
                    }, endValue.$clone(), duration)), target);
                },
                /*DG.Tweening.DOTweenModuleSprite.DOBlendableColor:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleSprite end.*/

    /*DG.Tweening.DOTweenModuleUI start.*/
    Bridge.define("DG.Tweening.DOTweenModuleUI", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleUI.DOFade:static start.*/
                /**
                 * Tweens a CanvasGroup's alpha color to the given value.
                 Also stores the canvasGroup as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.CanvasGroup}           target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFade", this ); }

                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.alpha;
                    }, function (x) {
                        target.alpha = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFade:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFade$1:static start.*/
                /**
                 * Tweens an Graphic's alpha color to the given value.
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Graphic}            target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade$1: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFade$1", this ); }

                    var t = DG.Tweening.DOTween.ToAlpha(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFade$1:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFade$2:static start.*/
                /**
                 * Tweens an Image's alpha color to the given value.
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Image}              target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade$2: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFade$2", this ); }

                    var t = DG.Tweening.DOTween.ToAlpha(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFade$2:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFade$3:static start.*/
                /**
                 * Tweens a Outline's effectColor alpha to the given value.
                 Also stores the Outline as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Outline}            target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade$3: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFade$3", this ); }

                    var t = DG.Tweening.DOTween.ToAlpha(function () {
                        return target.effectColor;
                    }, function (x) {
                        target.effectColor = x.$clone();
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFade$3:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFade$4:static start.*/
                /**
                 * Tweens a Text's alpha color to the given value.
                 Also stores the Text as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Text}               target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade$4: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFade$4", this ); }

                    var t = DG.Tweening.DOTween.ToAlpha(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFade$4:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOColor:static start.*/
                /**
                 * Tweens an Graphic's color to the given value.
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Graphic}            target      
                 * @param   {UnityEngine.Color}                 endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOColor: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOColor", this ); }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOColor:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOColor$1:static start.*/
                /**
                 * Tweens an Image's color to the given value.
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Image}              target      
                 * @param   {UnityEngine.Color}                 endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOColor$1: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOColor$1", this ); }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOColor$1:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOColor$2:static start.*/
                /**
                 * Tweens a Outline's effectColor to the given value.
                 Also stores the Outline as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Outline}            target      
                 * @param   {UnityEngine.Color}                 endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOColor$2: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOColor$2", this ); }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.effectColor;
                    }, function (x) {
                        target.effectColor = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOColor$2:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOColor$3:static start.*/
                /**
                 * Tweens a Text's color to the given value.
                 Also stores the Text as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Text}               target      
                 * @param   {UnityEngine.Color}                 endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOColor$3: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOColor$3", this ); }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOColor$3:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFillAmount:static start.*/
                /**
                 * Tweens an Image's fillAmount to the given value.
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Image}              target      
                 * @param   {number}                            endValue    The end value to reach (0 to 1)
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFillAmount: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFillAmount", this ); }

                    if (endValue > 1) {
                        endValue = 1;
                    } else {
                        if (endValue < 0) {
                            endValue = 0;
                        }
                    }
                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.fillAmount;
                    }, function (x) {
                        target.fillAmount = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFillAmount:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOGradientColor:static start.*/
                /**
                 * Tweens an Image's colors using the given gradient
                 (NOTE 1: only uses the colors of the gradient, not the alphas - NOTE 2: creates a Sequence, not a Tweener).
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Image}    target      
                 * @param   {pc.ColorGradient}        gradient    The gradient to use
                 * @param   {number}                  duration    The duration of the tween
                 * @return  {DG.Tweening.Sequence}
                 */
                DOGradientColor: function (target, gradient, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOGradientColor", this ); }

                    var s = DG.Tweening.DOTween.Sequence();
                    var colors = gradient.colorKeys;
                    var len = colors.length;
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        var c = colors[i];
                        if (i === 0 && c.time <= 0) {
                            target.color = c.color.$clone();
                            continue;
                        }
                        var colorDuration = i === ((len - 1) | 0) ? duration - DG.Tweening.TweenExtensions.Duration(s, false) : duration * (i === 0 ? c.time : c.time - colors[((i - 1) | 0)].time);
                        DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.DOTweenModuleUI.DOColor$1(target, c.color.$clone(), colorDuration), DG.Tweening.Ease.Linear));
                    }
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, s, target);
                    return s;
                },
                /*DG.Tweening.DOTweenModuleUI.DOGradientColor:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFlexibleSize:static start.*/
                /**
                 * Tweens an LayoutElement's flexibleWidth/Height to the given value.
                 Also stores the LayoutElement as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.LayoutElement}      target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFlexibleSize: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFlexibleSize", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return new pc.Vec2( target.flexibleWidth, target.flexibleHeight );
                    }, function (x) {
                        target.flexibleWidth = x.x;
                        target.flexibleHeight = x.y;
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFlexibleSize:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOMinSize:static start.*/
                /**
                 * Tweens an LayoutElement's minWidth/Height to the given value.
                 Also stores the LayoutElement as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.LayoutElement}      target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMinSize: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOMinSize", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return new pc.Vec2( target.minWidth, target.minHeight );
                    }, function (x) {
                        target.minWidth = x.x;
                        target.minHeight = x.y;
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOMinSize:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOPreferredSize:static start.*/
                /**
                 * Tweens an LayoutElement's preferredWidth/Height to the given value.
                 Also stores the LayoutElement as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.LayoutElement}      target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPreferredSize: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOPreferredSize", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return new pc.Vec2( target.preferredWidth, target.preferredHeight );
                    }, function (x) {
                        target.preferredWidth = x.x;
                        target.preferredHeight = x.y;
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOPreferredSize:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOScale:static start.*/
                /**
                 * Tweens a Outline's effectDistance to the given value.
                 Also stores the Outline as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Outline}            target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOScale: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOScale", this ); }

                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.effectDistance;
                    }, function (x) {
                        target.effectDistance = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOScale:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPos: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPos", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPosX:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition X to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPosX: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPosX", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, new pc.Vec2( endValue, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.X, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPosX:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPosY:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition Y to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPosY: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPosY", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, new pc.Vec2( 0, endValue ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.Y, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPosY:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3D:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition3D to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector3}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPos3D: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPos3D", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.anchoredPosition3D;
                    }, function (x) {
                        target.anchoredPosition3D = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$13(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3D:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DX:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition3D X to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPos3DX: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPos3DX", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.anchoredPosition3D;
                    }, function (x) {
                        target.anchoredPosition3D = x.$clone();
                    }, new pc.Vec3( endValue, 0, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.X, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DX:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DY:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition3D Y to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPos3DY: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPos3DY", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.anchoredPosition3D;
                    }, function (x) {
                        target.anchoredPosition3D = x.$clone();
                    }, new pc.Vec3( 0, endValue, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.Y, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DY:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DZ:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition3D Z to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPos3DZ: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPos3DZ", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.anchoredPosition3D;
                    }, function (x) {
                        target.anchoredPosition3D = x.$clone();
                    }, new pc.Vec3( 0, 0, endValue ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.Z, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DZ:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorMax:static start.*/
                /**
                 * Tweens a RectTransform's anchorMax to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorMax: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorMax", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.anchorMax;
                    }, function (x) {
                        target.anchorMax = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorMax:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorMin:static start.*/
                /**
                 * Tweens a RectTransform's anchorMin to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorMin: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorMin", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.anchorMin;
                    }, function (x) {
                        target.anchorMin = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorMin:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOPivot:static start.*/
                /**
                 * Tweens a RectTransform's pivot to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPivot: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOPivot", this ); }

                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.pivot;
                    }, function (x) {
                        target.pivot = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOPivot:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOPivotX:static start.*/
                /**
                 * Tweens a RectTransform's pivot X to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPivotX: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOPivotX", this ); }

                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.pivot;
                    }, function (x) {
                        target.pivot = x.$clone();
                    }, new pc.Vec2( endValue, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.X), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOPivotX:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOPivotY:static start.*/
                /**
                 * Tweens a RectTransform's pivot Y to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPivotY: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOPivotY", this ); }

                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.pivot;
                    }, function (x) {
                        target.pivot = x.$clone();
                    }, new pc.Vec2( 0, endValue ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.Y), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOPivotY:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOSizeDelta:static start.*/
                /**
                 * Tweens a RectTransform's sizeDelta to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOSizeDelta: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOSizeDelta", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.sizeDelta;
                    }, function (x) {
                        target.sizeDelta = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOSizeDelta:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOPunchAnchorPos:static start.*/
                /**
                 * Punches a RectTransform's anchoredPosition towards the given direction and then back to the starting one
                 as if it was connected to the starting position via an elastic.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}    target        
                 * @param   {UnityEngine.Vector2}          punch         The direction and strength of the punch (added to the RectTransform's current position)
                 * @param   {number}                       duration      The duration of the tween
                 * @param   {number}                       vibrato       Indicates how much will the punch vibrate
                 * @param   {number}                       elasticity    Represents how much (0 to 1) the vector will go beyond the starting position when bouncing backwards.
                 1 creates a full oscillation between the punch direction and the opposite direction,
                 while 0 oscillates only between the punch and the start position
                 * @param   {boolean}                      snapping      If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Tweener}
                 */
                DOPunchAnchorPos: function (target, punch, duration, vibrato, elasticity, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOPunchAnchorPos", this ); }

                    if (vibrato === void 0) { vibrato = 10; }
                    if (elasticity === void 0) { elasticity = 1.0; }
                    if (snapping === void 0) { snapping = false; }
                    return DG.Tweening.TweenSettingsExtensions.SetOptions$11(DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.DOTween.Punch(function () {
                        return UnityEngine.Vector3.FromVector2(target.anchoredPosition);
                    }, function (x) {
                        target.anchoredPosition = UnityEngine.Vector2.FromVector3(x.$clone());
                    }, UnityEngine.Vector3.FromVector2(punch.$clone()), duration, vibrato, elasticity), target), snapping);
                },
                /*DG.Tweening.DOTweenModuleUI.DOPunchAnchorPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOShakeAnchorPos:static start.*/
                /**
                 * Shakes a RectTransform's anchoredPosition with the given values.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}          target            
                 * @param   {number}                             duration          The duration of the tween
                 * @param   {number}                             strength          The shake strength
                 * @param   {number}                             vibrato           Indicates how much will the shake vibrate
                 * @param   {number}                             randomness        Indicates how much the shake will be random (0 to 180 - values higher than 90 kind of suck, so beware). 
                 Setting it to 0 will shake along a single direction.
                 * @param   {boolean}                            snapping          If TRUE the tween will smoothly snap all values to integers
                 * @param   {boolean}                            fadeOut           If TRUE the shake will automatically fadeOut smoothly within the tween's duration, otherwise it will not
                 * @param   {DG.Tweening.ShakeRandomnessMode}    randomnessMode    Randomness mode
                 * @return  {DG.Tweening.Tweener}
                 */
                DOShakeAnchorPos: function (target, duration, strength, vibrato, randomness, snapping, fadeOut, randomnessMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOShakeAnchorPos", this ); }

                    if (strength === void 0) { strength = 100.0; }
                    if (vibrato === void 0) { vibrato = 10; }
                    if (randomness === void 0) { randomness = 90.0; }
                    if (snapping === void 0) { snapping = false; }
                    if (fadeOut === void 0) { fadeOut = true; }
                    if (randomnessMode === void 0) { randomnessMode = 0; }
                    return DG.Tweening.TweenSettingsExtensions.SetOptions$11(DG.Tweening.Core.Extensions.SetSpecialStartupMode(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.DOTween.Shake(function () {
                        return UnityEngine.Vector3.FromVector2(target.anchoredPosition);
                    }, function (x) {
                        target.anchoredPosition = UnityEngine.Vector2.FromVector3(x.$clone());
                    }, duration, strength, vibrato, randomness, true, fadeOut, randomnessMode), target), DG.Tweening.Core.Enums.SpecialStartupMode.SetShake), snapping);
                },
                /*DG.Tweening.DOTweenModuleUI.DOShakeAnchorPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOShakeAnchorPos$1:static start.*/
                /**
                 * Shakes a RectTransform's anchoredPosition with the given values.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}          target            
                 * @param   {number}                             duration          The duration of the tween
                 * @param   {UnityEngine.Vector2}                strength          The shake strength on each axis
                 * @param   {number}                             vibrato           Indicates how much will the shake vibrate
                 * @param   {number}                             randomness        Indicates how much the shake will be random (0 to 180 - values higher than 90 kind of suck, so beware). 
                 Setting it to 0 will shake along a single direction.
                 * @param   {boolean}                            snapping          If TRUE the tween will smoothly snap all values to integers
                 * @param   {boolean}                            fadeOut           If TRUE the shake will automatically fadeOut smoothly within the tween's duration, otherwise it will not
                 * @param   {DG.Tweening.ShakeRandomnessMode}    randomnessMode    Randomness mode
                 * @return  {DG.Tweening.Tweener}
                 */
                DOShakeAnchorPos$1: function (target, duration, strength, vibrato, randomness, snapping, fadeOut, randomnessMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOShakeAnchorPos$1", this ); }

                    if (vibrato === void 0) { vibrato = 10; }
                    if (randomness === void 0) { randomness = 90.0; }
                    if (snapping === void 0) { snapping = false; }
                    if (fadeOut === void 0) { fadeOut = true; }
                    if (randomnessMode === void 0) { randomnessMode = 0; }
                    return DG.Tweening.TweenSettingsExtensions.SetOptions$11(DG.Tweening.Core.Extensions.SetSpecialStartupMode(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.DOTween.Shake$1(function () {
                        return UnityEngine.Vector3.FromVector2(target.anchoredPosition);
                    }, function (x) {
                        target.anchoredPosition = UnityEngine.Vector2.FromVector3(x.$clone());
                    }, duration, UnityEngine.Vector3.FromVector2(strength.$clone()), vibrato, randomness, fadeOut, randomnessMode), target), DG.Tweening.Core.Enums.SpecialStartupMode.SetShake), snapping);
                },
                /*DG.Tweening.DOTweenModuleUI.DOShakeAnchorPos$1:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOJumpAnchorPos:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition to the given value, while also applying a jump effect along the Y axis.
                 Returns a Sequence instead of a Tweener.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}    target       
                 * @param   {UnityEngine.Vector2}          endValue     The end value to reach
                 * @param   {number}                       jumpPower    Power of the jump (the max height of the jump is represented by this plus the final Y offset)
                 * @param   {number}                       numJumps     Total number of jumps
                 * @param   {number}                       duration     The duration of the tween
                 * @param   {boolean}                      snapping     If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Sequence}
                 */
                DOJumpAnchorPos: function (target, endValue, jumpPower, numJumps, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOJumpAnchorPos", this ); }

                    if (snapping === void 0) { snapping = false; }
                    if (numJumps < 1) {
                        numJumps = 1;
                    }
                    var startPosY = 0;
                    var offsetY = -1;
                    var offsetYSet = false;

                    // Separate Y Tween so we can elaborate elapsedPercentage on that insted of on the Sequence
                    // (in case users add a delay or other elements to the Sequence)
                    var s = DG.Tweening.DOTween.Sequence();
                    var yTween = DG.Tweening.TweenSettingsExtensions.OnStart(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetLoops$1(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetRelative(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(DG.Tweening.DOTween.To$11(function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, new pc.Vec2( 0, jumpPower ), duration / (Bridge.Int.mul(numJumps, 2))), DG.Tweening.AxisConstraint.Y, snapping), DG.Tweening.Ease.OutQuad)), Bridge.Int.mul(numJumps, 2), DG.Tweening.LoopType.Yoyo), function () {
                        startPosY = target.anchoredPosition.y;
                    });
                    DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.Join(DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(DG.Tweening.DOTween.To$11(function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, new pc.Vec2( endValue.x, 0 ), duration), DG.Tweening.AxisConstraint.X, snapping), DG.Tweening.Ease.Linear)), yTween), target), DG.Tweening.DOTween.defaultEaseType);
                    DG.Tweening.TweenSettingsExtensions.OnUpdate(DG.Tweening.Sequence, s, function () {
                        if (!offsetYSet) {
                            offsetYSet = true;
                            offsetY = s.isRelative ? endValue.y : endValue.y - startPosY;
                        }
                        var pos = target.anchoredPosition.$clone();
                        pos.y += DG.Tweening.DOVirtual.EasedValue(0, offsetY, DG.Tweening.TweenExtensions.ElapsedDirectionalPercentage(s), DG.Tweening.Ease.OutQuad);
                        target.anchoredPosition = pos.$clone();
                    });
                    return s;
                },
                /*DG.Tweening.DOTweenModuleUI.DOJumpAnchorPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DONormalizedPos:static start.*/
                /**
                 * Tweens a ScrollRect's horizontal/verticalNormalizedPosition to the given value.
                 Also stores the ScrollRect as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.ScrollRect}    target      
                 * @param   {UnityEngine.Vector2}          endValue    The end value to reach
                 * @param   {number}                       duration    The duration of the tween
                 * @param   {boolean}                      snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Tweener}
                 */
                DONormalizedPos: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DONormalizedPos", this ); }

                    if (snapping === void 0) { snapping = false; }
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(DG.Tweening.DOTween.To$11(function () {
                        return new pc.Vec2( target.horizontalNormalizedPosition, target.verticalNormalizedPosition );
                    }, function (x) {
                        target.horizontalNormalizedPosition = x.x;
                        target.verticalNormalizedPosition = x.y;
                    }, endValue.$clone(), duration), snapping), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DONormalizedPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOHorizontalNormalizedPos:static start.*/
                /**
                 * Tweens a ScrollRect's horizontalNormalizedPosition to the given value.
                 Also stores the ScrollRect as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.ScrollRect}    target      
                 * @param   {number}                       endValue    The end value to reach
                 * @param   {number}                       duration    The duration of the tween
                 * @param   {boolean}                      snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Tweener}
                 */
                DOHorizontalNormalizedPos: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOHorizontalNormalizedPos", this ); }

                    if (snapping === void 0) { snapping = false; }
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$2(DG.Tweening.DOTween.To$4(function () {
                        return target.horizontalNormalizedPosition;
                    }, function (x) {
                        target.horizontalNormalizedPosition = x;
                    }, endValue, duration), snapping), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DOHorizontalNormalizedPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOVerticalNormalizedPos:static start.*/
                /**
                 * Tweens a ScrollRect's verticalNormalizedPosition to the given value.
                 Also stores the ScrollRect as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.ScrollRect}    target      
                 * @param   {number}                       endValue    The end value to reach
                 * @param   {number}                       duration    The duration of the tween
                 * @param   {boolean}                      snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Tweener}
                 */
                DOVerticalNormalizedPos: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOVerticalNormalizedPos", this ); }

                    if (snapping === void 0) { snapping = false; }
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$2(DG.Tweening.DOTween.To$4(function () {
                        return target.verticalNormalizedPosition;
                    }, function (x) {
                        target.verticalNormalizedPosition = x;
                    }, endValue, duration), snapping), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DOVerticalNormalizedPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOValue:static start.*/
                /**
                 * Tweens a Slider's value to the given value.
                 Also stores the Slider as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Slider}             target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOValue: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOValue", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.value;
                    }, function (x) {
                        target.value = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$2(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOValue:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOCounter:static start.*/
                /**
                 * Tweens a Text's text from one integer to another, with options for thousands separators
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Text}                 target                   
                 * @param   {number}                              fromValue                The value to start from
                 * @param   {number}                              endValue                 The end value to reach
                 * @param   {number}                              duration                 The duration of the tween
                 * @param   {boolean}                             addThousandsSeparator    If TRUE (default) also adds thousands separators
                 * @param   {System.Globalization.CultureInfo}    culture                  The {@link } to use (InvariantCulture if NULL)
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOCounter: function (target, fromValue, endValue, duration, addThousandsSeparator, culture) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOCounter", this ); }

                    if (addThousandsSeparator === void 0) { addThousandsSeparator = true; }
                    if (culture === void 0) { culture = null; }
                    var v = fromValue;
                    var cInfo = !addThousandsSeparator ? null : culture || System.Globalization.CultureInfo.invariantCulture;
                    var t = DG.Tweening.DOTween.To$2(function () {
                        return v;
                    }, function (x) {
                        v = x;
                        target.text = addThousandsSeparator ? System.Int32.format(v, "N0", cInfo) : Bridge.toString(v);
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Int32,System.Int32,DG.Tweening.Plugins.Options.NoOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOCounter:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOText:static start.*/
                /**
                 * Tweens a Text's text to the given value.
                 Also stores the Text as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Text}               target             
                 * @param   {string}                            endValue           The end string to tween to
                 * @param   {number}                            duration           The duration of the tween
                 * @param   {boolean}                           richTextEnabled    If TRUE (default), rich text will be interpreted correctly while animated,
                 otherwise all tags will be considered as normal text
                 * @param   {DG.Tweening.ScrambleMode}          scrambleMode       The type of scramble mode to use, if any
                 * @param   {string}                            scrambleChars      A string containing the characters to use for scrambling.
                 Use as many characters as possible (minimum 10) because DOTween uses a fast scramble mode which gives better results with more characters.
                 Leave it to NULL (default) to use default ones
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOText: function (target, endValue, duration, richTextEnabled, scrambleMode, scrambleChars) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOText", this ); }

                    if (richTextEnabled === void 0) { richTextEnabled = true; }
                    if (scrambleMode === void 0) { scrambleMode = 0; }
                    if (scrambleChars === void 0) { scrambleChars = null; }
                    if (endValue == null) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogWarning("You can't pass a NULL string to DOText: an empty string will be used instead to avoid errors");
                        }
                        endValue = "";
                    }
                    var t = DG.Tweening.DOTween.To$5(function () {
                        return target.text;
                    }, function (x) {
                        target.text = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$3(t, richTextEnabled, scrambleMode, scrambleChars), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOText:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor:static start.*/
                /**
                 * Tweens a Graphic's color to the given value,
                 in a way that allows other DOBlendableColor tweens to work together on the same target,
                 instead than fight each other as multiple DOColor would do.
                 Also stores the Graphic as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Graphic}    target      
                 * @param   {UnityEngine.Color}         endValue    The value to tween to
                 * @param   {number}                    duration    The duration of the tween
                 * @return  {DG.Tweening.Tweener}
                 */
                DOBlendableColor: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOBlendableColor", this ); }

                    var $t;
                    endValue = ($t = target.color, new pc.Color( endValue.r - $t.r, endValue.g - $t.g, endValue.b - $t.b, endValue.a - $t.a ));
                    var to = new pc.Color( 0, 0, 0, 0 );
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.Core.Extensions.Blendable(UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions, DG.Tweening.DOTween.To$8(function () {
                        return to;
                    }, function (x) {
                        var $t1;
                        var diff = new pc.Color( x.r - to.r, x.g - to.g, x.b - to.b, x.a - to.a );
                        to = x.$clone();
                        target.color = ($t1 = target.color.$clone(), new pc.Color( $t1.r + diff.$clone().r, $t1.g + diff.$clone().g, $t1.b + diff.$clone().b, $t1.a + diff.$clone().a ));
                    }, endValue.$clone(), duration)), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor$1:static start.*/
                /**
                 * Tweens a Image's color to the given value,
                 in a way that allows other DOBlendableColor tweens to work together on the same target,
                 instead than fight each other as multiple DOColor would do.
                 Also stores the Image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Image}    target      
                 * @param   {UnityEngine.Color}       endValue    The value to tween to
                 * @param   {number}                  duration    The duration of the tween
                 * @return  {DG.Tweening.Tweener}
                 */
                DOBlendableColor$1: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOBlendableColor$1", this ); }

                    var $t;
                    endValue = ($t = target.color, new pc.Color( endValue.r - $t.r, endValue.g - $t.g, endValue.b - $t.b, endValue.a - $t.a ));
                    var to = new pc.Color( 0, 0, 0, 0 );
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.Core.Extensions.Blendable(UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions, DG.Tweening.DOTween.To$8(function () {
                        return to;
                    }, function (x) {
                        var $t1;
                        var diff = new pc.Color( x.r - to.r, x.g - to.g, x.b - to.b, x.a - to.a );
                        to = x.$clone();
                        target.color = ($t1 = target.color.$clone(), new pc.Color( $t1.r + diff.$clone().r, $t1.g + diff.$clone().g, $t1.b + diff.$clone().b, $t1.a + diff.$clone().a ));
                    }, endValue.$clone(), duration)), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor$1:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor$2:static start.*/
                /**
                 * Tweens a Text's color BY the given value,
                 in a way that allows other DOBlendableColor tweens to work together on the same target,
                 instead than fight each other as multiple DOColor would do.
                 Also stores the Text as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Text}    target      
                 * @param   {UnityEngine.Color}      endValue    The value to tween to
                 * @param   {number}                 duration    The duration of the tween
                 * @return  {DG.Tweening.Tweener}
                 */
                DOBlendableColor$2: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOBlendableColor$2", this ); }

                    var $t;
                    endValue = ($t = target.color, new pc.Color( endValue.r - $t.r, endValue.g - $t.g, endValue.b - $t.b, endValue.a - $t.a ));
                    var to = new pc.Color( 0, 0, 0, 0 );
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.Core.Extensions.Blendable(UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions, DG.Tweening.DOTween.To$8(function () {
                        return to;
                    }, function (x) {
                        var $t1;
                        var diff = new pc.Color( x.r - to.r, x.g - to.g, x.b - to.b, x.a - to.a );
                        to = x.$clone();
                        target.color = ($t1 = target.color.$clone(), new pc.Color( $t1.r + diff.$clone().r, $t1.g + diff.$clone().g, $t1.b + diff.$clone().b, $t1.a + diff.$clone().a ));
                    }, endValue.$clone(), duration)), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor$2:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOShapeCircle:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition so that it draws a circle around the given center.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations.<p />
                 IMPORTANT: SetFrom(value) requires a {@link } instead of a float, where the X property represents the "from degrees value"
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target             
                 * @param   {UnityEngine.Vector2}               center             Circle-center/pivot around which to rotate (in UI anchoredPosition coordinates)
                 * @param   {number}                            endValueDegrees    The end value degrees to reach (to rotate counter-clockwise pass a negative value)
                 * @param   {number}                            duration           The duration of the tween
                 * @param   {boolean}                           relativeCenter     If TRUE the {@link } coordinates will be considered as relative to the target's current anchoredPosition
                 * @param   {boolean}                           snapping           If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOShapeCircle: function (target, center, endValueDegrees, duration, relativeCenter, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOShapeCircle", this ); }

                    if (relativeCenter === void 0) { relativeCenter = false; }
                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To(UnityEngine.Vector2, UnityEngine.Vector2, DG.Tweening.Plugins.CircleOptions, DG.Tweening.Plugins.CirclePlugin.Get(), function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, center.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$7(t, endValueDegrees, relativeCenter, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOShapeCircle:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleUI end.*/

    /*DG.Tweening.DOTweenModuleUI+Utils start.*/
    Bridge.define("DG.Tweening.DOTweenModuleUI.Utils", {
        $kind: 1002,
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleUI+Utils.SwitchToRectTransform:static start.*/
                /**
                 * Converts the anchoredPosition of the first RectTransform to the second RectTransform,
                 taking into consideration offset, anchors and pivot, and returns the new anchoredPosition
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI.Utils
                 * @memberof DG.Tweening.DOTweenModuleUI.Utils
                 * @param   {UnityEngine.RectTransform}    from    
                 * @param   {UnityEngine.RectTransform}    to
                 * @return  {UnityEngine.Vector2}
                 */
                SwitchToRectTransform: function (from, to) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI.Utils#SwitchToRectTransform", this ); }

                    var localPoint = { v : new UnityEngine.Vector2() };
                    var fromPivotDerivedOffset = new pc.Vec2( from.rect.width * 0.5 + from.rect.xMin, from.rect.height * 0.5 + from.rect.yMin );
                    var screenP = UnityEngine.RectTransformUtility.WorldToScreenPoint(null, from.position);
                    screenP = screenP.$clone().add( fromPivotDerivedOffset.$clone() );
                    UnityEngine.RectTransformUtility.ScreenPointToLocalPointInRectangle(to, screenP, null, localPoint);
                    var pivotDerivedOffset = new pc.Vec2( to.rect.width * 0.5 + to.rect.xMin, to.rect.height * 0.5 + to.rect.yMin );
                    return to.anchoredPosition.$clone().add( localPoint.v ).sub( pivotDerivedOffset );
                },
                /*DG.Tweening.DOTweenModuleUI+Utils.SwitchToRectTransform:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleUI+Utils end.*/

    /*DG.Tweening.DOTweenModuleUnityVersion start.*/
    /** @namespace DG.Tweening */

    /**
     * Shortcuts/functions that are not strictly related to specific Modules
     but are available only on some Unity versions
     *
     * @static
     * @abstract
     * @public
     * @class DG.Tweening.DOTweenModuleUnityVersion
     */
    Bridge.define("DG.Tweening.DOTweenModuleUnityVersion", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleUnityVersion.DOGradientColor:static start.*/
                /**
                 * Tweens a Material's color using the given gradient
                 (NOTE 1: only uses the colors of the gradient, not the alphas - NOTE 2: creates a Sequence, not a Tweener).
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {UnityEngine.Material}    target      
                 * @param   {pc.ColorGradient}        gradient    The gradient to use
                 * @param   {number}                  duration    The duration of the tween
                 * @return  {DG.Tweening.Sequence}
                 */
                DOGradientColor: function (target, gradient, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#DOGradientColor", this ); }

                    var s = DG.Tweening.DOTween.Sequence();
                    var colors = gradient.colorKeys;
                    var len = colors.length;
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        var c = colors[i];
                        if (i === 0 && c.time <= 0) {
                            target.color = c.color.$clone();
                            continue;
                        }
                        var colorDuration = i === ((len - 1) | 0) ? duration - DG.Tweening.TweenExtensions.Duration(s, false) : duration * (i === 0 ? c.time : c.time - colors[((i - 1) | 0)].time);
                        DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.ShortcutExtensions.DOColor$3(target, c.color.$clone(), colorDuration), DG.Tweening.Ease.Linear));
                    }
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, s, target);
                    return s;
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.DOGradientColor:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.DOGradientColor$1:static start.*/
                /**
                 * Tweens a Material's named color property using the given gradient
                 (NOTE 1: only uses the colors of the gradient, not the alphas - NOTE 2: creates a Sequence, not a Tweener).
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {UnityEngine.Material}    target      
                 * @param   {pc.ColorGradient}        gradient    The gradient to use
                 * @param   {string}                  property    The name of the material property to tween (like _Tint or _SpecColor)
                 * @param   {number}                  duration    The duration of the tween
                 * @return  {DG.Tweening.Sequence}
                 */
                DOGradientColor$1: function (target, gradient, property, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#DOGradientColor$1", this ); }

                    var s = DG.Tweening.DOTween.Sequence();
                    var colors = gradient.colorKeys;
                    var len = colors.length;
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        var c = colors[i];
                        if (i === 0 && c.time <= 0) {
                            target.SetColor$1(property, c.color);
                            continue;
                        }
                        var colorDuration = i === ((len - 1) | 0) ? duration - DG.Tweening.TweenExtensions.Duration(s, false) : duration * (i === 0 ? c.time : c.time - colors[((i - 1) | 0)].time);
                        DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.ShortcutExtensions.DOColor$4(target, c.color.$clone(), property, colorDuration), DG.Tweening.Ease.Linear));
                    }
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, s, target);
                    return s;
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.DOGradientColor$1:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForCompletion:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed or complete.
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForCompletion(true);</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForCompletion: function (t, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForCompletion", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForCompletion(t);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForCompletion:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForRewind:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed or rewinded.
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForRewind();</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForRewind: function (t, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForRewind", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForRewind(t);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForRewind:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForKill:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed.
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForKill();</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForKill: function (t, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForKill", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForKill(t);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForKill:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForElapsedLoops:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed or has gone through the given amount of loops.
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForElapsedLoops(2);</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {number}                                elapsedLoops                    Elapsed loops to wait for
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForElapsedLoops: function (t, elapsedLoops, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForElapsedLoops", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops(t, elapsedLoops);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForElapsedLoops:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForPosition:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed
                 or has reached the given time position (loops included, delays excluded).
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForPosition(2.5f);</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {number}                                position                        Position (loops included, delays excluded) to wait for
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForPosition: function (t, position, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForPosition", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForPosition(t, position);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForPosition:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForStart:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed or started
                 (meaning when the tween is set in a playing state the first time, after any eventual delay).
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForStart();</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForStart: function (t, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForStart", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForStart(t);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForStart:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.DOOffset:static start.*/
                /**
                 * Tweens a Material's named texture offset property with the given ID to the given value.
                 Also stores the material as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {UnityEngine.Material}              target        
                 * @param   {UnityEngine.Vector2}               endValue      The end value to reach
                 * @param   {number}                            propertyID    The ID of the material property to tween (also called nameID in Unity's manual)
                 * @param   {number}                            duration      The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOOffset: function (target, endValue, propertyID, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#DOOffset", this ); }

                    if (!target.HasProperty(propertyID)) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogMissingMaterialProperty(propertyID);
                        }
                        return null;
                    }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.GetTextureOffset(propertyID);
                    }, function (x) {
                        target.SetTextureOffset(propertyID, x);
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.DOOffset:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.DOTiling:static start.*/
                /**
                 * Tweens a Material's named texture scale property with the given ID to the given value.
                 Also stores the material as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {UnityEngine.Material}              target        
                 * @param   {UnityEngine.Vector2}               endValue      The end value to reach
                 * @param   {number}                            propertyID    The ID of the material property to tween (also called nameID in Unity's manual)
                 * @param   {number}                            duration      The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOTiling: function (target, endValue, propertyID, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#DOTiling", this ); }

                    if (!target.HasProperty(propertyID)) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogMissingMaterialProperty(propertyID);
                        }
                        return null;
                    }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.GetTextureScale(propertyID);
                    }, function (x) {
                        target.SetTextureScale(propertyID, x);
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.DOTiling:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleUnityVersion end.*/

    /*DG.Tweening.DOTweenModuleUtils start.*/
    /**
     * Utility functions that deal with available Modules.
     Modules defines:
     - DOTAUDIO
     - DOTPHYSICS
     - DOTPHYSICS2D
     - DOTSPRITE
     - DOTUI
     Extra defines set and used for implementation of external assets:
     - DOTWEEN_TMP ► TextMesh Pro
     - DOTWEEN_TK2D ► 2D Toolkit
     *
     * @static
     * @abstract
     * @public
     * @class DG.Tweening.DOTweenModuleUtils
     */
    Bridge.define("DG.Tweening.DOTweenModuleUtils", {
        statics: {
            fields: {
                _initialized: false
            },
            methods: {
                /*DG.Tweening.DOTweenModuleUtils.Init:static start.*/
                /**
                 * Called via Reflection by DOTweenComponent on Awake
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUtils
                 * @memberof DG.Tweening.DOTweenModuleUtils
                 * @return  {void}
                 */
                Init: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils#Init", this ); }

                    if (DG.Tweening.DOTweenModuleUtils._initialized) {
                        return;
                    }

                    DG.Tweening.DOTweenModuleUtils._initialized = true;
                    DG.Tweening.Core.DOTweenExternalCommand.addSetOrientationOnPath(DG.Tweening.DOTweenModuleUtils.Physics.SetOrientationOnPath);

                },
                /*DG.Tweening.DOTweenModuleUtils.Init:static end.*/

                /*DG.Tweening.DOTweenModuleUtils.Preserver:static start.*/
                Preserver: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils#Preserver", this ); }

                    var loadedAssemblies = System.AppDomain.getAssemblies();
                    var mi = Bridge.Reflection.getMembers(UnityEngine.MonoBehaviour, 8, 284, "Stub");
                },
                /*DG.Tweening.DOTweenModuleUtils.Preserver:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleUtils end.*/

    /*DG.Tweening.DOTweenModuleUtils+Physics start.*/
    Bridge.define("DG.Tweening.DOTweenModuleUtils.Physics", {
        $kind: 1002,
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleUtils+Physics.SetOrientationOnPath:static start.*/
                SetOrientationOnPath: function (options, t, newRot, trans) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils.Physics#SetOrientationOnPath", this ); }

                    if (options.isRigidbody) {
                        Bridge.cast(t.target, UnityEngine.Rigidbody).rotation = newRot.$clone();
                    } else {
                        trans.rotation = newRot.$clone();
                    }
                },
                /*DG.Tweening.DOTweenModuleUtils+Physics.SetOrientationOnPath:static end.*/

                /*DG.Tweening.DOTweenModuleUtils+Physics.HasRigidbody2D:static start.*/
                HasRigidbody2D: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils.Physics#HasRigidbody2D", this ); }

                    return UnityEngine.Component.op_Inequality(target.GetComponent(UnityEngine.Rigidbody2D), null);
                },
                /*DG.Tweening.DOTweenModuleUtils+Physics.HasRigidbody2D:static end.*/

                /*DG.Tweening.DOTweenModuleUtils+Physics.HasRigidbody:static start.*/
                HasRigidbody: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils.Physics#HasRigidbody", this ); }

                    return UnityEngine.Component.op_Inequality(target.GetComponent(UnityEngine.Rigidbody), null);
                },
                /*DG.Tweening.DOTweenModuleUtils+Physics.HasRigidbody:static end.*/

                /*DG.Tweening.DOTweenModuleUtils+Physics.CreateDOTweenPathTween:static start.*/
                CreateDOTweenPathTween: function (target, tweenRigidbody, isLocal, path, duration, pathMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils.Physics#CreateDOTweenPathTween", this ); }

                    var t = null;
                    var rBodyFoundAndTweened = false;
                    if (tweenRigidbody) {
                        var rBody = target.GetComponent(UnityEngine.Rigidbody);
                        if (UnityEngine.Component.op_Inequality(rBody, null)) {
                            rBodyFoundAndTweened = true;
                            t = isLocal ? DG.Tweening.DOTweenModulePhysics.DOLocalPath$1(rBody, path, duration, pathMode) : DG.Tweening.DOTweenModulePhysics.DOPath$1(rBody, path, duration, pathMode);
                        }
                    }
                    if (!rBodyFoundAndTweened && tweenRigidbody) {
                        var rBody2D = target.GetComponent(UnityEngine.Rigidbody2D);
                        if (UnityEngine.Component.op_Inequality(rBody2D, null)) {
                            rBodyFoundAndTweened = true;
                            t = isLocal ? DG.Tweening.DOTweenModulePhysics2D.DOLocalPath$1(rBody2D, path, duration, pathMode) : DG.Tweening.DOTweenModulePhysics2D.DOPath$1(rBody2D, path, duration, pathMode);
                        }
                    }
                    if (!rBodyFoundAndTweened) {
                        t = isLocal ? DG.Tweening.ShortcutExtensions.DOLocalPath(target.transform, path, duration, pathMode) : DG.Tweening.ShortcutExtensions.DOPath(target.transform, path, duration, pathMode);
                    }
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUtils+Physics.CreateDOTweenPathTween:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleUtils+Physics end.*/

    /*GameplayVariables start.*/
    Bridge.define("GameplayVariables", {
        statics: {
            fields: {
                bestLevel: null,
                music: null,
                sound: null,
                vibrate: null,
                retendDay: null,
                dayPlayed: null,
                amountInter: null,
                coin: null,
                rate: null,
                hasAds: null,
                skinUsing: null,
                skinOwned: null,
                dailyLogin: null,
                lastTimeOpen: null,
                totalSpend: null,
                totalEarn: null,
                skinReward: null,
                winLevel: null,
                amountScrewdrive: null,
                amountBomb: null,
                tutUseScrewdrive: null,
                tutUseBomb: null,
                levelShowRemoveAds: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "GameplayVariables#init", this ); }

                    this.bestLevel = "bestLevel";
                    this.music = "music";
                    this.sound = "sound";
                    this.vibrate = "vibrate";
                    this.retendDay = "retendDay";
                    this.dayPlayed = "dayPlayed";
                    this.amountInter = "amountInter";
                    this.coin = "coin";
                    this.rate = "rate";
                    this.hasAds = "hasAds";
                    this.skinUsing = "skinUsing";
                    this.skinOwned = "skinOwned";
                    this.dailyLogin = "dailyLogin";
                    this.lastTimeOpen = "lastTimeOpen";
                    this.totalSpend = "totalSpend";
                    this.totalEarn = "totalEarn";
                    this.skinReward = "skinReward";
                    this.winLevel = "winLevel";
                    this.amountScrewdrive = "amountScrewdrive";
                    this.amountBomb = "amountBomb";
                    this.tutUseScrewdrive = "tutUseScrewdrive";
                    this.tutUseBomb = "tutUseBomb";
                    this.levelShowRemoveAds = "levelShowRemoveAds";
                }
            }
        }
    });
    /*GameplayVariables end.*/

    /*Hint start.*/
    Bridge.define("Hint", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            targetObject: null,
            hasClicked: false,
            tutorial: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Hint#init", this ); }

                this.hasClicked = false;
            }
        },
        methods: {
            /*Hint.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Hint#Start", this ); }

                // Bắt đầu coroutine khi scene bắt đầu
                this.StartCoroutine$1(this.ActivateDeactivateObject());
            },
            /*Hint.Start end.*/

            /*Hint.ActivateDeactivateObject start.*/
            ActivateDeactivateObject: function () {
if ( TRACE ) { TRACE( "Hint#ActivateDeactivateObject", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    if ( true ) {
                                            $step = 1;
                                            continue;
                                        } 
                                        $step = 10;
                                        continue;
                                }
                                case 1: {
                                    // Kiểm tra xem người dùng đã nhấn chuột chưa
                                        if (!this.hasClicked) {
                                            $step = 2;
                                            continue;
                                        } else  {
                                            $step = 7;
                                            continue;
                                        }
                                }
                                case 2: {
                                    // Vô hiệu hóa đối tượng
                                        this.targetObject.SetActive(false);
                                        //tutorial.SetActive(false);

                                        // Chờ 5 giây
                                        $enumerator.current = new UnityEngine.WaitForSeconds(5.0);
                                        $step = 3;
                                        return true;
                                }
                                case 3: {
                                    // Kiểm tra lại xem người chơi đã nhấn chuột chưa
                                        if (!this.hasClicked) {
                                            $step = 4;
                                            continue;
                                        } 
                                        $step = 6;
                                        continue;
                                }
                                case 4: {
                                    // Kích hoạt đối tượng
                                        this.targetObject.SetActive(true);
                                        this.tutorial.SetActive(false);
                                        //tutorialLandscape.SetActive(false);

                                        // Chờ 2 giây trước khi bắt đầu lại
                                        $enumerator.current = new UnityEngine.WaitForSeconds(2.0);
                                        $step = 5;
                                        return true;
                                }
                                case 5: {
                                    //tutorial.SetActive(true);
                                    $step = 6;
                                    continue;
                                }
                                case 6: {
                                    $step = 9;
                                    continue;
                                }
                                case 7: {
                                    // Nếu người chơi đã nhấn chuột, đặt lại biến hasClicked và chờ kiểm tra lại
                                        this.hasClicked = false;
                                        $enumerator.current = new UnityEngine.WaitForSeconds(0.1);
                                        $step = 8;
                                        return true;
                                }
                                case 8: {
                                    $step = 9;
                                    continue;
                                }
                                case 9: {
                                    
                                        $step = 0;
                                        continue;
                                }
                                case 10: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*Hint.ActivateDeactivateObject end.*/

            /*Hint.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Hint#Update", this ); }

                // Kiểm tra xem người chơi đã nhấn chuột trái hay không
                if (UnityEngine.Input.GetMouseButtonDown(0)) {
                    // Đặt biến hasClicked thành true khi người chơi nhấn chuột
                    this.hasClicked = true;
                }
            },
            /*Hint.Update end.*/


        }
    });
    /*Hint end.*/

    /*IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty start.*/
    Bridge.define("IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty", {
        inherits: [UnityEngine.MonoBehaviour]
    });
    /*IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty end.*/

    /*IngameTutorial start.*/
    Bridge.define("IngameTutorial", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                Instance: null
            }
        },
        fields: {
            tutorialRect: null
        },
        methods: {
            /*IngameTutorial.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "IngameTutorial#Awake", this ); }

                // If there is an instance, and it's not me, delete myself.

                if (UnityEngine.MonoBehaviour.op_Inequality(IngameTutorial.Instance, null) && UnityEngine.MonoBehaviour.op_Inequality(IngameTutorial.Instance, this)) {
                    UnityEngine.Object.Destroy(this);
                } else {
                    IngameTutorial.Instance = this;
                }
            },
            /*IngameTutorial.Awake end.*/

            /*IngameTutorial.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "IngameTutorial#Start", this ); }


            },
            /*IngameTutorial.Start end.*/

            /*IngameTutorial.SetTutorial start.*/
            SetTutorial: function (active, anchorPos) {
if ( TRACE ) { TRACE( "IngameTutorial#SetTutorial", this ); }

                this.tutorialRect.gameObject.SetActive(active);
                if (active) {
                    this.tutorialRect.anchoredPosition = UnityEngine.Vector2.FromVector3(anchorPos.$clone());
                }
            },
            /*IngameTutorial.SetTutorial end.*/

            /*IngameTutorial.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "IngameTutorial#Update", this ); }


            },
            /*IngameTutorial.Update end.*/


        }
    });
    /*IngameTutorial end.*/

    /*Key start.*/
    Bridge.define("Key", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            bolt: null,
            boardHole: null,
            getItem: null,
            actived: false
        },
        methods: {
            /*Key.Active start.*/
            Active: function () {
if ( TRACE ) { TRACE( "Key#Active", this ); }

                if (!this.actived) {
                    this.actived = true;
                    //SoundManager.instance.PlaySound("GetItem");
                    this.getItem.Play();
                    if (UnityEngine.MonoBehaviour.op_Inequality(this.bolt, null)) {
                        DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOMove(this.transform, this.bolt.transform.position.$clone(), 0.5), DG.Tweening.Ease.Linear), Bridge.fn.bind(this, function () {
                            this.bolt.Unlock();
                            ObjectPoolExtensions.Recycle(this.gameObject);
                        }));
                    } else {
                        DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOMove(this.transform, this.boardHole.transform.position.$clone(), 0.5), DG.Tweening.Ease.Linear), Bridge.fn.bind(this, function () {
                            this.boardHole.Unlock();
                            ObjectPoolExtensions.Recycle(this.gameObject);
                        }));
                    }
                }
            },
            /*Key.Active end.*/


        }
    });
    /*Key end.*/

    /*LevelController start.*/
    Bridge.define("LevelController", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                Instance: null
            }
        },
        fields: {
            currentHoleRw: null,
            numScrewOnBar: 0,
            fullSlot: false,
            timer: 0,
            timeLim: 0,
            reset: null,
            currentBolt: null,
            target: 0,
            select: null,
            place: null,
            confetti: null,
            amountBarScrewed: 0,
            gameOn: false,
            boardHoles: null,
            bolts: null,
            bars: null,
            isUsingItem: false,
            won: false,
            idItem: 0,
            count: 0,
            countToOpenStore: 0,
            store: null,
            isLv2: false,
            firstTouch: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "LevelController#init", this ); }

                this.fullSlot = false;
                this.timer = 0;
                this.timeLim = 5;
                this.gameOn = true;
                this.won = false;
                this.count = 0;
                this.countToOpenStore = 0;
                this.isLv2 = false;
                this.firstTouch = false;
            }
        },
        methods: {
            /*LevelController.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "LevelController#Awake", this ); }

                // If there is an instance, and it's not me, delete myself.

                if (UnityEngine.MonoBehaviour.op_Inequality(LevelController.Instance, null) && UnityEngine.MonoBehaviour.op_Inequality(LevelController.Instance, this)) {
                    UnityEngine.Object.Destroy(this);
                } else {
                    LevelController.Instance = this;
                }
            },
            /*LevelController.Awake end.*/

            /*LevelController.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "LevelController#Start", this ); }

                this.bars = this.GetComponentsInChildren(Bar);
                this.bolts = this.GetComponentsInChildren(Bolt);
                this.boardHoles = this.GetComponentsInChildren(BoardHole);
                this.target = this.bars.length;
                this.amountBarScrewed = 0;
            },
            /*LevelController.Start end.*/

            /*LevelController.ScrewBar start.*/
            ScrewBar: function () {
if ( TRACE ) { TRACE( "LevelController#ScrewBar", this ); }

                this.amountBarScrewed = (this.amountBarScrewed + 1) | 0;
                if (this.amountBarScrewed === this.target) {
                    this.confetti.Play();
                    var vfx = Singleton$1(GameManager).Instance.InstantiatePrefab("VFX/VFX_Confetti");
                    /* vfx.transform.position = Vector3.zero;*/
                    Singleton$1(GameManager).Instance.EndGame(true);
                    this.won = true;
                }
            },
            /*LevelController.ScrewBar end.*/

            /*LevelController.CheckOutMove start.*/
            CheckOutMove: function () {
if ( TRACE ) { TRACE( "LevelController#CheckOutMove", this ); }

                for (var i = 0; i < this.boardHoles.length; i = (i + 1) | 0) {
                    if (!this.boardHoles[i].isReward) {
                        var collider2D = UnityEngine.Physics2D.OverlapCircle$2(UnityEngine.Vector2.FromVector3(this.boardHoles[i].transform.position), 0.01, UnityEngine.LayerMask.op_Implicit(Singleton$1(GameManager).Instance.layerBolt.$clone()));
                        if (UnityEngine.Component.op_Equality(collider2D, null)) {
                            var tempBars = UnityEngine.Physics2D.OverlapCircleAll(UnityEngine.Vector2.FromVector3(this.boardHoles[i].transform.position), GameManager.RADIUS_CHECK_BAR, UnityEngine.LayerMask.op_Implicit(Singleton$1(GameManager).Instance.layerBar.$clone()));
                            var tempBarHoles = UnityEngine.Physics2D.OverlapCircleAll(UnityEngine.Vector2.FromVector3(this.boardHoles[i].transform.position), 0.01, UnityEngine.LayerMask.op_Implicit(Singleton$1(GameManager).Instance.layerBarHole.$clone()));

                            if (tempBars.length <= tempBarHoles.length) {
                                var count = 0;
                                for (var k = 0; k < tempBarHoles.length; k = (k + 1) | 0) {
                                    if (pc.Vec3.distance( this.boardHoles[i].transform.position, tempBarHoles[k].transform.position ) <= 0.0600000024) {
                                        var barHole = tempBarHoles[k].GetComponent(BarHole);
                                        var tempCount = 0;
                                        for (var j = 0; j < tempBars.length; j = (j + 1) | 0) {
                                            if (barHole.Match(tempBars[j].GetComponent(Bar))) {
                                                break;
                                            } else {
                                                tempCount = (tempCount + 1) | 0;
                                            }
                                        }

                                        if (tempCount === tempBars.length) {
                                            count = (count + 1) | 0;
                                            break;
                                        }
                                    } else {
                                        count = (count + 1) | 0;
                                        break;
                                    }
                                }

                                if (count === 0) {
                                    return;
                                }
                            }
                        }
                    }
                }
                Luna.Unity.LifeCycle.GameEnded();
                Luna.Unity.Playable.InstallFullGame();
                Luna.Unity.Analytics.LogEvent$1("Store", 0);
                this.store.SetActive(true);
                //UIManager.Instance.ingameMenu.ShowCaution();
            },
            /*LevelController.CheckOutMove end.*/

            /*LevelController.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "LevelController#Update", this ); }

                var $t, $t1;
                if (this.isLv2 && this.numScrewOnBar === 1) {
                    this.store.SetActive(true);
                    Singleton$1(GameManager).Instance.canControl = false;
                }
                if (Singleton$1(GameManager).Instance.canControl) {
                    if (UnityEngine.Input.GetMouseButtonDown(0) && this.firstTouch === false) {
                        this.firstTouch = true;
                    }
                    if (UnityEngine.Input.GetMouseButtonDown(0)) {
                        var worldPos = UnityEngine.Vector2.FromVector3(UnityEngine.Camera.main.ScreenToWorldPoint(UnityEngine.Input.mousePosition));

                        var vfxClick = Singleton$1(GameManager).Instance.InstantiatePrefab("VFX/VFX_Click");
                        vfxClick.transform.position = new pc.Vec3( worldPos.x, worldPos.y, -5 );

                        var collider2D = UnityEngine.Physics2D.OverlapCircle$2(worldPos, 0.5, UnityEngine.LayerMask.op_Implicit(Singleton$1(GameManager).Instance.layerBoardHole.$clone()));
                        if (UnityEngine.Component.op_Inequality(collider2D, null)) {
                            var boardHole = collider2D.GetComponent(BoardHole);
                            var temp = UnityEngine.Physics2D.OverlapCircle$2(UnityEngine.Vector2.FromVector3(collider2D.transform.position), 0.35, UnityEngine.LayerMask.op_Implicit(Singleton$1(GameManager).Instance.layerBar.$clone()));
                            if (UnityEngine.Component.op_Equality(temp, null)) {
                                this.fullSlot = false;
                                if (!boardHole.isReward) {
                                    var temp2 = UnityEngine.Physics2D.OverlapCircle$2(UnityEngine.Vector2.FromVector3(collider2D.transform.position), 0.35, UnityEngine.LayerMask.op_Implicit(Singleton$1(GameManager).Instance.layerBarHole.$clone()));
                                    if (UnityEngine.Component.op_Equality(temp2, null)) {
                                        this.fullSlot = false;
                                    } else {
                                        this.fullSlot = true;
                                    }
                                }
                            } else {
                                this.fullSlot = true;
                            }
                        }

                        if (!this.isUsingItem) {
                            collider2D = UnityEngine.Physics2D.OverlapCircle$2(worldPos, 0.5, UnityEngine.LayerMask.op_Implicit(Singleton$1(GameManager).Instance.layerBolt.$clone()));
                            if (UnityEngine.Component.op_Inequality(collider2D, null)) {
                                var bolt = collider2D.GetComponent(Bolt);
                                this.select.Play();
                                if (UnityEngine.MonoBehaviour.op_Equality(this.currentBolt, null)) {
                                    this.currentBolt = bolt;
                                    this.currentBolt.Screw();
                                } else {
                                    if (UnityEngine.MonoBehaviour.op_Equality(this.currentBolt, bolt)) {
                                        if (this.currentBolt.isScrewed) {
                                            bolt.UnScrew();
                                        } else {
                                            bolt.Screw();
                                        }
                                    } else {
                                        this.currentBolt.UnScrew();
                                        this.currentBolt = bolt;
                                        this.currentBolt.Screw();
                                    }
                                }

                                if (UnityEngine.MonoBehaviour.op_Inequality(this.currentBolt, null) && this.currentBolt.isFallingScrew) {
                                    this.UpdateState();
                                    this.place.Play();
                                    var temps = UnityEngine.Physics2D.OverlapCircleAll(UnityEngine.Vector2.FromVector3(this.currentBolt.transform.position), GameManager.RADIUS_CHECK_BAR, UnityEngine.LayerMask.op_Implicit(Singleton$1(GameManager).Instance.layerBar.$clone()));
                                    for (var i = 0; i < temps.length; i = (i + 1) | 0) {
                                        //Debug.Log(temps[i]);
                                        temps[i].GetComponent(Bar).RemoveBolt(this.currentBolt);
                                    }
                                    this.countToOpenStore = (this.countToOpenStore + 1) | 0;
                                    if (this.countToOpenStore === 12) {
                                        Luna.Unity.LifeCycle.GameEnded();
                                        Luna.Unity.Playable.InstallFullGame();
                                        Luna.Unity.Analytics.LogEvent$1("Store", 0);
                                        this.store.SetActive(true);
                                    }
                                    this.currentBolt.MoveTo(null);
                                    this.currentBolt = null;

                                    return;
                                }
                            } else {
                                var colliderBolts = UnityEngine.Physics2D.OverlapCircleAll(worldPos, 0.5, UnityEngine.LayerMask.op_Implicit(Singleton$1(GameManager).Instance.layerBolt.$clone()));
                                var colliderBoardHoles = UnityEngine.Physics2D.OverlapCircleAll(worldPos, 0.5, UnityEngine.LayerMask.op_Implicit(Singleton$1(GameManager).Instance.layerBoardHole.$clone()));

                                var minDist = 3.40282347E+38;
                                var stateCollider = 0;
                                for (var i1 = 0; i1 < colliderBolts.length; i1 = (i1 + 1) | 0) {
                                    var dist = pc.Vec3.distance( colliderBolts[i1].transform.position, UnityEngine.Vector3.FromVector2(worldPos) );
                                    if (dist < minDist) {
                                        minDist = dist;
                                        collider2D = colliderBolts[i1];
                                        stateCollider = 1;
                                    }
                                }

                                for (var i2 = 0; i2 < colliderBoardHoles.length; i2 = (i2 + 1) | 0) {
                                    var dist1 = pc.Vec3.distance( colliderBoardHoles[i2].transform.position, UnityEngine.Vector3.FromVector2(worldPos) );
                                    if (dist1 < minDist) {
                                        minDist = dist1;
                                        collider2D = colliderBoardHoles[i2];
                                        stateCollider = 2;
                                    }
                                }

                                /* if (stateCollider == 1)
                                {
                                   Bolt bolt = collider2D.GetComponent<Bolt>();
                                   if (bolt == currentBolt)
                                   {
                                       currentBolt.UnScrew();
                                       currentBolt = null;
                                   }

                                   else if (!bolt.locked && bolt != currentBolt)
                                   {
                                       select.Play();
                                       currentBolt.UnScrew();
                                       currentBolt = bolt;
                                       currentBolt.Screw();
                                       Debug.LogError(select);
                                   }
                                   return;
                                }*/

                                if (stateCollider === 2) {
                                    if (this.count === 12) {
                                        Luna.Unity.LifeCycle.GameEnded();
                                        Luna.Unity.Playable.InstallFullGame();
                                        Luna.Unity.Analytics.LogEvent$1("Store", 0);
                                        this.store.SetActive(true);
                                    }
                                    var boardHole1 = collider2D.GetComponent(BoardHole);
                                    var tempBars = UnityEngine.Physics2D.OverlapCircleAll(UnityEngine.Vector2.FromVector3(collider2D.transform.position), GameManager.RADIUS_CHECK_BAR, UnityEngine.LayerMask.op_Implicit(Singleton$1(GameManager).Instance.layerBar.$clone()));

                                    if (tempBars.length === 0) {
                                        if (!boardHole1.isReward && !boardHole1.locked) {
                                            this.UpdateState();
                                            this.place.Play();
                                            var temps1 = UnityEngine.Physics2D.OverlapCircleAll(UnityEngine.Vector2.FromVector3(this.currentBolt.transform.position), GameManager.RADIUS_CHECK_BAR, UnityEngine.LayerMask.op_Implicit(Singleton$1(GameManager).Instance.layerBar.$clone()));
                                            for (var i3 = 0; i3 < temps1.length; i3 = (i3 + 1) | 0) {
                                                //Debug.Log(temps[i]);
                                                temps1[i3].GetComponent(Bar).RemoveBolt(this.currentBolt);
                                            }

                                            temps1 = UnityEngine.Physics2D.OverlapCircleAll(UnityEngine.Vector2.FromVector3(boardHole1.transform.position), GameManager.RADIUS_CHECK_BAR, UnityEngine.LayerMask.op_Implicit(Singleton$1(GameManager).Instance.layerBar.$clone()));
                                            for (var i4 = 0; i4 < temps1.length; i4 = (i4 + 1) | 0) {
                                                temps1[i4].GetComponent(Bar).AddBolt(this.currentBolt, boardHole1.transform.position);
                                            }
                                            this.currentBolt.MoveTo(boardHole1);
                                            this.currentBolt = null;
                                        }
                                        return;
                                    } else {
                                        var count = 0;
                                        var tempBarHoles = UnityEngine.Physics2D.OverlapCircleAll(UnityEngine.Vector2.FromVector3(collider2D.transform.position), 0.01, UnityEngine.LayerMask.op_Implicit(Singleton$1(GameManager).Instance.layerBarHole.$clone()));
                                        if (tempBars.length <= tempBarHoles.length) {
                                            for (var i5 = 0; i5 < tempBarHoles.length; i5 = (i5 + 1) | 0) {
                                                if (pc.Vec3.distance( collider2D.transform.position, tempBarHoles[i5].transform.position ) <= 0.0600000024) {
                                                    var barHole = tempBarHoles[i5].GetComponent(BarHole);
                                                    var tempCount = 0;
                                                    for (var j = 0; j < tempBars.length; j = (j + 1) | 0) {
                                                        if (barHole.Match(tempBars[j].GetComponent(Bar))) {
                                                            break;
                                                        } else {
                                                            tempCount = (tempCount + 1) | 0;
                                                        }
                                                    }

                                                    if (tempCount === tempBars.length) {
                                                        count = (count + 1) | 0;
                                                        break;
                                                    }
                                                } else {
                                                    count = (count + 1) | 0;
                                                    break;
                                                }
                                            }

                                            if (count === 0) {
                                                this.UpdateState();
                                                this.place.Play();

                                                var temps2 = UnityEngine.Physics2D.OverlapCircleAll(UnityEngine.Vector2.FromVector3(this.currentBolt.transform.position), GameManager.RADIUS_CHECK_BAR, UnityEngine.LayerMask.op_Implicit(Singleton$1(GameManager).Instance.layerBar.$clone()));
                                                for (var i6 = 0; i6 < temps2.length; i6 = (i6 + 1) | 0) {
                                                    //Debug.Log(temps[i].gameObject.name + " va " + temps[i].transform.parent.gameObject);
                                                    //Debug.Log(temps[i].GetComponent<Bar>());
                                                    temps2[i6].GetComponent(Bar).RemoveBolt(this.currentBolt);
                                                }

                                                temps2 = UnityEngine.Physics2D.OverlapCircleAll(UnityEngine.Vector2.FromVector3(boardHole1.transform.position), GameManager.RADIUS_CHECK_BAR, UnityEngine.LayerMask.op_Implicit(Singleton$1(GameManager).Instance.layerBar.$clone()));
                                                for (var i7 = 0; i7 < temps2.length; i7 = (i7 + 1) | 0) {
                                                    temps2[i7].GetComponent(Bar).AddBolt(this.currentBolt, boardHole1.transform.position);
                                                }
                                                this.currentBolt.MoveTo(boardHole1);

                                                this.currentBolt = null;
                                                return;
                                            }
                                        }
                                    }
                                }
                                // currentBolt.UnScrew();
                                // currentBolt = null;
                            }
                        } else {
                            collider2D = null;
                            switch (this.idItem) {
                                case 0: 
                                    // Screwdrive
                                    collider2D = UnityEngine.Physics2D.OverlapCircle$2(worldPos, 0.5, UnityEngine.LayerMask.op_Implicit(Singleton$1(GameManager).Instance.layerBolt.$clone()));
                                    if (UnityEngine.Component.op_Inequality(collider2D, null)) {
                                        this.UpdateState();

                                        collider2D.GetComponent(Bolt).Explosion();
                                        //SoundManager.instance.PlaySound("BoltExplosion");
                                        var obj = Singleton$1(GameManager).Instance.InstantiatePrefab("VFX/VFX_BoltExplosion");
                                        obj.transform.position = UnityEngine.Vector3.FromVector2(worldPos.$clone());
                                        if (UserConfig.Instance.AmountScrewdrive > 0) {
                                            ($t = UserConfig.Instance).AmountScrewdrive = ($t.AmountScrewdrive - 1) | 0;
                                        }
                                    } else {
                                        if (UserConfig.Instance.AmountScrewdrive === 0) {
                                            ($t1 = UserConfig.Instance).AmountScrewdrive = ($t1.AmountScrewdrive + 1) | 0;

                                        }
                                    }
                                    break;
                            }

                            this.isUsingItem = false;
                        }
                    }
                }

                if (this.isLv2 && this.numScrewOnBar === 1) {
                    this.store.SetActive(true);
                    //Debug.Log("toStore");
                    Singleton$1(GameManager).Instance.canControl = false;
                }
            },
            /*LevelController.Update end.*/

            /*LevelController.UpdateState start.*/
            UpdateState: function () {
if ( TRACE ) { TRACE( "LevelController#UpdateState", this ); }

                var stateBars = System.Array.init(this.bars.length, null, LevelController.StateBar);
                for (var i = 0; i < this.bars.length; i = (i + 1) | 0) {
                    stateBars[i] = new LevelController.StateBar(UnityEngine.Vector2.FromVector3(this.bars[i].transform.localPosition.$clone()), this.bars[i].transform.localEulerAngles.$clone(), this.bars[i].gameObject.activeInHierarchy);
                }

                var stateBolts = System.Array.init(this.bolts.length, null, LevelController.StateBolt);
                for (var i1 = 0; i1 < this.bolts.length; i1 = (i1 + 1) | 0) {
                    stateBolts[i1] = new LevelController.StateBolt(UnityEngine.Vector2.FromVector3(this.bolts[i1].transform.localPosition.$clone()), this.bolts[i1].locked, this.bolts[i1].gameObject.activeInHierarchy);
                }

                var stateBoardHoles = System.Array.init(this.boardHoles.length, null, LevelController.StateBoardHole);
                for (var i2 = 0; i2 < this.boardHoles.length; i2 = (i2 + 1) | 0) {
                    stateBoardHoles[i2] = new LevelController.StateBoardHole(this.boardHoles[i2].locked);
                }

                //stateLevels.Add(new StateLevel(stateBars, stateBolts, stateBoardHoles));
            },
            /*LevelController.UpdateState end.*/

            /*LevelController.RecycleLevel start.*/
            RecycleLevel: function () {
if ( TRACE ) { TRACE( "LevelController#RecycleLevel", this ); }

                ObjectPoolExtensions.Recycle(this.gameObject);
            },
            /*LevelController.RecycleLevel end.*/


        }
    });
    /*LevelController end.*/

    /*LevelController+StateBar start.*/
    Bridge.define("LevelController.StateBar", {
        $kind: 1002,
        fields: {
            pos: null,
            rotate: null,
            actived: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "LevelController.StateBar#init", this ); }

                this.pos = new UnityEngine.Vector2();
                this.rotate = new UnityEngine.Vector3();
            },
            ctor: function (pos, rotate, actived) {
if ( TRACE ) { TRACE( "LevelController.StateBar#ctor", this ); }

                this.$initialize();
                this.pos = pos.$clone();
                this.rotate = rotate.$clone();
                this.actived = actived;
            }
        }
    });
    /*LevelController+StateBar end.*/

    /*LevelController+StateBoardHole start.*/
    Bridge.define("LevelController.StateBoardHole", {
        $kind: 1002,
        fields: {
            isLocked: false
        },
        ctors: {
            ctor: function (isLocked) {
if ( TRACE ) { TRACE( "LevelController.StateBoardHole#ctor", this ); }

                this.$initialize();
                this.isLocked = isLocked;
            }
        }
    });
    /*LevelController+StateBoardHole end.*/

    /*LevelController+StateBolt start.*/
    Bridge.define("LevelController.StateBolt", {
        $kind: 1002,
        fields: {
            pos: null,
            isLocked: false,
            actived: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "LevelController.StateBolt#init", this ); }

                this.pos = new UnityEngine.Vector2();
            },
            ctor: function (pos, isLocked, actived) {
if ( TRACE ) { TRACE( "LevelController.StateBolt#ctor", this ); }

                this.$initialize();
                this.pos = pos.$clone();
                this.isLocked = isLocked;
                this.actived = actived;
            }
        }
    });
    /*LevelController+StateBolt end.*/

    /*LoadEndcard start.*/
    Bridge.define("LoadEndcard", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                ins: null
            }
        },
        methods: {
            /*LoadEndcard.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "LoadEndcard#Awake", this ); }

                LoadEndcard.ins = this;
            },
            /*LoadEndcard.Awake end.*/

            /*LoadEndcard.loadscene77 start.*/
            loadscene77: function () {
if ( TRACE ) { TRACE( "LoadEndcard#loadscene77", this ); }

                UnityEngine.SceneManagement.SceneManager.LoadScene$2("Lv77");
                Luna.Unity.Analytics.LogEvent$1("Reset level 1", 0);
            },
            /*LoadEndcard.loadscene77 end.*/


        }
    });
    /*LoadEndcard end.*/

    /*LoadingManager start.*/
    Bridge.define("LoadingManager", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            loadingImg: null,
            vfx: null,
            loadingObj: null
        },
        methods: {
            /*LoadingManager.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "LoadingManager#Start", this ); }

                UnityEngine.Debug.unityLogger.UnityEngine$ILogger$logEnabled = false;
                UnityEngine.Application.targetFrameRate = 60;
                UnityEngine.Screen.sleepTimeout = UnityEngine.SleepTimeout.NeverSleep;

                this.loadingObj.SetActive(false);
                this.vfx.SetActive(true);

                // Config Init
                UserConfig.Instance.Init();

                // Ui Loading
                this.LoadData();

                // IAP initialize
                this.RegisterPurchaseComplete();
                /* IAPManager.Instance.Initialize(new ProductDefinition(IAPManager.kRemoveAds, ProductType.NonConsumable));*/
            },
            /*LoadingManager.Start end.*/

            /*LoadingManager.RegisterPurchaseComplete start.*/
            RegisterPurchaseComplete: function () {
if ( TRACE ) { TRACE( "LoadingManager#RegisterPurchaseComplete", this ); }

                /* IAPManager.Instance.OnPurchaseCompleted += (product) =>
                {
                   if (product.definition.id == IAPManager.kRemoveAds)
                   {
                       UserConfig.Instance.HasAds = false;
                       CGTeamBridge.instance.HideBanner();
                       EventManager.EmitEvent(EventVariables.BuyRemoveAds);
                   }
                };*/
            },
            /*LoadingManager.RegisterPurchaseComplete end.*/

            /*LoadingManager.LoadSceneStart start.*/
            LoadSceneStart: function () {
if ( TRACE ) { TRACE( "LoadingManager#LoadSceneStart", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    $enumerator.current = new UnityEngine.WaitForSeconds(6.0);
                                        $step = 1;
                                        return true;
                                }
                                case 1: {
                                    if (UserConfig.Instance.HasTurnOffInternet()) {
                                            this.vfx.SetActive(false);
                                        } else {
                                            this.loadingObj.SetActive(true);
                                            this.vfx.SetActive(false);

                                            /* if (UserConfig.Instance.isNewUser)
                                            {
                                               CGTeamBridge.instance.SetPropertyLevel("1");
                                               CGTeamBridge.instance.SetPropertyAppVersion();
                                            }
                                            /*CGTeamBridge.instance.LogEvent("open_app");#1#

                                            UserConfig.Instance.isNewDay = UserConfig.Instance.CanShowDailyBonus();

                                            RemoteConfig.Instance.LoadLevelData();
                                            StartCoroutine(LoadAsyncGame(1));*/
                                        }

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*LoadingManager.LoadSceneStart end.*/

            /*LoadingManager.LoadData start.*/
            LoadData: function () {
if ( TRACE ) { TRACE( "LoadingManager#LoadData", this ); }

                // Ui Loading
                this.StartCoroutine$1(this.LoadSceneStart());
            },
            /*LoadingManager.LoadData end.*/

            /*LoadingManager.LoadAsyncGame start.*/
            LoadAsyncGame: function (scene) {
if ( TRACE ) { TRACE( "LoadingManager#LoadAsyncGame", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    operation,
                    progress,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    operation = UnityEngine.SceneManagement.SceneManager.LoadSceneAsync(scene);
                                        operation.allowSceneActivation = false;
                                    $step = 1;
                                    continue;
                                }
                                case 1: {
                                    if ( !operation.isDone$1 ) {
                                            $step = 2;
                                            continue;
                                        } 
                                        $step = 4;
                                        continue;
                                }
                                case 2: {
                                    progress = operation.progress;

                                        if (progress === 0.9) {
                                            DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), DG.Tweening.DOTweenModuleUI.DOFillAmount(this.loadingImg, 1.0, 2.0), DG.Tweening.Ease.Linear), Bridge.fn.bind(this, function () {
                                                this.loadingImg.fillAmount = 1.0;
                                                operation.allowSceneActivation = true;
                                            }));
                                        }

                                        $enumerator.current = null;
                                        $step = 3;
                                        return true;
                                }
                                case 3: {
                                    
                                        $step = 1;
                                        continue;
                                }
                                case 4: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*LoadingManager.LoadAsyncGame end.*/

            /*LoadingManager.PressedRetryBtn start.*/
            PressedRetryBtn: function () {
if ( TRACE ) { TRACE( "LoadingManager#PressedRetryBtn", this ); }

                this.vfx.SetActive(true);
                this.LoadData();
            },
            /*LoadingManager.PressedRetryBtn end.*/


        }
    });
    /*LoadingManager end.*/

    /*ObjectPool start.*/
    Bridge.define("ObjectPool", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                _instance: null,
                tempList: null
            },
            props: {
                instance: {
                    get: function () {
if ( TRACE ) { TRACE( "ObjectPool#instance#get", this ); }

                        if (UnityEngine.MonoBehaviour.op_Inequality(ObjectPool._instance, null)) {
                            return ObjectPool._instance;
                        }

                        ObjectPool._instance = UnityEngine.Object.FindObjectOfType(ObjectPool);
                        if (UnityEngine.MonoBehaviour.op_Inequality(ObjectPool._instance, null)) {
                            return ObjectPool._instance;
                        }

                        var obj = new UnityEngine.GameObject.$ctor2("ObjectPool");
                        obj.transform.localPosition = pc.Vec3.ZERO.clone();
                        obj.transform.localRotation = pc.Quat.IDENTITY.clone();
                        obj.transform.localScale = new pc.Vec3( 1, 1, 1 );
                        ObjectPool._instance = obj.AddComponent(ObjectPool);
                        return ObjectPool._instance;
                    }
                }
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "ObjectPool#init", this ); }

                    this.tempList = new (System.Collections.Generic.List$1(UnityEngine.GameObject)).ctor();
                }
            },
            methods: {
                /*ObjectPool.CreateStartupPools:static start.*/
                CreateStartupPools: function () {
if ( TRACE ) { TRACE( "ObjectPool#CreateStartupPools", this ); }

                    if (!ObjectPool.instance.startupPoolsCreated) {
                        ObjectPool.instance.startupPoolsCreated = true;
                        var poolUIs = ObjectPool.instance.startupPools;
                        if (poolUIs != null && poolUIs.length > 0) {
                            for (var i = 0; i < poolUIs.length; i = (i + 1) | 0) {
                                ObjectPool.CreatePool(poolUIs[i].prefab, poolUIs[i].size);
                            }
                        }
                    }
                },
                /*ObjectPool.CreateStartupPools:static end.*/

                /*ObjectPool.CreatePool$1:static start.*/
                CreatePool$1: function (T, prefab, initialPoolSize) {
if ( TRACE ) { TRACE( "ObjectPool#CreatePool$1", this ); }

                    ObjectPool.CreatePool(Bridge.rValue(prefab).gameObject, initialPoolSize);
                },
                /*ObjectPool.CreatePool$1:static end.*/

                /*ObjectPool.CreatePool:static start.*/
                CreatePool: function (prefab, initialPoolSize) {
if ( TRACE ) { TRACE( "ObjectPool#CreatePool", this ); }

                    if (UnityEngine.GameObject.op_Inequality(prefab, null) && !ObjectPool.instance.pooledObjects.containsKey(prefab)) {
                        var list = new (System.Collections.Generic.List$1(UnityEngine.GameObject)).ctor();
                        ObjectPool.instance.pooledObjects.add(prefab, list);

                        if (initialPoolSize > 0) {
                            var active = prefab.activeSelf;
                            prefab.SetActive(false);
                            var parent = ObjectPool.instance.transform;
                            while (list.Count < initialPoolSize) {
                                var obj = UnityEngine.Object.Instantiate(UnityEngine.GameObject, prefab);
                                obj.transform.parent = parent;
                                list.add(obj);
                            }
                            prefab.SetActive(active);
                        }
                    }
                },
                /*ObjectPool.CreatePool:static end.*/

                /*ObjectPool.Spawn$3:static start.*/
                Spawn$3: function (T, prefab, parent, position, rotation) {
if ( TRACE ) { TRACE( "ObjectPool#Spawn$3", this ); }

                    return ObjectPool.Spawn$9(Bridge.rValue(prefab).gameObject, parent, position, rotation).GetComponent(T);
                },
                /*ObjectPool.Spawn$3:static end.*/

                /*ObjectPool.Spawn$5:static start.*/
                Spawn$5: function (T, prefab, position, rotation) {
if ( TRACE ) { TRACE( "ObjectPool#Spawn$5", this ); }

                    return ObjectPool.Spawn$9(Bridge.rValue(prefab).gameObject, null, position, rotation).GetComponent(T);
                },
                /*ObjectPool.Spawn$5:static end.*/

                /*ObjectPool.Spawn$2:static start.*/
                Spawn$2: function (T, prefab, parent, position) {
if ( TRACE ) { TRACE( "ObjectPool#Spawn$2", this ); }

                    return ObjectPool.Spawn$9(Bridge.rValue(prefab).gameObject, parent, position, pc.Quat.IDENTITY.clone()).GetComponent(T);
                },
                /*ObjectPool.Spawn$2:static end.*/

                /*ObjectPool.Spawn$4:static start.*/
                Spawn$4: function (T, prefab, position) {
if ( TRACE ) { TRACE( "ObjectPool#Spawn$4", this ); }

                    return ObjectPool.Spawn$9(Bridge.rValue(prefab).gameObject, null, position, pc.Quat.IDENTITY.clone()).GetComponent(T);
                },
                /*ObjectPool.Spawn$4:static end.*/

                /*ObjectPool.Spawn$1:static start.*/
                Spawn$1: function (T, prefab, parent) {
if ( TRACE ) { TRACE( "ObjectPool#Spawn$1", this ); }

                    return ObjectPool.Spawn$9(Bridge.rValue(prefab).gameObject, parent, pc.Vec3.ZERO.clone(), pc.Quat.IDENTITY.clone()).GetComponent(T);
                },
                /*ObjectPool.Spawn$1:static end.*/

                /*ObjectPool.Spawn:static start.*/
                Spawn: function (T, prefab) {
if ( TRACE ) { TRACE( "ObjectPool#Spawn", this ); }

                    return ObjectPool.Spawn$9(Bridge.rValue(prefab).gameObject, null, pc.Vec3.ZERO.clone(), pc.Quat.IDENTITY.clone()).GetComponent(T);
                },
                /*ObjectPool.Spawn:static end.*/

                /*ObjectPool.Spawn$9:static start.*/
                Spawn$9: function (prefab, parent, position, rotation) {
if ( TRACE ) { TRACE( "ObjectPool#Spawn$9", this ); }

                    var list = { };
                    var trans;
                    var obj;
                    if (ObjectPool.instance.pooledObjects.tryGetValue(prefab, list)) {
                        obj = null;
                        if (list.v.Count > 0) {
                            while (UnityEngine.GameObject.op_Equality(obj, null) && list.v.Count > 0) {
                                obj = list.v.getItem(0);
                                list.v.removeAt(0);
                            }
                            if (UnityEngine.GameObject.op_Inequality(obj, null)) {
                                trans = obj.transform;
                                trans.parent = parent;
                                trans.localPosition = position.$clone();
                                trans.localRotation = rotation.$clone();
                                obj.SetActive(true);
                                ObjectPool.instance.spawnedObjects.add(obj, prefab);
                                return obj;
                            }
                        }
                        obj = UnityEngine.Object.Instantiate(UnityEngine.GameObject, prefab);
                        trans = obj.transform;
                        trans.parent = parent;
                        trans.localPosition = position.$clone();
                        trans.localRotation = rotation.$clone();
                        ObjectPool.instance.spawnedObjects.add(obj, prefab);
                        return obj;
                    } else {
                        obj = UnityEngine.Object.Instantiate(UnityEngine.GameObject, prefab);
                        trans = obj.GetComponent(UnityEngine.Transform);
                        trans.parent = parent;
                        trans.localPosition = position.$clone();
                        trans.localRotation = rotation.$clone();
                        return obj;
                    }
                },
                /*ObjectPool.Spawn$9:static end.*/

                /*ObjectPool.Spawn$8:static start.*/
                Spawn$8: function (prefab, parent, position) {
if ( TRACE ) { TRACE( "ObjectPool#Spawn$8", this ); }

                    return ObjectPool.Spawn$9(prefab, parent, position, pc.Quat.IDENTITY.clone());
                },
                /*ObjectPool.Spawn$8:static end.*/

                /*ObjectPool.Spawn$11:static start.*/
                Spawn$11: function (prefab, position, rotation) {
if ( TRACE ) { TRACE( "ObjectPool#Spawn$11", this ); }

                    return ObjectPool.Spawn$9(prefab, null, position, rotation);
                },
                /*ObjectPool.Spawn$11:static end.*/

                /*ObjectPool.Spawn$7:static start.*/
                Spawn$7: function (prefab, parent) {
if ( TRACE ) { TRACE( "ObjectPool#Spawn$7", this ); }

                    return ObjectPool.Spawn$9(prefab, parent, pc.Vec3.ZERO.clone(), pc.Quat.IDENTITY.clone());
                },
                /*ObjectPool.Spawn$7:static end.*/

                /*ObjectPool.Spawn$10:static start.*/
                Spawn$10: function (prefab, position) {
if ( TRACE ) { TRACE( "ObjectPool#Spawn$10", this ); }

                    return ObjectPool.Spawn$9(prefab, null, position, pc.Quat.IDENTITY.clone());
                },
                /*ObjectPool.Spawn$10:static end.*/

                /*ObjectPool.Spawn$6:static start.*/
                Spawn$6: function (prefab) {
if ( TRACE ) { TRACE( "ObjectPool#Spawn$6", this ); }

                    return ObjectPool.Spawn$9(prefab, null, pc.Vec3.ZERO.clone(), pc.Quat.IDENTITY.clone());
                },
                /*ObjectPool.Spawn$6:static end.*/

                /*ObjectPool.Recycle$1:static start.*/
                Recycle$1: function (T, obj) {
if ( TRACE ) { TRACE( "ObjectPool#Recycle$1", this ); }

                    ObjectPool.Recycle(Bridge.rValue(obj).gameObject);
                },
                /*ObjectPool.Recycle$1:static end.*/

                /*ObjectPool.Recycle:static start.*/
                Recycle: function (obj) {
if ( TRACE ) { TRACE( "ObjectPool#Recycle", this ); }

                    var prefab = { };
                    if (ObjectPool.instance.spawnedObjects.tryGetValue(obj, prefab)) {
                        ObjectPool.Recycle$2(obj, prefab.v);
                    } else {
                        UnityEngine.Object.Destroy(obj);
                    }
                },
                /*ObjectPool.Recycle:static end.*/

                /*ObjectPool.Recycle$2:static start.*/
                Recycle$2: function (obj, prefab) {
if ( TRACE ) { TRACE( "ObjectPool#Recycle$2", this ); }

                    ObjectPool.instance.pooledObjects.getItem(prefab).add(obj);
                    ObjectPool.instance.spawnedObjects.remove(obj);
                    obj.transform.parent = ObjectPool.instance.transform;
                    obj.SetActive(false);
                },
                /*ObjectPool.Recycle$2:static end.*/

                /*ObjectPool.RecycleAll$2:static start.*/
                RecycleAll$2: function (T, prefab) {
if ( TRACE ) { TRACE( "ObjectPool#RecycleAll$2", this ); }

                    ObjectPool.RecycleAll$1(Bridge.rValue(prefab).gameObject);
                },
                /*ObjectPool.RecycleAll$2:static end.*/

                /*ObjectPool.RecycleAll$1:static start.*/
                RecycleAll$1: function (prefab) {
if ( TRACE ) { TRACE( "ObjectPool#RecycleAll$1", this ); }

                    var $t;
                    $t = Bridge.getEnumerator(ObjectPool.instance.spawnedObjects);
                    try {
                        while ($t.moveNext()) {
                            var item = $t.Current;
                            if (UnityEngine.GameObject.op_Equality(item.value, prefab)) {
                                ObjectPool.tempList.add(item.key);
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    for (var i = 0; i < ObjectPool.tempList.Count; i = (i + 1) | 0) {
                        ObjectPool.Recycle(ObjectPool.tempList.getItem(i));
                    }
                    ObjectPool.tempList.clear();
                },
                /*ObjectPool.RecycleAll$1:static end.*/

                /*ObjectPool.RecycleAll:static start.*/
                RecycleAll: function () {
if ( TRACE ) { TRACE( "ObjectPool#RecycleAll", this ); }

                    ObjectPool.tempList.AddRange(ObjectPool.instance.spawnedObjects.Keys);
                    for (var i = 0; i < ObjectPool.tempList.Count; i = (i + 1) | 0) {
                        ObjectPool.Recycle(ObjectPool.tempList.getItem(i));
                    }
                    ObjectPool.tempList.clear();
                },
                /*ObjectPool.RecycleAll:static end.*/

                /*ObjectPool.IsSpawned:static start.*/
                IsSpawned: function (obj) {
if ( TRACE ) { TRACE( "ObjectPool#IsSpawned", this ); }

                    return ObjectPool.instance.spawnedObjects.containsKey(obj);
                },
                /*ObjectPool.IsSpawned:static end.*/

                /*ObjectPool.CountPooled$1:static start.*/
                CountPooled$1: function (T, prefab) {
if ( TRACE ) { TRACE( "ObjectPool#CountPooled$1", this ); }

                    return ObjectPool.CountPooled(Bridge.rValue(prefab).gameObject);
                },
                /*ObjectPool.CountPooled$1:static end.*/

                /*ObjectPool.CountPooled:static start.*/
                CountPooled: function (prefab) {
if ( TRACE ) { TRACE( "ObjectPool#CountPooled", this ); }

                    var list = { };
                    if (ObjectPool.instance.pooledObjects.tryGetValue(prefab, list)) {
                        return list.v.Count;
                    }
                    return 0;
                },
                /*ObjectPool.CountPooled:static end.*/

                /*ObjectPool.CountSpawned$1:static start.*/
                CountSpawned$1: function (T, prefab) {
if ( TRACE ) { TRACE( "ObjectPool#CountSpawned$1", this ); }

                    return ObjectPool.CountSpawned(Bridge.rValue(prefab).gameObject);
                },
                /*ObjectPool.CountSpawned$1:static end.*/

                /*ObjectPool.CountSpawned:static start.*/
                CountSpawned: function (prefab) {
if ( TRACE ) { TRACE( "ObjectPool#CountSpawned", this ); }

                    var $t;
                    var count = 0;
                    $t = Bridge.getEnumerator(ObjectPool.instance.spawnedObjects.Values);
                    try {
                        while ($t.moveNext()) {
                            var instancePrefab = $t.Current;
                            if (UnityEngine.GameObject.op_Equality(prefab, instancePrefab)) {
                                count = (count + 1) | 0;
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    return count;
                },
                /*ObjectPool.CountSpawned:static end.*/

                /*ObjectPool.CountAllPooled:static start.*/
                CountAllPooled: function () {
if ( TRACE ) { TRACE( "ObjectPool#CountAllPooled", this ); }

                    var $t;
                    var count = 0;
                    $t = Bridge.getEnumerator(ObjectPool.instance.pooledObjects.Values);
                    try {
                        while ($t.moveNext()) {
                            var list = $t.Current;
                            count = (count + list.Count) | 0;
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    return count;
                },
                /*ObjectPool.CountAllPooled:static end.*/

                /*ObjectPool.GetPooled$1:static start.*/
                GetPooled$1: function (prefab, list, appendList) {
if ( TRACE ) { TRACE( "ObjectPool#GetPooled$1", this ); }

                    if (list == null) {
                        list = new (System.Collections.Generic.List$1(UnityEngine.GameObject)).ctor();
                    }
                    if (!appendList) {
                        list.clear();
                    }
                    var pooled = { };
                    if (ObjectPool.instance.pooledObjects.tryGetValue(prefab, pooled)) {
                        list.AddRange(pooled.v);
                    }
                    return list;
                },
                /*ObjectPool.GetPooled$1:static end.*/

                /*ObjectPool.GetPooled:static start.*/
                GetPooled: function (T, prefab, list, appendList) {
if ( TRACE ) { TRACE( "ObjectPool#GetPooled", this ); }

                    if (list == null) {
                        list = new (System.Collections.Generic.List$1(T)).ctor();
                    }
                    if (!appendList) {
                        list.clear();
                    }
                    var pooled = { };
                    if (ObjectPool.instance.pooledObjects.tryGetValue(Bridge.rValue(prefab).gameObject, pooled)) {
                        for (var i = 0; i < pooled.v.Count; i = (i + 1) | 0) {
                            list.add(Bridge.rValue(pooled.v.getItem(i).GetComponent(T)));
                        }
                    }
                    return list;
                },
                /*ObjectPool.GetPooled:static end.*/

                /*ObjectPool.GetSpawned$1:static start.*/
                GetSpawned$1: function (prefab, list, appendList) {
if ( TRACE ) { TRACE( "ObjectPool#GetSpawned$1", this ); }

                    var $t;
                    if (list == null) {
                        list = new (System.Collections.Generic.List$1(UnityEngine.GameObject)).ctor();
                    }
                    if (!appendList) {
                        list.clear();
                    }
                    $t = Bridge.getEnumerator(ObjectPool.instance.spawnedObjects);
                    try {
                        while ($t.moveNext()) {
                            var item = $t.Current;
                            if (UnityEngine.GameObject.op_Equality(item.value, prefab)) {
                                list.add(item.key);
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    return list;
                },
                /*ObjectPool.GetSpawned$1:static end.*/

                /*ObjectPool.GetSpawned:static start.*/
                GetSpawned: function (T, prefab, list, appendList) {
if ( TRACE ) { TRACE( "ObjectPool#GetSpawned", this ); }

                    var $t;
                    if (list == null) {
                        list = new (System.Collections.Generic.List$1(T)).ctor();
                    }
                    if (!appendList) {
                        list.clear();
                    }
                    var prefabObj = Bridge.rValue(prefab).gameObject;
                    $t = Bridge.getEnumerator(ObjectPool.instance.spawnedObjects);
                    try {
                        while ($t.moveNext()) {
                            var item = $t.Current;
                            if (UnityEngine.GameObject.op_Equality(item.value, prefabObj)) {
                                list.add(Bridge.rValue(item.key.GetComponent(T)));
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    return list;
                },
                /*ObjectPool.GetSpawned:static end.*/

                /*ObjectPool.DestroyPooled:static start.*/
                DestroyPooled: function (prefab) {
if ( TRACE ) { TRACE( "ObjectPool#DestroyPooled", this ); }

                    var pooled = { };
                    if (ObjectPool.instance.pooledObjects.tryGetValue(prefab, pooled)) {
                        for (var i = 0; i < pooled.v.Count; i = (i + 1) | 0) {
                            UnityEngine.Object.Destroy(pooled.v.getItem(i));
                        }
                        pooled.v.clear();
                    }
                },
                /*ObjectPool.DestroyPooled:static end.*/

                /*ObjectPool.DestroyPooled$1:static start.*/
                DestroyPooled$1: function (T, prefab) {
if ( TRACE ) { TRACE( "ObjectPool#DestroyPooled$1", this ); }

                    ObjectPool.DestroyPooled(Bridge.rValue(prefab).gameObject);
                },
                /*ObjectPool.DestroyPooled$1:static end.*/

                /*ObjectPool.DestroyAll:static start.*/
                DestroyAll: function (prefab) {
if ( TRACE ) { TRACE( "ObjectPool#DestroyAll", this ); }

                    ObjectPool.RecycleAll$1(prefab);
                    ObjectPool.DestroyPooled(prefab);
                },
                /*ObjectPool.DestroyAll:static end.*/

                /*ObjectPool.DestroyAll$1:static start.*/
                DestroyAll$1: function (T, prefab) {
if ( TRACE ) { TRACE( "ObjectPool#DestroyAll$1", this ); }

                    ObjectPool.DestroyAll(Bridge.rValue(prefab).gameObject);
                },
                /*ObjectPool.DestroyAll$1:static end.*/


            }
        },
        fields: {
            pooledObjects: null,
            spawnedObjects: null,
            startupPoolMode: 0,
            startupPools: null,
            startupPoolsCreated: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "ObjectPool#init", this ); }

                this.pooledObjects = new (System.Collections.Generic.Dictionary$2(UnityEngine.GameObject,System.Collections.Generic.List$1(UnityEngine.GameObject))).ctor();
                this.spawnedObjects = new (System.Collections.Generic.Dictionary$2(UnityEngine.GameObject,UnityEngine.GameObject)).ctor();
            }
        },
        methods: {
            /*ObjectPool.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "ObjectPool#Awake", this ); }

                ObjectPool._instance = this;
                if (this.startupPoolMode === ObjectPool.StartupPoolMode.Awake) {
                    ObjectPool.CreateStartupPools();
                }
            },
            /*ObjectPool.Awake end.*/

            /*ObjectPool.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "ObjectPool#Start", this ); }

                if (this.startupPoolMode === ObjectPool.StartupPoolMode.Start) {
                    ObjectPool.CreateStartupPools();
                }
            },
            /*ObjectPool.Start end.*/


        }
    });
    /*ObjectPool end.*/

    /*ObjectPool+StartupPool start.*/
    Bridge.define("ObjectPool.StartupPool", {
        $kind: 1002,
        fields: {
            size: 0,
            prefab: null
        }
    });
    /*ObjectPool+StartupPool end.*/

    /*ObjectPool+StartupPoolMode start.*/
    Bridge.define("ObjectPool.StartupPoolMode", {
        $kind: 1006,
        statics: {
            fields: {
                Awake: 0,
                Start: 1,
                CallManually: 2
            }
        }
    });
    /*ObjectPool+StartupPoolMode end.*/

    /*ObjectPoolExtensions start.*/
    Bridge.define("ObjectPoolExtensions", {
        statics: {
            methods: {
                /*ObjectPoolExtensions.CreatePool$2:static start.*/
                CreatePool$2: function (T, prefab) {
if ( TRACE ) { TRACE( "ObjectPoolExtensions#CreatePool$2", this ); }

                    ObjectPool.CreatePool$1(T, Bridge.rValue(prefab), 0);
                },
                /*ObjectPoolExtensions.CreatePool$2:static end.*/

                /*ObjectPoolExtensions.CreatePool$3:static start.*/
                CreatePool$3: function (T, prefab, initialPoolSize) {
if ( TRACE ) { TRACE( "ObjectPoolExtensions#CreatePool$3", this ); }

                    ObjectPool.CreatePool$1(T, Bridge.rValue(prefab), initialPoolSize);
                },
                /*ObjectPoolExtensions.CreatePool$3:static end.*/

                /*ObjectPoolExtensions.CreatePool:static start.*/
                CreatePool: function (prefab) {
if ( TRACE ) { TRACE( "ObjectPoolExtensions#CreatePool", this ); }

                    ObjectPool.CreatePool(prefab, 0);
                },
                /*ObjectPoolExtensions.CreatePool:static end.*/

                /*ObjectPoolExtensions.CreatePool$1:static start.*/
                CreatePool$1: function (prefab, initialPoolSize) {
if ( TRACE ) { TRACE( "ObjectPoolExtensions#CreatePool$1", this ); }

                    ObjectPool.CreatePool(prefab, initialPoolSize);
                },
                /*ObjectPoolExtensions.CreatePool$1:static end.*/

                /*ObjectPoolExtensions.Spawn$3:static start.*/
                Spawn$3: function (T, prefab, parent, position, rotation) {
if ( TRACE ) { TRACE( "ObjectPoolExtensions#Spawn$3", this ); }

                    return ObjectPool.Spawn$3(T, Bridge.rValue(prefab), parent, position, rotation);
                },
                /*ObjectPoolExtensions.Spawn$3:static end.*/

                /*ObjectPoolExtensions.Spawn$5:static start.*/
                Spawn$5: function (T, prefab, position, rotation) {
if ( TRACE ) { TRACE( "ObjectPoolExtensions#Spawn$5", this ); }

                    return ObjectPool.Spawn$3(T, Bridge.rValue(prefab), null, position, rotation);
                },
                /*ObjectPoolExtensions.Spawn$5:static end.*/

                /*ObjectPoolExtensions.Spawn$2:static start.*/
                Spawn$2: function (T, prefab, parent, position) {
if ( TRACE ) { TRACE( "ObjectPoolExtensions#Spawn$2", this ); }

                    return ObjectPool.Spawn$3(T, Bridge.rValue(prefab), parent, position, pc.Quat.IDENTITY.clone());
                },
                /*ObjectPoolExtensions.Spawn$2:static end.*/

                /*ObjectPoolExtensions.Spawn$4:static start.*/
                Spawn$4: function (T, prefab, position) {
if ( TRACE ) { TRACE( "ObjectPoolExtensions#Spawn$4", this ); }

                    return ObjectPool.Spawn$3(T, Bridge.rValue(prefab), null, position, pc.Quat.IDENTITY.clone());
                },
                /*ObjectPoolExtensions.Spawn$4:static end.*/

                /*ObjectPoolExtensions.Spawn$1:static start.*/
                Spawn$1: function (T, prefab, parent) {
if ( TRACE ) { TRACE( "ObjectPoolExtensions#Spawn$1", this ); }

                    return ObjectPool.Spawn$3(T, Bridge.rValue(prefab), parent, pc.Vec3.ZERO.clone(), pc.Quat.IDENTITY.clone());
                },
                /*ObjectPoolExtensions.Spawn$1:static end.*/

                /*ObjectPoolExtensions.Spawn:static start.*/
                Spawn: function (T, prefab) {
if ( TRACE ) { TRACE( "ObjectPoolExtensions#Spawn", this ); }

                    return ObjectPool.Spawn$3(T, Bridge.rValue(prefab), null, pc.Vec3.ZERO.clone(), pc.Quat.IDENTITY.clone());
                },
                /*ObjectPoolExtensions.Spawn:static end.*/

                /*ObjectPoolExtensions.Spawn$9:static start.*/
                Spawn$9: function (prefab, parent, position, rotation) {
if ( TRACE ) { TRACE( "ObjectPoolExtensions#Spawn$9", this ); }

                    return ObjectPool.Spawn$9(prefab, parent, position, rotation);
                },
                /*ObjectPoolExtensions.Spawn$9:static end.*/

                /*ObjectPoolExtensions.Spawn$11:static start.*/
                Spawn$11: function (prefab, position, rotation) {
if ( TRACE ) { TRACE( "ObjectPoolExtensions#Spawn$11", this ); }

                    return ObjectPool.Spawn$9(prefab, null, position, rotation);
                },
                /*ObjectPoolExtensions.Spawn$11:static end.*/

                /*ObjectPoolExtensions.Spawn$8:static start.*/
                Spawn$8: function (prefab, parent, position) {
if ( TRACE ) { TRACE( "ObjectPoolExtensions#Spawn$8", this ); }

                    return ObjectPool.Spawn$9(prefab, parent, position, pc.Quat.IDENTITY.clone());
                },
                /*ObjectPoolExtensions.Spawn$8:static end.*/

                /*ObjectPoolExtensions.Spawn$10:static start.*/
                Spawn$10: function (prefab, position) {
if ( TRACE ) { TRACE( "ObjectPoolExtensions#Spawn$10", this ); }

                    return ObjectPool.Spawn$9(prefab, null, position, pc.Quat.IDENTITY.clone());
                },
                /*ObjectPoolExtensions.Spawn$10:static end.*/

                /*ObjectPoolExtensions.Spawn$7:static start.*/
                Spawn$7: function (prefab, parent) {
if ( TRACE ) { TRACE( "ObjectPoolExtensions#Spawn$7", this ); }

                    return ObjectPool.Spawn$9(prefab, parent, pc.Vec3.ZERO.clone(), pc.Quat.IDENTITY.clone());
                },
                /*ObjectPoolExtensions.Spawn$7:static end.*/

                /*ObjectPoolExtensions.Spawn$6:static start.*/
                Spawn$6: function (prefab) {
if ( TRACE ) { TRACE( "ObjectPoolExtensions#Spawn$6", this ); }

                    return ObjectPool.Spawn$9(prefab, null, pc.Vec3.ZERO.clone(), pc.Quat.IDENTITY.clone());
                },
                /*ObjectPoolExtensions.Spawn$6:static end.*/

                /*ObjectPoolExtensions.Recycle$1:static start.*/
                Recycle$1: function (T, obj) {
if ( TRACE ) { TRACE( "ObjectPoolExtensions#Recycle$1", this ); }

                    ObjectPool.Recycle$1(T, Bridge.rValue(obj));
                },
                /*ObjectPoolExtensions.Recycle$1:static end.*/

                /*ObjectPoolExtensions.Recycle:static start.*/
                Recycle: function (obj) {
if ( TRACE ) { TRACE( "ObjectPoolExtensions#Recycle", this ); }

                    ObjectPool.Recycle(obj);
                },
                /*ObjectPoolExtensions.Recycle:static end.*/

                /*ObjectPoolExtensions.RecycleAll$1:static start.*/
                RecycleAll$1: function (T, prefab) {
if ( TRACE ) { TRACE( "ObjectPoolExtensions#RecycleAll$1", this ); }

                    ObjectPool.RecycleAll$2(T, Bridge.rValue(prefab));
                },
                /*ObjectPoolExtensions.RecycleAll$1:static end.*/

                /*ObjectPoolExtensions.RecycleAll:static start.*/
                RecycleAll: function (prefab) {
if ( TRACE ) { TRACE( "ObjectPoolExtensions#RecycleAll", this ); }

                    ObjectPool.RecycleAll$1(prefab);
                },
                /*ObjectPoolExtensions.RecycleAll:static end.*/

                /*ObjectPoolExtensions.CountPooled$1:static start.*/
                CountPooled$1: function (T, prefab) {
if ( TRACE ) { TRACE( "ObjectPoolExtensions#CountPooled$1", this ); }

                    return ObjectPool.CountPooled$1(T, Bridge.rValue(prefab));
                },
                /*ObjectPoolExtensions.CountPooled$1:static end.*/

                /*ObjectPoolExtensions.CountPooled:static start.*/
                CountPooled: function (prefab) {
if ( TRACE ) { TRACE( "ObjectPoolExtensions#CountPooled", this ); }

                    return ObjectPool.CountPooled(prefab);
                },
                /*ObjectPoolExtensions.CountPooled:static end.*/

                /*ObjectPoolExtensions.CountSpawned$1:static start.*/
                CountSpawned$1: function (T, prefab) {
if ( TRACE ) { TRACE( "ObjectPoolExtensions#CountSpawned$1", this ); }

                    return ObjectPool.CountSpawned$1(T, Bridge.rValue(prefab));
                },
                /*ObjectPoolExtensions.CountSpawned$1:static end.*/

                /*ObjectPoolExtensions.CountSpawned:static start.*/
                CountSpawned: function (prefab) {
if ( TRACE ) { TRACE( "ObjectPoolExtensions#CountSpawned", this ); }

                    return ObjectPool.CountSpawned(prefab);
                },
                /*ObjectPoolExtensions.CountSpawned:static end.*/

                /*ObjectPoolExtensions.GetSpawned$5:static start.*/
                GetSpawned$5: function (prefab, list, appendList) {
if ( TRACE ) { TRACE( "ObjectPoolExtensions#GetSpawned$5", this ); }

                    return ObjectPool.GetSpawned$1(prefab, list, appendList);
                },
                /*ObjectPoolExtensions.GetSpawned$5:static end.*/

                /*ObjectPoolExtensions.GetSpawned$4:static start.*/
                GetSpawned$4: function (prefab, list) {
if ( TRACE ) { TRACE( "ObjectPoolExtensions#GetSpawned$4", this ); }

                    return ObjectPool.GetSpawned$1(prefab, list, false);
                },
                /*ObjectPoolExtensions.GetSpawned$4:static end.*/

                /*ObjectPoolExtensions.GetSpawned$3:static start.*/
                GetSpawned$3: function (prefab) {
if ( TRACE ) { TRACE( "ObjectPoolExtensions#GetSpawned$3", this ); }

                    return ObjectPool.GetSpawned$1(prefab, null, false);
                },
                /*ObjectPoolExtensions.GetSpawned$3:static end.*/

                /*ObjectPoolExtensions.GetSpawned$2:static start.*/
                GetSpawned$2: function (T, prefab, list, appendList) {
if ( TRACE ) { TRACE( "ObjectPoolExtensions#GetSpawned$2", this ); }

                    return ObjectPool.GetSpawned(T, Bridge.rValue(prefab), list, appendList);
                },
                /*ObjectPoolExtensions.GetSpawned$2:static end.*/

                /*ObjectPoolExtensions.GetSpawned$1:static start.*/
                GetSpawned$1: function (T, prefab, list) {
if ( TRACE ) { TRACE( "ObjectPoolExtensions#GetSpawned$1", this ); }

                    return ObjectPool.GetSpawned(T, Bridge.rValue(prefab), list, false);
                },
                /*ObjectPoolExtensions.GetSpawned$1:static end.*/

                /*ObjectPoolExtensions.GetSpawned:static start.*/
                GetSpawned: function (T, prefab) {
if ( TRACE ) { TRACE( "ObjectPoolExtensions#GetSpawned", this ); }

                    return ObjectPool.GetSpawned(T, Bridge.rValue(prefab), null, false);
                },
                /*ObjectPoolExtensions.GetSpawned:static end.*/

                /*ObjectPoolExtensions.GetPooled$5:static start.*/
                GetPooled$5: function (prefab, list, appendList) {
if ( TRACE ) { TRACE( "ObjectPoolExtensions#GetPooled$5", this ); }

                    return ObjectPool.GetPooled$1(prefab, list, appendList);
                },
                /*ObjectPoolExtensions.GetPooled$5:static end.*/

                /*ObjectPoolExtensions.GetPooled$4:static start.*/
                GetPooled$4: function (prefab, list) {
if ( TRACE ) { TRACE( "ObjectPoolExtensions#GetPooled$4", this ); }

                    return ObjectPool.GetPooled$1(prefab, list, false);
                },
                /*ObjectPoolExtensions.GetPooled$4:static end.*/

                /*ObjectPoolExtensions.GetPooled$3:static start.*/
                GetPooled$3: function (prefab) {
if ( TRACE ) { TRACE( "ObjectPoolExtensions#GetPooled$3", this ); }

                    return ObjectPool.GetPooled$1(prefab, null, false);
                },
                /*ObjectPoolExtensions.GetPooled$3:static end.*/

                /*ObjectPoolExtensions.GetPooled$2:static start.*/
                GetPooled$2: function (T, prefab, list, appendList) {
if ( TRACE ) { TRACE( "ObjectPoolExtensions#GetPooled$2", this ); }

                    return ObjectPool.GetPooled(T, Bridge.rValue(prefab), list, appendList);
                },
                /*ObjectPoolExtensions.GetPooled$2:static end.*/

                /*ObjectPoolExtensions.GetPooled$1:static start.*/
                GetPooled$1: function (T, prefab, list) {
if ( TRACE ) { TRACE( "ObjectPoolExtensions#GetPooled$1", this ); }

                    return ObjectPool.GetPooled(T, Bridge.rValue(prefab), list, false);
                },
                /*ObjectPoolExtensions.GetPooled$1:static end.*/

                /*ObjectPoolExtensions.GetPooled:static start.*/
                GetPooled: function (T, prefab) {
if ( TRACE ) { TRACE( "ObjectPoolExtensions#GetPooled", this ); }

                    return ObjectPool.GetPooled(T, Bridge.rValue(prefab), null, false);
                },
                /*ObjectPoolExtensions.GetPooled:static end.*/

                /*ObjectPoolExtensions.DestroyPooled:static start.*/
                DestroyPooled: function (prefab) {
if ( TRACE ) { TRACE( "ObjectPoolExtensions#DestroyPooled", this ); }

                    ObjectPool.DestroyPooled(prefab);
                },
                /*ObjectPoolExtensions.DestroyPooled:static end.*/

                /*ObjectPoolExtensions.DestroyPooled$1:static start.*/
                DestroyPooled$1: function (T, prefab) {
if ( TRACE ) { TRACE( "ObjectPoolExtensions#DestroyPooled$1", this ); }

                    ObjectPool.DestroyPooled(Bridge.rValue(prefab).gameObject);
                },
                /*ObjectPoolExtensions.DestroyPooled$1:static end.*/

                /*ObjectPoolExtensions.DestroyAll:static start.*/
                DestroyAll: function (prefab) {
if ( TRACE ) { TRACE( "ObjectPoolExtensions#DestroyAll", this ); }

                    ObjectPool.DestroyAll(prefab);
                },
                /*ObjectPoolExtensions.DestroyAll:static end.*/

                /*ObjectPoolExtensions.DestroyAll$1:static start.*/
                DestroyAll$1: function (T, prefab) {
if ( TRACE ) { TRACE( "ObjectPoolExtensions#DestroyAll$1", this ); }

                    ObjectPool.DestroyAll(Bridge.rValue(prefab).gameObject);
                },
                /*ObjectPoolExtensions.DestroyAll$1:static end.*/


            }
        }
    });
    /*ObjectPoolExtensions end.*/

    /*RopeMaterial start.*/
    Bridge.define("RopeMaterial", {
        fields: {
            materials: null
        }
    });
    /*RopeMaterial end.*/

    /*Saw start.*/
    Bridge.define("Saw", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            countTrigger: 0,
            active: false,
            visualTrans: null,
            graphic: null,
            animation: null
        },
        methods: {
            /*Saw.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Saw#Start", this ); }

                this.countTrigger = 0;
                this.graphic.sortingOrder = 0;

                this.animation.gameObject.SetActive(false);
                DG.Tweening.TweenSettingsExtensions.SetLoops(DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions), DG.Tweening.TweenSettingsExtensions.SetRelative$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions), DG.Tweening.ShortcutExtensions.DORotate(this.visualTrans, new pc.Vec3( 0, 0, 1 ).clone().scale( -360 ), 0.5), true), DG.Tweening.Ease.Linear), -1);
            },
            /*Saw.Start end.*/

            /*Saw.OnTriggerEnter2D start.*/
            OnTriggerEnter2D: function (collision) {
if ( TRACE ) { TRACE( "Saw#OnTriggerEnter2D", this ); }


                collision.gameObject.SetActive(false);

                this.animation.gameObject.transform.position = collision.transform.position.$clone();
                this.animation.gameObject.SetActive(true);
                this.animation.AnimationState.SetAnimation$1(0, "attack", false);
                this.Invoke("DeactiveAnimation", 1.1);

                AudioManager.instance.PlayWoodDestroySound();
                if (!this.active) {
                    this.active = true;
                    this.graphic.sortingOrder = 10;
                    // transform.DOMoveY(-0.5f, 0.5f).SetRelative(true).SetEase(Ease.Linear).OnComplete(() =>
                    // {
                    //     transform.DOMoveY(0.5f, 1.0f).SetRelative(true).SetEase(Ease.Linear).OnComplete(() =>
                    //     {
                    //         active = false;
                    //     });
                    // });
                }
            },
            /*Saw.OnTriggerEnter2D end.*/

            /*Saw.DeactiveAnimation start.*/
            DeactiveAnimation: function () {
if ( TRACE ) { TRACE( "Saw#DeactiveAnimation", this ); }

                this.animation.gameObject.SetActive(false);
            },
            /*Saw.DeactiveAnimation end.*/

            /*Saw.OnTriggerExit2D start.*/
            OnTriggerExit2D: function (collision) {
if ( TRACE ) { TRACE( "Saw#OnTriggerExit2D", this ); }


            },
            /*Saw.OnTriggerExit2D end.*/


        }
    });
    /*Saw end.*/

    /*SharpJson.JsonDecoder start.*/
    Bridge.define("SharpJson.JsonDecoder", {
        statics: {
            methods: {
                /*SharpJson.JsonDecoder.DecodeText:static start.*/
                DecodeText: function (text) {
if ( TRACE ) { TRACE( "SharpJson.JsonDecoder#DecodeText", this ); }

                    var builder = new SharpJson.JsonDecoder();
                    return builder.Decode(text);
                },
                /*SharpJson.JsonDecoder.DecodeText:static end.*/


            }
        },
        fields: {
            errorMessage: null,
            parseNumbersAsFloat: false,
            lexer: null
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "SharpJson.JsonDecoder#ctor", this ); }

                this.$initialize();
                this.errorMessage = null;
                this.parseNumbersAsFloat = false;
            }
        },
        methods: {
            /*SharpJson.JsonDecoder.Decode start.*/
            Decode: function (text) {
if ( TRACE ) { TRACE( "SharpJson.JsonDecoder#Decode", this ); }

                this.errorMessage = null;

                this.lexer = new SharpJson.Lexer(text);
                this.lexer.parseNumbersAsFloat = this.parseNumbersAsFloat;

                return this.ParseValue();
            },
            /*SharpJson.JsonDecoder.Decode end.*/

            /*SharpJson.JsonDecoder.ParseObject start.*/
            ParseObject: function () {
if ( TRACE ) { TRACE( "SharpJson.JsonDecoder#ParseObject", this ); }

                var table = new (System.Collections.Generic.Dictionary$2(System.String,System.Object)).ctor();

                // {
                this.lexer.NextToken();

                while (true) {
                    var token = this.lexer.LookAhead();

                    switch (token) {
                        case SharpJson.Lexer.Token.None: 
                            this.TriggerError("Invalid token");
                            return null;
                        case SharpJson.Lexer.Token.Comma: 
                            this.lexer.NextToken();
                            break;
                        case SharpJson.Lexer.Token.CurlyClose: 
                            this.lexer.NextToken();
                            return table;
                        default: 
                            // name
                            var name = this.EvalLexer(System.String, this.lexer.ParseString());
                            if (this.errorMessage != null) {
                                return null;
                            }
                            // :
                            token = this.lexer.NextToken();
                            if (token !== SharpJson.Lexer.Token.Colon) {
                                this.TriggerError("Invalid token; expected ':'");
                                return null;
                            }
                            // value
                            var value = this.ParseValue();
                            if (this.errorMessage != null) {
                                return null;
                            }
                            table.setItem(name, value);
                            break;
                    }
                }

                //return null; // Unreachable code
            },
            /*SharpJson.JsonDecoder.ParseObject end.*/

            /*SharpJson.JsonDecoder.ParseArray start.*/
            ParseArray: function () {
if ( TRACE ) { TRACE( "SharpJson.JsonDecoder#ParseArray", this ); }

                var array = new (System.Collections.Generic.List$1(System.Object)).ctor();

                // [
                this.lexer.NextToken();

                while (true) {
                    var token = this.lexer.LookAhead();

                    switch (token) {
                        case SharpJson.Lexer.Token.None: 
                            this.TriggerError("Invalid token");
                            return null;
                        case SharpJson.Lexer.Token.Comma: 
                            this.lexer.NextToken();
                            break;
                        case SharpJson.Lexer.Token.SquaredClose: 
                            this.lexer.NextToken();
                            return array;
                        default: 
                            var value = this.ParseValue();
                            if (this.errorMessage != null) {
                                return null;
                            }
                            array.add(value);
                            break;
                    }
                }

                //return null; // Unreachable code
            },
            /*SharpJson.JsonDecoder.ParseArray end.*/

            /*SharpJson.JsonDecoder.ParseValue start.*/
            ParseValue: function () {
if ( TRACE ) { TRACE( "SharpJson.JsonDecoder#ParseValue", this ); }

                switch (this.lexer.LookAhead()) {
                    case SharpJson.Lexer.Token.String: 
                        return this.EvalLexer(System.String, this.lexer.ParseString());
                    case SharpJson.Lexer.Token.Number: 
                        if (this.parseNumbersAsFloat) {
                            return Bridge.box(this.EvalLexer(System.Single, this.lexer.ParseFloatNumber()), System.Single, System.Single.format, System.Single.getHashCode);
                        } else {
                            return Bridge.box(this.EvalLexer(System.Double, this.lexer.ParseDoubleNumber()), System.Double, System.Double.format, System.Double.getHashCode);
                        }
                    case SharpJson.Lexer.Token.CurlyOpen: 
                        return this.ParseObject();
                    case SharpJson.Lexer.Token.SquaredOpen: 
                        return this.ParseArray();
                    case SharpJson.Lexer.Token.True: 
                        this.lexer.NextToken();
                        return Bridge.box(true, System.Boolean, System.Boolean.toString);
                    case SharpJson.Lexer.Token.False: 
                        this.lexer.NextToken();
                        return Bridge.box(false, System.Boolean, System.Boolean.toString);
                    case SharpJson.Lexer.Token.Null: 
                        this.lexer.NextToken();
                        return null;
                    case SharpJson.Lexer.Token.None: 
                        break;
                }

                this.TriggerError("Unable to parse value");
                return null;
            },
            /*SharpJson.JsonDecoder.ParseValue end.*/

            /*SharpJson.JsonDecoder.TriggerError start.*/
            TriggerError: function (message) {
if ( TRACE ) { TRACE( "SharpJson.JsonDecoder#TriggerError", this ); }

                this.errorMessage = System.String.format("Error: '{0}' at line {1}", message, Bridge.box(this.lexer.lineNumber, System.Int32));
            },
            /*SharpJson.JsonDecoder.TriggerError end.*/

            /*SharpJson.JsonDecoder.EvalLexer start.*/
            EvalLexer: function (T, value) {
if ( TRACE ) { TRACE( "SharpJson.JsonDecoder#EvalLexer", this ); }

                if (this.lexer.hasError) {
                    this.TriggerError("Lexical error ocurred");
                }

                return Bridge.rValue(value);
            },
            /*SharpJson.JsonDecoder.EvalLexer end.*/


        }
    });
    /*SharpJson.JsonDecoder end.*/

    /*SharpJson.Lexer start.*/
    Bridge.define("SharpJson.Lexer", {
        statics: {
            methods: {
                /*SharpJson.Lexer.NextToken:static start.*/
                NextToken: function (json, index) {
if ( TRACE ) { TRACE( "SharpJson.Lexer#NextToken", this ); }

                    if (index.v === json.length) {
                        return SharpJson.Lexer.Token.None;
                    }

                    var c = json[Bridge.identity(index.v, ((index.v = (index.v + 1) | 0)))];

                    switch (c) {
                        case 123: 
                            return SharpJson.Lexer.Token.CurlyOpen;
                        case 125: 
                            return SharpJson.Lexer.Token.CurlyClose;
                        case 91: 
                            return SharpJson.Lexer.Token.SquaredOpen;
                        case 93: 
                            return SharpJson.Lexer.Token.SquaredClose;
                        case 44: 
                            return SharpJson.Lexer.Token.Comma;
                        case 34: 
                            return SharpJson.Lexer.Token.String;
                        case 48: 
                        case 49: 
                        case 50: 
                        case 51: 
                        case 52: 
                        case 53: 
                        case 54: 
                        case 55: 
                        case 56: 
                        case 57: 
                        case 45: 
                            return SharpJson.Lexer.Token.Number;
                        case 58: 
                            return SharpJson.Lexer.Token.Colon;
                    }

                    index.v = (index.v - 1) | 0;

                    var remainingLength = (json.length - index.v) | 0;

                    // false
                    if (remainingLength >= 5) {
                        if (json[index.v] === 102 && json[((index.v + 1) | 0)] === 97 && json[((index.v + 2) | 0)] === 108 && json[((index.v + 3) | 0)] === 115 && json[((index.v + 4) | 0)] === 101) {
                            index.v = (index.v + 5) | 0;
                            return SharpJson.Lexer.Token.False;
                        }
                    }

                    // true
                    if (remainingLength >= 4) {
                        if (json[index.v] === 116 && json[((index.v + 1) | 0)] === 114 && json[((index.v + 2) | 0)] === 117 && json[((index.v + 3) | 0)] === 101) {
                            index.v = (index.v + 4) | 0;
                            return SharpJson.Lexer.Token.True;
                        }
                    }

                    // null
                    if (remainingLength >= 4) {
                        if (json[index.v] === 110 && json[((index.v + 1) | 0)] === 117 && json[((index.v + 2) | 0)] === 108 && json[((index.v + 3) | 0)] === 108) {
                            index.v = (index.v + 4) | 0;
                            return SharpJson.Lexer.Token.Null;
                        }
                    }

                    return SharpJson.Lexer.Token.None;
                },
                /*SharpJson.Lexer.NextToken:static end.*/


            }
        },
        fields: {
            lineNumber: 0,
            parseNumbersAsFloat: false,
            json: null,
            index: 0,
            success: false,
            stringBuffer: null
        },
        props: {
            hasError: {
                get: function () {
if ( TRACE ) { TRACE( "SharpJson.Lexer#hasError#get", this ); }

                    return !this.success;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "SharpJson.Lexer#init", this ); }

                this.index = 0;
                this.success = true;
                this.stringBuffer = System.Array.init(4096, 0, System.Char);
            },
            ctor: function (text) {
if ( TRACE ) { TRACE( "SharpJson.Lexer#ctor", this ); }

                this.$initialize();
                this.Reset();

                this.json = System.String.toCharArray(text, 0, text.length);
                this.parseNumbersAsFloat = false;
            }
        },
        methods: {
            /*SharpJson.Lexer.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "SharpJson.Lexer#Reset", this ); }

                this.index = 0;
                this.lineNumber = 1;
                this.success = true;
            },
            /*SharpJson.Lexer.Reset end.*/

            /*SharpJson.Lexer.ParseString start.*/
            ParseString: function () {
if ( TRACE ) { TRACE( "SharpJson.Lexer#ParseString", this ); }

                var idx = 0;
                var builder = null;

                this.SkipWhiteSpaces();

                // "
                var c = this.json[Bridge.identity(this.index, ((this.index = (this.index + 1) | 0)))];

                var failed = false;
                var complete = false;

                while (!complete && !failed) {
                    if (this.index === this.json.length) {
                        break;
                    }

                    c = this.json[Bridge.identity(this.index, ((this.index = (this.index + 1) | 0)))];
                    if (c === 34) {
                        complete = true;
                        break;
                    } else if (c === 92) {
                        if (this.index === this.json.length) {
                            break;
                        }

                        c = this.json[Bridge.identity(this.index, ((this.index = (this.index + 1) | 0)))];

                        switch (c) {
                            case 34: 
                                this.stringBuffer[Bridge.identity(idx, ((idx = (idx + 1) | 0)))] = 34;
                                break;
                            case 92: 
                                this.stringBuffer[Bridge.identity(idx, ((idx = (idx + 1) | 0)))] = 92;
                                break;
                            case 47: 
                                this.stringBuffer[Bridge.identity(idx, ((idx = (idx + 1) | 0)))] = 47;
                                break;
                            case 98: 
                                this.stringBuffer[Bridge.identity(idx, ((idx = (idx + 1) | 0)))] = 8;
                                break;
                            case 102: 
                                this.stringBuffer[Bridge.identity(idx, ((idx = (idx + 1) | 0)))] = 12;
                                break;
                            case 110: 
                                this.stringBuffer[Bridge.identity(idx, ((idx = (idx + 1) | 0)))] = 10;
                                break;
                            case 114: 
                                this.stringBuffer[Bridge.identity(idx, ((idx = (idx + 1) | 0)))] = 13;
                                break;
                            case 116: 
                                this.stringBuffer[Bridge.identity(idx, ((idx = (idx + 1) | 0)))] = 9;
                                break;
                            case 117: 
                                var remainingLength = (this.json.length - this.index) | 0;
                                if (remainingLength >= 4) {
                                    var hex = System.String.fromCharArray(this.json, this.index, 4);

                                    // XXX: handle UTF
                                    this.stringBuffer[Bridge.identity(idx, ((idx = (idx + 1) | 0)))] = (System.Convert.toNumberInBase(hex, 16, 9)) & 65535;

                                    // skip 4 chars
                                    this.index = (this.index + 4) | 0;
                                } else {
                                    failed = true;
                                }
                                break;
                        }
                    } else {
                        this.stringBuffer[Bridge.identity(idx, ((idx = (idx + 1) | 0)))] = c;
                    }

                    if (idx >= this.stringBuffer.length) {
                        if (builder == null) {
                            builder = new System.Text.StringBuilder();
                        }

                        builder.append(this.stringBuffer.slice(0, idx).join());
                        idx = 0;
                    }
                }

                if (!complete) {
                    this.success = false;
                    return null;
                }

                if (builder != null) {
                    return builder.toString();
                } else {
                    return System.String.fromCharArray(this.stringBuffer, 0, idx);
                }
            },
            /*SharpJson.Lexer.ParseString end.*/

            /*SharpJson.Lexer.GetNumberString start.*/
            GetNumberString: function () {
if ( TRACE ) { TRACE( "SharpJson.Lexer#GetNumberString", this ); }

                this.SkipWhiteSpaces();

                var lastIndex = this.GetLastIndexOfNumber(this.index);
                var charLength = ((((lastIndex - this.index) | 0)) + 1) | 0;

                var result = System.String.fromCharArray(this.json, this.index, charLength);

                this.index = (lastIndex + 1) | 0;

                return result;
            },
            /*SharpJson.Lexer.GetNumberString end.*/

            /*SharpJson.Lexer.ParseFloatNumber start.*/
            ParseFloatNumber: function () {
if ( TRACE ) { TRACE( "SharpJson.Lexer#ParseFloatNumber", this ); }

                var number = { };
                var str = this.GetNumberString();

                if (!System.Single.tryParse4(str, 167, System.Globalization.CultureInfo.invariantCulture, number)) {
                    return 0;
                }

                return number.v;
            },
            /*SharpJson.Lexer.ParseFloatNumber end.*/

            /*SharpJson.Lexer.ParseDoubleNumber start.*/
            ParseDoubleNumber: function () {
if ( TRACE ) { TRACE( "SharpJson.Lexer#ParseDoubleNumber", this ); }

                var number = { };
                var str = this.GetNumberString();

                if (!System.Double.tryParse4(str, 511, System.Globalization.CultureInfo.invariantCulture, number)) {
                    return 0;
                }

                return number.v;
            },
            /*SharpJson.Lexer.ParseDoubleNumber end.*/

            /*SharpJson.Lexer.GetLastIndexOfNumber start.*/
            GetLastIndexOfNumber: function (index) {
if ( TRACE ) { TRACE( "SharpJson.Lexer#GetLastIndexOfNumber", this ); }

                var lastIndex;

                for (lastIndex = index; lastIndex < this.json.length; lastIndex = (lastIndex + 1) | 0) {
                    var ch = this.json[lastIndex];

                    if ((ch < 48 || ch > 57) && ch !== 43 && ch !== 45 && ch !== 46 && ch !== 101 && ch !== 69) {
                        break;
                    }
                }

                return ((lastIndex - 1) | 0);
            },
            /*SharpJson.Lexer.GetLastIndexOfNumber end.*/

            /*SharpJson.Lexer.SkipWhiteSpaces start.*/
            SkipWhiteSpaces: function () {
if ( TRACE ) { TRACE( "SharpJson.Lexer#SkipWhiteSpaces", this ); }

                for (; this.index < this.json.length; this.index = (this.index + 1) | 0) {
                    var ch = this.json[this.index];

                    if (ch === 10) {
                        this.lineNumber = (this.lineNumber + 1) | 0;
                    }

                    if (!System.Char.isWhiteSpace(String.fromCharCode(this.json[this.index]))) {
                        break;
                    }
                }
            },
            /*SharpJson.Lexer.SkipWhiteSpaces end.*/

            /*SharpJson.Lexer.LookAhead start.*/
            LookAhead: function () {
if ( TRACE ) { TRACE( "SharpJson.Lexer#LookAhead", this ); }

                this.SkipWhiteSpaces();

                var savedIndex = { v : this.index };
                return SharpJson.Lexer.NextToken(this.json, savedIndex);
            },
            /*SharpJson.Lexer.LookAhead end.*/

            /*SharpJson.Lexer.NextToken start.*/
            NextToken: function () {
if ( TRACE ) { TRACE( "SharpJson.Lexer#NextToken", this ); }

                this.SkipWhiteSpaces();
                return SharpJson.Lexer.NextToken(this.json, Bridge.ref(this, "index"));
            },
            /*SharpJson.Lexer.NextToken end.*/


        }
    });
    /*SharpJson.Lexer end.*/

    /*SharpJson.Lexer+Token start.*/
    Bridge.define("SharpJson.Lexer.Token", {
        $kind: 1006,
        statics: {
            fields: {
                None: 0,
                Null: 1,
                True: 2,
                False: 3,
                Colon: 4,
                Comma: 5,
                String: 6,
                Number: 7,
                CurlyOpen: 8,
                CurlyClose: 9,
                SquaredOpen: 10,
                SquaredClose: 11
            }
        }
    });
    /*SharpJson.Lexer+Token end.*/

    /*ShuffleExtension start.*/
    Bridge.define("ShuffleExtension", {
        statics: {
            methods: {
                /*ShuffleExtension.Shuffle:static start.*/
                Shuffle: function (T, array, shuffleAccuracy) {
if ( TRACE ) { TRACE( "ShuffleExtension#Shuffle", this ); }

                    for (var i = 0; i < shuffleAccuracy; i = (i + 1) | 0) {
                        var randomIndex = UnityEngine.Random.Range(1, array.length);

                        var temp = Bridge.rValue(array[randomIndex]);
                        array[randomIndex] = Bridge.rValue(array[0]);
                        array[0] = Bridge.rValue(temp);
                    }
                },
                /*ShuffleExtension.Shuffle:static end.*/

                /*ShuffleExtension.Shuffle$1:static start.*/
                Shuffle$1: function (T, list, shuffleAccuracy) {
if ( TRACE ) { TRACE( "ShuffleExtension#Shuffle$1", this ); }

                    for (var i = 0; i < shuffleAccuracy; i = (i + 1) | 0) {
                        var randomIndex = UnityEngine.Random.Range(1, list.Count);

                        var temp = Bridge.rValue(list.getItem(randomIndex));
                        list.setItem(randomIndex, Bridge.rValue(list.getItem(0)));
                        list.setItem(0, Bridge.rValue(temp));
                    }
                },
                /*ShuffleExtension.Shuffle$1:static end.*/


            }
        }
    });
    /*ShuffleExtension end.*/

    /*SoundManager start.*/
    Bridge.define("SoundManager", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                MIN_INTERVAL: 0,
                instance: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "SoundManager#init", this ); }

                    this.MIN_INTERVAL = 0.1;
                }
            },
            methods: {
                /*SoundManager.InitInstance:static start.*/
                InitInstance: function (parent) {
if ( TRACE ) { TRACE( "SoundManager#InitInstance", this ); }

                    if (UnityEngine.MonoBehaviour.op_Equality(SoundManager.instance, null)) {
                        var gameObject = Singleton$1(GameManager).Instance.InstantiatePrefab("SoundManager");
                        SoundManager.instance = gameObject.GetComponent(SoundManager);
                        SoundManager.instance.transform.parent = parent;
                    }
                },
                /*SoundManager.InitInstance:static end.*/


            }
        },
        fields: {
            bgMusic: null,
            sound: null,
            sound_medium: null,
            bgMusicName: null,
            _startTimes: null,
            fadeInning: false,
            fadeOuting: false,
            fadeInOutTimeMax: 0,
            fadeInOutTime: 0,
            orderBgm: null,
            audioClipHolder: null,
            volume: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "SoundManager#init", this ); }

                this.fadeInOutTimeMax = 1.0;
            }
        },
        methods: {
            /*SoundManager.LoadAudioHolder start.*/
            LoadAudioHolder: function (name) {
if ( TRACE ) { TRACE( "SoundManager#LoadAudioHolder", this ); }

                var gameObject = Singleton$1(GameManager).Instance.InstantiatePrefab(name);
                gameObject.transform.SetParent(this.transform);
                return gameObject.GetComponent(AudioClipsHolder);
            },
            /*SoundManager.LoadAudioHolder end.*/

            /*SoundManager.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "SoundManager#Start", this ); }

                this._startTimes = new (System.Collections.Generic.Dictionary$2(System.Int32,System.Single)).ctor();

                // registry event change ON/OFF music
                //EventManager.StartListening(EventVariables.ChangeMusic, this.OnMusicChanged);

                this.audioClipHolder = this.LoadAudioHolder("MainSound");
                this.volume = 1;
            },
            /*SoundManager.Start end.*/

            /*SoundManager.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "SoundManager#Update", this ); }

                if (this.fadeOuting) {
                    this.fadeInning = false;
                    this.fadeInOutTime += UnityEngine.Time.deltaTime;
                    if (this.fadeInOutTime >= this.fadeInOutTimeMax) {
                        this.fadeOuting = false;
                        this.bgMusic.volume = 0.0;
                        this.bgMusic.Stop();
                    } else {
                        this.bgMusic.volume = this.volume - this.fadeInOutTime / this.fadeInOutTimeMax;
                    }
                }
                if (this.fadeInning) {
                    this.fadeInOutTime += UnityEngine.Time.deltaTime;
                    if (this.fadeInOutTime >= this.fadeInOutTimeMax) {
                        this.fadeInning = false;
                        this.bgMusic.volume = this.volume;
                    } else {
                        this.bgMusic.volume = this.fadeInOutTime / this.fadeInOutTimeMax;
                    }
                }
            },
            /*SoundManager.Update end.*/

            /*SoundManager.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "SoundManager#OnDestroy", this ); }

                // Cancel registry event change ON/OFF music
                //EventManager.StopListening(EventVariables.ChangeMusic, this.OnMusicChanged);
            },
            /*SoundManager.OnDestroy end.*/

            /*SoundManager.OnMusicChanged start.*/
            OnMusicChanged: function () {
if ( TRACE ) { TRACE( "SoundManager#OnMusicChanged", this ); }

                //var changeValue = EventManager.GetBool(EventVariables.ChangeMusic);
                //if ((bool)changeValue)
                //{
                //    this.ResumeBGMusic();
                //}
                //else
                //{
                //    this.StopBGMusic();
                //}
            },
            /*SoundManager.OnMusicChanged end.*/

            /*SoundManager.PlayBGMusic start.*/
            PlayBGMusic: function (name, loop, overrideMode) {
if ( TRACE ) { TRACE( "SoundManager#PlayBGMusic", this ); }

                if (loop === void 0) { loop = true; }
                if (overrideMode === void 0) { overrideMode = true; }
                if (overrideMode) {
                    this.StopOrderedBgm();
                }
                var flag = true;
                if (!Bridge.referenceEquals(this.bgMusicName, name)) {
                    this.bgMusic.clip = this.LoadMusicClip(name);
                } else if (this.bgMusic.isPlaying) {
                    flag = false;
                }
                if (this.fadeOuting) {
                    this.fadeOuting = false;
                    this.fadeInOutTime = 0.0;
                    flag = true;
                }
                this.bgMusicName = name;
                this.bgMusic.loop = loop;
                if (flag && UserConfig.Instance.Music) {
                    this.bgMusic.Play();
                    this.fadeInning = true;
                    this.fadeInOutTime = 0.0;
                    this.bgMusic.volume = 0.0;
                }
            },
            /*SoundManager.PlayBGMusic end.*/

            /*SoundManager.LoadMusicClip start.*/
            LoadMusicClip: function (namePath) {
if ( TRACE ) { TRACE( "SoundManager#LoadMusicClip", this ); }

                return Bridge.cast(UnityEngine.Resources.Load$2("Musics/" + (namePath || ""), UnityEngine.AudioClip), UnityEngine.AudioClip);
            },
            /*SoundManager.LoadMusicClip end.*/

            /*SoundManager.StopBGMusic start.*/
            StopBGMusic: function () {
if ( TRACE ) { TRACE( "SoundManager#StopBGMusic", this ); }

                if (!this.fadeOuting && this.bgMusic.isPlaying) {
                    this.fadeOuting = true;
                    this.fadeInOutTime = 0.0;
                    this.bgMusic.volume = this.volume;
                }
            },
            /*SoundManager.StopBGMusic end.*/

            /*SoundManager.ResumeBGMusic start.*/
            ResumeBGMusic: function () {
if ( TRACE ) { TRACE( "SoundManager#ResumeBGMusic", this ); }

                this.fadeOuting = false;
                if (this.bgMusicName != null) {
                    this.PlayBGMusic(this.bgMusicName, this.bgMusic.loop, true);
                }
            },
            /*SoundManager.ResumeBGMusic end.*/

            /*SoundManager.SetBGVol start.*/
            SetBGVol: function (vol) {
if ( TRACE ) { TRACE( "SoundManager#SetBGVol", this ); }

                if (UnityEngine.Component.op_Inequality(this.bgMusic, null)) {
                    this.bgMusic.volume = vol;
                }
            },
            /*SoundManager.SetBGVol end.*/

            /*SoundManager.GetBGVol start.*/
            GetBGVol: function () {
if ( TRACE ) { TRACE( "SoundManager#GetBGVol", this ); }

                return (!(UnityEngine.Component.op_Equality(this.bgMusic, null))) ? this.bgMusic.volume : 0.0;
            },
            /*SoundManager.GetBGVol end.*/

            /*SoundManager.PlayOrderedBgm start.*/
            PlayOrderedBgm: function (music) {
if ( TRACE ) { TRACE( "SoundManager#PlayOrderedBgm", this ); }

                if (music === void 0) { music = []; }
                this.StopOrderedBgm();
                this.orderBgm = this.DoPlayOrderedBgm(music);
                this.StartCoroutine$1(this.orderBgm);
            },
            /*SoundManager.PlayOrderedBgm end.*/

            /*SoundManager.StopOrderedBgm start.*/
            StopOrderedBgm: function () {
if ( TRACE ) { TRACE( "SoundManager#StopOrderedBgm", this ); }

                if (this.orderBgm != null) {
                    this.StopCoroutine(this.orderBgm);
                    this.orderBgm = null;
                }
            },
            /*SoundManager.StopOrderedBgm end.*/

            /*SoundManager.DoPlayOrderedBgm start.*/
            DoPlayOrderedBgm: function (music) {
if ( TRACE ) { TRACE( "SoundManager#DoPlayOrderedBgm", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    i,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    if (music === void 0) { music = []; }
                                        i = 0;
                                        $step = 1;
                                        continue;
                                }
                                case 1: {
                                    if ( i < music.length ) {
                                            $step = 2;
                                            continue;
                                        }
                                    $step = 5;
                                    continue;
                                }
                                case 2: {
                                    if (i === ((music.length - 1) | 0)) {
                                            this.PlayBGMusic(music[i], true, false);
                                            $step = 4;
                                            continue;
                                        }
                                        this.PlayBGMusic(music[i], false, false);
                                        $enumerator.current = new UnityEngine.WaitForSeconds(this.bgMusic.clip.length);
                                        $step = 3;
                                        return true;
                                }
                                case 3: {
                                    $step = 4;
                                    continue;
                                }
                                case 4: {
                                    i = (i + 1) | 0;
                                    $step = 1;
                                    continue;
                                }
                                case 5: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*SoundManager.DoPlayOrderedBgm end.*/

            /*SoundManager.GetCatchedAudioClip start.*/
            GetCatchedAudioClip: function (name) {
if ( TRACE ) { TRACE( "SoundManager#GetCatchedAudioClip", this ); }

                var audioClip = this.audioClipHolder.TryGetAudioClip(name);
                if (audioClip == null) {
                    audioClip = this.audioClipHolder.TryGetAudioClip(name);
                }
                return audioClip;
            },
            /*SoundManager.GetCatchedAudioClip end.*/

            /*SoundManager.PauseSoundMedium start.*/
            PauseSoundMedium: function () {
if ( TRACE ) { TRACE( "SoundManager#PauseSoundMedium", this ); }

                this.sound_medium.Pause();
            },
            /*SoundManager.PauseSoundMedium end.*/

            /*SoundManager.UnpauseSoundMedium start.*/
            UnpauseSoundMedium: function () {
if ( TRACE ) { TRACE( "SoundManager#UnpauseSoundMedium", this ); }

                this.sound_medium.UnPause();
            },
            /*SoundManager.UnpauseSoundMedium end.*/

            /*SoundManager.StopSoundMedium start.*/
            StopSoundMedium: function () {
if ( TRACE ) { TRACE( "SoundManager#StopSoundMedium", this ); }

                this.sound_medium.loop = false;
                this.sound_medium.clip = null;
                this.sound_medium.Stop();
            },
            /*SoundManager.StopSoundMedium end.*/

            /*SoundManager.PlaySoundMedium start.*/
            PlaySoundMedium: function (name, loop, volumeScale) {
if ( TRACE ) { TRACE( "SoundManager#PlaySoundMedium", this ); }

                if (loop === void 0) { loop = false; }
                if (volumeScale === void 0) { volumeScale = 1.0; }
                var audioClip = this.audioClipHolder.TryGetAudioClip(name);
                if (audioClip != null) {
                    if (UserConfig.Instance.Sound) {
                        if (!(audioClip == null)) {
                            this.sound_medium.loop = loop;
                            if (!loop) {
                                this.sound_medium.PlayOneShot$1(audioClip, volumeScale);
                            } else {
                                this.sound_medium.volume = volumeScale;
                                this.sound_medium.clip = audioClip;
                                this.sound_medium.Play();
                            }
                        }
                    }
                }
            },
            /*SoundManager.PlaySoundMedium end.*/

            /*SoundManager.PlaySound start.*/
            PlaySound: function (name, loop, delay, volumeScale) {
if ( TRACE ) { TRACE( "SoundManager#PlaySound", this ); }

                if (loop === void 0) { loop = false; }
                if (delay === void 0) { delay = 0.0; }
                if (volumeScale === void 0) { volumeScale = 1.0; }
                var audioClip = this.audioClipHolder.TryGetAudioClip(name);
                if (audioClip == null) {
                    audioClip = this.audioClipHolder.TryGetAudioClip(name);
                }
                if (audioClip != null) {
                    this.PlaySound$1(audioClip, loop, delay, volumeScale);
                }
            },
            /*SoundManager.PlaySound end.*/

            /*SoundManager.PlaySound$1 start.*/
            PlaySound$1: function (clip, loop, delay, volumeScale) {
if ( TRACE ) { TRACE( "SoundManager#PlaySound$1", this ); }

                if (loop === void 0) { loop = false; }
                if (delay === void 0) { delay = 0.0; }
                if (volumeScale === void 0) { volumeScale = 1.0; }
                if (UserConfig.Instance.Sound) {
                    if (!(clip == null)) {
                        this.sound.loop = loop;
                        if (delay > 0.0) {
                            this.StartCoroutine$1(this.PlaySoundDelay(clip, delay, volumeScale));
                        } else if (this.SetStartTime(clip.GetInstanceID())) {
                            if (!loop) {
                                this.sound.PlayOneShot$1(clip, volumeScale);
                            } else {
                                this.sound.clip = clip;
                                this.sound.Play();
                            }
                        }
                    }
                }
            },
            /*SoundManager.PlaySound$1 end.*/

            /*SoundManager.PlaySoundDelay start.*/
            PlaySoundDelay: function (clip, delay, volumeScale) {
if ( TRACE ) { TRACE( "SoundManager#PlaySoundDelay", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    if (delay === void 0) { delay = 0.0; }
                                        if (volumeScale === void 0) { volumeScale = 1.0; }
                                        $enumerator.current = new UnityEngine.WaitForSecondsRealtime(delay);
                                        $step = 1;
                                        return true;
                                }
                                case 1: {
                                    this.PlaySound$1(clip, false, 0.0, volumeScale);

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*SoundManager.PlaySoundDelay end.*/

            /*SoundManager.SetStartTime start.*/
            SetStartTime: function (audio) {
if ( TRACE ) { TRACE( "SoundManager#SetStartTime", this ); }

                if (!this._startTimes.containsKey(audio)) {
                    this._startTimes.setItem(audio, 0.0);
                }
                if (UnityEngine.Time.time - this._startTimes.getItem(audio) > 0.1) {
                    this._startTimes.setItem(audio, UnityEngine.Time.time);
                    return true;
                }
                return false;
            },
            /*SoundManager.SetStartTime end.*/


        },
        overloads: {
            "PlaySound(AudioClip, bool, float, float)": "PlaySound$1"
        }
    });
    /*SoundManager end.*/

    /*Spine.ISlotTimeline start.*/
    /** @namespace Spine */

    /**
     * An interface for timelines which change the property of a slot.
     *
     * @abstract
     * @public
     * @class Spine.ISlotTimeline
     */
    Bridge.define("Spine.ISlotTimeline", {
        $kind: 3
    });
    /*Spine.ISlotTimeline end.*/

    /*Spine.Timeline start.*/
    /**
     * The base class for all timelines.
     *
     * @abstract
     * @public
     * @class Spine.Timeline
     */
    Bridge.define("Spine.Timeline", {
        statics: {
            methods: {
                /*Spine.Timeline.Search:static start.*/
                
                Search: function (frames, time) {
if ( TRACE ) { TRACE( "Spine.Timeline#Search", this ); }

                    var n = frames.length;
                    for (var i = 1; i < n; i = (i + 1) | 0) {
                        if (frames[i] > time) {
                            return ((i - 1) | 0);
                        }
                    }
                    return ((n - 1) | 0);
                },
                /*Spine.Timeline.Search:static end.*/

                /*Spine.Timeline.Search$1:static start.*/
                
                Search$1: function (frames, time, step) {
if ( TRACE ) { TRACE( "Spine.Timeline#Search$1", this ); }

                    var n = frames.length;
                    for (var i = step; i < n; i = (i + step) | 0) {
                        if (frames[i] > time) {
                            return ((i - step) | 0);
                        }
                    }
                    return ((n - step) | 0);
                },
                /*Spine.Timeline.Search$1:static end.*/


            }
        },
        fields: {
            propertyIds: null,
            frames: null
        },
        props: {
            /**
             * Uniquely encodes both the type of this timeline and the skeleton properties that it affects.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Timeline
             * @function PropertyIds
             * @type Array.<string>
             */
            PropertyIds: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Timeline#PropertyIds#get", this ); }

                    return this.propertyIds;
                }
            },
            /**
             * The time in seconds and any other values for each frame.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Timeline
             * @function Frames
             * @type Array.<number>
             */
            Frames: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Timeline#Frames#get", this ); }

                    return this.frames;
                }
            },
            /**
             * The number of entries stored per frame.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Timeline
             * @function FrameEntries
             * @type number
             */
            FrameEntries: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Timeline#FrameEntries#get", this ); }

                    return 1;
                }
            },
            /**
             * The number of frames for this timeline.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Timeline
             * @function FrameCount
             * @type number
             */
            FrameCount: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Timeline#FrameCount#get", this ); }

                    return ((Bridge.Int.div(this.frames.length, this.FrameEntries)) | 0);
                }
            },
            Duration: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Timeline#Duration#get", this ); }

                    return this.frames[((this.frames.length - this.FrameEntries) | 0)];
                }
            }
        },
        ctors: {
            /**
             * @instance
             * @public
             * @this Spine.Timeline
             * @memberof Spine.Timeline
             * @param   {number}            frameCount     
             * @param   {Array.<string>}    propertyIds    Unique identifiers for the properties the timeline modifies.
             * @return  {void}
             */
            ctor: function (frameCount, propertyIds) {
if ( TRACE ) { TRACE( "Spine.Timeline#ctor", this ); }

                if (propertyIds === void 0) { propertyIds = []; }

                this.$initialize();
                if (propertyIds == null) {
                    throw new System.ArgumentNullException.$ctor3("propertyIds", "propertyIds cannot be null.");
                }
                this.propertyIds = propertyIds;
                this.frames = System.Array.init(Bridge.Int.mul(frameCount, this.FrameEntries), 0, System.Single);
            }
        }
    });
    /*Spine.Timeline end.*/

    /*Spine.Animation start.*/
    /**
     * Stores a list of timelines to animate a skeleton's pose over time.
     *
     * @public
     * @class Spine.Animation
     */
    Bridge.define("Spine.Animation", {
        fields: {
            name: null,
            timelines: null,
            timelineIds: null,
            duration: 0
        },
        props: {
            Timelines: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Animation#Timelines#get", this ); }

                    return this.timelines;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Animation#Timelines#set", this ); }

                    this.SetTimelines(value);
                }
            },
            /**
             * The duration of the animation in seconds, which is usually the highest time of all frames in the timeline. The duration is
             used to know when it has completed and when it should loop back to the start.
             *
             * @instance
             * @public
             * @memberof Spine.Animation
             * @function Duration
             * @type number
             */
            Duration: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Animation#Duration#get", this ); }

                    return this.duration;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Animation#Duration#set", this ); }

                    this.duration = value;
                }
            },
            /**
             * The animation's name, which is unique across all animations in the skeleton.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Animation
             * @function Name
             * @type string
             */
            Name: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Animation#Name#get", this ); }

                    return this.name;
                }
            }
        },
        ctors: {
            ctor: function (name, timelines, duration) {
if ( TRACE ) { TRACE( "Spine.Animation#ctor", this ); }

                this.$initialize();
                if (name == null) {
                    throw new System.ArgumentNullException.$ctor3("name", "name cannot be null.");
                }

                this.name = name;
                this.SetTimelines(timelines);
                this.duration = duration;
            }
        },
        methods: {
            /*Spine.Animation.SetTimelines start.*/
            SetTimelines: function (timelines) {
if ( TRACE ) { TRACE( "Spine.Animation#SetTimelines", this ); }

                if (timelines == null) {
                    throw new System.ArgumentNullException.$ctor3("timelines", "timelines cannot be null.");
                }
                this.timelines = timelines;
                // Note: avoiding reallocations by adding all hash set entries at
                // once (EnsureCapacity() is only available in newer .Net versions).
                var idCount = 0;
                var timelinesCount = timelines.Count;
                var timelinesItems = timelines.Items;
                for (var t = 0; t < timelinesCount; t = (t + 1) | 0) {
                    idCount = (idCount + timelinesItems[t].PropertyIds.length) | 0;
                }
                var propertyIds = System.Array.init(idCount, null, System.String);
                var currentId = 0;
                for (var t1 = 0; t1 < timelinesCount; t1 = (t1 + 1) | 0) {
                    var ids = timelinesItems[t1].PropertyIds;
                    for (var i = 0, idsLength = ids.length; i < idsLength; i = (i + 1) | 0) {
                        propertyIds[Bridge.identity(currentId, ((currentId = (currentId + 1) | 0)))] = ids[i];
                    }
                }
                this.timelineIds = new (System.Collections.Generic.HashSet$1(System.String)).$ctor1(propertyIds);
            },
            /*Spine.Animation.SetTimelines end.*/

            /*Spine.Animation.HasTimeline start.*/
            /**
             * Returns true if this animation contains a timeline with any of the specified property IDs.
             *
             * @instance
             * @public
             * @this Spine.Animation
             * @memberof Spine.Animation
             * @param   {Array.<string>}    propertyIds
             * @return  {boolean}
             */
            HasTimeline: function (propertyIds) {
if ( TRACE ) { TRACE( "Spine.Animation#HasTimeline", this ); }

                var $t;
                $t = Bridge.getEnumerator(propertyIds);
                try {
                    while ($t.moveNext()) {
                        var id = $t.Current;
                        if (this.timelineIds.contains(id)) {
                            return true;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                return false;
            },
            /*Spine.Animation.HasTimeline end.*/

            /*Spine.Animation.Apply start.*/
            
            Apply: function (skeleton, lastTime, time, loop, events, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.Animation#Apply", this ); }

                if (skeleton == null) {
                    throw new System.ArgumentNullException.$ctor3("skeleton", "skeleton cannot be null.");
                }

                if (loop && this.duration !== 0) {
                    time %= this.duration;
                    if (lastTime > 0) {
                        lastTime %= this.duration;
                    }
                }

                var timelines = this.timelines.Items;
                for (var i = 0, n = this.timelines.Count; i < n; i = (i + 1) | 0) {
                    timelines[i].Apply(skeleton, lastTime, time, events, alpha, blend, direction);
                }
            },
            /*Spine.Animation.Apply end.*/

            /*Spine.Animation.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.Animation#toString", this ); }

                return this.name;
            },
            /*Spine.Animation.toString end.*/


        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.Animation end.*/
    /**
     * @memberof Spine
     * @callback Spine.AnimationState.TrackEntryDelegate
     * @param   {Spine.TrackEntry}    trackEntry
     * @return  {void}
     */


    /*Spine.AnimationState start.*/
    /**
     * <p>Applies animations over time, queues animations for later playback, mixes (crossfading) between animations, and applies
     multiple animations on top of each other (layering).</p><p>See <a href="http://esotericsoftware.com/spine-applying-animations/">Applying Animations</a> in the Spine Runtimes Guide.</p>
     *
     * @public
     * @class Spine.AnimationState
     */
    Bridge.define("Spine.AnimationState", {
        statics: {
            fields: {
                /**
                 * @static
                 * @memberof Spine.AnimationState
                 * @constant
                 * @default 0
                 * @type number
                 */
                Subsequent: 0,
                /**
                 * @static
                 * @memberof Spine.AnimationState
                 * @constant
                 * @default 1
                 * @type number
                 */
                First: 0,
                
                HoldSubsequent: 0,
                /**
                 * @static
                 * @memberof Spine.AnimationState
                 * @constant
                 * @default 3
                 * @type number
                 */
                HoldFirst: 0,
                /**
                 * @static
                 * @memberof Spine.AnimationState
                 * @constant
                 * @default 4
                 * @type number
                 */
                HoldMix: 0,
                Setup: 0,
                Current: 0,
                EmptyAnimation: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.AnimationState#init", this ); }

                    this.Subsequent = 0;
                    this.First = 1;
                    this.HoldSubsequent = 2;
                    this.HoldFirst = 3;
                    this.HoldMix = 4;
                    this.Setup = 1;
                    this.Current = 2;
                    this.EmptyAnimation = new Spine.Animation("<empty>", new (Spine.ExposedList$1(Spine.Timeline)).ctor(), 0);
                }
            },
            methods: {
                /*Spine.AnimationState.ApplyRotateTimeline:static start.*/
                /**
                 * Applies the rotate timeline, mixing with the current pose while keeping the same rotation direction chosen as the shortest
                 the first time the mixing was applied.
                 *
                 * @static
                 * @private
                 * @this Spine.AnimationState
                 * @memberof Spine.AnimationState
                 * @param   {Spine.RotateTimeline}    timeline             
                 * @param   {Spine.Skeleton}          skeleton             
                 * @param   {number}                  time                 
                 * @param   {number}                  alpha                
                 * @param   {Spine.MixBlend}          blend                
                 * @param   {Array.<number>}          timelinesRotation    
                 * @param   {number}                  i                    
                 * @param   {boolean}                 firstFrame
                 * @return  {void}
                 */
                ApplyRotateTimeline: function (timeline, skeleton, time, alpha, blend, timelinesRotation, i, firstFrame) {
if ( TRACE ) { TRACE( "Spine.AnimationState#ApplyRotateTimeline", this ); }

                    var $step = 0,
                        $jumpFromFinally, 
                        bone, 
                        $t, 
                        frames, 
                        r1, 
                        r2, 
                        total, 
                        diff, 
                        lastTotal, 
                        lastDiff, 
                        loops, 
                        current, 
                        dir, 
                        $asyncBody = Bridge.fn.bind(this, function () {
                            for (;;) {
                                $step = System.Array.min([0,1,2,3,4,5,6,7], $step);
                                switch ($step) {
                                    case 0: {
                                        if (firstFrame) {
                                            timelinesRotation[i] = 0;
                                        }

                                        if (alpha === 1) {
                                            timeline.Apply(skeleton, 0, time, null, 1, blend, Spine.MixDirection.In);
                                            return;
                                        }

                                        bone = ($t = skeleton.bones.Items)[timeline.BoneIndex];
                                        if (!bone.active) {
                                            return;
                                        }

                                        frames = timeline.frames;
                                        if (time < frames[0]) {
                                            $step = 1;
                                            continue;
                                        } else  {
                                            $step = 6;
                                            continue;
                                        }
                                    }
                                    case 1: {
                                        // Time is before first frame.
                                        if (blend === Spine.MixBlend.Setup) {
                                            $step = 2;
                                            continue;
                                        }
                                        else if (blend === Spine.MixBlend.First) {
                                            $step = 3;
                                            continue;
                                        }
                                        else  {
                                            $step = 4;
                                            continue;
                                        }
                                        $step = 5;
                                        continue;
                                    }
                                    case 2: {
                                        bone.rotation = bone.data.rotation;
                                        $step = 4;
                                        continue;
                                    }
                                    case 3: {
                                        r1 = bone.rotation;
                                        r2 = bone.data.rotation;
                                        $step = 5;
                                        continue;
                                    }
                                    case 4: {
                                        return;
                                    }
                                    case 5: {
                                        $step = 7;
                                        continue;
                                    }
                                    case 6: {
                                        r1 = blend === Spine.MixBlend.Setup ? bone.data.rotation : bone.rotation;
                                        r2 = bone.data.rotation + timeline.GetCurveValue(time);
                                        $step = 7;
                                        continue;
                                    }
                                    case 7: {
                                        // Mix between rotations using the direction of the shortest route on the first frame.
                                        ;
                                        diff = r2 - r1;
                                        diff -= Math.ceil(diff / 360 - 0.5) * 360;
                                        if (diff === 0) {
                                            total = timelinesRotation[i];
                                        } else {
                                            if (firstFrame) {
                                                lastTotal = 0;
                                                lastDiff = diff;
                                            } else {
                                                lastTotal = timelinesRotation[i];
                                                lastDiff = timelinesRotation[((i + 1) | 0)];
                                            }
                                            loops = lastTotal - lastTotal % 360;
                                            total = diff + loops;
                                            current = diff >= 0;
                                            dir = lastTotal >= 0;
                                            if (Math.abs(lastDiff) <= 90 && Bridge.Int.sign(lastDiff) !== Bridge.Int.sign(diff)) {
                                                if (Math.abs(lastTotal - loops) > 180) {
                                                    total += Bridge.Int.mul(360, Bridge.Int.sign(lastTotal));
                                                    dir = current;
                                                } else if (loops !== 0) {
                                                    total -= Bridge.Int.mul(360, Bridge.Int.sign(lastTotal));
                                                } else {
                                                    dir = current;
                                                }
                                            }
                                            if (dir !== current) {
                                                total += Bridge.Int.mul(360, Bridge.Int.sign(lastTotal));
                                            }
                                            timelinesRotation[i] = total;
                                        }
                                        timelinesRotation[((i + 1) | 0)] = diff;
                                        bone.rotation = r1 + total * alpha;
                                        return;
                                    }
                                    default: {
                                        return;
                                    }
                                }
                            }
                        }, arguments);

                    return $asyncBody();
                },
                /*Spine.AnimationState.ApplyRotateTimeline:static end.*/


            }
        },
        fields: {
            data: null,
            tracks: null,
            events: null,
            queue: null,
            propertyIds: null,
            animationsChanged: false,
            timeScale: 0,
            unkeyedState: 0,
            trackEntryPool: null
        },
        events: {
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @function addStart
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @function removeStart
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @function addInterrupt
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @function removeInterrupt
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @function addEnd
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @function removeEnd
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @function addDispose
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @function removeDispose
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @function addComplete
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @function removeComplete
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            Start: null,
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @function addStart
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @function removeStart
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @function addInterrupt
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @function removeInterrupt
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @function addEnd
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @function removeEnd
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @function addDispose
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @function removeDispose
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @function addComplete
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @function removeComplete
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            Interrupt: null,
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @function addStart
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @function removeStart
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @function addInterrupt
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @function removeInterrupt
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @function addEnd
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @function removeEnd
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @function addDispose
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @function removeDispose
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @function addComplete
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @function removeComplete
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            End: null,
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @function addStart
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @function removeStart
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @function addInterrupt
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @function removeInterrupt
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @function addEnd
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @function removeEnd
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @function addDispose
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @function removeDispose
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @function addComplete
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @function removeComplete
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            Dispose: null,
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @function addStart
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @function removeStart
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @function addInterrupt
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @function removeInterrupt
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @function addEnd
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @function removeEnd
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @function addDispose
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @function removeDispose
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @function addComplete
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @function removeComplete
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            Complete: null,
            Event: null
        },
        props: {
            /**
             * <p>Multiplier for the delta time when the animation state is updated, causing time for all animations and mixes to play slower
             or faster. Defaults to 1.</p><p>See TrackEntry {@link } for affecting a single animation.</p>
             *
             * @instance
             * @public
             * @memberof Spine.AnimationState
             * @function TimeScale
             * @type number
             */
            TimeScale: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.AnimationState#TimeScale#get", this ); }

                    return this.timeScale;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.AnimationState#TimeScale#set", this ); }

                    this.timeScale = value;
                }
            },
            /**
             * The {@link } to look up mix durations.
             *
             * @instance
             * @public
             * @memberof Spine.AnimationState
             * @function Data
             * @type Spine.AnimationStateData
             */
            Data: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.AnimationState#Data#get", this ); }

                    return this.data;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.AnimationState#Data#set", this ); }

                    if (this.data == null) {
                        throw new System.ArgumentNullException.$ctor3("data", "data cannot be null.");
                    }
                    this.data = value;
                }
            },
            /**
             * A list of tracks that have animations, which may contain nulls.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.AnimationState
             * @function Tracks
             * @type Spine.ExposedList$1
             */
            Tracks: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.AnimationState#Tracks#get", this ); }

                    return this.tracks;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.AnimationState#init", this ); }

                this.tracks = new (Spine.ExposedList$1(Spine.TrackEntry)).ctor();
                this.events = new (Spine.ExposedList$1(Spine.Event)).ctor();
                this.propertyIds = new (System.Collections.Generic.HashSet$1(System.String)).ctor();
                this.timeScale = 1;
                this.trackEntryPool = new (Spine.Pool$1(Spine.TrackEntry))();
            },
            ctor: function (data) {
if ( TRACE ) { TRACE( "Spine.AnimationState#ctor", this ); }

                this.$initialize();
                if (data == null) {
                    throw new System.ArgumentNullException.$ctor3("data", "data cannot be null.");
                }
                this.data = data;
                this.queue = new Spine.EventQueue(this, Bridge.fn.bind(this, function () {
                    this.animationsChanged = true;
                }), this.trackEntryPool);
            }
        },
        methods: {
            /*Spine.AnimationState.OnStart start.*/
            OnStart: function (entry) {
if ( TRACE ) { TRACE( "Spine.AnimationState#OnStart", this ); }

                if (!Bridge.staticEquals(this.Start, null)) {
                    this.Start(entry);
                }
            },
            /*Spine.AnimationState.OnStart end.*/

            /*Spine.AnimationState.OnInterrupt start.*/
            OnInterrupt: function (entry) {
if ( TRACE ) { TRACE( "Spine.AnimationState#OnInterrupt", this ); }

                if (!Bridge.staticEquals(this.Interrupt, null)) {
                    this.Interrupt(entry);
                }
            },
            /*Spine.AnimationState.OnInterrupt end.*/

            /*Spine.AnimationState.OnEnd start.*/
            OnEnd: function (entry) {
if ( TRACE ) { TRACE( "Spine.AnimationState#OnEnd", this ); }

                if (!Bridge.staticEquals(this.End, null)) {
                    this.End(entry);
                }
            },
            /*Spine.AnimationState.OnEnd end.*/

            /*Spine.AnimationState.OnDispose start.*/
            OnDispose: function (entry) {
if ( TRACE ) { TRACE( "Spine.AnimationState#OnDispose", this ); }

                if (!Bridge.staticEquals(this.Dispose, null)) {
                    this.Dispose(entry);
                }
            },
            /*Spine.AnimationState.OnDispose end.*/

            /*Spine.AnimationState.OnComplete start.*/
            OnComplete: function (entry) {
if ( TRACE ) { TRACE( "Spine.AnimationState#OnComplete", this ); }

                if (!Bridge.staticEquals(this.Complete, null)) {
                    this.Complete(entry);
                }
            },
            /*Spine.AnimationState.OnComplete end.*/

            /*Spine.AnimationState.OnEvent start.*/
            OnEvent: function (entry, e) {
if ( TRACE ) { TRACE( "Spine.AnimationState#OnEvent", this ); }

                if (!Bridge.staticEquals(this.Event, null)) {
                    this.Event(entry, e);
                }
            },
            /*Spine.AnimationState.OnEvent end.*/

            /*Spine.AnimationState.AssignEventSubscribersFrom start.*/
            AssignEventSubscribersFrom: function (src) {
if ( TRACE ) { TRACE( "Spine.AnimationState#AssignEventSubscribersFrom", this ); }

                this.Event = src.Event;
                this.Start = src.Start;
                this.Interrupt = src.Interrupt;
                this.End = src.End;
                this.Dispose = src.Dispose;
                this.Complete = src.Complete;
            },
            /*Spine.AnimationState.AssignEventSubscribersFrom end.*/

            /*Spine.AnimationState.AddEventSubscribersFrom start.*/
            AddEventSubscribersFrom: function (src) {
if ( TRACE ) { TRACE( "Spine.AnimationState#AddEventSubscribersFrom", this ); }

                this.addEvent(src.Event);
                this.addStart(src.Start);
                this.addInterrupt(src.Interrupt);
                this.addEnd(src.End);
                this.addDispose(src.Dispose);
                this.addComplete(src.Complete);
            },
            /*Spine.AnimationState.AddEventSubscribersFrom end.*/

            /*Spine.AnimationState.Update start.*/
            /**
             * Increments the track entry {@link }, setting queued animations as current if needed.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @param   {number}    delta    delta time
             * @return  {void}
             */
            Update: function (delta) {
if ( TRACE ) { TRACE( "Spine.AnimationState#Update", this ); }

                delta *= this.timeScale;
                var tracksItems = this.tracks.Items;
                for (var i = 0, n = this.tracks.Count; i < n; i = (i + 1) | 0) {
                    var current = tracksItems[i];
                    if (current == null) {
                        continue;
                    }

                    current.animationLast = current.nextAnimationLast;
                    current.trackLast = current.nextTrackLast;

                    var currentDelta = delta * current.timeScale;

                    if (current.delay > 0) {
                        current.delay -= currentDelta;
                        if (current.delay > 0) {
                            continue;
                        }
                        currentDelta = -current.delay;
                        current.delay = 0;
                    }

                    var next = current.next;
                    if (next != null) {
                        // When the next entry's delay is passed, change to the next entry, preserving leftover time.
                        var nextTime = current.trackLast - next.delay;
                        if (nextTime >= 0) {
                            next.delay = 0;
                            next.trackTime += current.timeScale === 0 ? 0 : (nextTime / current.timeScale + delta) * next.timeScale;
                            current.trackTime += currentDelta;
                            this.SetCurrent(i, next, true);
                            while (next.mixingFrom != null) {
                                next.mixTime += delta;
                                next = next.mixingFrom;
                            }
                            continue;
                        }
                    } else if (current.trackLast >= current.trackEnd && current.mixingFrom == null) {
                        // Clear the track when there is no next entry, the track end time is reached, and there is no mixingFrom.
                        tracksItems[i] = null;
                        this.queue.End(current);
                        this.ClearNext(current);
                        continue;
                    }
                    if (current.mixingFrom != null && this.UpdateMixingFrom(current, delta)) {
                        // End mixing from entries once all have completed.
                        var from = current.mixingFrom;
                        current.mixingFrom = null;
                        if (from != null) {
                            from.mixingTo = null;
                        }
                        while (from != null) {
                            this.queue.End(from);
                            from = from.mixingFrom;
                        }
                    }

                    current.trackTime += currentDelta;
                }

                this.queue.Drain();
            },
            /*Spine.AnimationState.Update end.*/

            /*Spine.AnimationState.UpdateMixingFrom start.*/
            /**
             * Returns true when all mixing from entries are complete.
             *
             * @instance
             * @private
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @param   {Spine.TrackEntry}    to       
             * @param   {number}              delta
             * @return  {boolean}
             */
            UpdateMixingFrom: function (to, delta) {
if ( TRACE ) { TRACE( "Spine.AnimationState#UpdateMixingFrom", this ); }

                var from = to.mixingFrom;
                if (from == null) {
                    return true;
                }

                var finished = this.UpdateMixingFrom(from, delta);

                from.animationLast = from.nextAnimationLast;
                from.trackLast = from.nextTrackLast;

                // Require mixTime > 0 to ensure the mixing from entry was applied at least once.
                if (to.mixTime > 0 && to.mixTime >= to.mixDuration) {
                    // Require totalAlpha == 0 to ensure mixing is complete, unless mixDuration == 0 (the transition is a single frame).
                    if (from.totalAlpha === 0 || to.mixDuration === 0) {
                        to.mixingFrom = from.mixingFrom;
                        if (from.mixingFrom != null) {
                            from.mixingFrom.mixingTo = to;
                        }
                        to.interruptAlpha = from.interruptAlpha;
                        this.queue.End(from);
                    }
                    return finished;
                }

                from.trackTime += delta * from.timeScale;
                to.mixTime += delta;
                return false;
            },
            /*Spine.AnimationState.UpdateMixingFrom end.*/

            /*Spine.AnimationState.Apply start.*/
            /**
             * Poses the skeleton using the track entry animations.  The animation state is not changed, so can be applied to multiple
             skeletons to pose them identically.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @param   {Spine.Skeleton}    skeleton
             * @return  {boolean}                       True if any animations were applied.
             */
            Apply: function (skeleton) {
if ( TRACE ) { TRACE( "Spine.AnimationState#Apply", this ); }

                if (skeleton == null) {
                    throw new System.ArgumentNullException.$ctor3("skeleton", "skeleton cannot be null.");
                }
                if (this.animationsChanged) {
                    this.AnimationsChanged();
                }

                var events = this.events;
                var applied = false;
                var tracksItems = this.tracks.Items;
                for (var i = 0, n = this.tracks.Count; i < n; i = (i + 1) | 0) {
                    var current = tracksItems[i];
                    if (current == null || current.delay > 0) {
                        continue;
                    }
                    applied = true;

                    // Track 0 animations aren't for layering, so do not show the previously applied animations before the first key.
                    var blend = i === 0 ? Spine.MixBlend.First : current.mixBlend;

                    // Apply mixing from entries first.
                    var alpha = current.alpha;
                    if (current.mixingFrom != null) {
                        alpha *= this.ApplyMixingFrom(current, skeleton, blend);
                    } else {
                        if (current.trackTime >= current.trackEnd && current.next == null) {
                            alpha = 0;
                        }
                    } // Set to setup pose the last time the entry will be applied.
                    var attachments = alpha >= current.alphaAttachmentThreshold;

                    // Apply current entry.
                    var animationLast = current.animationLast, animationTime = current.AnimationTime, applyTime = animationTime;
                    var applyEvents = events;
                    if (current.reverse) {
                        applyTime = current.animation.duration - applyTime;
                        applyEvents = null;
                    }

                    var timelineCount = current.animation.timelines.Count;
                    var timelines = current.animation.timelines.Items;
                    if ((i === 0 && alpha === 1) || blend === Spine.MixBlend.Add) {
                        if (i === 0) {
                            attachments = true;
                        }
                        for (var ii = 0; ii < timelineCount; ii = (ii + 1) | 0) {
                            var timeline = timelines[ii];
                            if (Bridge.is(timeline, Spine.AttachmentTimeline)) {
                                this.ApplyAttachmentTimeline(Bridge.cast(timeline, Spine.AttachmentTimeline), skeleton, applyTime, blend, attachments);
                            } else {
                                timeline.Apply(skeleton, animationLast, applyTime, applyEvents, alpha, blend, Spine.MixDirection.In);
                            }
                        }
                    } else {
                        var timelineMode = current.timelineMode.Items;

                        var shortestRotation = current.shortestRotation;
                        var firstFrame = !shortestRotation && current.timelinesRotation.Count !== timelineCount << 1;
                        if (firstFrame) {
                            current.timelinesRotation.Resize(timelineCount << 1);
                        }
                        var timelinesRotation = current.timelinesRotation.Items;

                        for (var ii1 = 0; ii1 < timelineCount; ii1 = (ii1 + 1) | 0) {
                            var timeline1 = timelines[ii1];
                            var timelineBlend = timelineMode[ii1] === Spine.AnimationState.Subsequent ? blend : Spine.MixBlend.Setup;
                            var rotateTimeline = Bridge.as(timeline1, Spine.RotateTimeline);
                            if (!shortestRotation && rotateTimeline != null) {
                                Spine.AnimationState.ApplyRotateTimeline(rotateTimeline, skeleton, applyTime, alpha, timelineBlend, timelinesRotation, ii1 << 1, firstFrame);
                            } else {
                                if (Bridge.is(timeline1, Spine.AttachmentTimeline)) {
                                    this.ApplyAttachmentTimeline(Bridge.cast(timeline1, Spine.AttachmentTimeline), skeleton, applyTime, blend, attachments);
                                } else {
                                    timeline1.Apply(skeleton, animationLast, applyTime, applyEvents, alpha, timelineBlend, Spine.MixDirection.In);
                                }
                            }
                        }
                    }
                    this.QueueEvents(current, animationTime);
                    events.Clear(false);
                    current.nextAnimationLast = animationTime;
                    current.nextTrackLast = current.trackTime;
                }

                // Set slots attachments to the setup pose, if needed. This occurs if an animation that is mixing out sets attachments so
                // subsequent timelines see any deform, but the subsequent timelines don't set an attachment (eg they are also mixing out or
                // the time is before the first key).
                var setupState = (this.unkeyedState + Spine.AnimationState.Setup) | 0;
                var slots = skeleton.slots.Items;
                for (var i1 = 0, n1 = skeleton.slots.Count; i1 < n1; i1 = (i1 + 1) | 0) {
                    var slot = slots[i1];
                    if (slot.attachmentState === setupState) {
                        var attachmentName = slot.data.attachmentName;
                        slot.Attachment = (attachmentName == null ? null : skeleton.GetAttachment(slot.data.index, attachmentName));
                    }
                }
                this.unkeyedState = (this.unkeyedState + 2) | 0; // Increasing after each use avoids the need to reset attachmentState for every slot.

                this.queue.Drain();
                return applied;
            },
            /*Spine.AnimationState.Apply end.*/

            /*Spine.AnimationState.ApplyEventTimelinesOnly start.*/
            /**
             * Version of {@link } only applying and updating time at
             EventTimelines for lightweight off-screen updates.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @param   {Spine.Skeleton}    skeleton       
             * @param   {boolean}           issueEvents    When set to false, only animation times of TrackEntries are updated.
             * @return  {boolean}
             */
            ApplyEventTimelinesOnly: function (skeleton, issueEvents) {
if ( TRACE ) { TRACE( "Spine.AnimationState#ApplyEventTimelinesOnly", this ); }

                if (issueEvents === void 0) { issueEvents = true; }
                if (skeleton == null) {
                    throw new System.ArgumentNullException.$ctor3("skeleton", "skeleton cannot be null.");
                }

                var events = this.events;
                var applied = false;
                var tracksItems = this.tracks.Items;
                for (var i = 0, n = this.tracks.Count; i < n; i = (i + 1) | 0) {
                    var current = tracksItems[i];
                    if (current == null || current.delay > 0) {
                        continue;
                    }
                    applied = true;

                    // Apply mixing from entries first.
                    if (current.mixingFrom != null) {
                        this.ApplyMixingFromEventTimelinesOnly(current, skeleton, issueEvents);
                    }

                    // Apply current entry.
                    var animationLast = current.animationLast, animationTime = current.AnimationTime;

                    if (issueEvents) {
                        var timelineCount = current.animation.timelines.Count;
                        var timelines = current.animation.timelines.Items;
                        for (var ii = 0; ii < timelineCount; ii = (ii + 1) | 0) {
                            var timeline = timelines[ii];
                            if (Bridge.is(timeline, Spine.EventTimeline)) {
                                timeline.Apply(skeleton, animationLast, animationTime, events, 1.0, Spine.MixBlend.Setup, Spine.MixDirection.In);
                            }
                        }
                        this.QueueEvents(current, animationTime);
                        events.Clear(false);
                    }
                    current.nextAnimationLast = animationTime;
                    current.nextTrackLast = current.trackTime;
                }

                if (issueEvents) {
                    this.queue.Drain();
                }
                return applied;
            },
            /*Spine.AnimationState.ApplyEventTimelinesOnly end.*/

            /*Spine.AnimationState.ApplyMixingFrom start.*/
            ApplyMixingFrom: function (to, skeleton, blend) {
if ( TRACE ) { TRACE( "Spine.AnimationState#ApplyMixingFrom", this ); }

                var from = to.mixingFrom;
                if (from.mixingFrom != null) {
                    this.ApplyMixingFrom(from, skeleton, blend);
                }

                var mix;
                if (to.mixDuration === 0) { // Single frame mix to undo mixingFrom changes.
                    mix = 1;
                    if (blend === Spine.MixBlend.First) {
                        blend = Spine.MixBlend.Setup;
                    } // Tracks > 0 are transparent and can't reset to setup pose.
                } else {
                    mix = to.mixTime / to.mixDuration;
                    if (mix > 1) {
                        mix = 1;
                    }
                    if (blend !== Spine.MixBlend.First) {
                        blend = from.mixBlend;
                    } // Track 0 ignores track mix blend.
                }

                var attachments = mix < from.mixAttachmentThreshold, drawOrder = mix < from.mixDrawOrderThreshold;
                var timelineCount = from.animation.timelines.Count;
                var timelines = from.animation.timelines.Items;
                var alphaHold = from.alpha * to.interruptAlpha, alphaMix = alphaHold * (1 - mix);
                var animationLast = from.animationLast, animationTime = from.AnimationTime, applyTime = animationTime;
                var events = null;
                if (from.reverse) {
                    applyTime = from.animation.duration - applyTime;
                } else {
                    if (mix < from.eventThreshold) {
                        events = this.events;
                    }
                }

                if (blend === Spine.MixBlend.Add) {
                    for (var i = 0; i < timelineCount; i = (i + 1) | 0) {
                        timelines[i].Apply(skeleton, animationLast, applyTime, events, alphaMix, blend, Spine.MixDirection.Out);
                    }
                } else {
                    var timelineMode = from.timelineMode.Items;
                    var timelineHoldMix = from.timelineHoldMix.Items;

                    var shortestRotation = from.shortestRotation;
                    var firstFrame = !shortestRotation && from.timelinesRotation.Count !== timelineCount << 1;
                    if (firstFrame) {
                        from.timelinesRotation.Resize(timelineCount << 1);
                    }
                    var timelinesRotation = from.timelinesRotation.Items;

                    from.totalAlpha = 0;
                    for (var i1 = 0; i1 < timelineCount; i1 = (i1 + 1) | 0) {
                        var timeline = timelines[i1];
                        var direction = Spine.MixDirection.Out;
                        var timelineBlend = new Spine.MixBlend();
                        var alpha;
                        switch (timelineMode[i1]) {
                            case Spine.AnimationState.Subsequent: 
                                if (!drawOrder && Bridge.is(timeline, Spine.DrawOrderTimeline)) {
                                    continue;
                                }
                                timelineBlend = blend;
                                alpha = alphaMix;
                                break;
                            case Spine.AnimationState.First: 
                                timelineBlend = Spine.MixBlend.Setup;
                                alpha = alphaMix;
                                break;
                            case Spine.AnimationState.HoldSubsequent: 
                                timelineBlend = blend;
                                alpha = alphaHold;
                                break;
                            case Spine.AnimationState.HoldFirst: 
                                timelineBlend = Spine.MixBlend.Setup;
                                alpha = alphaHold;
                                break;
                            default:  // HoldMix
                                timelineBlend = Spine.MixBlend.Setup;
                                var holdMix = timelineHoldMix[i1];
                                alpha = alphaHold * Math.max(0, 1 - holdMix.mixTime / holdMix.mixDuration);
                                break;
                        }
                        from.totalAlpha += alpha;
                        var rotateTimeline = Bridge.as(timeline, Spine.RotateTimeline);
                        if (!shortestRotation && rotateTimeline != null) {
                            Spine.AnimationState.ApplyRotateTimeline(rotateTimeline, skeleton, applyTime, alpha, timelineBlend, timelinesRotation, i1 << 1, firstFrame);
                        } else if (Bridge.is(timeline, Spine.AttachmentTimeline)) {
                            this.ApplyAttachmentTimeline(Bridge.cast(timeline, Spine.AttachmentTimeline), skeleton, applyTime, timelineBlend, attachments && alpha >= from.alphaAttachmentThreshold);
                        } else {
                            if (drawOrder && Bridge.is(timeline, Spine.DrawOrderTimeline) && timelineBlend === Spine.MixBlend.Setup) {
                                direction = Spine.MixDirection.In;
                            }
                            timeline.Apply(skeleton, animationLast, applyTime, events, alpha, timelineBlend, direction);
                        }
                    }
                }

                if (to.mixDuration > 0) {
                    this.QueueEvents(from, animationTime);
                }
                this.events.Clear(false);
                from.nextAnimationLast = animationTime;
                from.nextTrackLast = from.trackTime;

                return mix;
            },
            /*Spine.AnimationState.ApplyMixingFrom end.*/

            /*Spine.AnimationState.ApplyMixingFromEventTimelinesOnly start.*/
            /**
             * Version of {@link } only applying and updating time at
             EventTimelines for lightweight off-screen updates.
             *
             * @instance
             * @private
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @param   {Spine.TrackEntry}    to             
             * @param   {Spine.Skeleton}      skeleton       
             * @param   {boolean}             issueEvents    When set to false, only animation times of TrackEntries are updated.
             * @return  {number}
             */
            ApplyMixingFromEventTimelinesOnly: function (to, skeleton, issueEvents) {
if ( TRACE ) { TRACE( "Spine.AnimationState#ApplyMixingFromEventTimelinesOnly", this ); }

                var from = to.mixingFrom;
                if (from.mixingFrom != null) {
                    this.ApplyMixingFromEventTimelinesOnly(from, skeleton, issueEvents);
                }


                var mix;
                if (to.mixDuration === 0) { // Single frame mix to undo mixingFrom changes.
                    mix = 1;
                } else {
                    mix = to.mixTime / to.mixDuration;
                    if (mix > 1) {
                        mix = 1;
                    }
                }

                var eventBuffer = mix < from.eventThreshold ? this.events : null;
                if (eventBuffer == null) {
                    return mix;
                }

                var animationLast = from.animationLast, animationTime = from.AnimationTime;
                if (issueEvents) {
                    var timelineCount = from.animation.timelines.Count;
                    var timelines = from.animation.timelines.Items;
                    for (var i = 0; i < timelineCount; i = (i + 1) | 0) {
                        var timeline = timelines[i];
                        if (Bridge.is(timeline, Spine.EventTimeline)) {
                            timeline.Apply(skeleton, animationLast, animationTime, eventBuffer, 0, Spine.MixBlend.Setup, Spine.MixDirection.Out);
                        }
                    }

                    if (to.mixDuration > 0) {
                        this.QueueEvents(from, animationTime);
                    }
                    this.events.Clear(false);
                }
                from.nextAnimationLast = animationTime;
                from.nextTrackLast = from.trackTime;

                return mix;
            },
            /*Spine.AnimationState.ApplyMixingFromEventTimelinesOnly end.*/

            /*Spine.AnimationState.ApplyAttachmentTimeline start.*/
            
            ApplyAttachmentTimeline: function (timeline, skeleton, time, blend, attachments) {
if ( TRACE ) { TRACE( "Spine.AnimationState#ApplyAttachmentTimeline", this ); }

                var $t, $t1;

                var slot = ($t = skeleton.slots.Items)[timeline.SlotIndex];
                if (!slot.bone.active) {
                    return;
                }

                var frames = timeline.frames;
                if (time < frames[0]) { // Time is before first frame.
                    if (blend === Spine.MixBlend.Setup || blend === Spine.MixBlend.First) {
                        this.SetAttachment(skeleton, slot, slot.data.attachmentName, attachments);
                    }
                } else {
                    this.SetAttachment(skeleton, slot, ($t1 = timeline.AttachmentNames)[Spine.Timeline.Search(frames, time)], attachments);
                }

                // If an attachment wasn't set (ie before the first frame or attachments is false), set the setup attachment later.
                if (slot.attachmentState <= this.unkeyedState) {
                    slot.attachmentState = (this.unkeyedState + Spine.AnimationState.Setup) | 0;
                }
            },
            /*Spine.AnimationState.ApplyAttachmentTimeline end.*/

            /*Spine.AnimationState.SetAttachment start.*/
            SetAttachment: function (skeleton, slot, attachmentName, attachments) {
if ( TRACE ) { TRACE( "Spine.AnimationState#SetAttachment", this ); }

                slot.Attachment = attachmentName == null ? null : skeleton.GetAttachment(slot.data.index, attachmentName);
                if (attachments) {
                    slot.attachmentState = (this.unkeyedState + Spine.AnimationState.Current) | 0;
                }
            },
            /*Spine.AnimationState.SetAttachment end.*/

            /*Spine.AnimationState.QueueEvents start.*/
            QueueEvents: function (entry, animationTime) {
if ( TRACE ) { TRACE( "Spine.AnimationState#QueueEvents", this ); }

                var animationStart = entry.animationStart, animationEnd = entry.animationEnd;
                var duration = animationEnd - animationStart;
                var trackLastWrapped = entry.trackLast % duration;

                // Queue events before complete.
                var eventsItems = this.events.Items;
                var i = 0, n = this.events.Count;
                for (; i < n; i = (i + 1) | 0) {
                    var e = eventsItems[i];
                    if (e.time < trackLastWrapped) {
                        break;
                    }
                    if (e.time > animationEnd) {
                        continue;
                    } // Discard events outside animation start/end.
                    this.queue.Event(entry, e);
                }

                // Queue complete if completed a loop iteration or the animation.
                var complete = false;
                if (entry.loop) {
                    if (duration === 0) {
                        complete = true;
                    } else {
                        var cycles = Bridge.Int.clip32(entry.trackTime / duration);
                        complete = cycles > 0 && cycles > Bridge.Int.clip32((entry.trackLast / duration));
                    }
                } else {
                    complete = animationTime >= animationEnd && entry.animationLast < animationEnd;
                }
                if (complete) {
                    this.queue.Complete(entry);
                }

                // Queue events after complete.
                for (; i < n; i = (i + 1) | 0) {
                    var e1 = eventsItems[i];
                    if (e1.time < animationStart) {
                        continue;
                    } // Discard events outside animation start/end.
                    this.queue.Event(entry, eventsItems[i]);
                }
            },
            /*Spine.AnimationState.QueueEvents end.*/

            /*Spine.AnimationState.ClearTracks start.*/
            /**
             * <p>Removes all animations from all tracks, leaving skeletons in their current pose.</p><p>It may be desired to use {@link } to mix the skeletons back to the setup pose,
             rather than leaving them in their current pose.</p>
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @return  {void}
             */
            ClearTracks: function () {
if ( TRACE ) { TRACE( "Spine.AnimationState#ClearTracks", this ); }

                var oldDrainDisabled = this.queue.drainDisabled;
                this.queue.drainDisabled = true;
                for (var i = 0, n = this.tracks.Count; i < n; i = (i + 1) | 0) {
                    this.ClearTrack(i);
                }
                this.tracks.Clear();
                this.queue.drainDisabled = oldDrainDisabled;
                this.queue.Drain();
            },
            /*Spine.AnimationState.ClearTracks end.*/

            /*Spine.AnimationState.ClearTrack start.*/
            /**
             * <p>Removes all animations from the track, leaving skeletons in their current pose.</p><p>It may be desired to use {@link } to mix the skeletons back to the setup pose,
             rather than leaving them in their current pose.</p>
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @param   {number}    trackIndex
             * @return  {void}
             */
            ClearTrack: function (trackIndex) {
if ( TRACE ) { TRACE( "Spine.AnimationState#ClearTrack", this ); }

                var $t, $t1;
                if (trackIndex >= this.tracks.Count) {
                    return;
                }
                var current = ($t = this.tracks.Items)[trackIndex];
                if (current == null) {
                    return;
                }

                this.queue.End(current);

                this.ClearNext(current);

                var entry = current;
                while (true) {
                    var from = entry.mixingFrom;
                    if (from == null) {
                        break;
                    }
                    this.queue.End(from);
                    entry.mixingFrom = null;
                    entry.mixingTo = null;
                    entry = from;
                }

                ($t1 = this.tracks.Items)[current.trackIndex] = null;

                this.queue.Drain();
            },
            /*Spine.AnimationState.ClearTrack end.*/

            /*Spine.AnimationState.SetCurrent start.*/
            /**
             * Sets the active TrackEntry for a given track number.
             *
             * @instance
             * @private
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @param   {number}              index        
             * @param   {Spine.TrackEntry}    current      
             * @param   {boolean}             interrupt
             * @return  {void}
             */
            SetCurrent: function (index, current, interrupt) {
if ( TRACE ) { TRACE( "Spine.AnimationState#SetCurrent", this ); }

                var $t;
                var from = this.ExpandToIndex(index);
                ($t = this.tracks.Items)[index] = current;
                current.previous = null;

                if (from != null) {
                    if (interrupt) {
                        this.queue.Interrupt(from);
                    }
                    current.mixingFrom = from;
                    from.mixingTo = current;
                    current.mixTime = 0;

                    // Store the interrupted mix percentage.
                    if (from.mixingFrom != null && from.mixDuration > 0) {
                        current.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);
                    }

                    from.timelinesRotation.Clear(); // Reset rotation for mixing out, in case entry was mixed in.
                }

                this.queue.Start(current); // triggers AnimationsChanged
            },
            /*Spine.AnimationState.SetCurrent end.*/

            /*Spine.AnimationState.SetAnimation$1 start.*/
            /**
             * Sets an animation by name. <seealso cref="SetAnimation(int, Animation, bool)" />
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @param   {number}              trackIndex       
             * @param   {string}              animationName    
             * @param   {boolean}             loop
             * @return  {Spine.TrackEntry}
             * @see {@link SetAnimation(int, Animation, bool)}
             */
            SetAnimation$1: function (trackIndex, animationName, loop) {
if ( TRACE ) { TRACE( "Spine.AnimationState#SetAnimation$1", this ); }

                var animation = this.data.skeletonData.FindAnimation(animationName);
                if (animation == null) {
                    throw new System.ArgumentException.$ctor3("Animation not found: " + (animationName || ""), "animationName");
                }
                return this.SetAnimation(trackIndex, animation, loop);
            },
            /*Spine.AnimationState.SetAnimation$1 end.*/

            /*Spine.AnimationState.SetAnimation start.*/
            /**
             * Sets the current animation for a track, discarding any queued animations. If the formerly current track entry was never
             applied to a skeleton, it is replaced (not mixed from).
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @param   {number}              trackIndex    
             * @param   {Spine.Animation}     animation     
             * @param   {boolean}             loop          If true, the animation will repeat. If false it will not, instead its last frame is applied if played beyond its
                      duration. In either case{@link } determines when the track is cleared.
             * @return  {Spine.TrackEntry}                  A track entry to allow further customization of animation playback. References to the track entry must not be kept
                      after the {@link } event occurs.
             */
            SetAnimation: function (trackIndex, animation, loop) {
if ( TRACE ) { TRACE( "Spine.AnimationState#SetAnimation", this ); }

                var $t;
                if (animation == null) {
                    throw new System.ArgumentNullException.$ctor3("animation", "animation cannot be null.");
                }
                var interrupt = true;
                var current = this.ExpandToIndex(trackIndex);
                if (current != null) {
                    if (current.nextTrackLast === -1) {
                        // Don't mix from an entry that was never applied.
                        ($t = this.tracks.Items)[trackIndex] = current.mixingFrom;
                        this.queue.Interrupt(current);
                        this.queue.End(current);
                        this.ClearNext(current);
                        current = current.mixingFrom;
                        interrupt = false; // mixingFrom is current again, but don't interrupt it twice.
                    } else {
                        this.ClearNext(current);
                    }
                }
                var entry = this.NewTrackEntry(trackIndex, animation, loop, current);
                this.SetCurrent(trackIndex, entry, interrupt);
                this.queue.Drain();
                return entry;
            },
            /*Spine.AnimationState.SetAnimation end.*/

            /*Spine.AnimationState.AddAnimation$1 start.*/
            /**
             * Queues an animation by name.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @param   {number}              trackIndex       
             * @param   {string}              animationName    
             * @param   {boolean}             loop             
             * @param   {number}              delay
             * @return  {Spine.TrackEntry}
             * @see {@link AddAnimation(int, Animation, bool, float)}
             */
            AddAnimation$1: function (trackIndex, animationName, loop, delay) {
if ( TRACE ) { TRACE( "Spine.AnimationState#AddAnimation$1", this ); }

                var animation = this.data.skeletonData.FindAnimation(animationName);
                if (animation == null) {
                    throw new System.ArgumentException.$ctor3("Animation not found: " + (animationName || ""), "animationName");
                }
                return this.AddAnimation(trackIndex, animation, loop, delay);
            },
            /*Spine.AnimationState.AddAnimation$1 end.*/

            /*Spine.AnimationState.AddAnimation start.*/
            /**
             * Adds an animation to be played after the current or last queued animation for a track. If the track is empty, it is
             equivalent to calling {@link }.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @param   {number}              trackIndex    
             * @param   {Spine.Animation}     animation     
             * @param   {boolean}             loop          
             * @param   {number}              delay         If &gt; 0, sets {@link }. If &lt;= 0, the delay set is the duration of the previous track entry
             minus any mix duration (from the {@link } plus the specified <pre><code>Delay</code></pre> (ie the mix
             ends at (<pre><code>Delay</code></pre> = 0) or before (<pre><code>Delay</code></pre> &lt; 0) the previous track entry duration). If the
             previous entry is looping, its next loop completion is used instead of its duration.
             * @return  {Spine.TrackEntry}                  A track entry to allow further customization of animation playback. References to the track entry must not be kept
             after the {@link } event occurs.
             */
            AddAnimation: function (trackIndex, animation, loop, delay) {
if ( TRACE ) { TRACE( "Spine.AnimationState#AddAnimation", this ); }

                if (animation == null) {
                    throw new System.ArgumentNullException.$ctor3("animation", "animation cannot be null.");
                }

                var last = this.ExpandToIndex(trackIndex);
                if (last != null) {
                    while (last.next != null) {
                        last = last.next;
                    }
                }

                var entry = this.NewTrackEntry(trackIndex, animation, loop, last);

                if (last == null) {
                    this.SetCurrent(trackIndex, entry, true);
                    this.queue.Drain();
                } else {
                    last.next = entry;
                    entry.previous = last;
                    if (delay <= 0) {
                        delay += last.TrackComplete - entry.mixDuration;
                    }
                }

                entry.delay = delay;
                return entry;
            },
            /*Spine.AnimationState.AddAnimation end.*/

            /*Spine.AnimationState.SetEmptyAnimation start.*/
            /**
             * <p>Sets an empty animation for a track, discarding any queued animations, and sets the track entry's
             {@link }. An empty animation has no timelines and serves as a placeholder for mixing in or out.</p><p>Mixing out is done by setting an empty animation with a mix duration using either {@link },
             {@link }, or {@link }. Mixing to an empty animation causes
             the previous animation to be applied less and less over the mix duration. Properties keyed in the previous animation
             transition to the value from lower tracks or to the setup pose value if no lower tracks key the property. A mix duration of
             0 still mixes out over one frame.</p><p>Mixing in is done by first setting an empty animation, then adding an animation using
             {@link } with the desired delay (an empty animation has a duration of 0) and on
             the returned track entry, set the {@link }. Mixing from an empty animation causes the new
             animation to be applied more and more over the mix duration. Properties keyed in the new animation transition from the value
             from lower tracks or from the setup pose value if no lower tracks key the property to the value keyed in the new
             animation.</p>
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @param   {number}              trackIndex     
             * @param   {number}              mixDuration
             * @return  {Spine.TrackEntry}
             */
            SetEmptyAnimation: function (trackIndex, mixDuration) {
if ( TRACE ) { TRACE( "Spine.AnimationState#SetEmptyAnimation", this ); }

                var entry = this.SetAnimation(trackIndex, Spine.AnimationState.EmptyAnimation, false);
                entry.mixDuration = mixDuration;
                entry.trackEnd = mixDuration;
                return entry;
            },
            /*Spine.AnimationState.SetEmptyAnimation end.*/

            /*Spine.AnimationState.AddEmptyAnimation start.*/
            /**
             * Adds an empty animation to be played after the current or last queued animation for a track, and sets the track entry's
             {@link }. If the track is empty, it is equivalent to calling
             {@link }.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @param   {number}              trackIndex     Track number.
             * @param   {number}              mixDuration    Mix duration.
             * @param   {number}              delay          If &gt; 0, sets {@link }. If &lt;= 0, the delay set is the duration of the previous track entry
             minus any mix duration plus the specified <pre><code>Delay</code></pre> (ie the mix ends at (<pre><code>Delay</code></pre> = 0) or
             before (<pre><code>Delay</code></pre> &lt; 0) the previous track entry duration). If the previous entry is looping, its next
             loop completion is used instead of its duration.
             * @return  {Spine.TrackEntry}                   A track entry to allow further customization of animation playback. References to the track entry must not be kept
             after the {@link } event occurs.
             * @see {@link AnimationState.SetEmptyAnimation(int, float)}
             */
            AddEmptyAnimation: function (trackIndex, mixDuration, delay) {
if ( TRACE ) { TRACE( "Spine.AnimationState#AddEmptyAnimation", this ); }

                var entry = this.AddAnimation(trackIndex, Spine.AnimationState.EmptyAnimation, false, delay);
                if (delay <= 0) {
                    entry.delay += entry.mixDuration - mixDuration;
                }
                entry.mixDuration = mixDuration;
                entry.trackEnd = mixDuration;
                return entry;
            },
            /*Spine.AnimationState.AddEmptyAnimation end.*/

            /*Spine.AnimationState.SetEmptyAnimations start.*/
            /**
             * Sets an empty animation for every track, discarding any queued animations, and mixes to it over the specified mix
             duration.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @param   {number}    mixDuration
             * @return  {void}
             */
            SetEmptyAnimations: function (mixDuration) {
if ( TRACE ) { TRACE( "Spine.AnimationState#SetEmptyAnimations", this ); }

                var oldDrainDisabled = this.queue.drainDisabled;
                this.queue.drainDisabled = true;
                var tracksItems = this.tracks.Items;
                for (var i = 0, n = this.tracks.Count; i < n; i = (i + 1) | 0) {
                    var current = tracksItems[i];
                    if (current != null) {
                        this.SetEmptyAnimation(current.trackIndex, mixDuration);
                    }
                }
                this.queue.drainDisabled = oldDrainDisabled;
                this.queue.Drain();
            },
            /*Spine.AnimationState.SetEmptyAnimations end.*/

            /*Spine.AnimationState.ExpandToIndex start.*/
            ExpandToIndex: function (index) {
if ( TRACE ) { TRACE( "Spine.AnimationState#ExpandToIndex", this ); }

                var $t;
                if (index < this.tracks.Count) {
                    return ($t = this.tracks.Items)[index];
                }
                this.tracks.Resize(((index + 1) | 0));
                return null;
            },
            /*Spine.AnimationState.ExpandToIndex end.*/

            /*Spine.AnimationState.NewTrackEntry start.*/
            /**
             * Object-pooling version of new TrackEntry. Obtain an unused TrackEntry from the pool and clear/initialize its values.
             *
             * @instance
             * @private
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @param   {number}              trackIndex    
             * @param   {Spine.Animation}     animation     
             * @param   {boolean}             loop          
             * @param   {Spine.TrackEntry}    last          May be null.
             * @return  {Spine.TrackEntry}
             */
            NewTrackEntry: function (trackIndex, animation, loop, last) {
if ( TRACE ) { TRACE( "Spine.AnimationState#NewTrackEntry", this ); }

                var entry = this.trackEntryPool.Obtain();
                entry.trackIndex = trackIndex;
                entry.animation = animation;
                entry.loop = loop;
                entry.holdPrevious = false;

                entry.eventThreshold = 0;
                entry.alphaAttachmentThreshold = 0;
                entry.mixAttachmentThreshold = 0;
                entry.mixDrawOrderThreshold = 0;

                entry.animationStart = 0;
                entry.animationEnd = animation.Duration;
                entry.animationLast = -1;
                entry.nextAnimationLast = -1;

                entry.delay = 0;
                entry.trackTime = 0;
                entry.trackLast = -1;
                entry.nextTrackLast = -1;
                entry.trackEnd = 3.40282347E+38;
                entry.timeScale = 1;

                entry.alpha = 1;
                entry.interruptAlpha = 1;
                entry.mixTime = 0;
                entry.mixDuration = last == null ? 0 : this.data.GetMix(last.animation, animation);
                entry.mixBlend = Spine.MixBlend.Replace;
                return entry;
            },
            /*Spine.AnimationState.NewTrackEntry end.*/

            /*Spine.AnimationState.ClearNext start.*/
            /**
             * Removes the {@link } and all entries after it for the specified entry.
             *
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @param   {Spine.TrackEntry}    entry
             * @return  {void}
             */
            ClearNext: function (entry) {
if ( TRACE ) { TRACE( "Spine.AnimationState#ClearNext", this ); }

                var next = entry.next;
                while (next != null) {
                    this.queue.Dispose(next);
                    next = next.next;
                }
                entry.next = null;
            },
            /*Spine.AnimationState.ClearNext end.*/

            /*Spine.AnimationState.AnimationsChanged start.*/
            AnimationsChanged: function () {
if ( TRACE ) { TRACE( "Spine.AnimationState#AnimationsChanged", this ); }

                this.animationsChanged = false;

                // Process in the order that animations are applied.
                this.propertyIds.clear();
                var n = this.tracks.Count;
                var tracksItems = this.tracks.Items;
                for (var i = 0; i < n; i = (i + 1) | 0) {
                    var entry = tracksItems[i];
                    if (entry == null) {
                        continue;
                    }
                    while (entry.mixingFrom != null) {
                        entry = entry.mixingFrom;
                    }
                    do {
                        if (entry.mixingTo == null || entry.mixBlend !== Spine.MixBlend.Add) {
                            this.ComputeHold(entry);
                        }
                        entry = entry.mixingTo;
                    } while (entry != null);
                }
            },
            /*Spine.AnimationState.AnimationsChanged end.*/

            /*Spine.AnimationState.ComputeHold start.*/
            ComputeHold: function (entry) {
if ( TRACE ) { TRACE( "Spine.AnimationState#ComputeHold", this ); }

                var $step = 0,
                    $jumpFromFinally, 
                    to, 
                    timelines, 
                    timelinesCount, 
                    timelineMode, 
                    timelineHoldMix, 
                    propertyIds, 
                    i1, 
                    timeline, 
                    ids, 
                    next, 
                    $asyncBody = Bridge.fn.bind(this, function () {
                        for (;;) {
                            $step = System.Array.min([0,1,2,3,4,5,6,7,8,9,10,11,12,14,16,17], $step);
                            switch ($step) {
                                case 0: {
                                    to = entry.mixingTo;
                                    timelines = entry.animation.timelines.Items;
                                    timelinesCount = entry.animation.timelines.Count;
                                    timelineMode = entry.timelineMode.Resize(timelinesCount).Items;
                                    entry.timelineHoldMix.Clear();
                                    timelineHoldMix = entry.timelineHoldMix.Resize(timelinesCount).Items;
                                    propertyIds = this.propertyIds;

                                    if (to != null && to.holdPrevious) {
                                        for (var i = 0; i < timelinesCount; i = (i + 1) | 0) {
                                            timelineMode[i] = Spine.HashSetExtensions.AddAll(System.String, propertyIds, timelines[i].PropertyIds) ? Spine.AnimationState.HoldFirst : Spine.AnimationState.HoldSubsequent;
                                        }

                                        return;
                                    }

                                    // outer:
                                    i1 = 0;
                                    $step = 1;
                                    continue;
                                }
                                case 1: {
                                    if ( i1 < timelinesCount ) {
                                        $step = 2;
                                        continue;
                                    }
                                    $step = 17;
                                    continue;
                                }
                                case 2: {
                                    timeline = timelines[i1];
                                    ids = timeline.PropertyIds;
                                    if (!Spine.HashSetExtensions.AddAll(System.String, propertyIds, ids)) {
                                        $step = 3;
                                        continue;
                                    } else  {
                                        $step = 4;
                                        continue;
                                    }
                                }
                                case 3: {
                                    timelineMode[i1] = Spine.AnimationState.Subsequent;
                                    $step = 14;
                                    continue;
                                }
                                case 4: {
                                    if (to == null || Bridge.is(timeline, Spine.AttachmentTimeline) || Bridge.is(timeline, Spine.DrawOrderTimeline) || Bridge.is(timeline, Spine.EventTimeline) || !to.animation.HasTimeline(ids)) {
                                        $step = 5;
                                        continue;
                                    } else  {
                                        $step = 6;
                                        continue;
                                    }
                                }
                                case 5: {
                                    timelineMode[i1] = Spine.AnimationState.First;
                                    $step = 13;
                                    continue;
                                }
                                case 6: {
                                    next = to.mixingTo;
                                    $step = 7;
                                    continue;
                                }
                                case 7: {
                                    if ( next != null ) {
                                        $step = 8;
                                        continue;
                                    }
                                    $step = 12;
                                    continue;
                                }
                                case 8: {
                                    if (next.animation.HasTimeline(ids)) {
                                        $step = 11;
                                        continue;
                                    }
                                    if (next.mixDuration > 0) {
                                        $step = 9;
                                        continue;
                                    } 
                                    $step = 10;
                                    continue;
                                }
                                case 9: {
                                    timelineMode[i1] = Spine.AnimationState.HoldMix;
                                    timelineHoldMix[i1] = next;
                                    $step = 15;
                                    continue;// continue outer;
                                    $step = 10;
                                    continue;
                                }
                                case 10: {
                                    $step = 12;
                                    continue;
                                }
                                case 11: {
                                    next = next.mixingTo;
                                    $step = 7;
                                    continue;
                                }
                                case 12: {
                                    timelineMode[i1] = Spine.AnimationState.HoldFirst;
                                    $step = 13;
                                    continue;
                                }

                                case 14: {

                                }

                                case 16: {
                                    i1 = (i1 + 1) | 0;
                                    $step = 1;
                                    continue;
                                }
                                case 17: {
                                    return;
                                }
                                default: {
                                    return;
                                }
                            }
                        }
                    }, arguments);

                return $asyncBody();
            },
            /*Spine.AnimationState.ComputeHold end.*/

            /*Spine.AnimationState.GetCurrent start.*/
            /**
             * @instance
             * @public
             * @this Spine.AnimationState
             * @memberof Spine.AnimationState
             * @param   {number}              trackIndex
             * @return  {Spine.TrackEntry}                  The track entry for the animation currently playing on the track, or null if no animation is currently playing.
             */
            GetCurrent: function (trackIndex) {
if ( TRACE ) { TRACE( "Spine.AnimationState#GetCurrent", this ); }

                var $t;
                if (trackIndex >= this.tracks.Count) {
                    return null;
                }
                return ($t = this.tracks.Items)[trackIndex];
            },
            /*Spine.AnimationState.GetCurrent end.*/

            /*Spine.AnimationState.ClearListenerNotifications start.*/
            
            ClearListenerNotifications: function () {
if ( TRACE ) { TRACE( "Spine.AnimationState#ClearListenerNotifications", this ); }

                this.queue.Clear();
            },
            /*Spine.AnimationState.ClearListenerNotifications end.*/

            /*Spine.AnimationState.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.AnimationState#toString", this ); }

                var buffer = new System.Text.StringBuilder();
                var tracksItems = this.tracks.Items;
                for (var i = 0, n = this.tracks.Count; i < n; i = (i + 1) | 0) {
                    var entry = tracksItems[i];
                    if (entry == null) {
                        continue;
                    }
                    if (buffer.getLength() > 0) {
                        buffer.append(", ");
                    }
                    buffer.append(entry.toString());
                }
                if (buffer.getLength() === 0) {
                    return "<none>";
                }
                return buffer.toString();
            },
            /*Spine.AnimationState.toString end.*/


        },
        overloads: {
            "SetAnimation(int, string, bool)": "SetAnimation$1",
            "AddAnimation(int, string, bool, float)": "AddAnimation$1",
            "ToString()": "toString"
        }
    });
    /*Spine.AnimationState end.*/

    /*Spine.AnimationStateData start.*/
    /**
     * Stores mix (crossfade) durations to be applied when AnimationState animations are changed.
     *
     * @public
     * @class Spine.AnimationStateData
     */
    Bridge.define("Spine.AnimationStateData", {
        fields: {
            skeletonData: null,
            animationToMixTime: null,
            defaultMix: 0
        },
        props: {
            /**
             * The SkeletonData to look up animations when they are specified by name.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.AnimationStateData
             * @function SkeletonData
             * @type Spine.SkeletonData
             */
            SkeletonData: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.AnimationStateData#SkeletonData#get", this ); }

                    return this.skeletonData;
                }
            },
            /**
             * The mix duration to use when no mix duration has been specifically defined between two animations.
             *
             * @instance
             * @public
             * @memberof Spine.AnimationStateData
             * @function DefaultMix
             * @type number
             */
            DefaultMix: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.AnimationStateData#DefaultMix#get", this ); }

                    return this.defaultMix;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.AnimationStateData#DefaultMix#set", this ); }

                    this.defaultMix = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.AnimationStateData#init", this ); }

                this.animationToMixTime = new (System.Collections.Generic.Dictionary$2(Spine.AnimationStateData.AnimationPair,System.Single)).$ctor3(Spine.AnimationStateData.AnimationPairComparer.Instance);
            },
            ctor: function (skeletonData) {
if ( TRACE ) { TRACE( "Spine.AnimationStateData#ctor", this ); }

                this.$initialize();
                if (skeletonData == null) {
                    throw new System.ArgumentException.$ctor3("skeletonData cannot be null.", "skeletonData");
                }
                this.skeletonData = skeletonData;
            }
        },
        methods: {
            /*Spine.AnimationStateData.SetMix$1 start.*/
            /**
             * Sets a mix duration by animation names.
             *
             * @instance
             * @public
             * @this Spine.AnimationStateData
             * @memberof Spine.AnimationStateData
             * @param   {string}    fromName    
             * @param   {string}    toName      
             * @param   {number}    duration
             * @return  {void}
             */
            SetMix$1: function (fromName, toName, duration) {
if ( TRACE ) { TRACE( "Spine.AnimationStateData#SetMix$1", this ); }

                var from = this.skeletonData.FindAnimation(fromName);
                if (from == null) {
                    throw new System.ArgumentException.$ctor3("Animation not found: " + (fromName || ""), "fromName");
                }
                var to = this.skeletonData.FindAnimation(toName);
                if (to == null) {
                    throw new System.ArgumentException.$ctor3("Animation not found: " + (toName || ""), "toName");
                }
                this.SetMix(from, to, duration);
            },
            /*Spine.AnimationStateData.SetMix$1 end.*/

            /*Spine.AnimationStateData.SetMix start.*/
            /**
             * Sets a mix duration when changing from the specified animation to the other.
             See TrackEntry.MixDuration.
             *
             * @instance
             * @public
             * @this Spine.AnimationStateData
             * @memberof Spine.AnimationStateData
             * @param   {Spine.Animation}    from        
             * @param   {Spine.Animation}    to          
             * @param   {number}             duration
             * @return  {void}
             */
            SetMix: function (from, to, duration) {
if ( TRACE ) { TRACE( "Spine.AnimationStateData#SetMix", this ); }

                if (from == null) {
                    throw new System.ArgumentNullException.$ctor3("from", "from cannot be null.");
                }
                if (to == null) {
                    throw new System.ArgumentNullException.$ctor3("to", "to cannot be null.");
                }
                var key = new Spine.AnimationStateData.AnimationPair.$ctor1(from, to);
                this.animationToMixTime.remove(key);
                this.animationToMixTime.add(key, duration);
            },
            /*Spine.AnimationStateData.SetMix end.*/

            /*Spine.AnimationStateData.GetMix start.*/
            /**
             * The mix duration to use when changing from the specified animation to the other,
             or the DefaultMix if no mix duration has been set.
             *
             * @instance
             * @public
             * @this Spine.AnimationStateData
             * @memberof Spine.AnimationStateData
             * @param   {Spine.Animation}    from    
             * @param   {Spine.Animation}    to
             * @return  {number}
             */
            GetMix: function (from, to) {
if ( TRACE ) { TRACE( "Spine.AnimationStateData#GetMix", this ); }

                if (from == null) {
                    throw new System.ArgumentNullException.$ctor3("from", "from cannot be null.");
                }
                if (to == null) {
                    throw new System.ArgumentNullException.$ctor3("to", "to cannot be null.");
                }
                var key = new Spine.AnimationStateData.AnimationPair.$ctor1(from, to);
                var duration = { };
                if (this.animationToMixTime.tryGetValue(key, duration)) {
                    return duration.v;
                }
                return this.defaultMix;
            },
            /*Spine.AnimationStateData.GetMix end.*/


        },
        overloads: {
            "SetMix(string, string, float)": "SetMix$1"
        }
    });
    /*Spine.AnimationStateData end.*/

    /*Spine.AnimationStateData+AnimationPair start.*/
    Bridge.define("Spine.AnimationStateData.AnimationPair", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.AnimationStateData.AnimationPair#getDefaultValue", this ); }
 return new Spine.AnimationStateData.AnimationPair(); }
            }
        },
        fields: {
            a1: null,
            a2: null
        },
        ctors: {
            $ctor1: function (a1, a2) {
if ( TRACE ) { TRACE( "Spine.AnimationStateData.AnimationPair#$ctor1", this ); }

                this.$initialize();
                this.a1 = a1;
                this.a2 = a2;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.AnimationStateData.AnimationPair#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.AnimationStateData+AnimationPair.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.AnimationStateData.AnimationPair#toString", this ); }

                return (this.a1.name || "") + "->" + (this.a2.name || "");
            },
            /*Spine.AnimationStateData+AnimationPair.toString end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.AnimationStateData.AnimationPair#getHashCode", this ); }

                var h = Bridge.addHash([5472793474, this.a1, this.a2]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.AnimationStateData.AnimationPair#equals", this ); }

                if (!Bridge.is(o, Spine.AnimationStateData.AnimationPair)) {
                    return false;
                }
                return Bridge.equals(this.a1, o.a1) && Bridge.equals(this.a2, o.a2);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.AnimationStateData.AnimationPair#$clone", this ); }

                var s = to || new Spine.AnimationStateData.AnimationPair();
                s.a1 = this.a1;
                s.a2 = this.a2;
                return s;
            }
        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.AnimationStateData+AnimationPair end.*/

    /*Spine.TextureRegion start.*/
    Bridge.define("Spine.TextureRegion", {
        fields: {
            width: 0,
            height: 0,
            u: 0,
            v: 0,
            u2: 0,
            v2: 0
        },
        props: {
            OriginalWidth: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TextureRegion#OriginalWidth#get", this ); }

                    return this.width;
                }
            },
            OriginalHeight: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TextureRegion#OriginalHeight#get", this ); }

                    return this.height;
                }
            }
        }
    });
    /*Spine.TextureRegion end.*/

    /*Spine.AttachmentLoader start.*/
    Bridge.define("Spine.AttachmentLoader", {
        $kind: 3
    });
    /*Spine.AttachmentLoader end.*/

    /*Spine.AtlasPage start.*/
    Bridge.define("Spine.AtlasPage", {
        fields: {
            name: null,
            width: 0,
            height: 0,
            format: 0,
            minFilter: 0,
            magFilter: 0,
            uWrap: 0,
            vWrap: 0,
            pma: false,
            rendererObject: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.AtlasPage#init", this ); }

                this.format = Spine.Format.RGBA8888;
                this.minFilter = Spine.TextureFilter.Nearest;
                this.magFilter = Spine.TextureFilter.Nearest;
                this.uWrap = Spine.TextureWrap.ClampToEdge;
                this.vWrap = Spine.TextureWrap.ClampToEdge;
            }
        },
        methods: {
            /*Spine.AtlasPage.Clone start.*/
            Clone: function () {
if ( TRACE ) { TRACE( "Spine.AtlasPage#Clone", this ); }

                return Bridge.as(Bridge.clone(this), Spine.AtlasPage);
            },
            /*Spine.AtlasPage.Clone end.*/


        }
    });
    /*Spine.AtlasPage end.*/

    /*Spine.Attachment start.*/
    /**
     * The base class for all attachments.
     *
     * @abstract
     * @public
     * @class Spine.Attachment
     */
    Bridge.define("Spine.Attachment", {
        fields: {
            /**
             * The attachment's name.
             *
             * @instance
             * @public
             * @memberof Spine.Attachment
             * @function Name
             * @type string
             */
            Name: null
        },
        ctors: {
            $ctor1: function (name) {
if ( TRACE ) { TRACE( "Spine.Attachment#$ctor1", this ); }

                this.$initialize();
                if (name == null) {
                    throw new System.ArgumentNullException.$ctor3("name", "name cannot be null");
                }
                this.Name = name;
            },
            /**
             * Copy constructor.
             *
             * @instance
             * @protected
             * @this Spine.Attachment
             * @memberof Spine.Attachment
             * @param   {Spine.Attachment}    other
             * @return  {void}
             */
            ctor: function (other) {
if ( TRACE ) { TRACE( "Spine.Attachment#ctor", this ); }

                this.$initialize();
                this.Name = other.Name;
            }
        },
        methods: {
            /*Spine.Attachment.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.Attachment#toString", this ); }

                return this.Name;
            },
            /*Spine.Attachment.toString end.*/


        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.Attachment end.*/

    /*Spine.AttachmentType start.*/
    Bridge.define("Spine.AttachmentType", {
        $kind: 6,
        statics: {
            fields: {
                Region: 0,
                Boundingbox: 1,
                Mesh: 2,
                Linkedmesh: 3,
                Path: 4,
                Point: 5,
                Clipping: 6,
                Sequence: 7
            }
        }
    });
    /*Spine.AttachmentType end.*/

    /*Spine.BlendMode start.*/
    Bridge.define("Spine.BlendMode", {
        $kind: 6,
        statics: {
            fields: {
                Normal: 0,
                Additive: 1,
                Multiply: 2,
                Screen: 3
            }
        }
    });
    /*Spine.BlendMode end.*/

    /*Spine.IUpdatable start.*/
    /**
     * The interface for items updated by {@link }.
     *
     * @abstract
     * @public
     * @class Spine.IUpdatable
     */
    Bridge.define("Spine.IUpdatable", {
        $kind: 3
    });
    /*Spine.IUpdatable end.*/

    /*Spine.BoneData start.*/
    Bridge.define("Spine.BoneData", {
        fields: {
            index: 0,
            name: null,
            parent: null,
            length: 0,
            x: 0,
            y: 0,
            rotation: 0,
            scaleX: 0,
            scaleY: 0,
            shearX: 0,
            shearY: 0,
            inherit: 0,
            skinRequired: false
        },
        props: {
            /**
             * The index of the bone in Skeleton.Bones
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.BoneData
             * @function Index
             * @type number
             */
            Index: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#Index#get", this ); }

                    return this.index;
                }
            },
            /**
             * The name of the bone, which is unique across all bones in the skeleton.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.BoneData
             * @function Name
             * @type string
             */
            Name: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#Name#get", this ); }

                    return this.name;
                }
            },
            /**
             * May be null.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.BoneData
             * @function Parent
             * @type Spine.BoneData
             */
            Parent: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#Parent#get", this ); }

                    return this.parent;
                }
            },
            Length: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#Length#get", this ); }

                    return this.length;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.BoneData#Length#set", this ); }

                    this.length = value;
                }
            },
            /**
             * Local X translation.
             *
             * @instance
             * @public
             * @memberof Spine.BoneData
             * @function X
             * @type number
             */
            X: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#X#get", this ); }

                    return this.x;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.BoneData#X#set", this ); }

                    this.x = value;
                }
            },
            /**
             * Local Y translation.
             *
             * @instance
             * @public
             * @memberof Spine.BoneData
             * @function Y
             * @type number
             */
            Y: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#Y#get", this ); }

                    return this.y;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.BoneData#Y#set", this ); }

                    this.y = value;
                }
            },
            /**
             * Local rotation in degrees, counter clockwise.
             *
             * @instance
             * @public
             * @memberof Spine.BoneData
             * @function Rotation
             * @type number
             */
            Rotation: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#Rotation#get", this ); }

                    return this.rotation;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.BoneData#Rotation#set", this ); }

                    this.rotation = value;
                }
            },
            /**
             * Local scaleX.
             *
             * @instance
             * @public
             * @memberof Spine.BoneData
             * @function ScaleX
             * @type number
             */
            ScaleX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#ScaleX#get", this ); }

                    return this.scaleX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.BoneData#ScaleX#set", this ); }

                    this.scaleX = value;
                }
            },
            /**
             * Local scaleY.
             *
             * @instance
             * @public
             * @memberof Spine.BoneData
             * @function ScaleY
             * @type number
             */
            ScaleY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#ScaleY#get", this ); }

                    return this.scaleY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.BoneData#ScaleY#set", this ); }

                    this.scaleY = value;
                }
            },
            /**
             * Local shearX.
             *
             * @instance
             * @public
             * @memberof Spine.BoneData
             * @function ShearX
             * @type number
             */
            ShearX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#ShearX#get", this ); }

                    return this.shearX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.BoneData#ShearX#set", this ); }

                    this.shearX = value;
                }
            },
            /**
             * Local shearY.
             *
             * @instance
             * @public
             * @memberof Spine.BoneData
             * @function ShearY
             * @type number
             */
            ShearY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#ShearY#get", this ); }

                    return this.shearY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.BoneData#ShearY#set", this ); }

                    this.shearY = value;
                }
            },
            /**
             * Determines how parent world transforms affect this bone.
             *
             * @instance
             * @public
             * @memberof Spine.BoneData
             * @function Inherit
             * @type Spine.Inherit
             */
            Inherit: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#Inherit#get", this ); }

                    return this.inherit;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.BoneData#Inherit#set", this ); }

                    this.inherit = value;
                }
            },
            /**
             * When true, {@link } only updates this bone if the {@link } contains
             this bone.
             *
             * @instance
             * @public
             * @memberof Spine.BoneData
             * @function SkinRequired
             * @type boolean
             * @see {@link Skin.Bones}
             */
            SkinRequired: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#SkinRequired#get", this ); }

                    return this.skinRequired;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.BoneData#SkinRequired#set", this ); }

                    this.skinRequired = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#init", this ); }

                this.scaleX = 1;
                this.scaleY = 1;
                this.inherit = Spine.Inherit.Normal;
            },
            /**
             * @instance
             * @public
             * @this Spine.BoneData
             * @memberof Spine.BoneData
             * @param   {number}            index     
             * @param   {string}            name      
             * @param   {Spine.BoneData}    parent    May be null.
             * @return  {void}
             */
            ctor: function (index, name, parent) {
if ( TRACE ) { TRACE( "Spine.BoneData#ctor", this ); }

                this.$initialize();
                if (index < 0) {
                    throw new System.ArgumentException.$ctor3("index must be >= 0", "index");
                }
                if (name == null) {
                    throw new System.ArgumentNullException.$ctor3("name", "name cannot be null.");
                }
                this.index = index;
                this.name = name;
                this.parent = parent;
            }
        },
        methods: {
            /*Spine.BoneData.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#toString", this ); }

                return this.name;
            },
            /*Spine.BoneData.toString end.*/


        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.BoneData end.*/

    /*Spine.BoneMatrix start.*/
    Bridge.define("Spine.BoneMatrix", {
        $kind: 4,
        statics: {
            methods: {
                /*Spine.BoneMatrix.CalculateSetupWorld:static start.*/
                /**
                 * Recursively calculates a worldspace bone matrix based on BoneData.
                 *
                 * @static
                 * @public
                 * @this Spine.BoneMatrix
                 * @memberof Spine.BoneMatrix
                 * @param   {Spine.BoneData}      boneData
                 * @return  {Spine.BoneMatrix}
                 */
                CalculateSetupWorld: function (boneData) {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#CalculateSetupWorld", this ); }

                    if (boneData == null) {
                        return Bridge.getDefaultValue(Spine.BoneMatrix);
                    }

                    // End condition: isRootBone
                    if (boneData.Parent == null) {
                        return Spine.BoneMatrix.GetInheritedInternal(boneData, Bridge.getDefaultValue(Spine.BoneMatrix));
                    }

                    var result = Spine.BoneMatrix.CalculateSetupWorld(boneData.Parent);
                    return Spine.BoneMatrix.GetInheritedInternal(boneData, result.$clone());
                },
                /*Spine.BoneMatrix.CalculateSetupWorld:static end.*/

                /*Spine.BoneMatrix.GetInheritedInternal:static start.*/
                GetInheritedInternal: function (boneData, parentMatrix) {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#GetInheritedInternal", this ); }

                    var parent = boneData.Parent;
                    if (parent == null) {
                        return new Spine.BoneMatrix.$ctor2(boneData);
                    } // isRootBone

                    var pa = parentMatrix.a, pb = parentMatrix.b, pc = parentMatrix.c, pd = parentMatrix.d;
                    var result = Bridge.getDefaultValue(Spine.BoneMatrix);
                    result.x = pa * boneData.X + pb * boneData.Y + parentMatrix.x;
                    result.y = pc * boneData.X + pd * boneData.Y + parentMatrix.y;

                    switch (boneData.Inherit) {
                        case Spine.Inherit.Normal: 
                            {
                                var rotationY = boneData.Rotation + 90 + boneData.ShearY;
                                var la = Spine.MathUtils.CosDeg(boneData.Rotation + boneData.ShearX) * boneData.ScaleX;
                                var lb = Spine.MathUtils.CosDeg(rotationY) * boneData.ScaleY;
                                var lc = Spine.MathUtils.SinDeg(boneData.Rotation + boneData.ShearX) * boneData.ScaleX;
                                var ld = Spine.MathUtils.SinDeg(rotationY) * boneData.ScaleY;
                                result.a = pa * la + pb * lc;
                                result.b = pa * lb + pb * ld;
                                result.c = pc * la + pd * lc;
                                result.d = pc * lb + pd * ld;
                                break;
                            }
                        case Spine.Inherit.OnlyTranslation: 
                            {
                                var rotationY1 = boneData.Rotation + 90 + boneData.ShearY;
                                result.a = Spine.MathUtils.CosDeg(boneData.Rotation + boneData.ShearX) * boneData.ScaleX;
                                result.b = Spine.MathUtils.CosDeg(rotationY1) * boneData.ScaleY;
                                result.c = Spine.MathUtils.SinDeg(boneData.Rotation + boneData.ShearX) * boneData.ScaleX;
                                result.d = Spine.MathUtils.SinDeg(rotationY1) * boneData.ScaleY;
                                break;
                            }
                        case Spine.Inherit.NoRotationOrReflection: 
                            {
                                var s = pa * pa + pc * pc, prx;
                                if (s > 0.0001) {
                                    s = Math.abs(pa * pd - pb * pc) / s;
                                    pb = pc * s;
                                    pd = pa * s;
                                    prx = Spine.MathUtils.Atan2(pc, pa) * Spine.MathUtils.RadDeg;
                                } else {
                                    pa = 0;
                                    pc = 0;
                                    prx = 90 - Spine.MathUtils.Atan2(pd, pb) * Spine.MathUtils.RadDeg;
                                }
                                var rx = boneData.Rotation + boneData.ShearX - prx;
                                var ry = boneData.Rotation + boneData.ShearY - prx + 90;
                                var la1 = Spine.MathUtils.CosDeg(rx) * boneData.ScaleX;
                                var lb1 = Spine.MathUtils.CosDeg(ry) * boneData.ScaleY;
                                var lc1 = Spine.MathUtils.SinDeg(rx) * boneData.ScaleX;
                                var ld1 = Spine.MathUtils.SinDeg(ry) * boneData.ScaleY;
                                result.a = pa * la1 - pb * lc1;
                                result.b = pa * lb1 - pb * ld1;
                                result.c = pc * la1 + pd * lc1;
                                result.d = pc * lb1 + pd * ld1;
                                break;
                            }
                        case Spine.Inherit.NoScale: 
                        case Spine.Inherit.NoScaleOrReflection: 
                            {
                                var cos = Spine.MathUtils.CosDeg(boneData.Rotation), sin = Spine.MathUtils.SinDeg(boneData.Rotation);
                                var za = pa * cos + pb * sin;
                                var zc = pc * cos + pd * sin;
                                var s1 = Math.sqrt(za * za + zc * zc);
                                if (s1 > 1E-05) {
                                    s1 = 1 / s1;
                                }
                                za *= s1;
                                zc *= s1;
                                s1 = Math.sqrt(za * za + zc * zc);
                                var r = 1.57079637 + Spine.MathUtils.Atan2(zc, za);
                                var zb = Spine.MathUtils.Cos(r) * s1;
                                var zd = Spine.MathUtils.Sin(r) * s1;
                                var la2 = Spine.MathUtils.CosDeg(boneData.ShearX) * boneData.ScaleX;
                                var lb2 = Spine.MathUtils.CosDeg(90 + boneData.ShearY) * boneData.ScaleY;
                                var lc2 = Spine.MathUtils.SinDeg(boneData.ShearX) * boneData.ScaleX;
                                var ld2 = Spine.MathUtils.SinDeg(90 + boneData.ShearY) * boneData.ScaleY;
                                if (boneData.Inherit !== Spine.Inherit.NoScaleOrReflection ? pa * pd - pb * pc < 0 : false) {
                                    zb = -zb;
                                    zd = -zd;
                                }
                                result.a = za * la2 + zb * lc2;
                                result.b = za * lb2 + zb * ld2;
                                result.c = zc * la2 + zd * lc2;
                                result.d = zc * lb2 + zd * ld2;
                                break;
                            }
                    }

                    return result.$clone();
                },
                /*Spine.BoneMatrix.GetInheritedInternal:static end.*/

                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#getDefaultValue", this ); }
 return new Spine.BoneMatrix(); }
            }
        },
        fields: {
            a: 0,
            b: 0,
            c: 0,
            d: 0,
            x: 0,
            y: 0
        },
        ctors: {
            /**
             * Constructor for a local bone matrix based on Setup Pose BoneData.
             *
             * @instance
             * @public
             * @this Spine.BoneMatrix
             * @memberof Spine.BoneMatrix
             * @param   {Spine.BoneData}    boneData
             * @return  {void}
             */
            $ctor2: function (boneData) {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#$ctor2", this ); }

                this.$initialize();
                var rotationY = boneData.Rotation + 90 + boneData.ShearY;
                var rotationX = boneData.Rotation + boneData.ShearX;

                this.a = Spine.MathUtils.CosDeg(rotationX) * boneData.ScaleX;
                this.c = Spine.MathUtils.SinDeg(rotationX) * boneData.ScaleX;
                this.b = Spine.MathUtils.CosDeg(rotationY) * boneData.ScaleY;
                this.d = Spine.MathUtils.SinDeg(rotationY) * boneData.ScaleY;
                this.x = boneData.X;
                this.y = boneData.Y;
            },
            /**
             * Constructor for a local bone matrix based on a bone instance's current pose.
             *
             * @instance
             * @public
             * @this Spine.BoneMatrix
             * @memberof Spine.BoneMatrix
             * @param   {Spine.Bone}    bone
             * @return  {void}
             */
            $ctor1: function (bone) {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#$ctor1", this ); }

                this.$initialize();
                var rotationY = bone.Rotation + 90 + bone.ShearY;
                var rotationX = bone.Rotation + bone.ShearX;

                this.a = Spine.MathUtils.CosDeg(rotationX) * bone.ScaleX;
                this.c = Spine.MathUtils.SinDeg(rotationX) * bone.ScaleX;
                this.b = Spine.MathUtils.CosDeg(rotationY) * bone.ScaleY;
                this.d = Spine.MathUtils.SinDeg(rotationY) * bone.ScaleY;
                this.x = bone.X;
                this.y = bone.Y;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.BoneMatrix.TransformMatrix start.*/
            TransformMatrix: function (local) {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#TransformMatrix", this ); }

                var $t;
                return ($t = new Spine.BoneMatrix.ctor(), $t.a = this.a * local.a + this.b * local.c, $t.b = this.a * local.b + this.b * local.d, $t.c = this.c * local.a + this.d * local.c, $t.d = this.c * local.b + this.d * local.d, $t.x = this.a * local.x + this.b * local.y + this.x, $t.y = this.c * local.x + this.d * local.y + this.y, $t);
            },
            /*Spine.BoneMatrix.TransformMatrix end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#getHashCode", this ); }

                var h = Bridge.addHash([3621996792, this.a, this.b, this.c, this.d, this.x, this.y]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#equals", this ); }

                if (!Bridge.is(o, Spine.BoneMatrix)) {
                    return false;
                }
                return Bridge.equals(this.a, o.a) && Bridge.equals(this.b, o.b) && Bridge.equals(this.c, o.c) && Bridge.equals(this.d, o.d) && Bridge.equals(this.x, o.x) && Bridge.equals(this.y, o.y);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#$clone", this ); }

                var s = to || new Spine.BoneMatrix();
                s.a = this.a;
                s.b = this.b;
                s.c = this.c;
                s.d = this.d;
                s.x = this.x;
                s.y = this.y;
                return s;
            }
        }
    });
    /*Spine.BoneMatrix end.*/

    /*Spine.ConstraintData start.*/
    /**
     * The base class for all constraint datas.
     *
     * @abstract
     * @public
     * @class Spine.ConstraintData
     */
    Bridge.define("Spine.ConstraintData", {
        fields: {
            name: null,
            order: 0,
            skinRequired: false
        },
        props: {
            /**
             * The constraint's name, which is unique across all constraints in the skeleton of the same type.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.ConstraintData
             * @function Name
             * @type string
             */
            Name: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.ConstraintData#Name#get", this ); }

                    return this.name;
                }
            },
            /**
             * The ordinal of this constraint for the order a skeleton's constraints will be applied by
             {@link }.
             *
             * @instance
             * @public
             * @memberof Spine.ConstraintData
             * @function Order
             * @type number
             */
            Order: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.ConstraintData#Order#get", this ); }

                    return this.order;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.ConstraintData#Order#set", this ); }

                    this.order = value;
                }
            },
            /**
             * When true, {@link } only updates this constraint if the {@link }
             contains this constraint.
             *
             * @instance
             * @public
             * @memberof Spine.ConstraintData
             * @function SkinRequired
             * @type boolean
             * @see {@link Skin.Constraints}
             */
            SkinRequired: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.ConstraintData#SkinRequired#get", this ); }

                    return this.skinRequired;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.ConstraintData#SkinRequired#set", this ); }

                    this.skinRequired = value;
                }
            }
        },
        ctors: {
            ctor: function (name) {
if ( TRACE ) { TRACE( "Spine.ConstraintData#ctor", this ); }

                this.$initialize();
                if (name == null) {
                    throw new System.ArgumentNullException.$ctor3("name", "name cannot be null.");
                }
                this.name = name;
            }
        },
        methods: {
            /*Spine.ConstraintData.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.ConstraintData#toString", this ); }

                return this.name;
            },
            /*Spine.ConstraintData.toString end.*/


        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.ConstraintData end.*/

    /*Spine.Event start.*/
    /**
     * Stores the current pose values for an Event.
     *
     * @public
     * @class Spine.Event
     */
    Bridge.define("Spine.Event", {
        fields: {
            data: null,
            time: 0,
            intValue: 0,
            floatValue: 0,
            stringValue: null,
            volume: 0,
            balance: 0
        },
        props: {
            Data: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Event#Data#get", this ); }

                    return this.data;
                }
            },
            /**
             * The animation time this event was keyed.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Event
             * @function Time
             * @type number
             */
            Time: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Event#Time#get", this ); }

                    return this.time;
                }
            },
            Int: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Event#Int#get", this ); }

                    return this.intValue;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Event#Int#set", this ); }

                    this.intValue = value;
                }
            },
            Float: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Event#Float#get", this ); }

                    return this.floatValue;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Event#Float#set", this ); }

                    this.floatValue = value;
                }
            },
            String: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Event#String#get", this ); }

                    return this.stringValue;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Event#String#set", this ); }

                    this.stringValue = value;
                }
            },
            Volume: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Event#Volume#get", this ); }

                    return this.volume;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Event#Volume#set", this ); }

                    this.volume = value;
                }
            },
            Balance: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Event#Balance#get", this ); }

                    return this.balance;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Event#Balance#set", this ); }

                    this.balance = value;
                }
            }
        },
        ctors: {
            ctor: function (time, data) {
if ( TRACE ) { TRACE( "Spine.Event#ctor", this ); }

                this.$initialize();
                if (data == null) {
                    throw new System.ArgumentNullException.$ctor3("data", "data cannot be null.");
                }
                this.time = time;
                this.data = data;
            }
        },
        methods: {
            /*Spine.Event.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.Event#toString", this ); }

                return this.data.Name;
            },
            /*Spine.Event.toString end.*/


        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.Event end.*/

    /*Spine.EventData start.*/
    /**
     * Stores the setup pose values for an Event.
     *
     * @public
     * @class Spine.EventData
     */
    Bridge.define("Spine.EventData", {
        fields: {
            name: null,
            Int: 0,
            Float: 0,
            String: null,
            AudioPath: null,
            Volume: 0,
            Balance: 0
        },
        props: {
            /**
             * The name of the event, which is unique across all events in the skeleton.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.EventData
             * @function Name
             * @type string
             */
            Name: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.EventData#Name#get", this ); }

                    return this.name;
                }
            }
        },
        ctors: {
            ctor: function (name) {
if ( TRACE ) { TRACE( "Spine.EventData#ctor", this ); }

                this.$initialize();
                if (name == null) {
                    throw new System.ArgumentNullException.$ctor3("name", "name cannot be null.");
                }
                this.name = name;
            }
        },
        methods: {
            /*Spine.EventData.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.EventData#toString", this ); }

                return this.Name;
            },
            /*Spine.EventData.toString end.*/


        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.EventData end.*/

    /*Spine.EventQueue start.*/
    Bridge.define("Spine.EventQueue", {
        fields: {
            eventQueueEntries: null,
            drainDisabled: false,
            state: null,
            trackEntryPool: null
        },
        events: {
            AnimationsChanged: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.EventQueue#init", this ); }

                this.eventQueueEntries = new (System.Collections.Generic.List$1(Spine.EventQueue.EventQueueEntry)).ctor();
            },
            ctor: function (state, HandleAnimationsChanged, trackEntryPool) {
if ( TRACE ) { TRACE( "Spine.EventQueue#ctor", this ); }

                this.$initialize();
                this.state = state;
                this.addAnimationsChanged(HandleAnimationsChanged);
                this.trackEntryPool = trackEntryPool;
            }
        },
        methods: {
            /*Spine.EventQueue.Start start.*/
            Start: function (entry) {
if ( TRACE ) { TRACE( "Spine.EventQueue#Start", this ); }

                this.eventQueueEntries.add(new Spine.EventQueue.EventQueueEntry.$ctor1(Spine.EventQueue.EventType.Start, entry));
                if (!Bridge.staticEquals(this.AnimationsChanged, null)) {
                    this.AnimationsChanged();
                }
            },
            /*Spine.EventQueue.Start end.*/

            /*Spine.EventQueue.Interrupt start.*/
            Interrupt: function (entry) {
if ( TRACE ) { TRACE( "Spine.EventQueue#Interrupt", this ); }

                this.eventQueueEntries.add(new Spine.EventQueue.EventQueueEntry.$ctor1(Spine.EventQueue.EventType.Interrupt, entry));
            },
            /*Spine.EventQueue.Interrupt end.*/

            /*Spine.EventQueue.End start.*/
            End: function (entry) {
if ( TRACE ) { TRACE( "Spine.EventQueue#End", this ); }

                this.eventQueueEntries.add(new Spine.EventQueue.EventQueueEntry.$ctor1(Spine.EventQueue.EventType.End, entry));
                if (!Bridge.staticEquals(this.AnimationsChanged, null)) {
                    this.AnimationsChanged();
                }
            },
            /*Spine.EventQueue.End end.*/

            /*Spine.EventQueue.Dispose start.*/
            Dispose: function (entry) {
if ( TRACE ) { TRACE( "Spine.EventQueue#Dispose", this ); }

                this.eventQueueEntries.add(new Spine.EventQueue.EventQueueEntry.$ctor1(Spine.EventQueue.EventType.Dispose, entry));
            },
            /*Spine.EventQueue.Dispose end.*/

            /*Spine.EventQueue.Complete start.*/
            Complete: function (entry) {
if ( TRACE ) { TRACE( "Spine.EventQueue#Complete", this ); }

                this.eventQueueEntries.add(new Spine.EventQueue.EventQueueEntry.$ctor1(Spine.EventQueue.EventType.Complete, entry));
            },
            /*Spine.EventQueue.Complete end.*/

            /*Spine.EventQueue.Event start.*/
            Event: function (entry, e) {
if ( TRACE ) { TRACE( "Spine.EventQueue#Event", this ); }

                this.eventQueueEntries.add(new Spine.EventQueue.EventQueueEntry.$ctor1(Spine.EventQueue.EventType.Event, entry, e));
            },
            /*Spine.EventQueue.Event end.*/

            /*Spine.EventQueue.Drain start.*/
            /**
             * Raises all events in the queue and drains the queue.
             *
             * @instance
             * @this Spine.EventQueue
             * @memberof Spine.EventQueue
             * @return  {void}
             */
            Drain: function () {
if ( TRACE ) { TRACE( "Spine.EventQueue#Drain", this ); }

                var $step = 0,
                    $jumpFromFinally, 
                    eventQueueEntries, 
                    state, 
                    i, 
                    queueEntry, 
                    trackEntry, 
                    $t, 
                    $asyncBody = Bridge.fn.bind(this, function () {
                        for (;;) {
                            $step = System.Array.min([0,1,2,3,4,5,6,7,8,10,11], $step);
                            switch ($step) {
                                case 0: {
                                    if (this.drainDisabled) {
                                        return;
                                    }
                                    this.drainDisabled = true;

                                    eventQueueEntries = this.eventQueueEntries;
                                    state = this.state;

                                    // Don't cache eventQueueEntries.Count so callbacks can queue their own events (eg, call SetAnimation in AnimationState_Complete).
                                    i = 0;
                                    $step = 1;
                                    continue;
                                }
                                case 1: {
                                    if ( i < eventQueueEntries.Count ) {
                                        $step = 2;
                                        continue;
                                    }
                                    $step = 11;
                                    continue;
                                }
                                case 2: {
                                    queueEntry = eventQueueEntries.getItem(i).$clone();
                                    trackEntry = queueEntry.entry;

                                    $t = queueEntry.type;
                                    if ($t === Spine.EventQueue.EventType.Start) {
                                        $step = 3;
                                        continue;
                                    }
                                    else if ($t === Spine.EventQueue.EventType.Interrupt) {
                                        $step = 4;
                                        continue;
                                    }
                                    else if ($t === Spine.EventQueue.EventType.End) {
                                        $step = 5;
                                        continue;
                                    }
                                    else if ($t === Spine.EventQueue.EventType.Dispose) {
                                        $step = 6;
                                        continue;
                                    }
                                    else if ($t === Spine.EventQueue.EventType.Complete) {
                                        $step = 7;
                                        continue;
                                    }
                                    else if ($t === Spine.EventQueue.EventType.Event) {
                                        $step = 8;
                                        continue;
                                    }
                                    $step = 9;
                                    continue;
                                }
                                case 3: {
                                    trackEntry.OnStart();
                                    state.OnStart(trackEntry);
                                    $step = 9;
                                    continue;
                                }
                                case 4: {
                                    trackEntry.OnInterrupt();
                                    state.OnInterrupt(trackEntry);
                                    $step = 9;
                                    continue;
                                }
                                case 5: {
                                    trackEntry.OnEnd();
                                    state.OnEnd(trackEntry);
                                    $step = 6;
                                    continue;
                                }
                                case 6: {
                                    trackEntry.OnDispose();
                                    state.OnDispose(trackEntry);
                                    this.trackEntryPool.Free(trackEntry);
                                    $step = 9;
                                    continue;
                                }
                                case 7: {
                                    trackEntry.OnComplete();
                                    state.OnComplete(trackEntry);
                                    $step = 9;
                                    continue;
                                }
                                case 8: {
                                    trackEntry.OnEvent(queueEntry.e);
                                    state.OnEvent(trackEntry, queueEntry.e);
                                    $step = 9;
                                    continue;
                                }

                                case 10: {
                                    i = (i + 1) | 0;
                                    $step = 1;
                                    continue;
                                }
                                case 11: {
                                    eventQueueEntries.clear();

                                    this.drainDisabled = false;
                                    return;
                                }
                                default: {
                                    return;
                                }
                            }
                        }
                    }, arguments);

                return $asyncBody();
            },
            /*Spine.EventQueue.Drain end.*/

            /*Spine.EventQueue.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.EventQueue#Clear", this ); }

                this.eventQueueEntries.clear();
            },
            /*Spine.EventQueue.Clear end.*/


        }
    });
    /*Spine.EventQueue end.*/

    /*Spine.EventQueue+EventQueueEntry start.*/
    Bridge.define("Spine.EventQueue.EventQueueEntry", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.EventQueue.EventQueueEntry#getDefaultValue", this ); }
 return new Spine.EventQueue.EventQueueEntry(); }
            }
        },
        fields: {
            type: 0,
            entry: null,
            e: null
        },
        ctors: {
            $ctor1: function (eventType, trackEntry, e) {
if ( TRACE ) { TRACE( "Spine.EventQueue.EventQueueEntry#$ctor1", this ); }

                if (e === void 0) { e = null; }

                this.$initialize();
                this.type = eventType;
                this.entry = trackEntry;
                this.e = e;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.EventQueue.EventQueueEntry#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.EventQueue.EventQueueEntry#getHashCode", this ); }

                var h = Bridge.addHash([5412331426, this.type, this.entry, this.e]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.EventQueue.EventQueueEntry#equals", this ); }

                if (!Bridge.is(o, Spine.EventQueue.EventQueueEntry)) {
                    return false;
                }
                return Bridge.equals(this.type, o.type) && Bridge.equals(this.entry, o.entry) && Bridge.equals(this.e, o.e);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.EventQueue.EventQueueEntry#$clone", this ); }

                var s = to || new Spine.EventQueue.EventQueueEntry();
                s.type = this.type;
                s.entry = this.entry;
                s.e = this.e;
                return s;
            }
        }
    });
    /*Spine.EventQueue+EventQueueEntry end.*/

    /*Spine.EventQueue+EventType start.*/
    Bridge.define("Spine.EventQueue.EventType", {
        $kind: 1006,
        statics: {
            fields: {
                Start: 0,
                Interrupt: 1,
                End: 2,
                Dispose: 3,
                Complete: 4,
                Event: 5
            }
        }
    });
    /*Spine.EventQueue+EventType end.*/

    /*Spine.ExposedList$1 start.*/
    Bridge.define("Spine.ExposedList$1", function (T) { return {
        inherits: [System.Collections.Generic.IEnumerable$1(T)],
        statics: {
            fields: {
                DefaultCapacity: 0,
                EmptyArray: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#init", this ); }

                    this.DefaultCapacity = 4;
                    this.EmptyArray = System.Array.init(0, function (){
                        return Bridge.getDefaultValue(T);
                    }, T);
                }
            },
            methods: {
                /*Spine.ExposedList$1.CheckMatch:static start.*/
                CheckMatch: function (match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#CheckMatch", this ); }

                    if (Bridge.staticEquals(match, null)) {
                        throw new System.ArgumentNullException.$ctor1("match");
                    }
                },
                /*Spine.ExposedList$1.CheckMatch:static end.*/


            }
        },
        fields: {
            Items: null,
            Count: 0,
            version: 0
        },
        props: {
            Capacity: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Capacity#get", this ); }

                    return this.Items.length;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Capacity#set", this ); }

                    if ((value >>> 0) < (this.Count >>> 0)) {
                        throw new System.ArgumentOutOfRangeException.ctor();
                    }

                    System.Array.resize(Bridge.ref(this, "Items"), value, function () {
                        return Bridge.getDefaultValue(T);
                    }, T);
                }
            }
        },
        alias: ["System$Collections$Generic$IEnumerable$1$GetEnumerator", "System$Collections$Generic$IEnumerable$1$" + Bridge.getTypeAlias(T) + "$GetEnumerator"],
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#ctor", this ); }

                this.$initialize();
                this.Items = Spine.ExposedList$1(T).EmptyArray;
            },
            $ctor2: function (collection) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#$ctor2", this ); }

                this.$initialize();
                this.CheckCollection(collection);

                // initialize to needed size (if determinable)
                var c = Bridge.as(collection, System.Collections.Generic.ICollection$1(T));
                if (c == null) {
                    this.Items = Spine.ExposedList$1(T).EmptyArray;
                    this.AddEnumerable(collection);
                } else {
                    this.Items = System.Array.init(System.Array.getCount(c, T), function (){
                        return Bridge.getDefaultValue(T);
                    }, T);
                    this.AddCollection(c);
                }
            },
            $ctor3: function (capacity) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#$ctor3", this ); }

                this.$initialize();
                if (capacity < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("capacity");
                }
                this.Items = System.Array.init(capacity, function (){
                    return Bridge.getDefaultValue(T);
                }, T);
            },
            $ctor1: function (data, size) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#$ctor1", this ); }

                this.$initialize();
                this.Items = data;
                this.Count = size;
            }
        },
        methods: {
            /*Spine.ExposedList$1.Add start.*/
            Add: function (item) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Add", this ); }

                // If we check to see if we need to grow before trying to grow
                // we can speed things up by 25%
                if (this.Count === this.Items.length) {
                    this.GrowIfNeeded(1);
                }
                this.Items[Bridge.identity(this.Count, ((this.Count = (this.Count + 1) | 0)))] = Bridge.rValue(item);
                this.version = (this.version + 1) | 0;
            },
            /*Spine.ExposedList$1.Add end.*/

            /*Spine.ExposedList$1.GrowIfNeeded start.*/
            GrowIfNeeded: function (addedCount) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#GrowIfNeeded", this ); }

                var minimumSize = (this.Count + addedCount) | 0;
                if (minimumSize > this.Items.length) {
                    this.Capacity = Math.max(Math.max(Bridge.Int.mul(this.Capacity, 2), Spine.ExposedList$1(T).DefaultCapacity), minimumSize);
                }
            },
            /*Spine.ExposedList$1.GrowIfNeeded end.*/

            /*Spine.ExposedList$1.Resize start.*/
            Resize: function (newSize) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Resize", this ); }

                var itemsLength = this.Items.length;
                var oldItems = this.Items;
                if (newSize > itemsLength) {
                    System.Array.resize(Bridge.ref(this, "Items"), newSize, function () {
                        return Bridge.getDefaultValue(T);
                    }, T);
                } else if (newSize < itemsLength) {
                    // Allow nulling of T reference type to allow GC.
                    for (var i = newSize; i < itemsLength; i = (i + 1) | 0) {
                        oldItems[i] = Bridge.getDefaultValue(T);
                    }
                }
                this.Count = newSize;
                return this;
            },
            /*Spine.ExposedList$1.Resize end.*/

            /*Spine.ExposedList$1.EnsureCapacity start.*/
            EnsureCapacity: function (min) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#EnsureCapacity", this ); }

                if (this.Items.length < min) {
                    var newCapacity = this.Items.length === 0 ? Spine.ExposedList$1(T).DefaultCapacity : Bridge.Int.mul(this.Items.length, 2);
                    //if ((uint)newCapacity > Array.MaxArrayLength) newCapacity = Array.MaxArrayLength;
                    if (newCapacity < min) {
                        newCapacity = min;
                    }
                    this.Capacity = newCapacity;
                }
            },
            /*Spine.ExposedList$1.EnsureCapacity end.*/

            /*Spine.ExposedList$1.CheckRange start.*/
            CheckRange: function (index, count) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#CheckRange", this ); }

                if (index < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("index");
                }

                if (count < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("count");
                }

                if ((((index >>> 0) + (count >>> 0)) >>> 0) > (this.Count >>> 0)) {
                    throw new System.ArgumentException.$ctor1("index and count exceed length of list");
                }
            },
            /*Spine.ExposedList$1.CheckRange end.*/

            /*Spine.ExposedList$1.AddCollection start.*/
            AddCollection: function (collection) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#AddCollection", this ); }

                var collectionCount = System.Array.getCount(collection, T);
                if (collectionCount === 0) {
                    return;
                }

                this.GrowIfNeeded(collectionCount);
                System.Array.copyTo(collection, this.Items, this.Count, T);
                this.Count = (this.Count + collectionCount) | 0;
            },
            /*Spine.ExposedList$1.AddCollection end.*/

            /*Spine.ExposedList$1.AddEnumerable start.*/
            AddEnumerable: function (enumerable) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#AddEnumerable", this ); }

                var $t;
                $t = Bridge.getEnumerator(enumerable, T);
                try {
                    while ($t.moveNext()) {
                        var t = Bridge.rValue($t.Current);
                        this.Add(Bridge.rValue(t));
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.ExposedList$1.AddEnumerable end.*/

            /*Spine.ExposedList$1.AddRange start.*/
            AddRange: function (list) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#AddRange", this ); }

                this.CheckCollection(list);

                var collectionCount = list.Count;
                if (collectionCount === 0) {
                    return;
                }

                this.GrowIfNeeded(collectionCount);
                list.CopyTo$1(this.Items, this.Count);
                this.Count = (this.Count + collectionCount) | 0;

                this.version = (this.version + 1) | 0;
            },
            /*Spine.ExposedList$1.AddRange end.*/

            /*Spine.ExposedList$1.AddRange$1 start.*/
            AddRange$1: function (collection) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#AddRange$1", this ); }

                this.CheckCollection(collection);

                var c = Bridge.as(collection, System.Collections.Generic.ICollection$1(T));
                if (c != null) {
                    this.AddCollection(c);
                } else {
                    this.AddEnumerable(collection);
                }
                this.version = (this.version + 1) | 0;
            },
            /*Spine.ExposedList$1.AddRange$1 end.*/

            /*Spine.ExposedList$1.BinarySearch start.*/
            BinarySearch: function (item) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#BinarySearch", this ); }

                return System.Array.binarySearch(this.Items, 0, this.Count, Bridge.rValue(item));
            },
            /*Spine.ExposedList$1.BinarySearch end.*/

            /*Spine.ExposedList$1.BinarySearch$1 start.*/
            BinarySearch$1: function (item, comparer) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#BinarySearch$1", this ); }

                return System.Array.binarySearch(this.Items, 0, this.Count, Bridge.rValue(item), comparer);
            },
            /*Spine.ExposedList$1.BinarySearch$1 end.*/

            /*Spine.ExposedList$1.BinarySearch$2 start.*/
            BinarySearch$2: function (index, count, item, comparer) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#BinarySearch$2", this ); }

                this.CheckRange(index, count);
                return System.Array.binarySearch(this.Items, index, count, Bridge.rValue(item), comparer);
            },
            /*Spine.ExposedList$1.BinarySearch$2 end.*/

            /*Spine.ExposedList$1.Clear start.*/
            Clear: function (clearArray) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Clear", this ); }

                if (clearArray === void 0) { clearArray = true; }
                if (clearArray) {
                    System.Array.fill(this.Items, function () {
                        return Bridge.getDefaultValue(T);
                    }, 0, this.Items.length);
                }

                this.Count = 0;
                this.version = (this.version + 1) | 0;
            },
            /*Spine.ExposedList$1.Clear end.*/

            /*Spine.ExposedList$1.Contains start.*/
            Contains: function (item) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Contains", this ); }

                return System.Array.indexOfT(this.Items, Bridge.rValue(item), 0, this.Count) !== -1;
            },
            /*Spine.ExposedList$1.Contains end.*/

            /*Spine.ExposedList$1.ConvertAll start.*/
            ConvertAll: function (TOutput, converter) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#ConvertAll", this ); }

                if (Bridge.staticEquals(converter, null)) {
                    throw new System.ArgumentNullException.$ctor1("converter");
                }
                var u = new (Spine.ExposedList$1(TOutput)).$ctor3(this.Count);
                u.Count = this.Count;
                var items = this.Items;
                var uItems = u.Items;
                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    uItems[i] = Bridge.rValue(converter(Bridge.rValue(items[i])));
                }
                return u;
            },
            /*Spine.ExposedList$1.ConvertAll end.*/

            /*Spine.ExposedList$1.CopyTo start.*/
            CopyTo: function (array) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#CopyTo", this ); }

                System.Array.copy(this.Items, 0, array, 0, this.Count);
            },
            /*Spine.ExposedList$1.CopyTo end.*/

            /*Spine.ExposedList$1.CopyTo$1 start.*/
            CopyTo$1: function (array, arrayIndex) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#CopyTo$1", this ); }

                System.Array.copy(this.Items, 0, array, arrayIndex, this.Count);
            },
            /*Spine.ExposedList$1.CopyTo$1 end.*/

            /*Spine.ExposedList$1.CopyTo$2 start.*/
            CopyTo$2: function (index, array, arrayIndex, count) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#CopyTo$2", this ); }

                this.CheckRange(index, count);
                System.Array.copy(this.Items, index, array, arrayIndex, count);
            },
            /*Spine.ExposedList$1.CopyTo$2 end.*/

            /*Spine.ExposedList$1.Exists start.*/
            Exists: function (match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Exists", this ); }

                Spine.ExposedList$1(T).CheckMatch(match);
                return this.GetIndex(0, this.Count, match) !== -1;
            },
            /*Spine.ExposedList$1.Exists end.*/

            /*Spine.ExposedList$1.Find start.*/
            Find: function (match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Find", this ); }

                Spine.ExposedList$1(T).CheckMatch(match);
                var i = this.GetIndex(0, this.Count, match);
                return (i !== -1) ? Bridge.rValue(this.Items[i]) : Bridge.getDefaultValue(T);
            },
            /*Spine.ExposedList$1.Find end.*/

            /*Spine.ExposedList$1.FindAll start.*/
            FindAll: function (match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#FindAll", this ); }

                Spine.ExposedList$1(T).CheckMatch(match);
                return this.FindAllList(match);
            },
            /*Spine.ExposedList$1.FindAll end.*/

            /*Spine.ExposedList$1.FindAllList start.*/
            FindAllList: function (match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#FindAllList", this ); }

                var results = new (Spine.ExposedList$1(T)).ctor();
                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    if (match(Bridge.rValue(this.Items[i]))) {
                        results.Add(Bridge.rValue(this.Items[i]));
                    }
                }

                return results;
            },
            /*Spine.ExposedList$1.FindAllList end.*/

            /*Spine.ExposedList$1.FindIndex$2 start.*/
            FindIndex$2: function (match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#FindIndex$2", this ); }

                Spine.ExposedList$1(T).CheckMatch(match);
                return this.GetIndex(0, this.Count, match);
            },
            /*Spine.ExposedList$1.FindIndex$2 end.*/

            /*Spine.ExposedList$1.FindIndex$1 start.*/
            FindIndex$1: function (startIndex, match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#FindIndex$1", this ); }

                Spine.ExposedList$1(T).CheckMatch(match);
                this.CheckIndex(startIndex);
                return this.GetIndex(startIndex, ((this.Count - startIndex) | 0), match);
            },
            /*Spine.ExposedList$1.FindIndex$1 end.*/

            /*Spine.ExposedList$1.FindIndex start.*/
            FindIndex: function (startIndex, count, match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#FindIndex", this ); }

                Spine.ExposedList$1(T).CheckMatch(match);
                this.CheckRange(startIndex, count);
                return this.GetIndex(startIndex, count, match);
            },
            /*Spine.ExposedList$1.FindIndex end.*/

            /*Spine.ExposedList$1.GetIndex start.*/
            GetIndex: function (startIndex, count, match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#GetIndex", this ); }

                var end = (startIndex + count) | 0;
                for (var i = startIndex; i < end; i = (i + 1) | 0) {
                    if (match(Bridge.rValue(this.Items[i]))) {
                        return i;
                    }
                }

                return -1;
            },
            /*Spine.ExposedList$1.GetIndex end.*/

            /*Spine.ExposedList$1.FindLast start.*/
            FindLast: function (match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#FindLast", this ); }

                Spine.ExposedList$1(T).CheckMatch(match);
                var i = this.GetLastIndex(0, this.Count, match);
                return i === -1 ? Bridge.getDefaultValue(T) : Bridge.rValue(this.Items[i]);
            },
            /*Spine.ExposedList$1.FindLast end.*/

            /*Spine.ExposedList$1.FindLastIndex$2 start.*/
            FindLastIndex$2: function (match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#FindLastIndex$2", this ); }

                Spine.ExposedList$1(T).CheckMatch(match);
                return this.GetLastIndex(0, this.Count, match);
            },
            /*Spine.ExposedList$1.FindLastIndex$2 end.*/

            /*Spine.ExposedList$1.FindLastIndex$1 start.*/
            FindLastIndex$1: function (startIndex, match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#FindLastIndex$1", this ); }

                Spine.ExposedList$1(T).CheckMatch(match);
                this.CheckIndex(startIndex);
                return this.GetLastIndex(0, ((startIndex + 1) | 0), match);
            },
            /*Spine.ExposedList$1.FindLastIndex$1 end.*/

            /*Spine.ExposedList$1.FindLastIndex start.*/
            FindLastIndex: function (startIndex, count, match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#FindLastIndex", this ); }

                Spine.ExposedList$1(T).CheckMatch(match);
                var start = (((startIndex - count) | 0) + 1) | 0;
                this.CheckRange(start, count);
                return this.GetLastIndex(start, count, match);
            },
            /*Spine.ExposedList$1.FindLastIndex end.*/

            /*Spine.ExposedList$1.GetLastIndex start.*/
            GetLastIndex: function (startIndex, count, match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#GetLastIndex", this ); }

                // unlike FindLastIndex, takes regular params for search range
                for (var i = (startIndex + count) | 0; i !== startIndex; ) {
                    if (match(Bridge.rValue(this.Items[((i = (i - 1) | 0))]))) {
                        return i;
                    }
                }
                return -1;
            },
            /*Spine.ExposedList$1.GetLastIndex end.*/

            /*Spine.ExposedList$1.ForEach start.*/
            ForEach: function (action) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#ForEach", this ); }

                if (Bridge.staticEquals(action, null)) {
                    throw new System.ArgumentNullException.$ctor1("action");
                }
                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    action(Bridge.rValue(this.Items[i]));
                }
            },
            /*Spine.ExposedList$1.ForEach end.*/

            /*Spine.ExposedList$1.GetEnumerator start.*/
            GetEnumerator: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#GetEnumerator", this ); }

                return new (Spine.ExposedList$1.Enumerator(T)).$ctor1(this);
            },
            /*Spine.ExposedList$1.GetEnumerator end.*/

            /*Spine.ExposedList$1.System$Collections$Generic$IEnumerable$1$GetEnumerator start.*/
            System$Collections$Generic$IEnumerable$1$GetEnumerator: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#System$Collections$Generic$IEnumerable$1$GetEnumerator", this ); }

                return this.GetEnumerator().$clone();
            },
            /*Spine.ExposedList$1.System$Collections$Generic$IEnumerable$1$GetEnumerator end.*/

            /*Spine.ExposedList$1.System$Collections$IEnumerable$GetEnumerator start.*/
            System$Collections$IEnumerable$GetEnumerator: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#System$Collections$IEnumerable$GetEnumerator", this ); }

                return this.GetEnumerator().$clone();
            },
            /*Spine.ExposedList$1.System$Collections$IEnumerable$GetEnumerator end.*/

            /*Spine.ExposedList$1.GetRange start.*/
            GetRange: function (index, count) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#GetRange", this ); }

                this.CheckRange(index, count);
                var tmpArray = System.Array.init(count, function (){
                    return Bridge.getDefaultValue(T);
                }, T);
                System.Array.copy(this.Items, index, tmpArray, 0, count);
                return new (Spine.ExposedList$1(T)).$ctor1(tmpArray, count);
            },
            /*Spine.ExposedList$1.GetRange end.*/

            /*Spine.ExposedList$1.IndexOf start.*/
            IndexOf: function (item) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#IndexOf", this ); }

                return System.Array.indexOfT(this.Items, Bridge.rValue(item), 0, this.Count);
            },
            /*Spine.ExposedList$1.IndexOf end.*/

            /*Spine.ExposedList$1.IndexOf$1 start.*/
            IndexOf$1: function (item, index) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#IndexOf$1", this ); }

                this.CheckIndex(index);
                return System.Array.indexOfT(this.Items, Bridge.rValue(item), index, ((this.Count - index) | 0));
            },
            /*Spine.ExposedList$1.IndexOf$1 end.*/

            /*Spine.ExposedList$1.IndexOf$2 start.*/
            IndexOf$2: function (item, index, count) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#IndexOf$2", this ); }

                if (index < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("index");
                }

                if (count < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("count");
                }

                if ((((index >>> 0) + (count >>> 0)) >>> 0) > (this.Count >>> 0)) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("index and count exceed length of list");
                }

                return System.Array.indexOfT(this.Items, Bridge.rValue(item), index, count);
            },
            /*Spine.ExposedList$1.IndexOf$2 end.*/

            /*Spine.ExposedList$1.Shift start.*/
            Shift: function (start, delta) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Shift", this ); }

                if (delta < 0) {
                    start = (start - delta) | 0;
                }

                if (start < this.Count) {
                    System.Array.copy(this.Items, start, this.Items, ((start + delta) | 0), ((this.Count - start) | 0));
                }

                this.Count = (this.Count + delta) | 0;

                if (delta < 0) {
                    System.Array.fill(this.Items, function () {
                        return Bridge.getDefaultValue(T);
                    }, this.Count, ((-delta) | 0));
                }
            },
            /*Spine.ExposedList$1.Shift end.*/

            /*Spine.ExposedList$1.CheckIndex start.*/
            CheckIndex: function (index) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#CheckIndex", this ); }

                if (index < 0 || (index >>> 0) > (this.Count >>> 0)) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("index");
                }
            },
            /*Spine.ExposedList$1.CheckIndex end.*/

            /*Spine.ExposedList$1.Insert start.*/
            Insert: function (index, item) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Insert", this ); }

                this.CheckIndex(index);
                if (this.Count === this.Items.length) {
                    this.GrowIfNeeded(1);
                }
                this.Shift(index, 1);
                this.Items[index] = Bridge.rValue(item);
                this.version = (this.version + 1) | 0;
            },
            /*Spine.ExposedList$1.Insert end.*/

            /*Spine.ExposedList$1.CheckCollection start.*/
            CheckCollection: function (collection) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#CheckCollection", this ); }

                if (collection == null) {
                    throw new System.ArgumentNullException.$ctor1("collection");
                }
            },
            /*Spine.ExposedList$1.CheckCollection end.*/

            /*Spine.ExposedList$1.InsertRange start.*/
            InsertRange: function (index, collection) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#InsertRange", this ); }

                this.CheckCollection(collection);
                this.CheckIndex(index);
                if (Bridge.referenceEquals(collection, this)) {
                    var buffer = System.Array.init(this.Count, function (){
                        return Bridge.getDefaultValue(T);
                    }, T);
                    this.CopyTo$1(buffer, 0);
                    this.GrowIfNeeded(this.Count);
                    this.Shift(index, buffer.length);
                    System.Array.copy(buffer, 0, this.Items, index, buffer.length);
                } else {
                    var c = Bridge.as(collection, System.Collections.Generic.ICollection$1(T));
                    if (c != null) {
                        this.InsertCollection(index, c);
                    } else {
                        this.InsertEnumeration(index, collection);
                    }
                }
                this.version = (this.version + 1) | 0;
            },
            /*Spine.ExposedList$1.InsertRange end.*/

            /*Spine.ExposedList$1.InsertCollection start.*/
            InsertCollection: function (index, collection) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#InsertCollection", this ); }

                var collectionCount = System.Array.getCount(collection, T);
                this.GrowIfNeeded(collectionCount);

                this.Shift(index, collectionCount);
                System.Array.copyTo(collection, this.Items, index, T);
            },
            /*Spine.ExposedList$1.InsertCollection end.*/

            /*Spine.ExposedList$1.InsertEnumeration start.*/
            InsertEnumeration: function (index, enumerable) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#InsertEnumeration", this ); }

                var $t;
                $t = Bridge.getEnumerator(enumerable, T);
                try {
                    while ($t.moveNext()) {
                        var t = Bridge.rValue($t.Current);
                        this.Insert(Bridge.identity(index, ((index = (index + 1) | 0))), Bridge.rValue(t));
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.ExposedList$1.InsertEnumeration end.*/

            /*Spine.ExposedList$1.LastIndexOf start.*/
            LastIndexOf: function (item) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#LastIndexOf", this ); }

                return System.Array.lastIndexOfT(this.Items, Bridge.rValue(item), ((this.Count - 1) | 0), this.Count);
            },
            /*Spine.ExposedList$1.LastIndexOf end.*/

            /*Spine.ExposedList$1.LastIndexOf$1 start.*/
            LastIndexOf$1: function (item, index) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#LastIndexOf$1", this ); }

                this.CheckIndex(index);
                return System.Array.lastIndexOfT(this.Items, Bridge.rValue(item), index, ((index + 1) | 0));
            },
            /*Spine.ExposedList$1.LastIndexOf$1 end.*/

            /*Spine.ExposedList$1.LastIndexOf$2 start.*/
            LastIndexOf$2: function (item, index, count) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#LastIndexOf$2", this ); }

                if (index < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor3("index", Bridge.box(index, System.Int32), "index is negative");
                }

                if (count < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor3("count", Bridge.box(count, System.Int32), "count is negative");
                }

                if (((((index - count) | 0) + 1) | 0) < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor3("count", Bridge.box(count, System.Int32), "count is too large");
                }

                return System.Array.lastIndexOfT(this.Items, Bridge.rValue(item), index, count);
            },
            /*Spine.ExposedList$1.LastIndexOf$2 end.*/

            /*Spine.ExposedList$1.Remove start.*/
            Remove: function (item) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Remove", this ); }

                var loc = this.IndexOf(Bridge.rValue(item));
                if (loc !== -1) {
                    this.RemoveAt(loc);
                }

                return loc !== -1;
            },
            /*Spine.ExposedList$1.Remove end.*/

            /*Spine.ExposedList$1.RemoveAll start.*/
            RemoveAll: function (match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#RemoveAll", this ); }

                Spine.ExposedList$1(T).CheckMatch(match);
                var i = 0;
                var j = 0;

                // Find the first item to remove
                for (i = 0; i < this.Count; i = (i + 1) | 0) {
                    if (match(Bridge.rValue(this.Items[i]))) {
                        break;
                    }
                }

                if (i === this.Count) {
                    return 0;
                }

                this.version = (this.version + 1) | 0;

                // Remove any additional items
                for (j = (i + 1) | 0; j < this.Count; j = (j + 1) | 0) {
                    if (!match(Bridge.rValue(this.Items[j]))) {
                        this.Items[Bridge.identity(i, ((i = (i + 1) | 0)))] = Bridge.rValue(this.Items[j]);
                    }
                }
                if (((j - i) | 0) > 0) {
                    System.Array.fill(this.Items, function () {
                        return Bridge.getDefaultValue(T);
                    }, i, ((j - i) | 0));
                }

                this.Count = i;
                return (((j - i) | 0));
            },
            /*Spine.ExposedList$1.RemoveAll end.*/

            /*Spine.ExposedList$1.RemoveAt start.*/
            RemoveAt: function (index) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#RemoveAt", this ); }

                if (index < 0 || (index >>> 0) >= (this.Count >>> 0)) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("index");
                }
                this.Shift(index, -1);
                System.Array.fill(this.Items, function () {
                    return Bridge.getDefaultValue(T);
                }, this.Count, 1);
                this.version = (this.version + 1) | 0;
            },
            /*Spine.ExposedList$1.RemoveAt end.*/

            /*Spine.ExposedList$1.Pop start.*/
            /**
             * Pops the last item of the list. If the list is empty, Pop throws an InvalidOperationException.
             *
             * @instance
             * @public
             * @this Spine.ExposedList$1
             * @memberof Spine.ExposedList$1
             * @return  {T}
             */
            Pop: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Pop", this ); }

                if (this.Count === 0) {
                    throw new System.InvalidOperationException.$ctor1("List is empty. Nothing to pop.");
                }

                var i = (this.Count - 1) | 0;
                var item = Bridge.rValue(this.Items[i]);
                this.Items[i] = Bridge.getDefaultValue(T);
                this.Count = (this.Count - 1) | 0;
                this.version = (this.version + 1) | 0;
                return Bridge.rValue(item);
            },
            /*Spine.ExposedList$1.Pop end.*/

            /*Spine.ExposedList$1.RemoveRange start.*/
            RemoveRange: function (index, count) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#RemoveRange", this ); }

                this.CheckRange(index, count);
                if (count > 0) {
                    this.Shift(index, ((-count) | 0));
                    System.Array.fill(this.Items, function () {
                        return Bridge.getDefaultValue(T);
                    }, this.Count, count);
                    this.version = (this.version + 1) | 0;
                }
            },
            /*Spine.ExposedList$1.RemoveRange end.*/

            /*Spine.ExposedList$1.Reverse start.*/
            Reverse: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Reverse", this ); }

                System.Array.reverse(this.Items, 0, this.Count);
                this.version = (this.version + 1) | 0;
            },
            /*Spine.ExposedList$1.Reverse end.*/

            /*Spine.ExposedList$1.Reverse$1 start.*/
            Reverse$1: function (index, count) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Reverse$1", this ); }

                this.CheckRange(index, count);
                System.Array.reverse(this.Items, index, count);
                this.version = (this.version + 1) | 0;
            },
            /*Spine.ExposedList$1.Reverse$1 end.*/

            /*Spine.ExposedList$1.Sort start.*/
            Sort: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Sort", this ); }

                System.Array.sort(this.Items, 0, this.Count, new (System.Collections.Generic.Comparer$1(T))(System.Collections.Generic.Comparer$1.$default.fn));
                this.version = (this.version + 1) | 0;
            },
            /*Spine.ExposedList$1.Sort end.*/

            /*Spine.ExposedList$1.Sort$1 start.*/
            Sort$1: function (comparer) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Sort$1", this ); }

                System.Array.sort(this.Items, 0, this.Count, comparer);
                this.version = (this.version + 1) | 0;
            },
            /*Spine.ExposedList$1.Sort$1 end.*/

            /*Spine.ExposedList$1.Sort$2 start.*/
            Sort$2: function (comparison) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Sort$2", this ); }

                System.Array.sort(this.Items, comparison);
                this.version = (this.version + 1) | 0;
            },
            /*Spine.ExposedList$1.Sort$2 end.*/

            /*Spine.ExposedList$1.Sort$3 start.*/
            Sort$3: function (index, count, comparer) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Sort$3", this ); }

                this.CheckRange(index, count);
                System.Array.sort(this.Items, index, count, comparer);
                this.version = (this.version + 1) | 0;
            },
            /*Spine.ExposedList$1.Sort$3 end.*/

            /*Spine.ExposedList$1.ToArray start.*/
            ToArray: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#ToArray", this ); }

                var t = System.Array.init(this.Count, function (){
                    return Bridge.getDefaultValue(T);
                }, T);
                System.Array.copy(this.Items, 0, t, 0, this.Count);

                return t;
            },
            /*Spine.ExposedList$1.ToArray end.*/

            /*Spine.ExposedList$1.TrimExcess start.*/
            TrimExcess: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#TrimExcess", this ); }

                this.Capacity = this.Count;
            },
            /*Spine.ExposedList$1.TrimExcess end.*/

            /*Spine.ExposedList$1.TrueForAll start.*/
            TrueForAll: function (match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#TrueForAll", this ); }

                Spine.ExposedList$1(T).CheckMatch(match);

                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    if (!match(Bridge.rValue(this.Items[i]))) {
                        return false;
                    }
                }

                return true;
            },
            /*Spine.ExposedList$1.TrueForAll end.*/


        },
        overloads: {
            "AddRange(IEnumerable<T>)": "AddRange$1",
            "BinarySearch(T, IComparer<T>)": "BinarySearch$1",
            "BinarySearch(int, int, T, IComparer<T>)": "BinarySearch$2",
            "CopyTo(T[], int)": "CopyTo$1",
            "CopyTo(int, T[], int, int)": "CopyTo$2",
            "FindIndex(Predicate<T>)": "FindIndex$2",
            "FindIndex(int, Predicate<T>)": "FindIndex$1",
            "FindLastIndex(Predicate<T>)": "FindLastIndex$2",
            "FindLastIndex(int, Predicate<T>)": "FindLastIndex$1",
            "IndexOf(T, int)": "IndexOf$1",
            "IndexOf(T, int, int)": "IndexOf$2",
            "LastIndexOf(T, int)": "LastIndexOf$1",
            "LastIndexOf(T, int, int)": "LastIndexOf$2",
            "Reverse(int, int)": "Reverse$1",
            "Sort(IComparer<T>)": "Sort$1",
            "Sort(Comparison<T>)": "Sort$2",
            "Sort(int, int, IComparer<T>)": "Sort$3"
        }
    }; });
    /*Spine.ExposedList$1 end.*/

    /*Spine.ExposedList$1+Enumerator start.*/
    Bridge.define("Spine.ExposedList$1.Enumerator", function (T) { return {
        inherits: [System.Collections.Generic.IEnumerator$1(T),System.IDisposable],
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1.Enumerator#getDefaultValue", this ); }
 return new (Spine.ExposedList$1.Enumerator(T))(); }
            }
        },
        fields: {
            l: null,
            next: 0,
            ver: 0,
            current: Bridge.getDefaultValue(T)
        },
        props: {
            Current: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1.Enumerator#Current#get", this ); }

                    return Bridge.rValue(this.current);
                }
            },
            System$Collections$IEnumerator$Current: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1.Enumerator#System$Collections$IEnumerator$Current#get", this ); }

                    this.VerifyState();
                    if (this.next <= 0) {
                        throw new System.InvalidOperationException.ctor();
                    }
                    return this.current;
                }
            }
        },
        alias: [
            "Dispose", "System$IDisposable$Dispose",
            "moveNext", "System$Collections$IEnumerator$moveNext",
            "Current", ["System$Collections$Generic$IEnumerator$1$" + Bridge.getTypeAlias(T) + "$Current$1", "System$Collections$Generic$IEnumerator$1$Current$1"]
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1.Enumerator#init", this ); }

                this.current = Bridge.getDefaultValue(T);
            },
            $ctor1: function (l) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1.Enumerator#$ctor1", this ); }

                Spine.ExposedList$1.Enumerator(T).ctor.call(this);
                this.l = l;
                this.ver = l.version;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1.Enumerator#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.ExposedList$1+Enumerator.Dispose start.*/
            Dispose: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1.Enumerator#Dispose", this ); }

                this.l = null;
            },
            /*Spine.ExposedList$1+Enumerator.Dispose end.*/

            /*Spine.ExposedList$1+Enumerator.VerifyState start.*/
            VerifyState: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1.Enumerator#VerifyState", this ); }

                if (this.l == null) {
                    throw new System.ObjectDisposedException.$ctor1(Bridge.Reflection.getTypeFullName(Spine.ExposedList$1.Enumerator(T)));
                }
                if (this.ver !== this.l.version) {
                    throw new System.InvalidOperationException.$ctor1("Collection was modified; enumeration operation may not execute.");
                }
            },
            /*Spine.ExposedList$1+Enumerator.VerifyState end.*/

            /*Spine.ExposedList$1+Enumerator.moveNext start.*/
            moveNext: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1.Enumerator#moveNext", this ); }

                var $t;
                this.VerifyState();

                if (this.next < 0) {
                    return false;
                }

                if (this.next < this.l.Count) {
                    this.current = Bridge.rValue(($t = this.l.Items)[Bridge.identity(this.next, ((this.next = (this.next + 1) | 0)))]);
                    return true;
                }

                this.next = -1;
                return false;
            },
            /*Spine.ExposedList$1+Enumerator.moveNext end.*/

            /*Spine.ExposedList$1+Enumerator.System$Collections$IEnumerator$reset start.*/
            System$Collections$IEnumerator$reset: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1.Enumerator#System$Collections$IEnumerator$reset", this ); }

                this.VerifyState();
                this.next = 0;
            },
            /*Spine.ExposedList$1+Enumerator.System$Collections$IEnumerator$reset end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1.Enumerator#getHashCode", this ); }

                var h = Bridge.addHash([3788985113, this.l, this.next, this.ver, this.current]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1.Enumerator#equals", this ); }

                if (!Bridge.is(o, Spine.ExposedList$1.Enumerator(T))) {
                    return false;
                }
                return Bridge.equals(this.l, o.l) && Bridge.equals(this.next, o.next) && Bridge.equals(this.ver, o.ver) && Bridge.equals(this.current, o.current);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1.Enumerator#$clone", this ); }

                var s = to || new (Spine.ExposedList$1.Enumerator(T))();
                s.l = this.l;
                s.next = this.next;
                s.ver = this.ver;
                s.current = Bridge.rValue(this.current);
                return s;
            }
        },
        overloads: {
            "MoveNext()": "moveNext"
        }
    }; });
    /*Spine.ExposedList$1+Enumerator end.*/

    /*Spine.Format start.*/
    Bridge.define("Spine.Format", {
        $kind: 6,
        statics: {
            fields: {
                Alpha: 0,
                Intensity: 1,
                LuminanceAlpha: 2,
                RGB565: 3,
                RGBA4444: 4,
                RGB888: 5,
                RGBA8888: 6
            }
        }
    });
    /*Spine.Format end.*/

    /*Spine.HashSetExtensions start.*/
    Bridge.define("Spine.HashSetExtensions", {
        statics: {
            methods: {
                /*Spine.HashSetExtensions.AddAll:static start.*/
                AddAll: function (T, set, addSet) {
if ( TRACE ) { TRACE( "Spine.HashSetExtensions#AddAll", this ); }

                    var anyItemAdded = false;
                    for (var i = 0, n = addSet.length; i < n; i = (i + 1) | 0) {
                        var item = Bridge.rValue(addSet[i]);
                        anyItemAdded = !!(anyItemAdded | set.add(Bridge.rValue(item)));
                    }
                    return anyItemAdded;
                },
                /*Spine.HashSetExtensions.AddAll:static end.*/


            }
        }
    });
    /*Spine.HashSetExtensions end.*/

    /*Spine.IBoneTimeline start.*/
    /**
     * An interface for timelines which change the property of a bone.
     *
     * @abstract
     * @public
     * @class Spine.IBoneTimeline
     */
    Bridge.define("Spine.IBoneTimeline", {
        $kind: 3
    });
    /*Spine.IBoneTimeline end.*/

    /*Spine.IHasTextureRegion start.*/
    Bridge.define("Spine.IHasTextureRegion", {
        $kind: 3
    });
    /*Spine.IHasTextureRegion end.*/

    /*Spine.IInterpolation start.*/
    Bridge.define("Spine.IInterpolation", {
        statics: {
            fields: {
                Pow2: null,
                Pow2Out: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.IInterpolation#init", this ); }

                    this.Pow2 = new Spine.Pow(2);
                    this.Pow2Out = new Spine.PowOut(2);
                }
            }
        },
        methods: {
            /*Spine.IInterpolation.Apply start.*/
            Apply: function (start, end, a) {
if ( TRACE ) { TRACE( "Spine.IInterpolation#Apply", this ); }

                return start + (end - start) * this.Apply$1(a);
            },
            /*Spine.IInterpolation.Apply end.*/


        }
    });
    /*Spine.IInterpolation end.*/

    /*Spine.Inherit start.*/
    Bridge.define("Spine.Inherit", {
        $kind: 6,
        statics: {
            fields: {
                Normal: 0,
                OnlyTranslation: 1,
                NoRotationOrReflection: 2,
                NoScale: 3,
                NoScaleOrReflection: 4
            }
        }
    });
    /*Spine.Inherit end.*/

    /*Spine.InheritEnum start.*/
    Bridge.define("Spine.InheritEnum", {
        statics: {
            fields: {
                Values: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.InheritEnum#init", this ); }

                    this.Values = System.Array.init([
                        Spine.Inherit.Normal, 
                        Spine.Inherit.OnlyTranslation, 
                        Spine.Inherit.NoRotationOrReflection, 
                        Spine.Inherit.NoScale, 
                        Spine.Inherit.NoScaleOrReflection
                    ], Spine.Inherit);
                }
            }
        }
    });
    /*Spine.InheritEnum end.*/

    /*Spine.Json start.*/
    Bridge.define("Spine.Json", {
        statics: {
            methods: {
                /*Spine.Json.Deserialize:static start.*/
                Deserialize: function (text) {
if ( TRACE ) { TRACE( "Spine.Json#Deserialize", this ); }

                    var parser = new SharpJson.JsonDecoder();
                    parser.parseNumbersAsFloat = true;
                    return parser.Decode(text.ReadToEnd());
                },
                /*Spine.Json.Deserialize:static end.*/


            }
        }
    });
    /*Spine.Json end.*/

    /*Spine.MathUtils start.*/
    Bridge.define("Spine.MathUtils", {
        statics: {
            fields: {
                PI: 0,
                PI2: 0,
                InvPI2: 0,
                RadDeg: 0,
                DegRad: 0,
                random: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.MathUtils#init", this ); }

                    this.PI = 3.14159274;
                    this.PI2 = 6.28318548;
                    this.InvPI2 = 0.159154937;
                    this.RadDeg = 57.2957764;
                    this.DegRad = 0.0174532924;
                    this.random = new System.Random.ctor();
                }
            },
            methods: {
                /*Spine.MathUtils.Sin:static start.*/
                /**
                 * Returns the sine of a given angle in radians.
                 *
                 * @static
                 * @public
                 * @this Spine.MathUtils
                 * @memberof Spine.MathUtils
                 * @param   {number}    radians
                 * @return  {number}
                 */
                Sin: function (radians) {
if ( TRACE ) { TRACE( "Spine.MathUtils#Sin", this ); }

                    return Math.sin(radians);
                },
                /*Spine.MathUtils.Sin:static end.*/

                /*Spine.MathUtils.Cos:static start.*/
                /**
                 * Returns the cosine of a given angle in radians.
                 *
                 * @static
                 * @public
                 * @this Spine.MathUtils
                 * @memberof Spine.MathUtils
                 * @param   {number}    radians
                 * @return  {number}
                 */
                Cos: function (radians) {
if ( TRACE ) { TRACE( "Spine.MathUtils#Cos", this ); }

                    return Math.cos(radians);
                },
                /*Spine.MathUtils.Cos:static end.*/

                /*Spine.MathUtils.SinDeg:static start.*/
                /**
                 * Returns the sine of a given angle in degrees.
                 *
                 * @static
                 * @public
                 * @this Spine.MathUtils
                 * @memberof Spine.MathUtils
                 * @param   {number}    degrees
                 * @return  {number}
                 */
                SinDeg: function (degrees) {
if ( TRACE ) { TRACE( "Spine.MathUtils#SinDeg", this ); }

                    return Math.sin(degrees * Spine.MathUtils.DegRad);
                },
                /*Spine.MathUtils.SinDeg:static end.*/

                /*Spine.MathUtils.CosDeg:static start.*/
                /**
                 * Returns the cosine of a given angle in degrees.
                 *
                 * @static
                 * @public
                 * @this Spine.MathUtils
                 * @memberof Spine.MathUtils
                 * @param   {number}    degrees
                 * @return  {number}
                 */
                CosDeg: function (degrees) {
if ( TRACE ) { TRACE( "Spine.MathUtils#CosDeg", this ); }

                    return Math.cos(degrees * Spine.MathUtils.DegRad);
                },
                /*Spine.MathUtils.CosDeg:static end.*/

                /*Spine.MathUtils.Atan2Deg:static start.*/
                Atan2Deg: function (y, x) {
if ( TRACE ) { TRACE( "Spine.MathUtils#Atan2Deg", this ); }

                    return Math.atan2(y, x) * Spine.MathUtils.RadDeg;
                },
                /*Spine.MathUtils.Atan2Deg:static end.*/

                /*Spine.MathUtils.Atan2:static start.*/
                /**
                 * Returns the atan2 using Math.Atan2.
                 *
                 * @static
                 * @public
                 * @this Spine.MathUtils
                 * @memberof Spine.MathUtils
                 * @param   {number}    y    
                 * @param   {number}    x
                 * @return  {number}
                 */
                Atan2: function (y, x) {
if ( TRACE ) { TRACE( "Spine.MathUtils#Atan2", this ); }

                    return Math.atan2(y, x);
                },
                /*Spine.MathUtils.Atan2:static end.*/

                /*Spine.MathUtils.Clamp:static start.*/
                Clamp: function (value, min, max) {
if ( TRACE ) { TRACE( "Spine.MathUtils#Clamp", this ); }

                    if (value < min) {
                        return min;
                    }
                    if (value > max) {
                        return max;
                    }
                    return value;
                },
                /*Spine.MathUtils.Clamp:static end.*/

                /*Spine.MathUtils.RandomTriangle:static start.*/
                RandomTriangle: function (min, max) {
if ( TRACE ) { TRACE( "Spine.MathUtils#RandomTriangle", this ); }

                    return Spine.MathUtils.RandomTriangle$1(min, max, (min + max) * 0.5);
                },
                /*Spine.MathUtils.RandomTriangle:static end.*/

                /*Spine.MathUtils.RandomTriangle$1:static start.*/
                RandomTriangle$1: function (min, max, mode) {
if ( TRACE ) { TRACE( "Spine.MathUtils#RandomTriangle$1", this ); }

                    var u = Spine.MathUtils.random.NextDouble();
                    var d = max - min;
                    if (u <= (mode - min) / d) {
                        return min + Math.sqrt(u * d * (mode - min));
                    }
                    return max - Math.sqrt((1 - u) * d * (max - mode));
                },
                /*Spine.MathUtils.RandomTriangle$1:static end.*/


            }
        }
    });
    /*Spine.MathUtils end.*/

    /*Spine.MixBlend start.*/
    
    Bridge.define("Spine.MixBlend", {
        $kind: 6,
        statics: {
            fields: {
                /**
                 * Transitions from the setup value to the timeline value (the current value is not used). Before the first frame, the
                           setup value is set.
                 *
                 * @static
                 * @public
                 * @memberof Spine.MixBlend
                 * @constant
                 * @default 0
                 * @type Spine.MixBlend
                 */
                Setup: 0,
                /**
                 * <p>Transitions from the current value to the timeline value. Before the first frame, transitions from the current value to
                 the setup value. Timelines which perform instant transitions, such as {@link } or
                 {@link }, use the setup value before the first frame.</p><p><pre><code>First</code></pre> is intended for the first animations applied, not for animations layered on top of those.</p>
                 *
                 * @static
                 * @public
                 * @memberof Spine.MixBlend
                 * @constant
                 * @default 1
                 * @type Spine.MixBlend
                 */
                First: 1,
                /**
                 * <p>Transitions from the current value to the timeline value. No change is made before the first frame (the current value is
                 kept until the first frame).</p><p><pre><code>Replace</code></pre> is intended for animations layered on top of others, not for the first animations applied.</p>
                 *
                 * @static
                 * @public
                 * @memberof Spine.MixBlend
                 * @constant
                 * @default 2
                 * @type Spine.MixBlend
                 */
                Replace: 2,
                /**
                 * <p>Transitions from the current value to the current value plus the timeline value. No change is made before the first frame
                 (the current value is kept until the first frame).</p><p><pre><code>Add</code></pre> is intended for animations layered on top of others, not for the first animations applied. Properties
                 set by additive animations must be set manually or by another animation before applying the additive animations, else the
                 property values will increase each time the additive animations are applied.</p>
                 *
                 * @static
                 * @public
                 * @memberof Spine.MixBlend
                 * @constant
                 * @default 3
                 * @type Spine.MixBlend
                 */
                Add: 3
            }
        }
    });
    /*Spine.MixBlend end.*/

    /*Spine.MixDirection start.*/
    /**
     * Indicates whether a timeline's <pre><code>alpha</code></pre> is mixing out over time toward 0 (the setup or current pose value) or
     mixing in toward 1 (the timeline's value). Some timelines use this to decide how values are applied.
     *
     * @public
     * @class Spine.MixDirection
     * @see {@link Timeline.Apply(Skeleton, float, float, ExposedList, float, MixBlend, MixDirection)}
     */
    Bridge.define("Spine.MixDirection", {
        $kind: 6,
        statics: {
            fields: {
                In: 0,
                Out: 1
            }
        }
    });
    /*Spine.MixDirection end.*/

    /*Spine.Polygon start.*/
    Bridge.define("Spine.Polygon", {
        fields: {
            Vertices: null,
            Count: 0
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Polygon#ctor", this ); }

                this.$initialize();
                this.Vertices = System.Array.init(16, 0, System.Single);
            }
        }
    });
    /*Spine.Polygon end.*/

    /*Spine.Pool$1 start.*/
    Bridge.define("Spine.Pool$1", function (T) { return {
        fields: {
            max: 0,
            freeObjects: null,
            Peak: 0
        },
        props: {
            Count: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Pool$1#Count#get", this ); }

                    return this.freeObjects.Count;
                }
            }
        },
        ctors: {
            ctor: function (initialCapacity, max) {
if ( TRACE ) { TRACE( "Spine.Pool$1#ctor", this ); }

                if (initialCapacity === void 0) { initialCapacity = 16; }
                if (max === void 0) { max = 2147483647; }

                this.$initialize();
                this.freeObjects = new (System.Collections.Generic.Stack$1(T)).$ctor2(initialCapacity);
                this.max = max;
            }
        },
        methods: {
            /*Spine.Pool$1.Obtain start.*/
            Obtain: function () {
if ( TRACE ) { TRACE( "Spine.Pool$1#Obtain", this ); }

                return this.freeObjects.Count === 0 ? Bridge.createInstance(T) : this.freeObjects.Pop();
            },
            /*Spine.Pool$1.Obtain end.*/

            /*Spine.Pool$1.Free start.*/
            Free: function (obj) {
if ( TRACE ) { TRACE( "Spine.Pool$1#Free", this ); }

                if (Bridge.rValue(obj) == null) {
                    throw new System.ArgumentNullException.$ctor3("obj", "obj cannot be null");
                }
                if (this.freeObjects.Count < this.max) {
                    this.freeObjects.Push(Bridge.rValue(obj));
                    this.Peak = Math.max(this.Peak, this.freeObjects.Count);
                }
                this.Reset(Bridge.rValue(obj));
            },
            /*Spine.Pool$1.Free end.*/

            /*Spine.Pool$1.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Pool$1#Clear", this ); }

                this.freeObjects.Clear();
            },
            /*Spine.Pool$1.Clear end.*/

            /*Spine.Pool$1.Reset start.*/
            Reset: function (obj) {
if ( TRACE ) { TRACE( "Spine.Pool$1#Reset", this ); }

                var poolable = Bridge.as(Bridge.rValue(obj), Spine.Pool$1.IPoolable(T));
                if (poolable != null) {
                    poolable["Spine$Pool$1$IPoolable$" + Bridge.getTypeAlias(T) + "$Reset"]();
                }
            },
            /*Spine.Pool$1.Reset end.*/


        }
    }; });
    /*Spine.Pool$1 end.*/

    /*Spine.Pool$1+IPoolable start.*/
    Bridge.definei("Spine.Pool$1.IPoolable", function (T) { return {
        $kind: 1003
    }; });
    /*Spine.Pool$1+IPoolable end.*/

    /*Spine.PositionMode start.*/
    Bridge.define("Spine.PositionMode", {
        $kind: 6,
        statics: {
            fields: {
                Fixed: 0,
                Percent: 1
            }
        }
    });
    /*Spine.PositionMode end.*/

    /*Spine.Property start.*/
    Bridge.define("Spine.Property", {
        $kind: 6,
        statics: {
            fields: {
                Rotate: 0,
                X: 1,
                Y: 2,
                ScaleX: 3,
                ScaleY: 4,
                ShearX: 5,
                ShearY: 6,
                Inherit: 7,
                RGB: 8,
                Alpha: 9,
                RGB2: 10,
                Attachment: 11,
                Deform: 12,
                Event: 13,
                DrawOrder: 14,
                IkConstraint: 15,
                TransformConstraint: 16,
                PathConstraintPosition: 17,
                PathConstraintSpacing: 18,
                PathConstraintMix: 19,
                PhysicsConstraintInertia: 20,
                PhysicsConstraintStrength: 21,
                PhysicsConstraintDamping: 22,
                PhysicsConstraintMass: 23,
                PhysicsConstraintWind: 24,
                PhysicsConstraintGravity: 25,
                PhysicsConstraintMix: 26,
                PhysicsConstraintReset: 27,
                Sequence: 28
            }
        }
    });
    /*Spine.Property end.*/

    /*Spine.RotateMode start.*/
    Bridge.define("Spine.RotateMode", {
        $kind: 6,
        statics: {
            fields: {
                Tangent: 0,
                Chain: 1,
                ChainScale: 2
            }
        }
    });
    /*Spine.RotateMode end.*/

    /*Spine.Sequence start.*/
    Bridge.define("Spine.Sequence", {
        statics: {
            fields: {
                nextID: 0,
                nextIdLock: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Sequence#init", this ); }

                    this.nextID = 0;
                    this.nextIdLock = { };
                }
            }
        },
        fields: {
            id: 0,
            regions: null,
            start: 0,
            digits: 0,
            setupIndex: 0
        },
        props: {
            Start: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Sequence#Start#get", this ); }

                    return this.start;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Sequence#Start#set", this ); }

                    this.start = value;
                }
            },
            Digits: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Sequence#Digits#get", this ); }

                    return this.digits;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Sequence#Digits#set", this ); }

                    this.digits = value;
                }
            },
            /**
             * The index of the region to show for the setup pose.
             *
             * @instance
             * @public
             * @memberof Spine.Sequence
             * @function SetupIndex
             * @type number
             */
            SetupIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Sequence#SetupIndex#get", this ); }

                    return this.setupIndex;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Sequence#SetupIndex#set", this ); }

                    this.setupIndex = value;
                }
            },
            Regions: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Sequence#Regions#get", this ); }

                    return this.regions;
                }
            },
            /**
             * Returns a unique ID for this attachment.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Sequence
             * @function Id
             * @type number
             */
            Id: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Sequence#Id#get", this ); }

                    return this.id;
                }
            }
        },
        ctors: {
            $ctor1: function (count) {
if ( TRACE ) { TRACE( "Spine.Sequence#$ctor1", this ); }

                var $t;
                this.$initialize();
                Spine.Sequence.nextIdLock;
                {
                    this.id = Bridge.identity(Spine.Sequence.nextID, (($t = (Spine.Sequence.nextID + 1) | 0, Spine.Sequence.nextID = $t, $t)));
                }
                this.regions = System.Array.init(count, null, Spine.TextureRegion);
            },
            /**
             * Copy constructor.
             *
             * @instance
             * @public
             * @this Spine.Sequence
             * @memberof Spine.Sequence
             * @param   {Spine.Sequence}    other
             * @return  {void}
             */
            ctor: function (other) {
if ( TRACE ) { TRACE( "Spine.Sequence#ctor", this ); }

                var $t;
                this.$initialize();
                Spine.Sequence.nextIdLock;
                {
                    this.id = Bridge.identity(Spine.Sequence.nextID, (($t = (Spine.Sequence.nextID + 1) | 0, Spine.Sequence.nextID = $t, $t)));
                }
                this.regions = System.Array.init(other.regions.length, null, Spine.TextureRegion);
                System.Array.copy(other.regions, 0, this.regions, 0, this.regions.length);

                this.start = other.start;
                this.digits = other.digits;
                this.setupIndex = other.setupIndex;
            }
        },
        methods: {
            /*Spine.Sequence.Apply start.*/
            Apply: function (slot, attachment) {
if ( TRACE ) { TRACE( "Spine.Sequence#Apply", this ); }

                var index = slot.SequenceIndex;
                if (index === -1) {
                    index = this.setupIndex;
                }
                if (index >= this.regions.length) {
                    index = (this.regions.length - 1) | 0;
                }
                var region = this.regions[index];
                if (!Bridge.referenceEquals(attachment.Spine$IHasTextureRegion$Region, region)) {
                    attachment.Spine$IHasTextureRegion$Region = region;
                    attachment.Spine$IHasTextureRegion$UpdateRegion();
                }
            },
            /*Spine.Sequence.Apply end.*/

            /*Spine.Sequence.GetPath start.*/
            GetPath: function (basePath, index) {
if ( TRACE ) { TRACE( "Spine.Sequence#GetPath", this ); }

                var buffer = new System.Text.StringBuilder("", ((basePath.length + this.digits) | 0));
                buffer.append(basePath);
                var frame = Bridge.toString((((this.start + index) | 0)));
                for (var i = (this.digits - frame.length) | 0; i > 0; i = (i - 1) | 0) {
                    buffer.append(String.fromCharCode(48));
                }
                buffer.append(frame);
                return buffer.toString();
            },
            /*Spine.Sequence.GetPath end.*/


        }
    });
    /*Spine.Sequence end.*/

    /*Spine.SequenceMode start.*/
    Bridge.define("Spine.SequenceMode", {
        $kind: 6,
        statics: {
            fields: {
                Hold: 0,
                Once: 1,
                Loop: 2,
                Pingpong: 3,
                OnceReverse: 4,
                LoopReverse: 5,
                PingpongReverse: 6
            }
        }
    });
    /*Spine.SequenceMode end.*/

    /*Spine.Skeleton start.*/
    Bridge.define("Spine.Skeleton", {
        statics: {
            fields: {
                quadTriangles: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#init", this ); }

                    this.quadTriangles = System.Array.init([
                        0, 
                        1, 
                        2, 
                        2, 
                        3, 
                        0
                    ], System.Int32);
                }
            },
            methods: {
                /*Spine.Skeleton.SortReset:static start.*/
                SortReset: function (bones) {
if ( TRACE ) { TRACE( "Spine.Skeleton#SortReset", this ); }

                    var bonesItems = bones.Items;
                    for (var i = 0, n = bones.Count; i < n; i = (i + 1) | 0) {
                        var bone = bonesItems[i];
                        if (!bone.active) {
                            continue;
                        }
                        if (bone.sorted) {
                            Spine.Skeleton.SortReset(bone.children);
                        }
                        bone.sorted = false;
                    }
                },
                /*Spine.Skeleton.SortReset:static end.*/


            }
        },
        fields: {
            data: null,
            bones: null,
            slots: null,
            drawOrder: null,
            ikConstraints: null,
            transformConstraints: null,
            pathConstraints: null,
            physicsConstraints: null,
            updateCache: null,
            skin: null,
            r: 0,
            g: 0,
            b: 0,
            a: 0,
            x: 0,
            y: 0,
            scaleX: 0,
            time: 0,
            /**
             * Private to enforce usage of ScaleY getter taking Bone.yDown into account.
             *
             * @instance
             * @private
             * @memberof Spine.Skeleton
             * @default 1
             * @type number
             */
            scaleY: 0
        },
        props: {
            /**
             * The skeleton's setup pose data.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Skeleton
             * @function Data
             * @type Spine.SkeletonData
             */
            Data: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#Data#get", this ); }

                    return this.data;
                }
            },
            /**
             * The skeleton's bones, sorted parent first. The root bone is always the first bone.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Skeleton
             * @function Bones
             * @type Spine.ExposedList$1
             */
            Bones: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#Bones#get", this ); }

                    return this.bones;
                }
            },
            /**
             * The list of bones and constraints, sorted in the order they should be updated,
             as computed by {@link }.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Skeleton
             * @function UpdateCacheList
             * @type Spine.ExposedList$1
             */
            UpdateCacheList: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#UpdateCacheList#get", this ); }

                    return this.updateCache;
                }
            },
            /**
             * The skeleton's slots.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Skeleton
             * @function Slots
             * @type Spine.ExposedList$1
             */
            Slots: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#Slots#get", this ); }

                    return this.slots;
                }
            },
            /**
             * The skeleton's slots in the order they should be drawn.
             The returned array may be modified to change the draw order.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Skeleton
             * @function DrawOrder
             * @type Spine.ExposedList$1
             */
            DrawOrder: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#DrawOrder#get", this ); }

                    return this.drawOrder;
                }
            },
            /**
             * The skeleton's IK constraints.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Skeleton
             * @function IkConstraints
             * @type Spine.ExposedList$1
             */
            IkConstraints: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#IkConstraints#get", this ); }

                    return this.ikConstraints;
                }
            },
            /**
             * The skeleton's path constraints.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Skeleton
             * @function PathConstraints
             * @type Spine.ExposedList$1
             */
            PathConstraints: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#PathConstraints#get", this ); }

                    return this.pathConstraints;
                }
            },
            /**
             * The skeleton's physics constraints.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Skeleton
             * @function PhysicsConstraints
             * @type Spine.ExposedList$1
             */
            PhysicsConstraints: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#PhysicsConstraints#get", this ); }

                    return this.physicsConstraints;
                }
            },
            /**
             * The skeleton's transform constraints.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Skeleton
             * @function TransformConstraints
             * @type Spine.ExposedList$1
             */
            TransformConstraints: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#TransformConstraints#get", this ); }

                    return this.transformConstraints;
                }
            },
            /**
             * The skeleton's current skin.
             *
             * @instance
             * @public
             * @memberof Spine.Skeleton
             * @function Skin
             * @type Spine.Skin
             */
            Skin: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#Skin#get", this ); }

                    return this.skin;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Skeleton#Skin#set", this ); }

                    this.SetSkin(value);
                }
            },
            R: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#R#get", this ); }

                    return this.r;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Skeleton#R#set", this ); }

                    this.r = value;
                }
            },
            G: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#G#get", this ); }

                    return this.g;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Skeleton#G#set", this ); }

                    this.g = value;
                }
            },
            B: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#B#get", this ); }

                    return this.b;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Skeleton#B#set", this ); }

                    this.b = value;
                }
            },
            A: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#A#get", this ); }

                    return this.a;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Skeleton#A#set", this ); }

                    this.a = value;
                }
            },
            /**
             * <p>The skeleton X position, which is added to the root bone worldX position.</p><p>Bones that do not inherit translation are still affected by this property.</p>
             *
             * @instance
             * @public
             * @memberof Spine.Skeleton
             * @function X
             * @type number
             */
            X: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#X#get", this ); }

                    return this.x;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Skeleton#X#set", this ); }

                    this.x = value;
                }
            },
            /**
             * <p>The skeleton Y position, which is added to the root bone worldY position.</p><p>Bones that do not inherit translation are still affected by this property.</p>
             *
             * @instance
             * @public
             * @memberof Spine.Skeleton
             * @function Y
             * @type number
             */
            Y: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#Y#get", this ); }

                    return this.y;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Skeleton#Y#set", this ); }

                    this.y = value;
                }
            },
            /**
             * <p>Scales the entire skeleton on the X axis.</p><p>Bones that do not inherit scale are still affected by this property.</p>
             *
             * @instance
             * @public
             * @memberof Spine.Skeleton
             * @function ScaleX
             * @type number
             */
            ScaleX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#ScaleX#get", this ); }

                    return this.scaleX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Skeleton#ScaleX#set", this ); }

                    this.scaleX = value;
                }
            },
            /**
             * <p>Scales the entire skeleton on the Y axis.</p><p>Bones that do not inherit scale are still affected by this property.</p>
             *
             * @instance
             * @public
             * @memberof Spine.Skeleton
             * @function ScaleY
             * @type number
             */
            ScaleY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#ScaleY#get", this ); }

                    return this.scaleY * (Spine.Bone.yDown ? -1 : 1);
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Skeleton#ScaleY#set", this ); }

                    this.scaleY = value;
                }
            },
            FlipX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#FlipX#get", this ); }

                    return this.scaleX < 0;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Skeleton#FlipX#set", this ); }

                    this.scaleX = value ? -1.0 : 1.0;
                }
            },
            FlipY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#FlipY#get", this ); }

                    return this.scaleY < 0;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Skeleton#FlipY#set", this ); }

                    this.scaleY = value ? -1.0 : 1.0;
                }
            },
            /**
             * Returns the skeleton's time. This is used for time-based manipulations, such as {@link }.
             *
             * @instance
             * @public
             * @memberof Spine.Skeleton
             * @function Time
             * @type number
             * @see {@link Update(float)}
             */
            Time: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#Time#get", this ); }

                    return this.time;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Skeleton#Time#set", this ); }

                    this.time = value;
                }
            },
            /**
             * Returns the root bone, or null if the skeleton has no bones.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Skeleton
             * @function RootBone
             * @type Spine.Bone
             */
            RootBone: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#RootBone#get", this ); }

                    var $t;
                    return this.bones.Count === 0 ? null : ($t = this.bones.Items)[0];
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#init", this ); }

                this.updateCache = new (Spine.ExposedList$1(Spine.IUpdatable)).ctor();
                this.r = 1;
                this.g = 1;
                this.b = 1;
                this.a = 1;
                this.scaleX = 1;
                this.scaleY = 1;
            },
            $ctor1: function (data) {
if ( TRACE ) { TRACE( "Spine.Skeleton#$ctor1", this ); }

                var $t, $t1, $t2, $t3, $t4, $t5;
                this.$initialize();
                if (data == null) {
                    throw new System.ArgumentNullException.$ctor3("data", "data cannot be null.");
                }
                this.data = data;

                this.bones = new (Spine.ExposedList$1(Spine.Bone)).$ctor3(data.bones.Count);
                var bonesItems = this.bones.Items;
                $t = Bridge.getEnumerator(data.bones);
                try {
                    while ($t.moveNext()) {
                        var boneData = $t.Current;
                        var bone;
                        if (boneData.parent == null) {
                            bone = new Spine.Bone.$ctor1(boneData, this, null);
                        } else {
                            var parent = bonesItems[boneData.parent.index];
                            bone = new Spine.Bone.$ctor1(boneData, this, parent);
                            parent.children.Add(bone);
                        }
                        this.bones.Add(bone);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                this.slots = new (Spine.ExposedList$1(Spine.Slot)).$ctor3(data.slots.Count);
                this.drawOrder = new (Spine.ExposedList$1(Spine.Slot)).$ctor3(data.slots.Count);
                $t1 = Bridge.getEnumerator(data.slots);
                try {
                    while ($t1.moveNext()) {
                        var slotData = $t1.Current;
                        var bone1 = bonesItems[slotData.boneData.index];
                        var slot = new Spine.Slot.$ctor1(slotData, bone1);
                        this.slots.Add(slot);
                        this.drawOrder.Add(slot);
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }

                this.ikConstraints = new (Spine.ExposedList$1(Spine.IkConstraint)).$ctor3(data.ikConstraints.Count);
                $t2 = Bridge.getEnumerator(data.ikConstraints);
                try {
                    while ($t2.moveNext()) {
                        var ikConstraintData = $t2.Current;
                        this.ikConstraints.Add(new Spine.IkConstraint.$ctor1(ikConstraintData, this));
                    }
                } finally {
                    if (Bridge.is($t2, System.IDisposable)) {
                        $t2.System$IDisposable$Dispose();
                    }
                }

                this.transformConstraints = new (Spine.ExposedList$1(Spine.TransformConstraint)).$ctor3(data.transformConstraints.Count);
                $t3 = Bridge.getEnumerator(data.transformConstraints);
                try {
                    while ($t3.moveNext()) {
                        var transformConstraintData = $t3.Current;
                        this.transformConstraints.Add(new Spine.TransformConstraint.$ctor1(transformConstraintData, this));
                    }
                } finally {
                    if (Bridge.is($t3, System.IDisposable)) {
                        $t3.System$IDisposable$Dispose();
                    }
                }

                this.pathConstraints = new (Spine.ExposedList$1(Spine.PathConstraint)).$ctor3(data.pathConstraints.Count);
                $t4 = Bridge.getEnumerator(data.pathConstraints);
                try {
                    while ($t4.moveNext()) {
                        var pathConstraintData = $t4.Current;
                        this.pathConstraints.Add(new Spine.PathConstraint.$ctor1(pathConstraintData, this));
                    }
                } finally {
                    if (Bridge.is($t4, System.IDisposable)) {
                        $t4.System$IDisposable$Dispose();
                    }
                }

                this.physicsConstraints = new (Spine.ExposedList$1(Spine.PhysicsConstraint)).$ctor3(data.physicsConstraints.Count);
                $t5 = Bridge.getEnumerator(data.physicsConstraints);
                try {
                    while ($t5.moveNext()) {
                        var physicsConstraintData = $t5.Current;
                        this.physicsConstraints.Add(new Spine.PhysicsConstraint.$ctor1(physicsConstraintData, this));
                    }
                } finally {
                    if (Bridge.is($t5, System.IDisposable)) {
                        $t5.System$IDisposable$Dispose();
                    }
                }

                this.UpdateCache();
            },
            /**
             * Copy constructor.
             *
             * @instance
             * @public
             * @this Spine.Skeleton
             * @memberof Spine.Skeleton
             * @param   {Spine.Skeleton}    skeleton
             * @return  {void}
             */
            ctor: function (skeleton) {
if ( TRACE ) { TRACE( "Spine.Skeleton#ctor", this ); }

                var $t, $t1, $t2, $t3, $t4, $t5, $t6, $t7;
                this.$initialize();
                if (skeleton == null) {
                    throw new System.ArgumentNullException.$ctor3("skeleton", "skeleton cannot be null.");
                }
                this.data = skeleton.data;

                this.bones = new (Spine.ExposedList$1(Spine.Bone)).$ctor3(skeleton.bones.Count);
                $t = Bridge.getEnumerator(skeleton.bones);
                try {
                    while ($t.moveNext()) {
                        var bone = $t.Current;
                        var newBone;
                        if (bone.parent == null) {
                            newBone = new Spine.Bone.ctor(bone, this, null);
                        } else {
                            var parent = ($t1 = this.bones.Items)[bone.parent.data.index];
                            newBone = new Spine.Bone.ctor(bone, this, parent);
                            parent.children.Add(newBone);
                        }
                        this.bones.Add(newBone);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                this.slots = new (Spine.ExposedList$1(Spine.Slot)).$ctor3(skeleton.slots.Count);
                var bonesItems = this.bones.Items;
                $t2 = Bridge.getEnumerator(skeleton.slots);
                try {
                    while ($t2.moveNext()) {
                        var slot = $t2.Current;
                        var bone1 = bonesItems[slot.bone.data.index];
                        this.slots.Add(new Spine.Slot.ctor(slot, bone1));
                    }
                } finally {
                    if (Bridge.is($t2, System.IDisposable)) {
                        $t2.System$IDisposable$Dispose();
                    }
                }

                this.drawOrder = new (Spine.ExposedList$1(Spine.Slot)).$ctor3(this.slots.Count);
                var slotsItems = this.slots.Items;
                $t3 = Bridge.getEnumerator(skeleton.drawOrder);
                try {
                    while ($t3.moveNext()) {
                        var slot1 = $t3.Current;
                        this.drawOrder.Add(slotsItems[slot1.data.index]);
                    }
                } finally {
                    if (Bridge.is($t3, System.IDisposable)) {
                        $t3.System$IDisposable$Dispose();
                    }
                }

                this.ikConstraints = new (Spine.ExposedList$1(Spine.IkConstraint)).$ctor3(skeleton.ikConstraints.Count);
                $t4 = Bridge.getEnumerator(skeleton.ikConstraints);
                try {
                    while ($t4.moveNext()) {
                        var ikConstraint = $t4.Current;
                        this.ikConstraints.Add(new Spine.IkConstraint.ctor(ikConstraint, skeleton));
                    }
                } finally {
                    if (Bridge.is($t4, System.IDisposable)) {
                        $t4.System$IDisposable$Dispose();
                    }
                }

                this.transformConstraints = new (Spine.ExposedList$1(Spine.TransformConstraint)).$ctor3(skeleton.transformConstraints.Count);
                $t5 = Bridge.getEnumerator(skeleton.transformConstraints);
                try {
                    while ($t5.moveNext()) {
                        var transformConstraint = $t5.Current;
                        this.transformConstraints.Add(new Spine.TransformConstraint.ctor(transformConstraint, skeleton));
                    }
                } finally {
                    if (Bridge.is($t5, System.IDisposable)) {
                        $t5.System$IDisposable$Dispose();
                    }
                }

                this.pathConstraints = new (Spine.ExposedList$1(Spine.PathConstraint)).$ctor3(skeleton.pathConstraints.Count);
                $t6 = Bridge.getEnumerator(skeleton.pathConstraints);
                try {
                    while ($t6.moveNext()) {
                        var pathConstraint = $t6.Current;
                        this.pathConstraints.Add(new Spine.PathConstraint.ctor(pathConstraint, skeleton));
                    }
                } finally {
                    if (Bridge.is($t6, System.IDisposable)) {
                        $t6.System$IDisposable$Dispose();
                    }
                }

                this.physicsConstraints = new (Spine.ExposedList$1(Spine.PhysicsConstraint)).$ctor3(skeleton.physicsConstraints.Count);
                $t7 = Bridge.getEnumerator(skeleton.physicsConstraints);
                try {
                    while ($t7.moveNext()) {
                        var physicsConstraint = $t7.Current;
                        this.physicsConstraints.Add(new Spine.PhysicsConstraint.ctor(physicsConstraint, skeleton));
                    }
                } finally {
                    if (Bridge.is($t7, System.IDisposable)) {
                        $t7.System$IDisposable$Dispose();
                    }
                }

                this.skin = skeleton.skin;
                this.r = skeleton.r;
                this.g = skeleton.g;
                this.b = skeleton.b;
                this.a = skeleton.a;
                this.x = skeleton.x;
                this.y = skeleton.y;
                this.scaleX = skeleton.scaleX;
                this.scaleY = skeleton.scaleY;
                this.time = skeleton.time;

                this.UpdateCache();
            }
        },
        methods: {
            /*Spine.Skeleton.UpdateCache start.*/
            /**
             * Caches information about bones and constraints. Must be called if the {@link } is modified or if bones, constraints, or
             constraints, or weighted path attachments are added or removed.
             *
             * @instance
             * @public
             * @this Spine.Skeleton
             * @memberof Spine.Skeleton
             * @return  {void}
             */
            UpdateCache: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#UpdateCache", this ); }

                var $step = 0,
                    $jumpFromFinally, 
                    updateCache, 
                    boneCount, 
                    bones, 
                    bone, 
                    skinBones, 
                    bone1, 
                    ikCount, 
                    transformCount, 
                    pathCount, 
                    physicsCount, 
                    ikConstraints, 
                    transformConstraints, 
                    pathConstraints, 
                    physicsConstraints, 
                    constraintCount, 
                    i2, 
                    ii, 
                    constraint, 
                    ii1, 
                    constraint1, 
                    ii2, 
                    constraint2, 
                    ii3, 
                    constraint3, 
                    $asyncBody = Bridge.fn.bind(this, function () {
                        for (;;) {
                            $step = System.Array.min([0,1,2,3,4,5,7,8,9,10,11,13,14,15,16,17,19,20,21,22,23,25,26,28,29], $step);
                            switch ($step) {
                                case 0: {
                                    updateCache = this.updateCache;
                                    updateCache.Clear();

                                    boneCount = this.bones.Count;
                                    bones = this.bones.Items;
                                    for (var i = 0; i < boneCount; i = (i + 1) | 0) {
                                        bone = bones[i];
                                        bone.sorted = bone.data.skinRequired;
                                        bone.active = !bone.sorted;
                                    }
                                    if (this.skin != null) {
                                        skinBones = this.skin.bones.Items;
                                        for (var i1 = 0, n = this.skin.bones.Count; i1 < n; i1 = (i1 + 1) | 0) {
                                            bone1 = bones[skinBones[i1].index];
                                            do {
                                                bone1.sorted = false;
                                                bone1.active = true;
                                                bone1 = bone1.parent;
                                            } while (bone1 != null);
                                        }
                                    }

                                    ikCount = this.ikConstraints.Count;
                                    transformCount = this.transformConstraints.Count;
                                    pathCount = this.pathConstraints.Count;
                                    physicsCount = this.physicsConstraints.Count;
                                    ikConstraints = this.ikConstraints.Items;
                                    transformConstraints = this.transformConstraints.Items;
                                    pathConstraints = this.pathConstraints.Items;
                                    physicsConstraints = this.physicsConstraints.Items;
                                    constraintCount = (((((ikCount + transformCount) | 0) + pathCount) | 0) + physicsCount) | 0;
                                    i2 = 0;
                                    $step = 1;
                                    continue;
                                }
                                case 1: {
                                    if ( i2 < constraintCount ) {
                                        $step = 2;
                                        continue;
                                    }
                                    $step = 29;
                                    continue;
                                }
                                case 2: {
                                    ii = 0;
                                    $step = 3;
                                    continue;
                                }
                                case 3: {
                                    if ( ii < ikCount ) {
                                        $step = 4;
                                        continue;
                                    }
                                    $step = 8;
                                    continue;
                                }
                                case 4: {
                                    constraint = ikConstraints[ii];
                                    if (constraint.data.order === i2) {
                                        $step = 5;
                                        continue;
                                    } 
                                    $step = 6;
                                    continue;
                                }
                                case 5: {
                                    this.SortIkConstraint(constraint);
                                    $step = 27;
                                    continue;
                                }

                                case 7: {
                                    ii = (ii + 1) | 0;
                                    $step = 3;
                                    continue;
                                }
                                case 8: {
                                    ii1 = 0;
                                    $step = 9;
                                    continue;
                                }
                                case 9: {
                                    if ( ii1 < transformCount ) {
                                        $step = 10;
                                        continue;
                                    }
                                    $step = 14;
                                    continue;
                                }
                                case 10: {
                                    constraint1 = transformConstraints[ii1];
                                    if (constraint1.data.order === i2) {
                                        $step = 11;
                                        continue;
                                    } 
                                    $step = 12;
                                    continue;
                                }
                                case 11: {
                                    this.SortTransformConstraint(constraint1);
                                    $step = 27;
                                    continue;
                                }

                                case 13: {
                                    ii1 = (ii1 + 1) | 0;
                                    $step = 9;
                                    continue;
                                }
                                case 14: {
                                    ii2 = 0;
                                    $step = 15;
                                    continue;
                                }
                                case 15: {
                                    if ( ii2 < pathCount ) {
                                        $step = 16;
                                        continue;
                                    }
                                    $step = 20;
                                    continue;
                                }
                                case 16: {
                                    constraint2 = pathConstraints[ii2];
                                    if (constraint2.data.order === i2) {
                                        $step = 17;
                                        continue;
                                    } 
                                    $step = 18;
                                    continue;
                                }
                                case 17: {
                                    this.SortPathConstraint(constraint2);
                                    $step = 27;
                                    continue;
                                }

                                case 19: {
                                    ii2 = (ii2 + 1) | 0;
                                    $step = 15;
                                    continue;
                                }
                                case 20: {
                                    ii3 = 0;
                                    $step = 21;
                                    continue;
                                }
                                case 21: {
                                    if ( ii3 < physicsCount ) {
                                        $step = 22;
                                        continue;
                                    }
                                    $step = 26;
                                    continue;
                                }
                                case 22: {
                                    constraint3 = physicsConstraints[ii3];
                                    if (constraint3.data.order === i2) {
                                        $step = 23;
                                        continue;
                                    } 
                                    $step = 24;
                                    continue;
                                }
                                case 23: {
                                    this.SortPhysicsConstraint(constraint3);
                                    $step = 27;
                                    continue;
                                }

                                case 25: {
                                    ii3 = (ii3 + 1) | 0;
                                    $step = 21;
                                    continue;
                                }
                                case 26: {

                                }

                                case 28: {
                                    i2 = (i2 + 1) | 0;
                                    $step = 1;
                                    continue;
                                }
                                case 29: {
                                    for (var i3 = 0; i3 < boneCount; i3 = (i3 + 1) | 0) {
                                        this.SortBone(bones[i3]);
                                    }
                                    return;
                                }
                                default: {
                                    return;
                                }
                            }
                        }
                    }, arguments);

                return $asyncBody();
            },
            /*Spine.Skeleton.UpdateCache end.*/

            /*Spine.Skeleton.SortIkConstraint start.*/
            SortIkConstraint: function (constraint) {
if ( TRACE ) { TRACE( "Spine.Skeleton#SortIkConstraint", this ); }

                constraint.active = constraint.target.active && (!constraint.data.skinRequired || (this.skin != null && this.skin.constraints.Contains(constraint.data)));
                if (!constraint.active) {
                    return;
                }

                var target = constraint.target;
                this.SortBone(target);

                var constrained = constraint.bones;
                var parent = constrained.Items[0];
                this.SortBone(parent);

                if (constrained.Count === 1) {
                    this.updateCache.Add(constraint);
                    Spine.Skeleton.SortReset(parent.children);
                } else {
                    var child = constrained.Items[((constrained.Count - 1) | 0)];
                    this.SortBone(child);

                    this.updateCache.Add(constraint);

                    Spine.Skeleton.SortReset(parent.children);
                    child.sorted = true;
                }
            },
            /*Spine.Skeleton.SortIkConstraint end.*/

            /*Spine.Skeleton.SortTransformConstraint start.*/
            SortTransformConstraint: function (constraint) {
if ( TRACE ) { TRACE( "Spine.Skeleton#SortTransformConstraint", this ); }

                constraint.active = constraint.target.active && (!constraint.data.skinRequired || (this.skin != null && this.skin.constraints.Contains(constraint.data)));
                if (!constraint.active) {
                    return;
                }

                this.SortBone(constraint.target);

                var constrained = constraint.bones.Items;
                var boneCount = constraint.bones.Count;
                if (constraint.data.local) {
                    for (var i = 0; i < boneCount; i = (i + 1) | 0) {
                        var child = constrained[i];
                        this.SortBone(child.parent);
                        this.SortBone(child);
                    }
                } else {
                    for (var i1 = 0; i1 < boneCount; i1 = (i1 + 1) | 0) {
                        this.SortBone(constrained[i1]);
                    }
                }

                this.updateCache.Add(constraint);

                for (var i2 = 0; i2 < boneCount; i2 = (i2 + 1) | 0) {
                    Spine.Skeleton.SortReset(constrained[i2].children);
                }
                for (var i3 = 0; i3 < boneCount; i3 = (i3 + 1) | 0) {
                    constrained[i3].sorted = true;
                }
            },
            /*Spine.Skeleton.SortTransformConstraint end.*/

            /*Spine.Skeleton.SortPathConstraint start.*/
            SortPathConstraint: function (constraint) {
if ( TRACE ) { TRACE( "Spine.Skeleton#SortPathConstraint", this ); }

                constraint.active = constraint.target.bone.active && (!constraint.data.skinRequired || (this.skin != null && this.skin.constraints.Contains(constraint.data)));
                if (!constraint.active) {
                    return;
                }

                var slot = constraint.target;
                var slotIndex = slot.data.index;
                var slotBone = slot.bone;
                if (this.skin != null) {
                    this.SortPathConstraintAttachment$1(this.skin, slotIndex, slotBone);
                }
                if (this.data.defaultSkin != null && !Bridge.referenceEquals(this.data.defaultSkin, this.skin)) {
                    this.SortPathConstraintAttachment$1(this.data.defaultSkin, slotIndex, slotBone);
                }

                var attachment = slot.attachment;
                if (Bridge.is(attachment, Spine.PathAttachment)) {
                    this.SortPathConstraintAttachment(attachment, slotBone);
                }

                var constrained = constraint.bones.Items;
                var boneCount = constraint.bones.Count;
                for (var i = 0; i < boneCount; i = (i + 1) | 0) {
                    this.SortBone(constrained[i]);
                }

                this.updateCache.Add(constraint);

                for (var i1 = 0; i1 < boneCount; i1 = (i1 + 1) | 0) {
                    Spine.Skeleton.SortReset(constrained[i1].children);
                }
                for (var i2 = 0; i2 < boneCount; i2 = (i2 + 1) | 0) {
                    constrained[i2].sorted = true;
                }
            },
            /*Spine.Skeleton.SortPathConstraint end.*/

            /*Spine.Skeleton.SortPathConstraintAttachment$1 start.*/
            SortPathConstraintAttachment$1: function (skin, slotIndex, slotBone) {
if ( TRACE ) { TRACE( "Spine.Skeleton#SortPathConstraintAttachment$1", this ); }

                var $t;
                $t = Bridge.getEnumerator(skin.Attachments, Spine.Skin.SkinEntry);
                try {
                    while ($t.moveNext()) {
                        var entry = $t.Current;
                        if (entry.SlotIndex === slotIndex) {
                            this.SortPathConstraintAttachment(entry.Attachment, slotBone);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Skeleton.SortPathConstraintAttachment$1 end.*/

            /*Spine.Skeleton.SortPathConstraintAttachment start.*/
            SortPathConstraintAttachment: function (attachment, slotBone) {
if ( TRACE ) { TRACE( "Spine.Skeleton#SortPathConstraintAttachment", this ); }

                if (!(Bridge.is(attachment, Spine.PathAttachment))) {
                    return;
                }
                var pathBones = Bridge.cast(attachment, Spine.PathAttachment).bones;
                if (pathBones == null) {
                    this.SortBone(slotBone);
                } else {
                    var bones = this.bones.Items;
                    for (var i = 0, n = pathBones.length; i < n; ) {
                        var nn = pathBones[Bridge.identity(i, ((i = (i + 1) | 0)))];
                        nn = (nn + i) | 0;
                        while (i < nn) {
                            this.SortBone(bones[pathBones[Bridge.identity(i, ((i = (i + 1) | 0)))]]);
                        }
                    }
                }
            },
            /*Spine.Skeleton.SortPathConstraintAttachment end.*/

            /*Spine.Skeleton.SortPhysicsConstraint start.*/
            SortPhysicsConstraint: function (constraint) {
if ( TRACE ) { TRACE( "Spine.Skeleton#SortPhysicsConstraint", this ); }

                var bone = constraint.bone;
                constraint.active = bone.active && (!constraint.data.skinRequired || (this.skin != null && this.skin.constraints.Contains(constraint.data)));
                if (!constraint.active) {
                    return;
                }

                this.SortBone(bone);

                this.updateCache.Add(constraint);

                Spine.Skeleton.SortReset(bone.children);
                bone.sorted = true;
            },
            /*Spine.Skeleton.SortPhysicsConstraint end.*/

            /*Spine.Skeleton.SortBone start.*/
            SortBone: function (bone) {
if ( TRACE ) { TRACE( "Spine.Skeleton#SortBone", this ); }

                if (bone.sorted) {
                    return;
                }
                var parent = bone.parent;
                if (parent != null) {
                    this.SortBone(parent);
                }
                bone.sorted = true;
                this.updateCache.Add(bone);
            },
            /*Spine.Skeleton.SortBone end.*/

            /*Spine.Skeleton.UpdateWorldTransform start.*/
            /**
             * Updates the world transform for each bone and applies all constraints.
             <p>See <a href="http://esotericsoftware.com/spine-runtime-skeletons#World-transforms">World transforms</a> in the Spine
             Runtimes Guide.</p>
             *
             * @instance
             * @public
             * @this Spine.Skeleton
             * @memberof Spine.Skeleton
             * @param   {number}    physics
             * @return  {void}
             */
            UpdateWorldTransform: function (physics) {
if ( TRACE ) { TRACE( "Spine.Skeleton#UpdateWorldTransform", this ); }

                var bones = this.bones.Items;
                for (var i = 0, n = this.bones.Count; i < n; i = (i + 1) | 0) {
                    var bone = bones[i];
                    bone.ax = bone.x;
                    bone.ay = bone.y;
                    bone.arotation = bone.rotation;
                    bone.ascaleX = bone.scaleX;
                    bone.ascaleY = bone.scaleY;
                    bone.ashearX = bone.shearX;
                    bone.ashearY = bone.shearY;
                }

                var updateCache = this.updateCache.Items;
                for (var i1 = 0, n1 = this.updateCache.Count; i1 < n1; i1 = (i1 + 1) | 0) {
                    updateCache[i1].Spine$IUpdatable$Update(physics);
                }
            },
            /*Spine.Skeleton.UpdateWorldTransform end.*/

            /*Spine.Skeleton.UpdateWorldTransform$1 start.*/
            /**
             * Temporarily sets the root bone as a child of the specified bone, then updates the world transform for each bone and applies
             all constraints.
             *
             * @instance
             * @public
             * @this Spine.Skeleton
             * @memberof Spine.Skeleton
             * @param   {number}        physics    
             * @param   {Spine.Bone}    parent
             * @return  {void}
             */
            UpdateWorldTransform$1: function (physics, parent) {
if ( TRACE ) { TRACE( "Spine.Skeleton#UpdateWorldTransform$1", this ); }

                if (parent == null) {
                    throw new System.ArgumentNullException.$ctor3("parent", "parent cannot be null.");
                }

                // Apply the parent bone transform to the root bone. The root bone always inherits scale, rotation and reflection.
                var rootBone = this.RootBone;
                var pa = parent.a, pb = parent.b, pc = parent.c, pd = parent.d;
                rootBone.worldX = pa * this.x + pb * this.y + parent.worldX;
                rootBone.worldY = pc * this.x + pd * this.y + parent.worldY;

                var rx = (rootBone.rotation + rootBone.shearX) * Spine.MathUtils.DegRad;
                var ry = (rootBone.rotation + 90 + rootBone.shearY) * Spine.MathUtils.DegRad;
                var la = Math.cos(rx) * rootBone.scaleX;
                var lb = Math.cos(ry) * rootBone.scaleY;
                var lc = Math.sin(rx) * rootBone.scaleX;
                var ld = Math.sin(ry) * rootBone.scaleY;
                rootBone.a = (pa * la + pb * lc) * this.scaleX;
                rootBone.b = (pa * lb + pb * ld) * this.scaleX;
                rootBone.c = (pc * la + pd * lc) * this.scaleY;
                rootBone.d = (pc * lb + pd * ld) * this.scaleY;

                // Update everything except root bone.
                var updateCache = this.updateCache.Items;
                for (var i = 0, n = this.updateCache.Count; i < n; i = (i + 1) | 0) {
                    var updatable = updateCache[i];
                    if (!Bridge.referenceEquals(updatable, rootBone)) {
                        updatable.Spine$IUpdatable$Update(physics);
                    }
                }
            },
            /*Spine.Skeleton.UpdateWorldTransform$1 end.*/

            /*Spine.Skeleton.PhysicsTranslate start.*/
            /**
             * Calls {@link } for each physics constraint.
             *
             * @instance
             * @public
             * @this Spine.Skeleton
             * @memberof Spine.Skeleton
             * @param   {number}    x    
             * @param   {number}    y
             * @return  {void}
             */
            PhysicsTranslate: function (x, y) {
if ( TRACE ) { TRACE( "Spine.Skeleton#PhysicsTranslate", this ); }

                var physicsConstraints = this.physicsConstraints.Items;
                for (var i = 0, n = this.physicsConstraints.Count; i < n; i = (i + 1) | 0) {
                    physicsConstraints[i].Translate(x, y);
                }
            },
            /*Spine.Skeleton.PhysicsTranslate end.*/

            /*Spine.Skeleton.PhysicsRotate start.*/
            /**
             * Calls {@link } for each physics constraint.
             *
             * @instance
             * @public
             * @this Spine.Skeleton
             * @memberof Spine.Skeleton
             * @param   {number}    x          
             * @param   {number}    y          
             * @param   {number}    degrees
             * @return  {void}
             */
            PhysicsRotate: function (x, y, degrees) {
if ( TRACE ) { TRACE( "Spine.Skeleton#PhysicsRotate", this ); }

                var physicsConstraints = this.physicsConstraints.Items;
                for (var i = 0, n = this.physicsConstraints.Count; i < n; i = (i + 1) | 0) {
                    physicsConstraints[i].Rotate(x, y, degrees);
                }
            },
            /*Spine.Skeleton.PhysicsRotate end.*/

            /*Spine.Skeleton.Update start.*/
            /**
             * Increments the skeleton's {@link }.
             *
             * @instance
             * @public
             * @this Spine.Skeleton
             * @memberof Spine.Skeleton
             * @param   {number}    delta
             * @return  {void}
             */
            Update: function (delta) {
if ( TRACE ) { TRACE( "Spine.Skeleton#Update", this ); }

                this.time += delta;
            },
            /*Spine.Skeleton.Update end.*/

            /*Spine.Skeleton.SetToSetupPose start.*/
            /**
             * Sets the bones, constraints, and slots to their setup pose values.
             *
             * @instance
             * @public
             * @this Spine.Skeleton
             * @memberof Spine.Skeleton
             * @return  {void}
             */
            SetToSetupPose: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#SetToSetupPose", this ); }

                this.SetBonesToSetupPose();
                this.SetSlotsToSetupPose();
            },
            /*Spine.Skeleton.SetToSetupPose end.*/

            /*Spine.Skeleton.SetBonesToSetupPose start.*/
            /**
             * Sets the bones and constraints to their setup pose values.
             *
             * @instance
             * @public
             * @this Spine.Skeleton
             * @memberof Spine.Skeleton
             * @return  {void}
             */
            SetBonesToSetupPose: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#SetBonesToSetupPose", this ); }

                var bones = this.bones.Items;
                for (var i = 0, n = this.bones.Count; i < n; i = (i + 1) | 0) {
                    bones[i].SetToSetupPose();
                }

                var ikConstraints = this.ikConstraints.Items;
                for (var i1 = 0, n1 = this.ikConstraints.Count; i1 < n1; i1 = (i1 + 1) | 0) {
                    ikConstraints[i1].SetToSetupPose();
                }

                var transformConstraints = this.transformConstraints.Items;
                for (var i2 = 0, n2 = this.transformConstraints.Count; i2 < n2; i2 = (i2 + 1) | 0) {
                    transformConstraints[i2].SetToSetupPose();
                }

                var pathConstraints = this.pathConstraints.Items;
                for (var i3 = 0, n3 = this.pathConstraints.Count; i3 < n3; i3 = (i3 + 1) | 0) {
                    pathConstraints[i3].SetToSetupPose();
                }

                var physicsConstraints = this.physicsConstraints.Items;
                for (var i4 = 0, n4 = this.physicsConstraints.Count; i4 < n4; i4 = (i4 + 1) | 0) {
                    physicsConstraints[i4].SetToSetupPose();
                }
            },
            /*Spine.Skeleton.SetBonesToSetupPose end.*/

            /*Spine.Skeleton.SetSlotsToSetupPose start.*/
            SetSlotsToSetupPose: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#SetSlotsToSetupPose", this ); }

                var slots = this.slots.Items;
                var n = this.slots.Count;
                System.Array.copy(slots, 0, this.drawOrder.Items, 0, n);
                for (var i = 0; i < n; i = (i + 1) | 0) {
                    slots[i].SetToSetupPose();
                }
            },
            /*Spine.Skeleton.SetSlotsToSetupPose end.*/

            /*Spine.Skeleton.FindBone start.*/
            /**
             * Finds a bone by comparing each bone's name. It is more efficient to cache the results of this method than to call it
             repeatedly.
             *
             * @instance
             * @public
             * @this Spine.Skeleton
             * @memberof Spine.Skeleton
             * @param   {string}        boneName
             * @return  {Spine.Bone}                May be null.
             */
            FindBone: function (boneName) {
if ( TRACE ) { TRACE( "Spine.Skeleton#FindBone", this ); }

                if (boneName == null) {
                    throw new System.ArgumentNullException.$ctor3("boneName", "boneName cannot be null.");
                }
                var bones = this.bones.Items;
                for (var i = 0, n = this.bones.Count; i < n; i = (i + 1) | 0) {
                    var bone = bones[i];
                    if (Bridge.referenceEquals(bone.data.name, boneName)) {
                        return bone;
                    }
                }
                return null;
            },
            /*Spine.Skeleton.FindBone end.*/

            /*Spine.Skeleton.FindSlot start.*/
            /**
             * Finds a slot by comparing each slot's name. It is more efficient to cache the results of this method than to call it
             repeatedly.
             *
             * @instance
             * @public
             * @this Spine.Skeleton
             * @memberof Spine.Skeleton
             * @param   {string}        slotName
             * @return  {Spine.Slot}                May be null.
             */
            FindSlot: function (slotName) {
if ( TRACE ) { TRACE( "Spine.Skeleton#FindSlot", this ); }

                if (slotName == null) {
                    throw new System.ArgumentNullException.$ctor3("slotName", "slotName cannot be null.");
                }
                var slots = this.slots.Items;
                for (var i = 0, n = this.slots.Count; i < n; i = (i + 1) | 0) {
                    var slot = slots[i];
                    if (Bridge.referenceEquals(slot.data.name, slotName)) {
                        return slot;
                    }
                }
                return null;
            },
            /*Spine.Skeleton.FindSlot end.*/

            /*Spine.Skeleton.SetSkin$1 start.*/
            /**
             * Sets a skin by name (see {@link }).
             *
             * @instance
             * @public
             * @this Spine.Skeleton
             * @memberof Spine.Skeleton
             * @param   {string}    skinName
             * @return  {void}
             */
            SetSkin$1: function (skinName) {
if ( TRACE ) { TRACE( "Spine.Skeleton#SetSkin$1", this ); }

                var foundSkin = this.data.FindSkin(skinName);
                if (foundSkin == null) {
                    throw new System.ArgumentException.$ctor3("Skin not found: " + (skinName || ""), "skinName");
                }
                this.SetSkin(foundSkin);
            },
            /*Spine.Skeleton.SetSkin$1 end.*/

            /*Spine.Skeleton.SetSkin start.*/
            /**
             * <p>Sets the skin used to look up attachments before looking in the {@link }. If the
             skin is changed, {@link } is called.</p><p>Attachments from the new skin are attached if the corresponding attachment from the old skin was attached.
             If there was no old skin, each slot's setup mode attachment is attached from the new skin.</p><p>After changing the skin, the visible attachments can be reset to those attached in the setup pose by calling
             {@link }.
             Also, often {@link } is called before the next time the
             skeleton is rendered to allow any attachment keys in the current animation(s) to hide or show attachments from the new skin.</p>
             *
             * @instance
             * @public
             * @this Spine.Skeleton
             * @memberof Spine.Skeleton
             * @param   {Spine.Skin}    newSkin    May be null.
             * @return  {void}
             */
            SetSkin: function (newSkin) {
if ( TRACE ) { TRACE( "Spine.Skeleton#SetSkin", this ); }

                if (Bridge.referenceEquals(newSkin, this.skin)) {
                    return;
                }
                if (newSkin != null) {
                    if (this.skin != null) {
                        newSkin.AttachAll(this, this.skin);
                    } else {
                        var slots = this.slots.Items;
                        for (var i = 0, n = this.slots.Count; i < n; i = (i + 1) | 0) {
                            var slot = slots[i];
                            var name = slot.data.attachmentName;
                            if (name != null) {
                                var attachment = newSkin.GetAttachment(i, name);
                                if (attachment != null) {
                                    slot.Attachment = attachment;
                                }
                            }
                        }
                    }
                }
                this.skin = newSkin;
                this.UpdateCache();
            },
            /*Spine.Skeleton.SetSkin end.*/

            /*Spine.Skeleton.GetAttachment$1 start.*/
            /**
             * Finds an attachment by looking in the {@link } and {@link } using the slot name and attachment name.
             *
             * @instance
             * @public
             * @this Spine.Skeleton
             * @memberof Spine.Skeleton
             * @param   {string}              slotName          
             * @param   {string}              attachmentName
             * @return  {Spine.Attachment}                      May be null.
             */
            GetAttachment$1: function (slotName, attachmentName) {
if ( TRACE ) { TRACE( "Spine.Skeleton#GetAttachment$1", this ); }

                return this.GetAttachment(this.data.FindSlot(slotName).index, attachmentName);
            },
            /*Spine.Skeleton.GetAttachment$1 end.*/

            /*Spine.Skeleton.GetAttachment start.*/
            /**
             * Finds an attachment by looking in the skin and skeletonData.defaultSkin using the slot index and attachment name.First the skin is checked and if the attachment was not found, the default skin is checked.
             *
             * @instance
             * @public
             * @this Spine.Skeleton
             * @memberof Spine.Skeleton
             * @param   {number}              slotIndex         
             * @param   {string}              attachmentName
             * @return  {Spine.Attachment}                      May be null.
             */
            GetAttachment: function (slotIndex, attachmentName) {
if ( TRACE ) { TRACE( "Spine.Skeleton#GetAttachment", this ); }

                if (attachmentName == null) {
                    throw new System.ArgumentNullException.$ctor3("attachmentName", "attachmentName cannot be null.");
                }
                if (this.skin != null) {
                    var attachment = this.skin.GetAttachment(slotIndex, attachmentName);
                    if (attachment != null) {
                        return attachment;
                    }
                }
                return this.data.defaultSkin != null ? this.data.defaultSkin.GetAttachment(slotIndex, attachmentName) : null;
            },
            /*Spine.Skeleton.GetAttachment end.*/

            /*Spine.Skeleton.SetAttachment start.*/
            /**
             * A convenience method to set an attachment by finding the slot with FindSlot, finding the attachment with GetAttachment, then setting the slot's slot.Attachment.
             *
             * @instance
             * @public
             * @this Spine.Skeleton
             * @memberof Spine.Skeleton
             * @param   {string}    slotName          
             * @param   {string}    attachmentName    May be null to clear the slot's attachment.
             * @return  {void}
             */
            SetAttachment: function (slotName, attachmentName) {
if ( TRACE ) { TRACE( "Spine.Skeleton#SetAttachment", this ); }

                if (slotName == null) {
                    throw new System.ArgumentNullException.$ctor3("slotName", "slotName cannot be null.");
                }
                var slots = this.slots.Items;
                for (var i = 0, n = this.slots.Count; i < n; i = (i + 1) | 0) {
                    var slot = slots[i];
                    if (Bridge.referenceEquals(slot.data.name, slotName)) {
                        var attachment = null;
                        if (attachmentName != null) {
                            attachment = this.GetAttachment(i, attachmentName);
                            if (attachment == null) {
                                throw new System.Exception("Attachment not found: " + (attachmentName || "") + ", for slot: " + (slotName || ""));
                            }
                        }
                        slot.Attachment = attachment;
                        return;
                    }
                }
                throw new System.Exception("Slot not found: " + (slotName || ""));
            },
            /*Spine.Skeleton.SetAttachment end.*/

            /*Spine.Skeleton.FindIkConstraint start.*/
            /**
             * Finds an IK constraint by comparing each IK constraint's name. It is more efficient to cache the results of this method
             than to call it repeatedly.
             *
             * @instance
             * @public
             * @this Spine.Skeleton
             * @memberof Spine.Skeleton
             * @param   {string}                constraintName
             * @return  {Spine.IkConstraint}                      May be null.
             */
            FindIkConstraint: function (constraintName) {
if ( TRACE ) { TRACE( "Spine.Skeleton#FindIkConstraint", this ); }

                if (constraintName == null) {
                    throw new System.ArgumentNullException.$ctor3("constraintName", "constraintName cannot be null.");
                }
                var ikConstraints = this.ikConstraints.Items;
                for (var i = 0, n = this.ikConstraints.Count; i < n; i = (i + 1) | 0) {
                    var ikConstraint = ikConstraints[i];
                    if (Bridge.referenceEquals(ikConstraint.data.name, constraintName)) {
                        return ikConstraint;
                    }
                }
                return null;
            },
            /*Spine.Skeleton.FindIkConstraint end.*/

            /*Spine.Skeleton.FindTransformConstraint start.*/
            /**
             * Finds a transform constraint by comparing each transform constraint's name. It is more efficient to cache the results of
             this method than to call it repeatedly.
             *
             * @instance
             * @public
             * @this Spine.Skeleton
             * @memberof Spine.Skeleton
             * @param   {string}                       constraintName
             * @return  {Spine.TransformConstraint}                      May be null.
             */
            FindTransformConstraint: function (constraintName) {
if ( TRACE ) { TRACE( "Spine.Skeleton#FindTransformConstraint", this ); }

                if (constraintName == null) {
                    throw new System.ArgumentNullException.$ctor3("constraintName", "constraintName cannot be null.");
                }
                var transformConstraints = this.transformConstraints.Items;
                for (var i = 0, n = this.transformConstraints.Count; i < n; i = (i + 1) | 0) {
                    var transformConstraint = transformConstraints[i];
                    if (Bridge.referenceEquals(transformConstraint.data.Name, constraintName)) {
                        return transformConstraint;
                    }
                }
                return null;
            },
            /*Spine.Skeleton.FindTransformConstraint end.*/

            /*Spine.Skeleton.FindPathConstraint start.*/
            /**
             * Finds a path constraint by comparing each path constraint's name. It is more efficient to cache the results of this method
             than to call it repeatedly.
             *
             * @instance
             * @public
             * @this Spine.Skeleton
             * @memberof Spine.Skeleton
             * @param   {string}                  constraintName
             * @return  {Spine.PathConstraint}                      May be null.
             */
            FindPathConstraint: function (constraintName) {
if ( TRACE ) { TRACE( "Spine.Skeleton#FindPathConstraint", this ); }

                if (constraintName == null) {
                    throw new System.ArgumentNullException.$ctor3("constraintName", "constraintName cannot be null.");
                }
                var pathConstraints = this.pathConstraints.Items;
                for (var i = 0, n = this.pathConstraints.Count; i < n; i = (i + 1) | 0) {
                    var constraint = pathConstraints[i];
                    if (System.String.equals(constraint.data.Name, constraintName)) {
                        return constraint;
                    }
                }
                return null;
            },
            /*Spine.Skeleton.FindPathConstraint end.*/

            /*Spine.Skeleton.FindPhysicsConstraint start.*/
            /**
             * Finds a physics constraint by comparing each physics constraint's name. It is more efficient to cache the results of this
             method than to call it repeatedly.
             *
             * @instance
             * @public
             * @this Spine.Skeleton
             * @memberof Spine.Skeleton
             * @param   {string}                     constraintName
             * @return  {Spine.PhysicsConstraint}                      May be null.
             */
            FindPhysicsConstraint: function (constraintName) {
if ( TRACE ) { TRACE( "Spine.Skeleton#FindPhysicsConstraint", this ); }

                if (constraintName == null) {
                    throw new System.ArgumentNullException.$ctor3("constraintName", "constraintName cannot be null.");
                }
                var physicsConstraints = this.physicsConstraints.Items;
                for (var i = 0, n = this.physicsConstraints.Count; i < n; i = (i + 1) | 0) {
                    var constraint = physicsConstraints[i];
                    if (System.String.equals(constraint.data.name, constraintName)) {
                        return constraint;
                    }
                }
                return null;
            },
            /*Spine.Skeleton.FindPhysicsConstraint end.*/

            /*Spine.Skeleton.GetBounds start.*/
            /**
             * Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose.
             *
             * @instance
             * @public
             * @this Spine.Skeleton
             * @memberof Spine.Skeleton
             * @param   {System.Single}             x               The horizontal distance between the skeleton origin and the left side of the AABB.
             * @param   {System.Single}             y               The vertical distance between the skeleton origin and the bottom side of the AABB.
             * @param   {System.Single}             width           The width of the AABB
             * @param   {System.Single}             height          The height of the AABB.
             * @param   {System.Single}             vertexBuffer    Reference to hold a float[]. May be a null reference. This method will assign it a new float[] with the appropriate size as needed.
             * @param   {Spine.SkeletonClipping}    clipper
             * @return  {void}
             */
            GetBounds: function (x, y, width, height, vertexBuffer, clipper) {
if ( TRACE ) { TRACE( "Spine.Skeleton#GetBounds", this ); }

                if (clipper === void 0) { clipper = null; }

                var temp = vertexBuffer.v;
                temp = temp || System.Array.init(8, 0, System.Single);
                var drawOrder = this.drawOrder.Items;
                var minX = 2147483647, minY = 2147483647, maxX = -2147483648, maxY = -2147483648;
                for (var i = 0, n = this.drawOrder.Count; i < n; i = (i + 1) | 0) {
                    var slot = drawOrder[i];
                    if (!slot.bone.active) {
                        continue;
                    }
                    var verticesLength = 0;
                    var vertices = null;
                    var triangles = null;
                    var attachment = slot.attachment;
                    var region = Bridge.as(attachment, Spine.RegionAttachment);
                    if (region != null) {
                        verticesLength = 8;
                        vertices = temp;
                        if (vertices.length < 8) {
                            vertices = (temp = System.Array.init(8, 0, System.Single));
                        }
                        region.ComputeWorldVertices(slot, temp, 0, 2);
                        triangles = Spine.Skeleton.quadTriangles;
                    } else {
                        var mesh = Bridge.as(attachment, Spine.MeshAttachment);
                        if (mesh != null) {
                            verticesLength = mesh.WorldVerticesLength;
                            vertices = temp;
                            if (vertices.length < verticesLength) {
                                vertices = (temp = System.Array.init(verticesLength, 0, System.Single));
                            }
                            mesh.ComputeWorldVertices(slot, 0, verticesLength, temp, 0, 2);
                            triangles = mesh.Triangles;
                        } else if (clipper != null) {
                            var clip = Bridge.as(attachment, Spine.ClippingAttachment);
                            if (clip != null) {
                                clipper.ClipStart(slot, clip);
                                continue;
                            }
                        }
                    }

                    if (vertices != null) {
                        if (clipper != null && clipper.IsClipping) {
                            clipper.ClipTriangles(vertices, triangles, triangles.length);
                            vertices = clipper.ClippedVertices.Items;
                            verticesLength = clipper.ClippedVertices.Count;
                        }

                        for (var ii = 0; ii < verticesLength; ii = (ii + 2) | 0) {
                            var vx = vertices[ii], vy = vertices[((ii + 1) | 0)];
                            minX = Math.min(minX, vx);
                            minY = Math.min(minY, vy);
                            maxX = Math.max(maxX, vx);
                            maxY = Math.max(maxY, vy);
                        }
                    }
                    if (clipper != null) {
                        clipper.ClipEnd$1(slot);
                    }
                }
                if (clipper != null) {
                    clipper.ClipEnd();
                }
                x.v = minX;
                y.v = minY;
                width.v = maxX - minX;
                height.v = maxY - minY;
                vertexBuffer.v = temp;
            },
            /*Spine.Skeleton.GetBounds end.*/

            /*Spine.Skeleton.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#toString", this ); }

                return this.data.name;
            },
            /*Spine.Skeleton.toString end.*/


        },
        overloads: {
            "SortPathConstraintAttachment(Skin, int, Bone)": "SortPathConstraintAttachment$1",
            "UpdateWorldTransform(Physics, Bone)": "UpdateWorldTransform$1",
            "SetSkin(string)": "SetSkin$1",
            "GetAttachment(string, string)": "GetAttachment$1",
            "ToString()": "toString"
        }
    });
    /*Spine.Skeleton end.*/

    /*Spine.Skeleton+Physics start.*/
    /**
     * Determines how physics and other non-deterministic updates are applied.
     *
     * @public
     * @class number
     */
    Bridge.define("Spine.Skeleton.Physics", {
        $kind: 1006,
        statics: {
            fields: {
                /**
                 * Physics are not updated or applied.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 0
                 * @type number
                 */
                None: 0,
                /**
                 * Physics are reset to the current pose.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 1
                 * @type number
                 */
                Reset: 1,
                /**
                 * Physics are updated and the pose from physics is applied.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 2
                 * @type number
                 */
                Update: 2,
                /**
                 * Physics are not updated but the pose from physics is applied.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 3
                 * @type number
                 */
                Pose: 3
            }
        }
    });
    /*Spine.Skeleton+Physics end.*/

    /*Spine.SkeletonLoader start.*/
    /**
     * Base class for loading skeleton data from a file.
     <p>See<a href="http://esotericsoftware.com/spine-loading-skeleton-data#JSON-and-binary-data">JSON and binary data</a> in the
     Spine Runtimes Guide.</p>
     *
     * @abstract
     * @public
     * @class Spine.SkeletonLoader
     */
    Bridge.define("Spine.SkeletonLoader", {
        fields: {
            attachmentLoader: null,
            scale: 0
        },
        props: {
            /**
             * Scales bone positions, image sizes, and translations as they are loaded. This allows different size images to be used at
             runtime than were used in Spine.
             <p>See <a href="http://esotericsoftware.com/spine-loading-skeleton-data#Scaling">Scaling</a> in the Spine Runtimes Guide.</p>
             *
             * @instance
             * @public
             * @memberof Spine.SkeletonLoader
             * @function Scale
             * @type number
             */
            Scale: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonLoader#Scale#get", this ); }

                    return this.scale;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonLoader#Scale#set", this ); }

                    if (this.scale === 0) {
                        throw new System.ArgumentNullException.$ctor3("scale", "scale cannot be 0.");
                    }
                    this.scale = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonLoader#init", this ); }

                this.scale = 1;
            },
            /**
             * Creates a skeleton loader that loads attachments using an {@link } with the specified atlas.
             *
             * @instance
             * @public
             * @this Spine.SkeletonLoader
             * @memberof Spine.SkeletonLoader
             * @param   {Array.<Spine.Atlas>}    atlasArray
             * @return  {void}
             */
            ctor: function (atlasArray) {
if ( TRACE ) { TRACE( "Spine.SkeletonLoader#ctor", this ); }

                if (atlasArray === void 0) { atlasArray = []; }

                this.$initialize();
                this.attachmentLoader = new Spine.AtlasAttachmentLoader(atlasArray);
            },
            /**
             * Creates a skeleton loader that loads attachments using the specified attachment loader.
             <p>See <a href="http://esotericsoftware.com/spine-loading-skeleton-data#JSON-and-binary-data">Loading skeleton data</a> in the
             Spine Runtimes Guide.</p>
             *
             * @instance
             * @public
             * @this Spine.SkeletonLoader
             * @memberof Spine.SkeletonLoader
             * @param   {Spine.AttachmentLoader}    attachmentLoader
             * @return  {void}
             */
            $ctor1: function (attachmentLoader) {
if ( TRACE ) { TRACE( "Spine.SkeletonLoader#$ctor1", this ); }

                this.$initialize();
                if (attachmentLoader == null) {
                    throw new System.ArgumentNullException.$ctor3("attachmentLoader", "attachmentLoader cannot be null.");
                }
                this.attachmentLoader = attachmentLoader;
            }
        }
    });
    /*Spine.SkeletonLoader end.*/

    /*Spine.SkeletonBinary+LinkedMesh start.*/
    Bridge.define("Spine.SkeletonBinary.LinkedMesh", {
        $kind: 1002,
        fields: {
            parent: null,
            skinIndex: 0,
            slotIndex: 0,
            mesh: null,
            inheritTimelines: false
        },
        ctors: {
            ctor: function (mesh, skinIndex, slotIndex, parent, inheritTimelines) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary.LinkedMesh#ctor", this ); }

                this.$initialize();
                this.mesh = mesh;
                this.skinIndex = skinIndex;
                this.slotIndex = slotIndex;
                this.parent = parent;
                this.inheritTimelines = inheritTimelines;
            }
        }
    });
    /*Spine.SkeletonBinary+LinkedMesh end.*/

    /*Spine.SkeletonBinary+SkeletonInput start.*/
    Bridge.define("Spine.SkeletonBinary.SkeletonInput", {
        $kind: 1002,
        fields: {
            chars: null,
            bytesBigEndian: null,
            strings: null,
            input: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary.SkeletonInput#init", this ); }

                this.chars = System.Array.init(32, 0, System.Byte);
                this.bytesBigEndian = System.Array.init(8, 0, System.Byte);
            },
            ctor: function (input) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary.SkeletonInput#ctor", this ); }

                this.$initialize();
                this.input = input;
            }
        },
        methods: {
            /*Spine.SkeletonBinary+SkeletonInput.Read start.*/
            Read: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary.SkeletonInput#Read", this ); }

                return this.input.ReadByte();
            },
            /*Spine.SkeletonBinary+SkeletonInput.Read end.*/

            /*Spine.SkeletonBinary+SkeletonInput.ReadUByte start.*/
            /**
             * Explicit unsigned byte variant to prevent pitfalls porting Java reference implementation
             where byte is signed vs C# where byte is unsigned.
             *
             * @instance
             * @public
             * @this Spine.SkeletonBinary.SkeletonInput
             * @memberof Spine.SkeletonBinary.SkeletonInput
             * @return  {number}
             */
            ReadUByte: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary.SkeletonInput#ReadUByte", this ); }

                return ((this.input.ReadByte()) & 255);
            },
            /*Spine.SkeletonBinary+SkeletonInput.ReadUByte end.*/

            /*Spine.SkeletonBinary+SkeletonInput.ReadSByte start.*/
            /**
             * Explicit signed byte variant to prevent pitfalls porting Java reference implementation
             where byte is signed vs C# where byte is unsigned.
             *
             * @instance
             * @public
             * @this Spine.SkeletonBinary.SkeletonInput
             * @memberof Spine.SkeletonBinary.SkeletonInput
             * @return  {number}
             */
            ReadSByte: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary.SkeletonInput#ReadSByte", this ); }

                var value = this.input.ReadByte();
                if (value === -1) {
                    throw new System.IO.EndOfStreamException.ctor();
                }
                return Bridge.Int.sxb(value & 255);
            },
            /*Spine.SkeletonBinary+SkeletonInput.ReadSByte end.*/

            /*Spine.SkeletonBinary+SkeletonInput.ReadBoolean start.*/
            ReadBoolean: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary.SkeletonInput#ReadBoolean", this ); }

                return this.input.ReadByte() !== 0;
            },
            /*Spine.SkeletonBinary+SkeletonInput.ReadBoolean end.*/

            /*Spine.SkeletonBinary+SkeletonInput.ReadFloat start.*/
            ReadFloat: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary.SkeletonInput#ReadFloat", this ); }

                this.input.Read(this.bytesBigEndian, 0, 4);
                this.chars[3] = this.bytesBigEndian[0];
                this.chars[2] = this.bytesBigEndian[1];
                this.chars[1] = this.bytesBigEndian[2];
                this.chars[0] = this.bytesBigEndian[3];
                return System.BitConverter.toSingle(this.chars, 0);
            },
            /*Spine.SkeletonBinary+SkeletonInput.ReadFloat end.*/

            /*Spine.SkeletonBinary+SkeletonInput.ReadInt start.*/
            ReadInt: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary.SkeletonInput#ReadInt", this ); }

                this.input.Read(this.bytesBigEndian, 0, 4);
                return (((((((this.bytesBigEndian[0] << 24) + (this.bytesBigEndian[1] << 16)) | 0) + (this.bytesBigEndian[2] << 8)) | 0) + this.bytesBigEndian[3]) | 0);
            },
            /*Spine.SkeletonBinary+SkeletonInput.ReadInt end.*/

            /*Spine.SkeletonBinary+SkeletonInput.ReadInt$1 start.*/
            ReadInt$1: function (optimizePositive) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary.SkeletonInput#ReadInt$1", this ); }

                var b = this.input.ReadByte();
                var result = b & 127;
                if ((b & 128) !== 0) {
                    b = this.input.ReadByte();
                    result = result | ((b & 127) << 7);
                    if ((b & 128) !== 0) {
                        b = this.input.ReadByte();
                        result = result | ((b & 127) << 14);
                        if ((b & 128) !== 0) {
                            b = this.input.ReadByte();
                            result = result | ((b & 127) << 21);
                            if ((b & 128) !== 0) {
                                result = result | ((this.input.ReadByte() & 127) << 28);
                            }
                        }
                    }
                }
                return optimizePositive ? result : ((result >> 1) ^ ((-(result & 1)) | 0));
            },
            /*Spine.SkeletonBinary+SkeletonInput.ReadInt$1 end.*/

            /*Spine.SkeletonBinary+SkeletonInput.ReadLong start.*/
            ReadLong: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary.SkeletonInput#ReadLong", this ); }

                this.input.Read(this.bytesBigEndian, 0, 8);
                return (System.Int64((this.bytesBigEndian[0])).shl(56)).add((System.Int64((this.bytesBigEndian[1])).shl(48))).add((System.Int64((this.bytesBigEndian[2])).shl(40))).add((System.Int64((this.bytesBigEndian[3])).shl(32))).add((System.Int64((this.bytesBigEndian[4])).shl(24))).add((System.Int64((this.bytesBigEndian[5])).shl(16))).add((System.Int64((this.bytesBigEndian[6])).shl(8))).add(System.Int64((this.bytesBigEndian[7])));
            },
            /*Spine.SkeletonBinary+SkeletonInput.ReadLong end.*/

            /*Spine.SkeletonBinary+SkeletonInput.ReadString start.*/
            ReadString: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary.SkeletonInput#ReadString", this ); }

                var byteCount = this.ReadInt$1(true);
                switch (byteCount) {
                    case 0: 
                        return null;
                    case 1: 
                        return "";
                }
                byteCount = (byteCount - 1) | 0;
                var buffer = this.chars;
                if (buffer.length < byteCount) {
                    buffer = System.Array.init(byteCount, 0, System.Byte);
                }
                this.ReadFully(buffer, 0, byteCount);
                return System.Text.Encoding.UTF8.GetString$1(buffer, 0, byteCount);
            },
            /*Spine.SkeletonBinary+SkeletonInput.ReadString end.*/

            /*Spine.SkeletonBinary+SkeletonInput.ReadStringRef start.*/
            /**
             * @instance
             * @public
             * @this Spine.SkeletonBinary.SkeletonInput
             * @memberof Spine.SkeletonBinary.SkeletonInput
             * @return  {string}
             */
            ReadStringRef: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary.SkeletonInput#ReadStringRef", this ); }

                var index = this.ReadInt$1(true);
                return index === 0 ? null : this.strings[((index - 1) | 0)];
            },
            /*Spine.SkeletonBinary+SkeletonInput.ReadStringRef end.*/

            /*Spine.SkeletonBinary+SkeletonInput.ReadFully start.*/
            ReadFully: function (buffer, offset, length) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary.SkeletonInput#ReadFully", this ); }

                while (length > 0) {
                    var count = this.input.Read(buffer, offset, length);
                    if (count <= 0) {
                        throw new System.IO.EndOfStreamException.ctor();
                    }
                    offset = (offset + count) | 0;
                    length = (length - count) | 0;
                }
            },
            /*Spine.SkeletonBinary+SkeletonInput.ReadFully end.*/

            /*Spine.SkeletonBinary+SkeletonInput.GetVersionString start.*/
            /**
             * Returns the version string of binary skeleton data.
             *
             * @instance
             * @public
             * @this Spine.SkeletonBinary.SkeletonInput
             * @memberof Spine.SkeletonBinary.SkeletonInput
             * @return  {string}
             */
            GetVersionString: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary.SkeletonInput#GetVersionString", this ); }

                try {
                    // try reading 4.0+ format
                    var initialPosition = this.input.Position;
                    this.ReadLong(); // long hash

                    var stringPosition = this.input.Position;
                    var stringByteCount = this.ReadInt$1(true);
                    this.input.Position = stringPosition;
                    if (stringByteCount <= 13) {
                        var version = this.ReadString();
                        if (System.Char.isDigit(version.charCodeAt(0))) {
                            return version;
                        }
                    }
                    // fallback to old version format
                    this.input.Position = initialPosition;
                    return this.GetVersionStringOld3X();
                } catch (e) {
                    e = System.Exception.create(e);
                    throw new System.ArgumentException.$ctor3(System.String.concat("Stream does not contain valid binary Skeleton Data.\n", e), "input");
                }
            },
            /*Spine.SkeletonBinary+SkeletonInput.GetVersionString end.*/

            /*Spine.SkeletonBinary+SkeletonInput.GetVersionStringOld3X start.*/
            /**
             * Returns old 3.8 and earlier format version string of binary skeleton data.
             *
             * @instance
             * @public
             * @this Spine.SkeletonBinary.SkeletonInput
             * @memberof Spine.SkeletonBinary.SkeletonInput
             * @return  {string}
             */
            GetVersionStringOld3X: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary.SkeletonInput#GetVersionStringOld3X", this ); }

                var $t;
                // Hash.
                var byteCount = this.ReadInt$1(true);
                if (byteCount > 1) {
                    ($t = this.input).Position = $t.Position.add(System.Int64(byteCount - 1));
                }

                // Version.
                byteCount = this.ReadInt$1(true);
                if (byteCount > 1 && byteCount <= 13) {
                    byteCount = (byteCount - 1) | 0;
                    var buffer = System.Array.init(byteCount, 0, System.Byte);
                    this.ReadFully(buffer, 0, byteCount);
                    return System.Text.Encoding.UTF8.GetString$1(buffer, 0, byteCount);
                }
                throw new System.ArgumentException.$ctor1("Stream does not contain valid binary Skeleton Data.");
            },
            /*Spine.SkeletonBinary+SkeletonInput.GetVersionStringOld3X end.*/


        },
        overloads: {
            "ReadInt(bool)": "ReadInt$1"
        }
    });
    /*Spine.SkeletonBinary+SkeletonInput end.*/

    /*Spine.SkeletonBinary+Vertices start.*/
    Bridge.define("Spine.SkeletonBinary.Vertices", {
        $kind: 1002,
        fields: {
            length: 0,
            bones: null,
            vertices: null
        }
    });
    /*Spine.SkeletonBinary+Vertices end.*/

    /*Spine.SkeletonBounds start.*/
    /**
     * Collects each BoundingBoxAttachment that is visible and computes the world vertices for its polygon.
     The polygon vertices are provided along with convenience methods for doing hit detection.
     *
     * @public
     * @class Spine.SkeletonBounds
     */
    Bridge.define("Spine.SkeletonBounds", {
        fields: {
            polygonPool: null,
            minX: 0,
            minY: 0,
            maxX: 0,
            maxY: 0,
            BoundingBoxes: null,
            Polygons: null
        },
        props: {
            MinX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#MinX#get", this ); }

                    return this.minX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#MinX#set", this ); }

                    this.minX = value;
                }
            },
            MinY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#MinY#get", this ); }

                    return this.minY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#MinY#set", this ); }

                    this.minY = value;
                }
            },
            MaxX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#MaxX#get", this ); }

                    return this.maxX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#MaxX#set", this ); }

                    this.maxX = value;
                }
            },
            MaxY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#MaxY#get", this ); }

                    return this.maxY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#MaxY#set", this ); }

                    this.maxY = value;
                }
            },
            Width: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#Width#get", this ); }

                    return this.maxX - this.minX;
                }
            },
            Height: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#Height#get", this ); }

                    return this.maxY - this.minY;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#init", this ); }

                this.polygonPool = new (Spine.ExposedList$1(Spine.Polygon)).ctor();
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#ctor", this ); }

                this.$initialize();
                this.BoundingBoxes = new (Spine.ExposedList$1(Spine.BoundingBoxAttachment)).ctor();
                this.Polygons = new (Spine.ExposedList$1(Spine.Polygon)).ctor();
            }
        },
        methods: {
            /*Spine.SkeletonBounds.Update start.*/
            /**
             * Clears any previous polygons, finds all visible bounding box attachments,
             and computes the world vertices for each bounding box's polygon.
             *
             * @instance
             * @public
             * @this Spine.SkeletonBounds
             * @memberof Spine.SkeletonBounds
             * @param   {Spine.Skeleton}    skeleton      The skeleton.
             * @param   {boolean}           updateAabb    If true, the axis aligned bounding box containing all the polygons is computed.
             If false, the SkeletonBounds AABB methods will always return true.
             * @return  {void}
             */
            Update: function (skeleton, updateAabb) {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#Update", this ); }

                var $t;
                var boundingBoxes = this.BoundingBoxes;
                var polygons = this.Polygons;
                var slots = skeleton.slots.Items;
                var slotCount = skeleton.slots.Count;

                boundingBoxes.Clear();
                for (var i = 0, n = polygons.Count; i < n; i = (i + 1) | 0) {
                    this.polygonPool.Add(polygons.Items[i]);
                }
                polygons.Clear();

                for (var i1 = 0; i1 < slotCount; i1 = (i1 + 1) | 0) {
                    var slot = slots[i1];
                    if (!slot.bone.active) {
                        continue;
                    }
                    var boundingBox = Bridge.as(slot.attachment, Spine.BoundingBoxAttachment);
                    if (boundingBox == null) {
                        continue;
                    }
                    boundingBoxes.Add(boundingBox);

                    var polygon = null;
                    var poolCount = this.polygonPool.Count;
                    if (poolCount > 0) {
                        polygon = ($t = this.polygonPool.Items)[((poolCount - 1) | 0)];
                        this.polygonPool.RemoveAt(((poolCount - 1) | 0));
                    } else {
                        polygon = new Spine.Polygon();
                    }
                    polygons.Add(polygon);

                    var count = boundingBox.worldVerticesLength;
                    polygon.Count = count;
                    if (polygon.Vertices.length < count) {
                        polygon.Vertices = System.Array.init(count, 0, System.Single);
                    }
                    boundingBox.ComputeWorldVertices$1(slot, polygon.Vertices);
                }

                if (updateAabb) {
                    this.AabbCompute();
                } else {
                    this.minX = -2147483648;
                    this.minY = -2147483648;
                    this.maxX = 2147483647;
                    this.maxY = 2147483647;
                }
            },
            /*Spine.SkeletonBounds.Update end.*/

            /*Spine.SkeletonBounds.AabbCompute start.*/
            AabbCompute: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#AabbCompute", this ); }

                var minX = 2147483647, minY = 2147483647, maxX = -2147483648, maxY = -2147483648;
                var polygons = this.Polygons.Items;
                for (var i = 0, n = this.Polygons.Count; i < n; i = (i + 1) | 0) {
                    var polygon = polygons[i];
                    var vertices = polygon.Vertices;
                    for (var ii = 0, nn = polygon.Count; ii < nn; ii = (ii + 2) | 0) {
                        var x = vertices[ii];
                        var y = vertices[((ii + 1) | 0)];
                        minX = Math.min(minX, x);
                        minY = Math.min(minY, y);
                        maxX = Math.max(maxX, x);
                        maxY = Math.max(maxY, y);
                    }
                }
                this.minX = minX;
                this.minY = minY;
                this.maxX = maxX;
                this.maxY = maxY;
            },
            /*Spine.SkeletonBounds.AabbCompute end.*/

            /*Spine.SkeletonBounds.AabbContainsPoint start.*/
            /**
             * Returns true if the axis aligned bounding box contains the point.
             *
             * @instance
             * @public
             * @this Spine.SkeletonBounds
             * @memberof Spine.SkeletonBounds
             * @param   {number}     x    
             * @param   {number}     y
             * @return  {boolean}
             */
            AabbContainsPoint: function (x, y) {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#AabbContainsPoint", this ); }

                return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;
            },
            /*Spine.SkeletonBounds.AabbContainsPoint end.*/

            /*Spine.SkeletonBounds.AabbIntersectsSegment start.*/
            /**
             * Returns true if the axis aligned bounding box intersects the line segment.
             *
             * @instance
             * @public
             * @this Spine.SkeletonBounds
             * @memberof Spine.SkeletonBounds
             * @param   {number}     x1    
             * @param   {number}     y1    
             * @param   {number}     x2    
             * @param   {number}     y2
             * @return  {boolean}
             */
            AabbIntersectsSegment: function (x1, y1, x2, y2) {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#AabbIntersectsSegment", this ); }

                var minX = this.minX;
                var minY = this.minY;
                var maxX = this.maxX;
                var maxY = this.maxY;
                if ((x1 <= minX && x2 <= minX) || (y1 <= minY && y2 <= minY) || (x1 >= maxX && x2 >= maxX) || (y1 >= maxY && y2 >= maxY)) {
                    return false;
                }
                var m = (y2 - y1) / (x2 - x1);
                var y = m * (minX - x1) + y1;
                if (y > minY && y < maxY) {
                    return true;
                }
                y = m * (maxX - x1) + y1;
                if (y > minY && y < maxY) {
                    return true;
                }
                var x = (minY - y1) / m + x1;
                if (x > minX && x < maxX) {
                    return true;
                }
                x = (maxY - y1) / m + x1;
                if (x > minX && x < maxX) {
                    return true;
                }
                return false;
            },
            /*Spine.SkeletonBounds.AabbIntersectsSegment end.*/

            /*Spine.SkeletonBounds.AabbIntersectsSkeleton start.*/
            /**
             * Returns true if the axis aligned bounding box intersects the axis aligned bounding box of the specified bounds.
             *
             * @instance
             * @public
             * @this Spine.SkeletonBounds
             * @memberof Spine.SkeletonBounds
             * @param   {Spine.SkeletonBounds}    bounds
             * @return  {boolean}
             */
            AabbIntersectsSkeleton: function (bounds) {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#AabbIntersectsSkeleton", this ); }

                return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;
            },
            /*Spine.SkeletonBounds.AabbIntersectsSkeleton end.*/

            /*Spine.SkeletonBounds.ContainsPoint$1 start.*/
            /**
             * Returns true if the polygon contains the point.
             *
             * @instance
             * @public
             * @this Spine.SkeletonBounds
             * @memberof Spine.SkeletonBounds
             * @param   {Spine.Polygon}    polygon    
             * @param   {number}           x          
             * @param   {number}           y
             * @return  {boolean}
             */
            ContainsPoint$1: function (polygon, x, y) {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#ContainsPoint$1", this ); }

                var vertices = polygon.Vertices;
                var nn = polygon.Count;

                var prevIndex = (nn - 2) | 0;
                var inside = false;
                for (var ii = 0; ii < nn; ii = (ii + 2) | 0) {
                    var vertexY = vertices[((ii + 1) | 0)];
                    var prevY = vertices[((prevIndex + 1) | 0)];
                    if ((vertexY < y && prevY >= y) || (prevY < y && vertexY >= y)) {
                        var vertexX = vertices[ii];
                        if (vertexX + (y - vertexY) / (prevY - vertexY) * (vertices[prevIndex] - vertexX) < x) {
                            inside = !inside;
                        }
                    }
                    prevIndex = ii;
                }
                return inside;
            },
            /*Spine.SkeletonBounds.ContainsPoint$1 end.*/

            /*Spine.SkeletonBounds.ContainsPoint start.*/
            /**
             * Returns the first bounding box attachment that contains the point, or null. When doing many checks, it is usually more
             efficient to only call this method if {@link } returns true.
             *
             * @instance
             * @public
             * @this Spine.SkeletonBounds
             * @memberof Spine.SkeletonBounds
             * @param   {number}                         x    
             * @param   {number}                         y
             * @return  {Spine.BoundingBoxAttachment}
             */
            ContainsPoint: function (x, y) {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#ContainsPoint", this ); }

                var $t;
                var polygons = this.Polygons.Items;
                for (var i = 0, n = this.Polygons.Count; i < n; i = (i + 1) | 0) {
                    if (this.ContainsPoint$1(polygons[i], x, y)) {
                        return ($t = this.BoundingBoxes.Items)[i];
                    }
                }
                return null;
            },
            /*Spine.SkeletonBounds.ContainsPoint end.*/

            /*Spine.SkeletonBounds.IntersectsSegment start.*/
            /**
             * Returns the first bounding box attachment that contains the line segment, or null. When doing many checks, it is usually
             more efficient to only call this method if {@link } returns true.
             *
             * @instance
             * @public
             * @this Spine.SkeletonBounds
             * @memberof Spine.SkeletonBounds
             * @param   {number}                         x1    
             * @param   {number}                         y1    
             * @param   {number}                         x2    
             * @param   {number}                         y2
             * @return  {Spine.BoundingBoxAttachment}
             */
            IntersectsSegment: function (x1, y1, x2, y2) {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#IntersectsSegment", this ); }

                var $t;
                var polygons = this.Polygons.Items;
                for (var i = 0, n = this.Polygons.Count; i < n; i = (i + 1) | 0) {
                    if (this.IntersectsSegment$1(polygons[i], x1, y1, x2, y2)) {
                        return ($t = this.BoundingBoxes.Items)[i];
                    }
                }
                return null;
            },
            /*Spine.SkeletonBounds.IntersectsSegment end.*/

            /*Spine.SkeletonBounds.IntersectsSegment$1 start.*/
            /**
             * Returns true if the polygon contains the line segment.
             *
             * @instance
             * @public
             * @this Spine.SkeletonBounds
             * @memberof Spine.SkeletonBounds
             * @param   {Spine.Polygon}    polygon    
             * @param   {number}           x1         
             * @param   {number}           y1         
             * @param   {number}           x2         
             * @param   {number}           y2
             * @return  {boolean}
             */
            IntersectsSegment$1: function (polygon, x1, y1, x2, y2) {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#IntersectsSegment$1", this ); }

                var vertices = polygon.Vertices;
                var nn = polygon.Count;

                var width12 = x1 - x2, height12 = y1 - y2;
                var det1 = x1 * y2 - y1 * x2;
                var x3 = vertices[((nn - 2) | 0)], y3 = vertices[((nn - 1) | 0)];
                for (var ii = 0; ii < nn; ii = (ii + 2) | 0) {
                    var x4 = vertices[ii], y4 = vertices[((ii + 1) | 0)];
                    var det2 = x3 * y4 - y3 * x4;
                    var width34 = x3 - x4, height34 = y3 - y4;
                    var det3 = width12 * height34 - height12 * width34;
                    var x = (det1 * width34 - width12 * det2) / det3;
                    if (((x >= x3 && x <= x4) || (x >= x4 && x <= x3)) && ((x >= x1 && x <= x2) || (x >= x2 && x <= x1))) {
                        var y = (det1 * height34 - height12 * det2) / det3;
                        if (((y >= y3 && y <= y4) || (y >= y4 && y <= y3)) && ((y >= y1 && y <= y2) || (y >= y2 && y <= y1))) {
                            return true;
                        }
                    }
                    x3 = x4;
                    y3 = y4;
                }
                return false;
            },
            /*Spine.SkeletonBounds.IntersectsSegment$1 end.*/

            /*Spine.SkeletonBounds.GetPolygon start.*/
            GetPolygon: function (attachment) {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#GetPolygon", this ); }

                var $t;
                var index = this.BoundingBoxes.IndexOf(attachment);
                return index === -1 ? null : ($t = this.Polygons.Items)[index];
            },
            /*Spine.SkeletonBounds.GetPolygon end.*/


        },
        overloads: {
            "ContainsPoint(Polygon, float, float)": "ContainsPoint$1",
            "IntersectsSegment(Polygon, float, float, float, float)": "IntersectsSegment$1"
        }
    });
    /*Spine.SkeletonBounds end.*/

    /*Spine.SkeletonClipping start.*/
    Bridge.define("Spine.SkeletonClipping", {
        statics: {
            methods: {
                /*Spine.SkeletonClipping.MakeClockwise:static start.*/
                MakeClockwise: function (polygon) {
if ( TRACE ) { TRACE( "Spine.SkeletonClipping#MakeClockwise", this ); }

                    var vertices = polygon.Items;
                    var verticeslength = polygon.Count;

                    var area = vertices[((verticeslength - 2) | 0)] * vertices[1] - vertices[0] * vertices[((verticeslength - 1) | 0)], p1x, p1y, p2x, p2y;
                    for (var i = 0, n = (verticeslength - 3) | 0; i < n; i = (i + 2) | 0) {
                        p1x = vertices[i];
                        p1y = vertices[((i + 1) | 0)];
                        p2x = vertices[((i + 2) | 0)];
                        p2y = vertices[((i + 3) | 0)];
                        area += p1x * p2y - p2x * p1y;
                    }
                    if (area < 0) {
                        return;
                    }

                    for (var i1 = 0, lastX = (verticeslength - 2) | 0, n1 = verticeslength >> 1; i1 < n1; i1 = (i1 + 2) | 0) {
                        var x = vertices[i1], y = vertices[((i1 + 1) | 0)];
                        var other = (lastX - i1) | 0;
                        vertices[i1] = vertices[other];
                        vertices[((i1 + 1) | 0)] = vertices[((other + 1) | 0)];
                        vertices[other] = x;
                        vertices[((other + 1) | 0)] = y;
                    }
                },
                /*Spine.SkeletonClipping.MakeClockwise:static end.*/


            }
        },
        fields: {
            triangulator: null,
            clippingPolygon: null,
            clipOutput: null,
            clippedVertices: null,
            clippedTriangles: null,
            clippedUVs: null,
            scratch: null,
            clipAttachment: null,
            clippingPolygons: null
        },
        props: {
            ClippedVertices: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonClipping#ClippedVertices#get", this ); }

                    return this.clippedVertices;
                }
            },
            ClippedTriangles: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonClipping#ClippedTriangles#get", this ); }

                    return this.clippedTriangles;
                }
            },
            ClippedUVs: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonClipping#ClippedUVs#get", this ); }

                    return this.clippedUVs;
                }
            },
            IsClipping: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonClipping#IsClipping#get", this ); }

                    return this.clipAttachment != null;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonClipping#init", this ); }

                this.triangulator = new Spine.Triangulator();
                this.clippingPolygon = new (Spine.ExposedList$1(System.Single)).ctor();
                this.clipOutput = new (Spine.ExposedList$1(System.Single)).$ctor3(128);
                this.clippedVertices = new (Spine.ExposedList$1(System.Single)).$ctor3(128);
                this.clippedTriangles = new (Spine.ExposedList$1(System.Int32)).$ctor3(128);
                this.clippedUVs = new (Spine.ExposedList$1(System.Single)).$ctor3(128);
                this.scratch = new (Spine.ExposedList$1(System.Single)).ctor();
            }
        },
        methods: {
            /*Spine.SkeletonClipping.ClipStart start.*/
            ClipStart: function (slot, clip) {
if ( TRACE ) { TRACE( "Spine.SkeletonClipping#ClipStart", this ); }

                var $t;
                if (this.clipAttachment != null) {
                    return 0;
                }
                this.clipAttachment = clip;

                var n = clip.worldVerticesLength;
                var vertices = this.clippingPolygon.Resize(n).Items;
                clip.ComputeWorldVertices(slot, 0, n, vertices, 0, 2);
                Spine.SkeletonClipping.MakeClockwise(this.clippingPolygon);
                this.clippingPolygons = this.triangulator.Decompose(this.clippingPolygon, this.triangulator.Triangulate(this.clippingPolygon));
                $t = Bridge.getEnumerator(this.clippingPolygons);
                try {
                    while ($t.moveNext()) {
                        var polygon = $t.Current;
                        Spine.SkeletonClipping.MakeClockwise(polygon);
                        polygon.Add(polygon.Items[0]);
                        polygon.Add(polygon.Items[1]);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                return this.clippingPolygons.Count;
            },
            /*Spine.SkeletonClipping.ClipStart end.*/

            /*Spine.SkeletonClipping.ClipEnd$1 start.*/
            ClipEnd$1: function (slot) {
if ( TRACE ) { TRACE( "Spine.SkeletonClipping#ClipEnd$1", this ); }

                if (this.clipAttachment != null && Bridge.referenceEquals(this.clipAttachment.endSlot, slot.data)) {
                    this.ClipEnd();
                }
            },
            /*Spine.SkeletonClipping.ClipEnd$1 end.*/

            /*Spine.SkeletonClipping.ClipEnd start.*/
            ClipEnd: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonClipping#ClipEnd", this ); }

                if (this.clipAttachment == null) {
                    return;
                }
                this.clipAttachment = null;
                this.clippingPolygons = null;
                this.clippedVertices.Clear();
                this.clippedTriangles.Clear();
                this.clippingPolygon.Clear();
            },
            /*Spine.SkeletonClipping.ClipEnd end.*/

            /*Spine.SkeletonClipping.ClipTriangles start.*/
            ClipTriangles: function (vertices, triangles, trianglesLength) {
if ( TRACE ) { TRACE( "Spine.SkeletonClipping#ClipTriangles", this ); }

                var clipOutput = this.clipOutput, clippedVertices = this.clippedVertices;
                var clippedTriangles = this.clippedTriangles;
                var polygons = this.clippingPolygons.Items;
                var polygonsCount = this.clippingPolygons.Count;

                var index = 0;
                clippedVertices.Clear();
                clippedTriangles.Clear();
                for (var i = 0; i < trianglesLength; i = (i + 3) | 0) {
                    var vertexOffset = triangles[i] << 1;
                    var x1 = vertices[vertexOffset], y1 = vertices[((vertexOffset + 1) | 0)];

                    vertexOffset = triangles[((i + 1) | 0)] << 1;
                    var x2 = vertices[vertexOffset], y2 = vertices[((vertexOffset + 1) | 0)];

                    vertexOffset = triangles[((i + 2) | 0)] << 1;
                    var x3 = vertices[vertexOffset], y3 = vertices[((vertexOffset + 1) | 0)];

                    for (var p = 0; p < polygonsCount; p = (p + 1) | 0) {
                        var s = clippedVertices.Count;
                        if (this.Clip(x1, y1, x2, y2, x3, y3, polygons[p], clipOutput)) {
                            var clipOutputLength = clipOutput.Count;
                            if (clipOutputLength === 0) {
                                continue;
                            }

                            var clipOutputCount = clipOutputLength >> 1;
                            var clipOutputItems = clipOutput.Items;
                            var clippedVerticesItems = clippedVertices.Resize(((s + Bridge.Int.mul(clipOutputCount, 2)) | 0)).Items;
                            for (var ii = 0; ii < clipOutputLength; ii = (ii + 2) | 0, s = (s + 2) | 0) {
                                var x = clipOutputItems[ii], y = clipOutputItems[((ii + 1) | 0)];
                                clippedVerticesItems[s] = x;
                                clippedVerticesItems[((s + 1) | 0)] = y;
                            }

                            s = clippedTriangles.Count;
                            var clippedTrianglesItems = clippedTriangles.Resize(((s + Bridge.Int.mul(3, (((clipOutputCount - 2) | 0)))) | 0)).Items;
                            clipOutputCount = (clipOutputCount - 1) | 0;
                            for (var ii1 = 1; ii1 < clipOutputCount; ii1 = (ii1 + 1) | 0, s = (s + 3) | 0) {
                                clippedTrianglesItems[s] = index;
                                clippedTrianglesItems[((s + 1) | 0)] = (index + ii1) | 0;
                                clippedTrianglesItems[((s + 2) | 0)] = (((index + ii1) | 0) + 1) | 0;
                            }
                            index = (index + (((clipOutputCount + 1) | 0))) | 0;
                        } else {
                            var clippedVerticesItems1 = clippedVertices.Resize(((s + 6) | 0)).Items;
                            clippedVerticesItems1[s] = x1;
                            clippedVerticesItems1[((s + 1) | 0)] = y1;
                            clippedVerticesItems1[((s + 2) | 0)] = x2;
                            clippedVerticesItems1[((s + 3) | 0)] = y2;
                            clippedVerticesItems1[((s + 4) | 0)] = x3;
                            clippedVerticesItems1[((s + 5) | 0)] = y3;

                            s = clippedTriangles.Count;
                            var clippedTrianglesItems1 = clippedTriangles.Resize(((s + 3) | 0)).Items;
                            clippedTrianglesItems1[s] = index;
                            clippedTrianglesItems1[((s + 1) | 0)] = (index + 1) | 0;
                            clippedTrianglesItems1[((s + 2) | 0)] = (index + 2) | 0;
                            index = (index + 3) | 0;
                            break;
                        }
                    }
                }
            },
            /*Spine.SkeletonClipping.ClipTriangles end.*/

            /*Spine.SkeletonClipping.ClipTriangles$1 start.*/
            ClipTriangles$1: function (vertices, triangles, trianglesLength, uvs) {
if ( TRACE ) { TRACE( "Spine.SkeletonClipping#ClipTriangles$1", this ); }

                var clipOutput = this.clipOutput, clippedVertices = this.clippedVertices;
                var clippedTriangles = this.clippedTriangles;
                var polygons = this.clippingPolygons.Items;
                var polygonsCount = this.clippingPolygons.Count;

                var index = 0;
                clippedVertices.Clear();
                this.clippedUVs.Clear();
                clippedTriangles.Clear();

                for (var i = 0; i < trianglesLength; i = (i + 3) | 0) {
                    var vertexOffset = triangles[i] << 1;
                    var x1 = vertices[vertexOffset], y1 = vertices[((vertexOffset + 1) | 0)];
                    var u1 = uvs[vertexOffset], v1 = uvs[((vertexOffset + 1) | 0)];

                    vertexOffset = triangles[((i + 1) | 0)] << 1;
                    var x2 = vertices[vertexOffset], y2 = vertices[((vertexOffset + 1) | 0)];
                    var u2 = uvs[vertexOffset], v2 = uvs[((vertexOffset + 1) | 0)];

                    vertexOffset = triangles[((i + 2) | 0)] << 1;
                    var x3 = vertices[vertexOffset], y3 = vertices[((vertexOffset + 1) | 0)];
                    var u3 = uvs[vertexOffset], v3 = uvs[((vertexOffset + 1) | 0)];

                    for (var p = 0; p < polygonsCount; p = (p + 1) | 0) {
                        var s = clippedVertices.Count;
                        if (this.Clip(x1, y1, x2, y2, x3, y3, polygons[p], clipOutput)) {
                            var clipOutputLength = clipOutput.Count;
                            if (clipOutputLength === 0) {
                                continue;
                            }
                            var d0 = y2 - y3, d1 = x3 - x2, d2 = x1 - x3, d4 = y3 - y1;
                            var d = 1 / (d0 * d2 + d1 * (y1 - y3));

                            var clipOutputCount = clipOutputLength >> 1;
                            var clipOutputItems = clipOutput.Items;
                            var clippedVerticesItems = clippedVertices.Resize(((s + Bridge.Int.mul(clipOutputCount, 2)) | 0)).Items;
                            var clippedUVsItems = this.clippedUVs.Resize(((s + Bridge.Int.mul(clipOutputCount, 2)) | 0)).Items;
                            for (var ii = 0; ii < clipOutputLength; ii = (ii + 2) | 0, s = (s + 2) | 0) {
                                var x = clipOutputItems[ii], y = clipOutputItems[((ii + 1) | 0)];
                                clippedVerticesItems[s] = x;
                                clippedVerticesItems[((s + 1) | 0)] = y;
                                var c0 = x - x3, c1 = y - y3;
                                var a = (d0 * c0 + d1 * c1) * d;
                                var b = (d4 * c0 + d2 * c1) * d;
                                var c = 1 - a - b;
                                clippedUVsItems[s] = u1 * a + u2 * b + u3 * c;
                                clippedUVsItems[((s + 1) | 0)] = v1 * a + v2 * b + v3 * c;
                            }

                            s = clippedTriangles.Count;
                            var clippedTrianglesItems = clippedTriangles.Resize(((s + Bridge.Int.mul(3, (((clipOutputCount - 2) | 0)))) | 0)).Items;
                            clipOutputCount = (clipOutputCount - 1) | 0;
                            for (var ii1 = 1; ii1 < clipOutputCount; ii1 = (ii1 + 1) | 0, s = (s + 3) | 0) {
                                clippedTrianglesItems[s] = index;
                                clippedTrianglesItems[((s + 1) | 0)] = (index + ii1) | 0;
                                clippedTrianglesItems[((s + 2) | 0)] = (((index + ii1) | 0) + 1) | 0;
                            }
                            index = (index + (((clipOutputCount + 1) | 0))) | 0;
                        } else {
                            var clippedVerticesItems1 = clippedVertices.Resize(((s + 6) | 0)).Items;
                            var clippedUVsItems1 = this.clippedUVs.Resize(((s + 6) | 0)).Items;
                            clippedVerticesItems1[s] = x1;
                            clippedVerticesItems1[((s + 1) | 0)] = y1;
                            clippedVerticesItems1[((s + 2) | 0)] = x2;
                            clippedVerticesItems1[((s + 3) | 0)] = y2;
                            clippedVerticesItems1[((s + 4) | 0)] = x3;
                            clippedVerticesItems1[((s + 5) | 0)] = y3;

                            clippedUVsItems1[s] = u1;
                            clippedUVsItems1[((s + 1) | 0)] = v1;
                            clippedUVsItems1[((s + 2) | 0)] = u2;
                            clippedUVsItems1[((s + 3) | 0)] = v2;
                            clippedUVsItems1[((s + 4) | 0)] = u3;
                            clippedUVsItems1[((s + 5) | 0)] = v3;

                            s = clippedTriangles.Count;
                            var clippedTrianglesItems1 = clippedTriangles.Resize(((s + 3) | 0)).Items;
                            clippedTrianglesItems1[s] = index;
                            clippedTrianglesItems1[((s + 1) | 0)] = (index + 1) | 0;
                            clippedTrianglesItems1[((s + 2) | 0)] = (index + 2) | 0;
                            index = (index + 3) | 0;
                            break;
                        }
                    }
                }
            },
            /*Spine.SkeletonClipping.ClipTriangles$1 end.*/

            /*Spine.SkeletonClipping.Clip start.*/
            /**
             * Clips the input triangle against the convex, clockwise clipping area. If the triangle lies entirely within the clipping
             area, false is returned. The clipping area must duplicate the first vertex at the end of the vertices list.
             *
             * @instance
             * @this Spine.SkeletonClipping
             * @memberof Spine.SkeletonClipping
             * @param   {number}                 x1              
             * @param   {number}                 y1              
             * @param   {number}                 x2              
             * @param   {number}                 y2              
             * @param   {number}                 x3              
             * @param   {number}                 y3              
             * @param   {Spine.ExposedList$1}    clippingArea    
             * @param   {Spine.ExposedList$1}    output
             * @return  {boolean}
             */
            Clip: function (x1, y1, x2, y2, x3, y3, clippingArea, output) {
if ( TRACE ) { TRACE( "Spine.SkeletonClipping#Clip", this ); }

                var originalOutput = output;
                var clipped = false;

                // Avoid copy at the end.
                var input = null;
                if (clippingArea.Count % 4 >= 2) {
                    input = output;
                    output = this.scratch;
                } else {
                    input = this.scratch;
                }

                input.Clear();
                input.Add(x1);
                input.Add(y1);
                input.Add(x2);
                input.Add(y2);
                input.Add(x3);
                input.Add(y3);
                input.Add(x1);
                input.Add(y1);
                output.Clear();

                var clippingVerticesLast = (clippingArea.Count - 4) | 0;
                var clippingVertices = clippingArea.Items;
                for (var i = 0; ; i = (i + 2) | 0) {
                    var edgeX = clippingVertices[i], edgeY = clippingVertices[((i + 1) | 0)];
                    var ex = edgeX - clippingVertices[((i + 2) | 0)], ey = edgeY - clippingVertices[((i + 3) | 0)];

                    var outputStart = output.Count;
                    var inputVertices = input.Items;
                    for (var ii = 0, nn = (input.Count - 2) | 0; ii < nn; ) {

                        var inputX = inputVertices[ii], inputY = inputVertices[((ii + 1) | 0)];
                        ii = (ii + 2) | 0;
                        var inputX2 = inputVertices[ii], inputY2 = inputVertices[((ii + 1) | 0)];
                        var s2 = ey * (edgeX - inputX2) > ex * (edgeY - inputY2);
                        var s1 = ey * (edgeX - inputX) - ex * (edgeY - inputY);
                        if (s1 > 0) {
                            if (s2) { // v1 inside, v2 inside
                                output.Add(inputX2);
                                output.Add(inputY2);
                                continue;
                            }
                            // v1 inside, v2 outside
                            var ix = inputX2 - inputX, iy = inputY2 - inputY, t = s1 / (ix * ey - iy * ex);
                            if (t >= 0 && t <= 1) {
                                output.Add(inputX + ix * t);
                                output.Add(inputY + iy * t);
                            } else {
                                output.Add(inputX2);
                                output.Add(inputY2);
                                continue;
                            }
                        } else if (s2) { // v1 outside, v2 inside
                            var ix1 = inputX2 - inputX, iy1 = inputY2 - inputY, t1 = s1 / (ix1 * ey - iy1 * ex);
                            if (t1 >= 0 && t1 <= 1) {
                                output.Add(inputX + ix1 * t1);
                                output.Add(inputY + iy1 * t1);
                                output.Add(inputX2);
                                output.Add(inputY2);
                            } else {
                                output.Add(inputX2);
                                output.Add(inputY2);
                                continue;
                            }
                        }
                        clipped = true;
                    }

                    if (outputStart === output.Count) { // All edges outside.
                        originalOutput.Clear();
                        return true;
                    }

                    output.Add(output.Items[0]);
                    output.Add(output.Items[1]);

                    if (i === clippingVerticesLast) {
                        break;
                    }
                    var temp = output;
                    output = input;
                    output.Clear();
                    input = temp;
                }

                if (!Bridge.referenceEquals(originalOutput, output)) {
                    originalOutput.Clear();
                    for (var i1 = 0, n = (output.Count - 2) | 0; i1 < n; i1 = (i1 + 1) | 0) {
                        originalOutput.Add(output.Items[i1]);
                    }
                } else {
                    originalOutput.Resize(((originalOutput.Count - 2) | 0));
                }

                return clipped;
            },
            /*Spine.SkeletonClipping.Clip end.*/


        },
        overloads: {
            "ClipEnd(Slot)": "ClipEnd$1",
            "ClipTriangles(float[], int[], int, float[])": "ClipTriangles$1"
        }
    });
    /*Spine.SkeletonClipping end.*/

    /*Spine.SkeletonData start.*/
    /**
     * Stores the setup pose and all of the stateless data for a skeleton.
     *
     * @public
     * @class Spine.SkeletonData
     */
    Bridge.define("Spine.SkeletonData", {
        fields: {
            name: null,
            bones: null,
            slots: null,
            skins: null,
            defaultSkin: null,
            events: null,
            animations: null,
            ikConstraints: null,
            transformConstraints: null,
            pathConstraints: null,
            physicsConstraints: null,
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            referenceScale: 0,
            version: null,
            hash: null,
            fps: 0,
            imagesPath: null,
            audioPath: null
        },
        props: {
            /**
             * The skeleton's name, which by default is the name of the skeleton data file when possible, or null when a name hasn't been
             set.
             *
             * @instance
             * @public
             * @memberof Spine.SkeletonData
             * @function Name
             * @type string
             */
            Name: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Name#get", this ); }

                    return this.name;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Name#set", this ); }

                    this.name = value;
                }
            },
            /**
             * The skeleton's bones, sorted parent first. The root bone is always the first bone.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.SkeletonData
             * @function Bones
             * @type Spine.ExposedList$1
             */
            Bones: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Bones#get", this ); }

                    return this.bones;
                }
            },
            /**
             * The skeleton's slots in the setup pose draw order.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.SkeletonData
             * @function Slots
             * @type Spine.ExposedList$1
             */
            Slots: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Slots#get", this ); }

                    return this.slots;
                }
            },
            /**
             * All skins, including the default skin.
             *
             * @instance
             * @public
             * @memberof Spine.SkeletonData
             * @function Skins
             * @type Spine.ExposedList$1
             */
            Skins: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Skins#get", this ); }

                    return this.skins;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Skins#set", this ); }

                    this.skins = value;
                }
            },
            /**
             * The skeleton's default skin.
             By default this skin contains all attachments that were not in a skin in Spine.
             *
             * @instance
             * @public
             * @memberof Spine.SkeletonData
             * @function DefaultSkin
             * @type Spine.Skin
             */
            DefaultSkin: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#DefaultSkin#get", this ); }

                    return this.defaultSkin;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#DefaultSkin#set", this ); }

                    this.defaultSkin = value;
                }
            },
            /**
             * The skeleton's events.
             *
             * @instance
             * @public
             * @memberof Spine.SkeletonData
             * @function Events
             * @type Spine.ExposedList$1
             */
            Events: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Events#get", this ); }

                    return this.events;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Events#set", this ); }

                    this.events = value;
                }
            },
            /**
             * The skeleton's animations.
             *
             * @instance
             * @public
             * @memberof Spine.SkeletonData
             * @function Animations
             * @type Spine.ExposedList$1
             */
            Animations: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Animations#get", this ); }

                    return this.animations;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Animations#set", this ); }

                    this.animations = value;
                }
            },
            /**
             * The skeleton's IK constraints.
             *
             * @instance
             * @public
             * @memberof Spine.SkeletonData
             * @function IkConstraints
             * @type Spine.ExposedList$1
             */
            IkConstraints: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#IkConstraints#get", this ); }

                    return this.ikConstraints;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#IkConstraints#set", this ); }

                    this.ikConstraints = value;
                }
            },
            /**
             * The skeleton's transform constraints.
             *
             * @instance
             * @public
             * @memberof Spine.SkeletonData
             * @function TransformConstraints
             * @type Spine.ExposedList$1
             */
            TransformConstraints: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#TransformConstraints#get", this ); }

                    return this.transformConstraints;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#TransformConstraints#set", this ); }

                    this.transformConstraints = value;
                }
            },
            /**
             * The skeleton's path constraints.
             *
             * @instance
             * @public
             * @memberof Spine.SkeletonData
             * @function PathConstraints
             * @type Spine.ExposedList$1
             */
            PathConstraints: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#PathConstraints#get", this ); }

                    return this.pathConstraints;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#PathConstraints#set", this ); }

                    this.pathConstraints = value;
                }
            },
            /**
             * The skeleton's physics constraints.
             *
             * @instance
             * @public
             * @memberof Spine.SkeletonData
             * @function PhysicsConstraints
             * @type Spine.ExposedList$1
             */
            PhysicsConstraints: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#PhysicsConstraints#get", this ); }

                    return this.physicsConstraints;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#PhysicsConstraints#set", this ); }

                    this.physicsConstraints = value;
                }
            },
            X: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#X#get", this ); }

                    return this.x;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#X#set", this ); }

                    this.x = value;
                }
            },
            Y: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Y#get", this ); }

                    return this.y;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Y#set", this ); }

                    this.y = value;
                }
            },
            Width: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Width#get", this ); }

                    return this.width;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Width#set", this ); }

                    this.width = value;
                }
            },
            Height: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Height#get", this ); }

                    return this.height;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Height#set", this ); }

                    this.height = value;
                }
            },
            /**
             * Baseline scale factor for applying distance-dependent effects on non-scalable properties, such as angle or scale. Default
             is 100.
             *
             * @instance
             * @public
             * @memberof Spine.SkeletonData
             * @function ReferenceScale
             * @type number
             */
            ReferenceScale: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#ReferenceScale#get", this ); }

                    return this.referenceScale;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#ReferenceScale#set", this ); }

                    this.referenceScale = value;
                }
            },
            /**
             * The Spine version used to export this data, or null.
             *
             * @instance
             * @public
             * @memberof Spine.SkeletonData
             * @function Version
             * @type string
             */
            Version: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Version#get", this ); }

                    return this.version;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Version#set", this ); }

                    this.version = value;
                }
            },
            /**
             * The skeleton data hash. This value will change if any of the skeleton data has changed.
             May be null.
             *
             * @instance
             * @public
             * @memberof Spine.SkeletonData
             * @function Hash
             * @type string
             */
            Hash: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Hash#get", this ); }

                    return this.hash;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Hash#set", this ); }

                    this.hash = value;
                }
            },
            ImagesPath: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#ImagesPath#get", this ); }

                    return this.imagesPath;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#ImagesPath#set", this ); }

                    this.imagesPath = value;
                }
            },
            /**
             * The path to the audio directory as defined in Spine. Available only when nonessential data was exported.
             May be null.
             *
             * @instance
             * @public
             * @memberof Spine.SkeletonData
             * @function AudioPath
             * @type string
             */
            AudioPath: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#AudioPath#get", this ); }

                    return this.audioPath;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#AudioPath#set", this ); }

                    this.audioPath = value;
                }
            },
            /**
             * The dopesheet FPS in Spine, or zero if nonessential data was not exported.
             *
             * @instance
             * @public
             * @memberof Spine.SkeletonData
             * @function Fps
             * @type number
             */
            Fps: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Fps#get", this ); }

                    return this.fps;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Fps#set", this ); }

                    this.fps = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#init", this ); }

                this.bones = new (Spine.ExposedList$1(Spine.BoneData)).ctor();
                this.slots = new (Spine.ExposedList$1(Spine.SlotData)).ctor();
                this.skins = new (Spine.ExposedList$1(Spine.Skin)).ctor();
                this.events = new (Spine.ExposedList$1(Spine.EventData)).ctor();
                this.animations = new (Spine.ExposedList$1(Spine.Animation)).ctor();
                this.ikConstraints = new (Spine.ExposedList$1(Spine.IkConstraintData)).ctor();
                this.transformConstraints = new (Spine.ExposedList$1(Spine.TransformConstraintData)).ctor();
                this.pathConstraints = new (Spine.ExposedList$1(Spine.PathConstraintData)).ctor();
                this.physicsConstraints = new (Spine.ExposedList$1(Spine.PhysicsConstraintData)).ctor();
                this.referenceScale = 100;
            }
        },
        methods: {
            /*Spine.SkeletonData.FindBone start.*/
            /**
             * Finds a bone by comparing each bone's name.
             It is more efficient to cache the results of this method than to call it multiple times.
             *
             * @instance
             * @public
             * @this Spine.SkeletonData
             * @memberof Spine.SkeletonData
             * @param   {string}            boneName
             * @return  {Spine.BoneData}                May be null.
             */
            FindBone: function (boneName) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#FindBone", this ); }

                if (boneName == null) {
                    throw new System.ArgumentNullException.$ctor3("boneName", "boneName cannot be null.");
                }
                var bones = this.bones.Items;
                for (var i = 0, n = this.bones.Count; i < n; i = (i + 1) | 0) {
                    var bone = bones[i];
                    if (Bridge.referenceEquals(bone.name, boneName)) {
                        return bone;
                    }
                }
                return null;
            },
            /*Spine.SkeletonData.FindBone end.*/

            /*Spine.SkeletonData.FindSlot start.*/
            /**
             * @instance
             * @public
             * @this Spine.SkeletonData
             * @memberof Spine.SkeletonData
             * @param   {string}            slotName
             * @return  {Spine.SlotData}                May be null.
             */
            FindSlot: function (slotName) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#FindSlot", this ); }

                if (slotName == null) {
                    throw new System.ArgumentNullException.$ctor3("slotName", "slotName cannot be null.");
                }
                var slots = this.slots.Items;
                for (var i = 0, n = this.slots.Count; i < n; i = (i + 1) | 0) {
                    var slot = slots[i];
                    if (Bridge.referenceEquals(slot.name, slotName)) {
                        return slot;
                    }
                }
                return null;
            },
            /*Spine.SkeletonData.FindSlot end.*/

            /*Spine.SkeletonData.FindSkin start.*/
            /**
             * @instance
             * @public
             * @this Spine.SkeletonData
             * @memberof Spine.SkeletonData
             * @param   {string}        skinName
             * @return  {Spine.Skin}                May be null.
             */
            FindSkin: function (skinName) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#FindSkin", this ); }

                var $t;
                if (skinName == null) {
                    throw new System.ArgumentNullException.$ctor3("skinName", "skinName cannot be null.");
                }
                $t = Bridge.getEnumerator(this.skins);
                try {
                    while ($t.moveNext()) {
                        var skin = $t.Current;
                        if (Bridge.referenceEquals(skin.name, skinName)) {
                            return skin;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                return null;
            },
            /*Spine.SkeletonData.FindSkin end.*/

            /*Spine.SkeletonData.FindEvent start.*/
            /**
             * @instance
             * @public
             * @this Spine.SkeletonData
             * @memberof Spine.SkeletonData
             * @param   {string}             eventDataName
             * @return  {Spine.EventData}                     May be null.
             */
            FindEvent: function (eventDataName) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#FindEvent", this ); }

                var $t;
                if (eventDataName == null) {
                    throw new System.ArgumentNullException.$ctor3("eventDataName", "eventDataName cannot be null.");
                }
                $t = Bridge.getEnumerator(this.events);
                try {
                    while ($t.moveNext()) {
                        var eventData = $t.Current;
                        if (Bridge.referenceEquals(eventData.name, eventDataName)) {
                            return eventData;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                return null;
            },
            /*Spine.SkeletonData.FindEvent end.*/

            /*Spine.SkeletonData.FindAnimation start.*/
            /**
             * @instance
             * @public
             * @this Spine.SkeletonData
             * @memberof Spine.SkeletonData
             * @param   {string}             animationName
             * @return  {Spine.Animation}                     May be null.
             */
            FindAnimation: function (animationName) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#FindAnimation", this ); }

                if (animationName == null) {
                    throw new System.ArgumentNullException.$ctor3("animationName", "animationName cannot be null.");
                }
                var animations = this.animations.Items;
                for (var i = 0, n = this.animations.Count; i < n; i = (i + 1) | 0) {
                    var animation = animations[i];
                    if (Bridge.referenceEquals(animation.name, animationName)) {
                        return animation;
                    }
                }
                return null;
            },
            /*Spine.SkeletonData.FindAnimation end.*/

            /*Spine.SkeletonData.FindIkConstraint start.*/
            /**
             * @instance
             * @public
             * @this Spine.SkeletonData
             * @memberof Spine.SkeletonData
             * @param   {string}                    constraintName
             * @return  {Spine.IkConstraintData}                      May be null.
             */
            FindIkConstraint: function (constraintName) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#FindIkConstraint", this ); }

                if (constraintName == null) {
                    throw new System.ArgumentNullException.$ctor3("constraintName", "constraintName cannot be null.");
                }
                var ikConstraints = this.ikConstraints.Items;
                for (var i = 0, n = this.ikConstraints.Count; i < n; i = (i + 1) | 0) {
                    var ikConstraint = ikConstraints[i];
                    if (Bridge.referenceEquals(ikConstraint.name, constraintName)) {
                        return ikConstraint;
                    }
                }
                return null;
            },
            /*Spine.SkeletonData.FindIkConstraint end.*/

            /*Spine.SkeletonData.FindTransformConstraint start.*/
            /**
             * @instance
             * @public
             * @this Spine.SkeletonData
             * @memberof Spine.SkeletonData
             * @param   {string}                           constraintName
             * @return  {Spine.TransformConstraintData}                      May be null.
             */
            FindTransformConstraint: function (constraintName) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#FindTransformConstraint", this ); }

                if (constraintName == null) {
                    throw new System.ArgumentNullException.$ctor3("constraintName", "constraintName cannot be null.");
                }
                var transformConstraints = this.transformConstraints.Items;
                for (var i = 0, n = this.transformConstraints.Count; i < n; i = (i + 1) | 0) {
                    var transformConstraint = transformConstraints[i];
                    if (Bridge.referenceEquals(transformConstraint.name, constraintName)) {
                        return transformConstraint;
                    }
                }
                return null;
            },
            /*Spine.SkeletonData.FindTransformConstraint end.*/

            /*Spine.SkeletonData.FindPathConstraint start.*/
            /**
             * Finds a path constraint by comparing each path constraint's name. It is more efficient to cache the results of this method
             than to call it multiple times.
             *
             * @instance
             * @public
             * @this Spine.SkeletonData
             * @memberof Spine.SkeletonData
             * @param   {string}                      constraintName
             * @return  {Spine.PathConstraintData}                      May be null.
             */
            FindPathConstraint: function (constraintName) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#FindPathConstraint", this ); }

                if (constraintName == null) {
                    throw new System.ArgumentNullException.$ctor3("constraintName", "constraintName cannot be null.");
                }
                var pathConstraints = this.pathConstraints.Items;
                for (var i = 0, n = this.pathConstraints.Count; i < n; i = (i + 1) | 0) {
                    var constraint = pathConstraints[i];
                    if (System.String.equals(constraint.name, constraintName)) {
                        return constraint;
                    }
                }
                return null;
            },
            /*Spine.SkeletonData.FindPathConstraint end.*/

            /*Spine.SkeletonData.FindPhysicsConstraint start.*/
            /**
             * Finds a physics constraint by comparing each physics constraint's name. It is more efficient to cache the results of this
             method than to call it multiple times.
             *
             * @instance
             * @public
             * @this Spine.SkeletonData
             * @memberof Spine.SkeletonData
             * @param   {string}                         constraintName
             * @return  {Spine.PhysicsConstraintData}                      May be null.
             */
            FindPhysicsConstraint: function (constraintName) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#FindPhysicsConstraint", this ); }

                if (constraintName == null) {
                    throw new System.ArgumentNullException.$ctor3("constraintName", "constraintName cannot be null.");
                }
                var physicsConstraints = this.physicsConstraints.Items;
                for (var i = 0, n = this.physicsConstraints.Count; i < n; i = (i + 1) | 0) {
                    var constraint = physicsConstraints[i];
                    if (System.String.equals(constraint.name, constraintName)) {
                        return constraint;
                    }
                }
                return null;
            },
            /*Spine.SkeletonData.FindPhysicsConstraint end.*/

            /*Spine.SkeletonData.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#toString", this ); }

                var $t;
                return ($t = this.name, $t != null ? $t : Bridge.toString(this));
            },
            /*Spine.SkeletonData.toString end.*/


        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.SkeletonData end.*/

    /*Spine.SkeletonJson+LinkedMesh start.*/
    Bridge.define("Spine.SkeletonJson.LinkedMesh", {
        $kind: 1002,
        fields: {
            parent: null,
            skin: null,
            slotIndex: 0,
            mesh: null,
            inheritTimelines: false
        },
        ctors: {
            ctor: function (mesh, skin, slotIndex, parent, inheritTimelines) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson.LinkedMesh#ctor", this ); }

                this.$initialize();
                this.mesh = mesh;
                this.skin = skin;
                this.slotIndex = slotIndex;
                this.parent = parent;
                this.inheritTimelines = inheritTimelines;
            }
        }
    });
    /*Spine.SkeletonJson+LinkedMesh end.*/

    /*Spine.Skin start.*/
    /**
     * Stores attachments by slot index and attachment name.
     <p>See SkeletonData {@link }, Skeleton {@link }, and
     <a href="http://esotericsoftware.com/spine-runtime-skins">Runtime skins</a> in the Spine Runtimes Guide.</p>
     *
     * @public
     * @class Spine.Skin
     */
    Bridge.define("Spine.Skin", {
        fields: {
            name: null,
            attachments: null,
            bones: null,
            constraints: null
        },
        props: {
            Name: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skin#Name#get", this ); }

                    return this.name;
                }
            },
            /**
             * Returns all attachments contained in this skin.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Skin
             * @function Attachments
             * @type System.Collections.Generic.ICollection$1
             */
            Attachments: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skin#Attachments#get", this ); }

                    return this.attachments.Values;
                }
            },
            Bones: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skin#Bones#get", this ); }

                    return this.bones;
                }
            },
            Constraints: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skin#Constraints#get", this ); }

                    return this.constraints;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Skin#init", this ); }

                this.attachments = new (System.Collections.Generic.Dictionary$2(Spine.Skin.SkinKey,Spine.Skin.SkinEntry)).$ctor3(Spine.Skin.SkinKeyComparer.Instance);
                this.bones = new (Spine.ExposedList$1(Spine.BoneData)).ctor();
                this.constraints = new (Spine.ExposedList$1(Spine.ConstraintData)).ctor();
            },
            ctor: function (name) {
if ( TRACE ) { TRACE( "Spine.Skin#ctor", this ); }

                this.$initialize();
                if (name == null) {
                    throw new System.ArgumentNullException.$ctor3("name", "name cannot be null.");
                }
                this.name = name;
            }
        },
        methods: {
            /*Spine.Skin.SetAttachment start.*/
            /**
             * Adds an attachment to the skin for the specified slot index and name.
             If the name already exists for the slot, the previous value is replaced.
             *
             * @instance
             * @public
             * @this Spine.Skin
             * @memberof Spine.Skin
             * @param   {number}              slotIndex     
             * @param   {string}              name          
             * @param   {Spine.Attachment}    attachment
             * @return  {void}
             */
            SetAttachment: function (slotIndex, name, attachment) {
if ( TRACE ) { TRACE( "Spine.Skin#SetAttachment", this ); }

                if (attachment == null) {
                    throw new System.ArgumentNullException.$ctor3("attachment", "attachment cannot be null.");
                }
                this.attachments.setItem(new Spine.Skin.SkinKey.$ctor1(slotIndex, name), new Spine.Skin.SkinEntry.$ctor1(slotIndex, name, attachment));
            },
            /*Spine.Skin.SetAttachment end.*/

            /*Spine.Skin.AddSkin start.*/
            /**
             * Adds all attachments, bones, and constraints from the specified skin to this skin.
             *
             * @instance
             * @public
             * @this Spine.Skin
             * @memberof Spine.Skin
             * @param   {Spine.Skin}    skin
             * @return  {void}
             */
            AddSkin: function (skin) {
if ( TRACE ) { TRACE( "Spine.Skin#AddSkin", this ); }

                var $t, $t1, $t2;
                $t = Bridge.getEnumerator(skin.bones);
                try {
                    while ($t.moveNext()) {
                        var data = $t.Current;
                        if (!this.bones.Contains(data)) {
                            this.bones.Add(data);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                $t1 = Bridge.getEnumerator(skin.constraints);
                try {
                    while ($t1.moveNext()) {
                        var data1 = $t1.Current;
                        if (!this.constraints.Contains(data1)) {
                            this.constraints.Add(data1);
                        }
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }

                $t2 = Bridge.getEnumerator(skin.attachments);
                try {
                    while ($t2.moveNext()) {
                        var item = $t2.Current;
                        var entry = item.value;
                        this.SetAttachment(entry.slotIndex, entry.name, entry.attachment);
                    }
                } finally {
                    if (Bridge.is($t2, System.IDisposable)) {
                        $t2.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Skin.AddSkin end.*/

            /*Spine.Skin.CopySkin start.*/
            /**
             * Adds all attachments from the specified skin to this skin. Attachments are deep copied.
             *
             * @instance
             * @public
             * @this Spine.Skin
             * @memberof Spine.Skin
             * @param   {Spine.Skin}    skin
             * @return  {void}
             */
            CopySkin: function (skin) {
if ( TRACE ) { TRACE( "Spine.Skin#CopySkin", this ); }

                var $t, $t1, $t2;
                $t = Bridge.getEnumerator(skin.bones);
                try {
                    while ($t.moveNext()) {
                        var data = $t.Current;
                        if (!this.bones.Contains(data)) {
                            this.bones.Add(data);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                $t1 = Bridge.getEnumerator(skin.constraints);
                try {
                    while ($t1.moveNext()) {
                        var data1 = $t1.Current;
                        if (!this.constraints.Contains(data1)) {
                            this.constraints.Add(data1);
                        }
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }

                $t2 = Bridge.getEnumerator(skin.attachments);
                try {
                    while ($t2.moveNext()) {
                        var item = $t2.Current;
                        var entry = item.value;
                        if (Bridge.is(entry.attachment, Spine.MeshAttachment)) {
                            this.SetAttachment(entry.slotIndex, entry.name, entry.attachment != null ? Bridge.cast(entry.attachment, Spine.MeshAttachment).NewLinkedMesh() : null);
                        } else {
                            this.SetAttachment(entry.slotIndex, entry.name, entry.attachment != null ? entry.attachment.Copy() : null);
                        }
                    }
                } finally {
                    if (Bridge.is($t2, System.IDisposable)) {
                        $t2.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Skin.CopySkin end.*/

            /*Spine.Skin.GetAttachment start.*/
            /**
             * Returns the attachment for the specified slot index and name, or null.
             *
             * @instance
             * @public
             * @this Spine.Skin
             * @memberof Spine.Skin
             * @param   {number}              slotIndex    
             * @param   {string}              name
             * @return  {Spine.Attachment}                 May be null.
             */
            GetAttachment: function (slotIndex, name) {
if ( TRACE ) { TRACE( "Spine.Skin#GetAttachment", this ); }

                var entry = { v : new Spine.Skin.SkinEntry() };
                var containsKey = this.attachments.tryGetValue(new Spine.Skin.SkinKey.$ctor1(slotIndex, name), entry);
                return containsKey ? entry.v.attachment : null;
            },
            /*Spine.Skin.GetAttachment end.*/

            /*Spine.Skin.RemoveAttachment start.*/
            /**
             * Removes the attachment in the skin for the specified slot index and name, if any.
             *
             * @instance
             * @public
             * @this Spine.Skin
             * @memberof Spine.Skin
             * @param   {number}    slotIndex    
             * @param   {string}    name
             * @return  {void}
             */
            RemoveAttachment: function (slotIndex, name) {
if ( TRACE ) { TRACE( "Spine.Skin#RemoveAttachment", this ); }

                this.attachments.remove(new Spine.Skin.SkinKey.$ctor1(slotIndex, name));
            },
            /*Spine.Skin.RemoveAttachment end.*/

            /*Spine.Skin.GetAttachments start.*/
            
            GetAttachments: function (slotIndex, attachments) {
if ( TRACE ) { TRACE( "Spine.Skin#GetAttachments", this ); }

                var $t;
                if (slotIndex < 0) {
                    throw new System.ArgumentException.$ctor1("slotIndex must be >= 0.");
                }
                if (attachments == null) {
                    throw new System.ArgumentNullException.$ctor3("attachments", "attachments cannot be null.");
                }
                $t = Bridge.getEnumerator(this.attachments);
                try {
                    while ($t.moveNext()) {
                        var item = $t.Current;
                        var entry = item.value;
                        if (entry.slotIndex === slotIndex) {
                            attachments.add(entry);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Skin.GetAttachments end.*/

            /*Spine.Skin.Clear start.*/
            /**
             * Clears all attachments, bones, and constraints.
             *
             * @instance
             * @public
             * @this Spine.Skin
             * @memberof Spine.Skin
             * @return  {void}
             */
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Skin#Clear", this ); }

                this.attachments.clear();
                this.bones.Clear();
                this.constraints.Clear();
            },
            /*Spine.Skin.Clear end.*/

            /*Spine.Skin.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.Skin#toString", this ); }

                return this.name;
            },
            /*Spine.Skin.toString end.*/

            /*Spine.Skin.AttachAll start.*/
            /**
             * Attach all attachments from this skin if the corresponding attachment from the old skin is currently attached.
             *
             * @instance
             * @this Spine.Skin
             * @memberof Spine.Skin
             * @param   {Spine.Skeleton}    skeleton    
             * @param   {Spine.Skin}        oldSkin
             * @return  {void}
             */
            AttachAll: function (skeleton, oldSkin) {
if ( TRACE ) { TRACE( "Spine.Skin#AttachAll", this ); }

                var $t;
                var slots = skeleton.slots.Items;
                $t = Bridge.getEnumerator(oldSkin.attachments);
                try {
                    while ($t.moveNext()) {
                        var item = $t.Current;
                        var entry = item.value;
                        var slotIndex = entry.slotIndex;
                        var slot = slots[slotIndex];
                        if (Bridge.referenceEquals(slot.Attachment, entry.attachment)) {
                            var attachment = this.GetAttachment(slotIndex, entry.name);
                            if (attachment != null) {
                                slot.Attachment = attachment;
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Skin.AttachAll end.*/


        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.Skin end.*/

    /*Spine.Skin+SkinEntry start.*/
    /**
     * Stores an entry in the skin consisting of the slot index, name, and attachment.
     *
     * @public
     * @class Spine.Skin.SkinEntry
     */
    Bridge.define("Spine.Skin.SkinEntry", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Skin.SkinEntry#getDefaultValue", this ); }
 return new Spine.Skin.SkinEntry(); }
            }
        },
        fields: {
            slotIndex: 0,
            name: null,
            attachment: null
        },
        props: {
            SlotIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skin.SkinEntry#SlotIndex#get", this ); }

                    return this.slotIndex;
                }
            },
            /**
             * The name the attachment is associated with, equivalent to the skin placeholder name in the Spine editor.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Skin.SkinEntry
             * @function Name
             * @type string
             */
            Name: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skin.SkinEntry#Name#get", this ); }

                    return this.name;
                }
            },
            Attachment: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skin.SkinEntry#Attachment#get", this ); }

                    return this.attachment;
                }
            }
        },
        ctors: {
            $ctor1: function (slotIndex, name, attachment) {
if ( TRACE ) { TRACE( "Spine.Skin.SkinEntry#$ctor1", this ); }

                this.$initialize();
                this.slotIndex = slotIndex;
                this.name = name;
                this.attachment = attachment;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Skin.SkinEntry#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Skin.SkinEntry#getHashCode", this ); }

                var h = Bridge.addHash([3772635665, this.slotIndex, this.name, this.attachment]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Skin.SkinEntry#equals", this ); }

                if (!Bridge.is(o, Spine.Skin.SkinEntry)) {
                    return false;
                }
                return Bridge.equals(this.slotIndex, o.slotIndex) && Bridge.equals(this.name, o.name) && Bridge.equals(this.attachment, o.attachment);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Skin.SkinEntry#$clone", this ); }

                var s = to || new Spine.Skin.SkinEntry();
                s.slotIndex = this.slotIndex;
                s.name = this.name;
                s.attachment = this.attachment;
                return s;
            }
        }
    });
    /*Spine.Skin+SkinEntry end.*/

    /*Spine.Skin+SkinKey start.*/
    Bridge.define("Spine.Skin.SkinKey", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Skin.SkinKey#getDefaultValue", this ); }
 return new Spine.Skin.SkinKey(); }
            }
        },
        fields: {
            slotIndex: 0,
            name: null,
            hashCode: 0
        },
        ctors: {
            $ctor1: function (slotIndex, name) {
if ( TRACE ) { TRACE( "Spine.Skin.SkinKey#$ctor1", this ); }

                this.$initialize();
                if (slotIndex < 0) {
                    throw new System.ArgumentException.$ctor1("slotIndex must be >= 0.");
                }
                if (name == null) {
                    throw new System.ArgumentNullException.$ctor3("name", "name cannot be null");
                }
                this.slotIndex = slotIndex;
                this.name = name;
                this.hashCode = (Bridge.getHashCode(name) + Bridge.Int.mul(slotIndex, 37)) | 0;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Skin.SkinKey#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Skin.SkinKey#getHashCode", this ); }

                var h = Bridge.addHash([1860358302, this.slotIndex, this.name, this.hashCode]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Skin.SkinKey#equals", this ); }

                if (!Bridge.is(o, Spine.Skin.SkinKey)) {
                    return false;
                }
                return Bridge.equals(this.slotIndex, o.slotIndex) && Bridge.equals(this.name, o.name) && Bridge.equals(this.hashCode, o.hashCode);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Skin.SkinKey#$clone", this ); }

                var s = to || new Spine.Skin.SkinKey();
                s.slotIndex = this.slotIndex;
                s.name = this.name;
                s.hashCode = this.hashCode;
                return s;
            }
        }
    });
    /*Spine.Skin+SkinKey end.*/

    /*Spine.Slot start.*/
    /**
     * Stores a slot's current pose. Slots organize attachments for {@link } purposes and provide a place to store
     state for an attachment.State cannot be stored in an attachment itself because attachments are stateless and may be shared
     across multiple skeletons.
     *
     * @public
     * @class Spine.Slot
     */
    Bridge.define("Spine.Slot", {
        fields: {
            data: null,
            bone: null,
            r: 0,
            g: 0,
            b: 0,
            a: 0,
            r2: 0,
            g2: 0,
            b2: 0,
            hasSecondColor: false,
            attachment: null,
            sequenceIndex: 0,
            deform: null,
            attachmentState: 0
        },
        props: {
            /**
             * The slot's setup pose data.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Slot
             * @function Data
             * @type Spine.SlotData
             */
            Data: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Slot#Data#get", this ); }

                    return this.data;
                }
            },
            /**
             * The bone this slot belongs to.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Slot
             * @function Bone
             * @type Spine.Bone
             */
            Bone: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Slot#Bone#get", this ); }

                    return this.bone;
                }
            },
            /**
             * The skeleton this slot belongs to.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Slot
             * @function Skeleton
             * @type Spine.Skeleton
             */
            Skeleton: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Slot#Skeleton#get", this ); }

                    return this.bone.skeleton;
                }
            },
            /**
             * The color used to tint the slot's attachment. If {@link } is set, this is used as the light color for two
             color tinting.
             *
             * @instance
             * @public
             * @memberof Spine.Slot
             * @function R
             * @type number
             */
            R: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Slot#R#get", this ); }

                    return this.r;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Slot#R#set", this ); }

                    this.r = value;
                }
            },
            /**
             * The color used to tint the slot's attachment. If {@link } is set, this is used as the light color for two
             color tinting.
             *
             * @instance
             * @public
             * @memberof Spine.Slot
             * @function G
             * @type number
             */
            G: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Slot#G#get", this ); }

                    return this.g;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Slot#G#set", this ); }

                    this.g = value;
                }
            },
            /**
             * The color used to tint the slot's attachment. If {@link } is set, this is used as the light color for two
             color tinting.
             *
             * @instance
             * @public
             * @memberof Spine.Slot
             * @function B
             * @type number
             */
            B: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Slot#B#get", this ); }

                    return this.b;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Slot#B#set", this ); }

                    this.b = value;
                }
            },
            /**
             * The color used to tint the slot's attachment. If {@link } is set, this is used as the light color for two
             color tinting.
             *
             * @instance
             * @public
             * @memberof Spine.Slot
             * @function A
             * @type number
             */
            A: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Slot#A#get", this ); }

                    return this.a;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Slot#A#set", this ); }

                    this.a = value;
                }
            },
            /**
             * The dark color used to tint the slot's attachment for two color tinting, ignored if two color tinting is not used.
             *
             * @instance
             * @public
             * @memberof Spine.Slot
             * @function R2
             * @type number
             * @see {@link HasSecondColor}
             */
            R2: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Slot#R2#get", this ); }

                    return this.r2;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Slot#R2#set", this ); }

                    this.r2 = value;
                }
            },
            /**
             * The dark color used to tint the slot's attachment for two color tinting, ignored if two color tinting is not used.
             *
             * @instance
             * @public
             * @memberof Spine.Slot
             * @function G2
             * @type number
             * @see {@link HasSecondColor}
             */
            G2: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Slot#G2#get", this ); }

                    return this.g2;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Slot#G2#set", this ); }

                    this.g2 = value;
                }
            },
            /**
             * The dark color used to tint the slot's attachment for two color tinting, ignored if two color tinting is not used.
             *
             * @instance
             * @public
             * @memberof Spine.Slot
             * @function B2
             * @type number
             * @see {@link HasSecondColor}
             */
            B2: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Slot#B2#get", this ); }

                    return this.b2;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Slot#B2#set", this ); }

                    this.b2 = value;
                }
            },
            /**
             * Whether R2 G2 B2 are used to tint the slot's attachment for two color tinting. False if two color tinting is not used.
             *
             * @instance
             * @public
             * @memberof Spine.Slot
             * @function HasSecondColor
             * @type boolean
             */
            HasSecondColor: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Slot#HasSecondColor#get", this ); }

                    return this.data.hasSecondColor;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Slot#HasSecondColor#set", this ); }

                    this.data.hasSecondColor = value;
                }
            },
            Attachment: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Slot#Attachment#get", this ); }

                    return this.attachment;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Slot#Attachment#set", this ); }

                    if (Bridge.referenceEquals(this.attachment, value)) {
                        return;
                    }
                    if (!(Bridge.is(value, Spine.VertexAttachment)) || !(Bridge.is(this.attachment, Spine.VertexAttachment)) || !Bridge.referenceEquals(Bridge.cast(value, Spine.VertexAttachment).TimelineAttachment, Bridge.cast(this.attachment, Spine.VertexAttachment).TimelineAttachment)) {
                        this.deform.Clear();
                    }
                    this.attachment = value;
                    this.sequenceIndex = -1;
                }
            },
            /**
             * The index of the texture region to display when the slot's attachment has a {@link }. -1 represents the
             {@link }.
             *
             * @instance
             * @public
             * @memberof Spine.Slot
             * @function SequenceIndex
             * @type number
             */
            SequenceIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Slot#SequenceIndex#get", this ); }

                    return this.sequenceIndex;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Slot#SequenceIndex#set", this ); }

                    this.sequenceIndex = value;
                }
            },
            /**
             * Vertices to deform the slot's attachment. For an unweighted mesh, the entries are local positions for each vertex. For a
             weighted mesh, the entries are an offset for each vertex which will be added to the mesh's local vertex positions.
             <p />
             See {@link } and {@link }.
             *
             * @instance
             * @public
             * @memberof Spine.Slot
             * @function Deform
             * @type Spine.ExposedList$1
             */
            Deform: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Slot#Deform#get", this ); }

                    return this.deform;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Slot#Deform#set", this ); }

                    if (this.deform == null) {
                        throw new System.ArgumentNullException.$ctor3("deform", "deform cannot be null.");
                    }
                    this.deform = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Slot#init", this ); }

                this.deform = new (Spine.ExposedList$1(System.Single)).ctor();
            },
            $ctor1: function (data, bone) {
if ( TRACE ) { TRACE( "Spine.Slot#$ctor1", this ); }

                this.$initialize();
                if (data == null) {
                    throw new System.ArgumentNullException.$ctor3("data", "data cannot be null.");
                }
                if (bone == null) {
                    throw new System.ArgumentNullException.$ctor3("bone", "bone cannot be null.");
                }
                this.data = data;
                this.bone = bone;

                // darkColor = data.darkColor == null ? null : new Color();
                if (data.hasSecondColor) {
                    this.r2 = (this.g2 = (this.b2 = 0));
                }

                this.SetToSetupPose();
            },
            /**
             * Copy constructor.
             *
             * @instance
             * @public
             * @this Spine.Slot
             * @memberof Spine.Slot
             * @param   {Spine.Slot}    slot    
             * @param   {Spine.Bone}    bone
             * @return  {void}
             */
            ctor: function (slot, bone) {
if ( TRACE ) { TRACE( "Spine.Slot#ctor", this ); }

                this.$initialize();
                if (slot == null) {
                    throw new System.ArgumentNullException.$ctor3("slot", "slot cannot be null.");
                }
                if (bone == null) {
                    throw new System.ArgumentNullException.$ctor3("bone", "bone cannot be null.");
                }
                this.data = slot.data;
                this.bone = bone;
                this.r = slot.r;
                this.g = slot.g;
                this.b = slot.b;
                this.a = slot.a;

                // darkColor = slot.darkColor == null ? null : new Color(slot.darkColor);
                if (slot.hasSecondColor) {
                    this.r2 = slot.r2;
                    this.g2 = slot.g2;
                    this.b2 = slot.b2;
                } else {
                    this.r2 = (this.g2 = (this.b2 = 0));
                }
                this.hasSecondColor = slot.hasSecondColor;

                this.attachment = slot.attachment;
                this.sequenceIndex = slot.sequenceIndex;
                this.deform.AddRange(slot.deform);
            }
        },
        methods: {
            /*Spine.Slot.ClampColor start.*/
            ClampColor: function () {
if ( TRACE ) { TRACE( "Spine.Slot#ClampColor", this ); }

                this.r = Spine.MathUtils.Clamp(this.r, 0, 1);
                this.g = Spine.MathUtils.Clamp(this.g, 0, 1);
                this.b = Spine.MathUtils.Clamp(this.b, 0, 1);
                this.a = Spine.MathUtils.Clamp(this.a, 0, 1);
            },
            /*Spine.Slot.ClampColor end.*/

            /*Spine.Slot.ClampSecondColor start.*/
            ClampSecondColor: function () {
if ( TRACE ) { TRACE( "Spine.Slot#ClampSecondColor", this ); }

                this.r2 = Spine.MathUtils.Clamp(this.r2, 0, 1);
                this.g2 = Spine.MathUtils.Clamp(this.g2, 0, 1);
                this.b2 = Spine.MathUtils.Clamp(this.b2, 0, 1);
            },
            /*Spine.Slot.ClampSecondColor end.*/

            /*Spine.Slot.SetToSetupPose start.*/
            /**
             * Sets this slot to the setup pose.
             *
             * @instance
             * @public
             * @this Spine.Slot
             * @memberof Spine.Slot
             * @return  {void}
             */
            SetToSetupPose: function () {
if ( TRACE ) { TRACE( "Spine.Slot#SetToSetupPose", this ); }

                this.r = this.data.r;
                this.g = this.data.g;
                this.b = this.data.b;
                this.a = this.data.a;

                // if (darkColor != null) darkColor.set(data.darkColor);
                if (this.HasSecondColor) {
                    this.r2 = this.data.r2;
                    this.g2 = this.data.g2;
                    this.b2 = this.data.b2;
                }

                if (this.data.attachmentName == null) {
                    this.Attachment = null;
                } else {
                    this.attachment = null;
                    this.Attachment = this.bone.skeleton.GetAttachment(this.data.index, this.data.attachmentName);
                }
            },
            /*Spine.Slot.SetToSetupPose end.*/

            /*Spine.Slot.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.Slot#toString", this ); }

                return this.data.name;
            },
            /*Spine.Slot.toString end.*/


        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.Slot end.*/

    /*Spine.SlotData start.*/
    Bridge.define("Spine.SlotData", {
        fields: {
            index: 0,
            name: null,
            boneData: null,
            r: 0,
            g: 0,
            b: 0,
            a: 0,
            r2: 0,
            g2: 0,
            b2: 0,
            hasSecondColor: false,
            attachmentName: null,
            blendMode: 0
        },
        props: {
            /**
             * The index of the slot in {@link }.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.SlotData
             * @function Index
             * @type number
             */
            Index: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#Index#get", this ); }

                    return this.index;
                }
            },
            /**
             * The name of the slot, which is unique across all slots in the skeleton.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.SlotData
             * @function Name
             * @type string
             */
            Name: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#Name#get", this ); }

                    return this.name;
                }
            },
            /**
             * The bone this slot belongs to.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.SlotData
             * @function BoneData
             * @type Spine.BoneData
             */
            BoneData: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#BoneData#get", this ); }

                    return this.boneData;
                }
            },
            R: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#R#get", this ); }

                    return this.r;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SlotData#R#set", this ); }

                    this.r = value;
                }
            },
            G: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#G#get", this ); }

                    return this.g;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SlotData#G#set", this ); }

                    this.g = value;
                }
            },
            B: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#B#get", this ); }

                    return this.b;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SlotData#B#set", this ); }

                    this.b = value;
                }
            },
            A: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#A#get", this ); }

                    return this.a;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SlotData#A#set", this ); }

                    this.a = value;
                }
            },
            R2: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#R2#get", this ); }

                    return this.r2;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SlotData#R2#set", this ); }

                    this.r2 = value;
                }
            },
            G2: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#G2#get", this ); }

                    return this.g2;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SlotData#G2#set", this ); }

                    this.g2 = value;
                }
            },
            B2: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#B2#get", this ); }

                    return this.b2;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SlotData#B2#set", this ); }

                    this.b2 = value;
                }
            },
            HasSecondColor: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#HasSecondColor#get", this ); }

                    return this.hasSecondColor;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SlotData#HasSecondColor#set", this ); }

                    this.hasSecondColor = value;
                }
            },
            /**
             * The name of the attachment that is visible for this slot in the setup pose, or null if no attachment is visible.
             *
             * @instance
             * @public
             * @memberof Spine.SlotData
             * @function AttachmentName
             * @type string
             */
            AttachmentName: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#AttachmentName#get", this ); }

                    return this.attachmentName;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SlotData#AttachmentName#set", this ); }

                    this.attachmentName = value;
                }
            },
            /**
             * The blend mode for drawing the slot's attachment.
             *
             * @instance
             * @public
             * @memberof Spine.SlotData
             * @function BlendMode
             * @type Spine.BlendMode
             */
            BlendMode: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#BlendMode#get", this ); }

                    return this.blendMode;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SlotData#BlendMode#set", this ); }

                    this.blendMode = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#init", this ); }

                this.r = 1;
                this.g = 1;
                this.b = 1;
                this.a = 1;
                this.r2 = 0;
                this.g2 = 0;
                this.b2 = 0;
                this.hasSecondColor = false;
            },
            ctor: function (index, name, boneData) {
if ( TRACE ) { TRACE( "Spine.SlotData#ctor", this ); }

                this.$initialize();
                if (index < 0) {
                    throw new System.ArgumentException.$ctor3("index must be >= 0.", "index");
                }
                if (name == null) {
                    throw new System.ArgumentNullException.$ctor3("name", "name cannot be null.");
                }
                if (boneData == null) {
                    throw new System.ArgumentNullException.$ctor3("boneData", "boneData cannot be null.");
                }
                this.index = index;
                this.name = name;
                this.boneData = boneData;
            }
        },
        methods: {
            /*Spine.SlotData.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#toString", this ); }

                return this.name;
            },
            /*Spine.SlotData.toString end.*/


        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.SlotData end.*/

    /*Spine.SpacingMode start.*/
    Bridge.define("Spine.SpacingMode", {
        $kind: 6,
        statics: {
            fields: {
                Length: 0,
                Fixed: 1,
                Percent: 2,
                Proportional: 3
            }
        }
    });
    /*Spine.SpacingMode end.*/

    /*Spine.SpineSkeletonExtensions start.*/
    Bridge.define("Spine.SpineSkeletonExtensions", {
        statics: {
            methods: {
                /*Spine.SpineSkeletonExtensions.IsWeighted:static start.*/
                IsWeighted: function (va) {
if ( TRACE ) { TRACE( "Spine.SpineSkeletonExtensions#IsWeighted", this ); }

                    return va.Bones != null && va.Bones.length > 0;
                },
                /*Spine.SpineSkeletonExtensions.IsWeighted:static end.*/

                /*Spine.SpineSkeletonExtensions.InheritsRotation:static start.*/
                InheritsRotation: function (mode) {
if ( TRACE ) { TRACE( "Spine.SpineSkeletonExtensions#InheritsRotation", this ); }

                    return mode === Spine.Inherit.Normal || mode === Spine.Inherit.NoScale || mode === Spine.Inherit.NoScaleOrReflection;
                },
                /*Spine.SpineSkeletonExtensions.InheritsRotation:static end.*/

                /*Spine.SpineSkeletonExtensions.InheritsScale:static start.*/
                InheritsScale: function (mode) {
if ( TRACE ) { TRACE( "Spine.SpineSkeletonExtensions#InheritsScale", this ); }

                    return mode === Spine.Inherit.Normal || mode === Spine.Inherit.NoRotationOrReflection;
                },
                /*Spine.SpineSkeletonExtensions.InheritsScale:static end.*/


            }
        }
    });
    /*Spine.SpineSkeletonExtensions end.*/

    /*Spine.TextureFilter start.*/
    Bridge.define("Spine.TextureFilter", {
        $kind: 6,
        statics: {
            fields: {
                Nearest: 0,
                Linear: 1,
                MipMap: 2,
                MipMapNearestNearest: 3,
                MipMapLinearNearest: 4,
                MipMapNearestLinear: 5,
                MipMapLinearLinear: 6
            }
        }
    });
    /*Spine.TextureFilter end.*/

    /*Spine.TextureLoader start.*/
    Bridge.define("Spine.TextureLoader", {
        $kind: 3
    });
    /*Spine.TextureLoader end.*/

    /*Spine.TextureWrap start.*/
    Bridge.define("Spine.TextureWrap", {
        $kind: 6,
        statics: {
            fields: {
                MirroredRepeat: 0,
                ClampToEdge: 1,
                Repeat: 2
            }
        }
    });
    /*Spine.TextureWrap end.*/

    /*Spine.Triangulator start.*/
    Bridge.define("Spine.Triangulator", {
        statics: {
            methods: {
                /*Spine.Triangulator.IsConcave:static start.*/
                IsConcave: function (index, vertexCount, vertices, indices) {
if ( TRACE ) { TRACE( "Spine.Triangulator#IsConcave", this ); }

                    var previous = indices[(((((vertexCount + index) | 0) - 1) | 0)) % vertexCount] << 1;
                    var current = indices[index] << 1;
                    var next = indices[(((index + 1) | 0)) % vertexCount] << 1;
                    return !Spine.Triangulator.PositiveArea(vertices[previous], vertices[((previous + 1) | 0)], vertices[current], vertices[((current + 1) | 0)], vertices[next], vertices[((next + 1) | 0)]);
                },
                /*Spine.Triangulator.IsConcave:static end.*/

                /*Spine.Triangulator.PositiveArea:static start.*/
                PositiveArea: function (p1x, p1y, p2x, p2y, p3x, p3y) {
if ( TRACE ) { TRACE( "Spine.Triangulator#PositiveArea", this ); }

                    return p1x * (p3y - p2y) + p2x * (p1y - p3y) + p3x * (p2y - p1y) >= 0;
                },
                /*Spine.Triangulator.PositiveArea:static end.*/

                /*Spine.Triangulator.Winding:static start.*/
                Winding: function (p1x, p1y, p2x, p2y, p3x, p3y) {
if ( TRACE ) { TRACE( "Spine.Triangulator#Winding", this ); }

                    var px = p2x - p1x, py = p2y - p1y;
                    return p3x * py - p3y * px + px * p1y - p1x * py >= 0 ? 1 : -1;
                },
                /*Spine.Triangulator.Winding:static end.*/


            }
        },
        fields: {
            convexPolygons: null,
            convexPolygonsIndices: null,
            indicesArray: null,
            isConcaveArray: null,
            triangles: null,
            polygonPool: null,
            polygonIndicesPool: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Triangulator#init", this ); }

                this.convexPolygons = new (Spine.ExposedList$1(Spine.ExposedList$1(System.Single))).ctor();
                this.convexPolygonsIndices = new (Spine.ExposedList$1(Spine.ExposedList$1(System.Int32))).ctor();
                this.indicesArray = new (Spine.ExposedList$1(System.Int32)).ctor();
                this.isConcaveArray = new (Spine.ExposedList$1(System.Boolean)).ctor();
                this.triangles = new (Spine.ExposedList$1(System.Int32)).ctor();
                this.polygonPool = new (Spine.Pool$1(Spine.ExposedList$1(System.Single)))();
                this.polygonIndicesPool = new (Spine.Pool$1(Spine.ExposedList$1(System.Int32)))();
            }
        },
        methods: {
            /*Spine.Triangulator.Triangulate start.*/
            Triangulate: function (verticesArray) {
if ( TRACE ) { TRACE( "Spine.Triangulator#Triangulate", this ); }

                var $step = 0,
                    $jumpFromFinally, 
                    vertices, 
                    vertexCount, 
                    indicesArray, 
                    indices, 
                    isConcaveArray, 
                    isConcave, 
                    triangles, 
                    previous, 
                    i2, 
                    next, 
                    p1, 
                    p2, 
                    p3, 
                    p1x, 
                    p1y, 
                    p2x, 
                    p2y, 
                    p3x, 
                    p3y, 
                    ii, 
                    v, 
                    vx, 
                    vy, 
                    previousIndex, 
                    nextIndex, 
                    $asyncBody = Bridge.fn.bind(this, function () {
                        for (;;) {
                            $step = System.Array.min([0,1,2,3,4,5,6,7,8,9,10,11,14,15,16,17,18,19], $step);
                            switch ($step) {
                                case 0: {
                                    vertices = verticesArray.Items;
                                    vertexCount = verticesArray.Count >> 1;

                                    indicesArray = this.indicesArray;
                                    indicesArray.Clear();
                                    indices = indicesArray.Resize(vertexCount).Items;
                                    for (var i = 0; i < vertexCount; i = (i + 1) | 0) {
                                        indices[i] = i;
                                    }

                                    isConcaveArray = this.isConcaveArray;
                                    isConcave = isConcaveArray.Resize(vertexCount).Items;
                                    for (var i1 = 0, n = vertexCount; i1 < n; i1 = (i1 + 1) | 0) {
                                        isConcave[i1] = Spine.Triangulator.IsConcave(i1, vertexCount, vertices, indices);
                                    }

                                    triangles = this.triangles;
                                    triangles.Clear();
                                    triangles.EnsureCapacity(Math.max(0, ((vertexCount - 2) | 0)) << 2);
                                    $step = 1;
                                    continue;
                                }
                                case 1: {
                                    if ( vertexCount > 3 ) {
                                        $step = 2;
                                        continue;
                                    } 
                                    $step = 19;
                                    continue;
                                }
                                case 2: {
                                    // Find ear tip.
                                    previous = (vertexCount - 1) | 0;
                                    i2 = 0;
                                    next = 1;

                                    // outer:
                                    $step = 3;
                                    continue;
                                }
                                case 3: {
                                    if ( true ) {
                                        $step = 4;
                                        continue;
                                    } 
                                    $step = 18;
                                    continue;
                                }
                                case 4: {
                                    if (!isConcave[i2]) {
                                        $step = 5;
                                        continue;
                                    } 
                                    $step = 16;
                                    continue;
                                }
                                case 5: {
                                    p1 = indices[previous] << 1;
                                    p2 = indices[i2] << 1;
                                    p3 = indices[next] << 1;
                                    p1x = vertices[p1];
                                    p1y = vertices[((p1 + 1) | 0)];
                                    p2x = vertices[p2];
                                    p2y = vertices[((p2 + 1) | 0)];
                                    p3x = vertices[p3];
                                    p3y = vertices[((p3 + 1) | 0)];
                                    ii = (((next + 1) | 0)) % vertexCount;
                                    $step = 6;
                                    continue;
                                }
                                case 6: {
                                    if ( ii !== previous ) {
                                        $step = 7;
                                        continue;
                                    }
                                    $step = 15;
                                    continue;
                                }
                                case 7: {
                                    if (!isConcave[ii]) {
                                        $step = 14;
                                        continue;
                                    }
                                    v = indices[ii] << 1;
                                    vx = vertices[v];
                                    vy = vertices[((v + 1) | 0)];
                                    if (Spine.Triangulator.PositiveArea(p3x, p3y, p1x, p1y, vx, vy)) {
                                        $step = 8;
                                        continue;
                                    } 
                                    $step = 13;
                                    continue;
                                }
                                case 8: {
                                    if (Spine.Triangulator.PositiveArea(p1x, p1y, p2x, p2y, vx, vy)) {
                                        $step = 9;
                                        continue;
                                    } 
                                    $step = 12;
                                    continue;
                                }
                                case 9: {
                                    if (Spine.Triangulator.PositiveArea(p2x, p2y, p3x, p3y, vx, vy)) {
                                        $step = 10;
                                        continue;
                                    } 
                                    $step = 11;
                                    continue;
                                }
                                case 10: {
                                    $step = 17;
                                    continue;
                                }
                                case 11: {
                                    // break outer;
                                    $step = 12;
                                    continue;
                                }


                                case 14: {
                                    ii = (((ii + 1) | 0)) % vertexCount;
                                    $step = 6;
                                    continue;
                                }
                                case 15: {
                                    $step = 18;
                                    continue;
                                }
                                case 16: {

                                }
                                case 17: {
                                    if (next === 0) {
                                        do {
                                            if (!isConcave[i2]) {
                                                break;
                                            }
                                            i2 = (i2 - 1) | 0;
                                        } while (i2 > 0);
                                        $step = 18;
                                        continue;
                                    }

                                    previous = i2;
                                    i2 = next;
                                    next = (((next + 1) | 0)) % vertexCount;

                                    $step = 3;
                                    continue;
                                }
                                case 18: {
                                    // Cut ear tip.
                                    triangles.Add(indices[(((((vertexCount + i2) | 0) - 1) | 0)) % vertexCount]);
                                    triangles.Add(indices[i2]);
                                    triangles.Add(indices[(((i2 + 1) | 0)) % vertexCount]);
                                    indicesArray.RemoveAt(i2);
                                    isConcaveArray.RemoveAt(i2);
                                    vertexCount = (vertexCount - 1) | 0;

                                    previousIndex = (((((vertexCount + i2) | 0) - 1) | 0)) % vertexCount;
                                    nextIndex = i2 === vertexCount ? 0 : i2;
                                    isConcave[previousIndex] = Spine.Triangulator.IsConcave(previousIndex, vertexCount, vertices, indices);
                                    isConcave[nextIndex] = Spine.Triangulator.IsConcave(nextIndex, vertexCount, vertices, indices);

                                    $step = 1;
                                    continue;
                                }
                                case 19: {
                                    if (vertexCount === 3) {
                                        triangles.Add(indices[2]);
                                        triangles.Add(indices[0]);
                                        triangles.Add(indices[1]);
                                    }

                                    return triangles;
                                }
                                default: {
                                    return;
                                }
                            }
                        }
                    }, arguments);

                return $asyncBody();
            },
            /*Spine.Triangulator.Triangulate end.*/

            /*Spine.Triangulator.Decompose start.*/
            Decompose: function (verticesArray, triangles) {
if ( TRACE ) { TRACE( "Spine.Triangulator#Decompose", this ); }

                var vertices = verticesArray.Items;
                var convexPolygons = this.convexPolygons;
                for (var i = 0, n = convexPolygons.Count; i < n; i = (i + 1) | 0) {
                    this.polygonPool.Free(convexPolygons.Items[i]);
                }
                convexPolygons.Clear();

                var convexPolygonsIndices = this.convexPolygonsIndices;
                for (var i1 = 0, n1 = convexPolygonsIndices.Count; i1 < n1; i1 = (i1 + 1) | 0) {
                    this.polygonIndicesPool.Free(convexPolygonsIndices.Items[i1]);
                }
                convexPolygonsIndices.Clear();

                var polygonIndices = this.polygonIndicesPool.Obtain();
                polygonIndices.Clear();

                var polygon = this.polygonPool.Obtain();
                polygon.Clear();

                // Merge subsequent triangles if they form a triangle fan.
                var fanBaseIndex = -1, lastWinding = 0;
                var trianglesItems = triangles.Items;
                for (var i2 = 0, n2 = triangles.Count; i2 < n2; i2 = (i2 + 3) | 0) {
                    var t1 = trianglesItems[i2] << 1, t2 = trianglesItems[((i2 + 1) | 0)] << 1, t3 = trianglesItems[((i2 + 2) | 0)] << 1;
                    var x1 = vertices[t1], y1 = vertices[((t1 + 1) | 0)];
                    var x2 = vertices[t2], y2 = vertices[((t2 + 1) | 0)];
                    var x3 = vertices[t3], y3 = vertices[((t3 + 1) | 0)];

                    // If the base of the last triangle is the same as this triangle, check if they form a convex polygon (triangle fan).
                    var merged = false;
                    if (fanBaseIndex === t1) {
                        var o = (polygon.Count - 4) | 0;
                        var p = polygon.Items;
                        var winding1 = Spine.Triangulator.Winding(p[o], p[((o + 1) | 0)], p[((o + 2) | 0)], p[((o + 3) | 0)], x3, y3);
                        var winding2 = Spine.Triangulator.Winding(x3, y3, p[0], p[1], p[2], p[3]);
                        if (winding1 === lastWinding && winding2 === lastWinding) {
                            polygon.Add(x3);
                            polygon.Add(y3);
                            polygonIndices.Add(t3);
                            merged = true;
                        }
                    }

                    // Otherwise make this triangle the new base.
                    if (!merged) {
                        if (polygon.Count > 0) {
                            convexPolygons.Add(polygon);
                            convexPolygonsIndices.Add(polygonIndices);
                        } else {
                            this.polygonPool.Free(polygon);
                            this.polygonIndicesPool.Free(polygonIndices);
                        }
                        polygon = this.polygonPool.Obtain();
                        polygon.Clear();
                        polygon.Add(x1);
                        polygon.Add(y1);
                        polygon.Add(x2);
                        polygon.Add(y2);
                        polygon.Add(x3);
                        polygon.Add(y3);
                        polygonIndices = this.polygonIndicesPool.Obtain();
                        polygonIndices.Clear();
                        polygonIndices.Add(t1);
                        polygonIndices.Add(t2);
                        polygonIndices.Add(t3);
                        lastWinding = Spine.Triangulator.Winding(x1, y1, x2, y2, x3, y3);
                        fanBaseIndex = t1;
                    }
                }

                if (polygon.Count > 0) {
                    convexPolygons.Add(polygon);
                    convexPolygonsIndices.Add(polygonIndices);
                }

                // Go through the list of polygons and try to merge the remaining triangles with the found triangle fans.
                for (var i3 = 0, n3 = convexPolygons.Count; i3 < n3; i3 = (i3 + 1) | 0) {
                    polygonIndices = convexPolygonsIndices.Items[i3];
                    if (polygonIndices.Count === 0) {
                        continue;
                    }
                    var firstIndex = polygonIndices.Items[0];
                    var lastIndex = polygonIndices.Items[((polygonIndices.Count - 1) | 0)];

                    polygon = convexPolygons.Items[i3];
                    var o1 = (polygon.Count - 4) | 0;
                    var p1 = polygon.Items;
                    var prevPrevX = p1[o1], prevPrevY = p1[((o1 + 1) | 0)];
                    var prevX = p1[((o1 + 2) | 0)], prevY = p1[((o1 + 3) | 0)];
                    var firstX = p1[0], firstY = p1[1];
                    var secondX = p1[2], secondY = p1[3];
                    var winding = Spine.Triangulator.Winding(prevPrevX, prevPrevY, prevX, prevY, firstX, firstY);

                    for (var ii = 0; ii < n3; ii = (ii + 1) | 0) {
                        if (ii === i3) {
                            continue;
                        }
                        var otherIndices = convexPolygonsIndices.Items[ii];
                        if (otherIndices.Count !== 3) {
                            continue;
                        }
                        var otherFirstIndex = otherIndices.Items[0];
                        var otherSecondIndex = otherIndices.Items[1];
                        var otherLastIndex = otherIndices.Items[2];

                        var otherPoly = convexPolygons.Items[ii];
                        var x31 = otherPoly.Items[((otherPoly.Count - 2) | 0)], y31 = otherPoly.Items[((otherPoly.Count - 1) | 0)];

                        if (otherFirstIndex !== firstIndex || otherSecondIndex !== lastIndex) {
                            continue;
                        }
                        var winding11 = Spine.Triangulator.Winding(prevPrevX, prevPrevY, prevX, prevY, x31, y31);
                        var winding21 = Spine.Triangulator.Winding(x31, y31, firstX, firstY, secondX, secondY);
                        if (winding11 === winding && winding21 === winding) {
                            otherPoly.Clear();
                            otherIndices.Clear();
                            polygon.Add(x31);
                            polygon.Add(y31);
                            polygonIndices.Add(otherLastIndex);
                            prevPrevX = prevX;
                            prevPrevY = prevY;
                            prevX = x31;
                            prevY = y31;
                            ii = 0;
                        }
                    }
                }

                // Remove empty polygons that resulted from the merge step above.
                for (var i4 = (convexPolygons.Count - 1) | 0; i4 >= 0; i4 = (i4 - 1) | 0) {
                    polygon = convexPolygons.Items[i4];
                    if (polygon.Count === 0) {
                        convexPolygons.RemoveAt(i4);
                        this.polygonPool.Free(polygon);
                        polygonIndices = convexPolygonsIndices.Items[i4];
                        convexPolygonsIndices.RemoveAt(i4);
                        this.polygonIndicesPool.Free(polygonIndices);
                    }
                }

                return convexPolygons;
            },
            /*Spine.Triangulator.Decompose end.*/


        }
    });
    /*Spine.Triangulator end.*/

    /*Spine.Unity.ActivateBasedOnFlipDirection start.*/
    /** @namespace Spine.Unity */

    /**
     * Utility component to support flipping of 2D hinge chains (chains of HingeJoint2D objects) along
     with the parent skeleton by activating the respective mirrored versions of the hinge chain.
     Note: This component is automatically attached when calling "Create Hinge Chain 2D" at {@link },
     do not attempt to use this component for other purposes.
     *
     * @public
     * @class Spine.Unity.ActivateBasedOnFlipDirection
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Spine.Unity.ActivateBasedOnFlipDirection", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonRenderer: null,
            skeletonGraphic: null,
            activeOnNormalX: null,
            activeOnFlippedX: null,
            jointsNormalX: null,
            jointsFlippedX: null,
            skeletonComponent: null,
            wasFlippedXBefore: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.ActivateBasedOnFlipDirection#init", this ); }

                this.wasFlippedXBefore = false;
            }
        },
        methods: {
            /*Spine.Unity.ActivateBasedOnFlipDirection.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.ActivateBasedOnFlipDirection#Start", this ); }

                this.jointsNormalX = this.activeOnNormalX.GetComponentsInChildren(UnityEngine.HingeJoint2D);
                this.jointsFlippedX = this.activeOnFlippedX.GetComponentsInChildren(UnityEngine.HingeJoint2D);
                this.skeletonComponent = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) ? Bridge.cast(this.skeletonRenderer, Spine.Unity.ISkeletonComponent) : Bridge.cast(this.skeletonGraphic, Spine.Unity.ISkeletonComponent);
            },
            /*Spine.Unity.ActivateBasedOnFlipDirection.Start end.*/

            /*Spine.Unity.ActivateBasedOnFlipDirection.FixedUpdate start.*/
            FixedUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.ActivateBasedOnFlipDirection#FixedUpdate", this ); }

                var isFlippedX = (this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton.ScaleX < 0);
                if (isFlippedX !== this.wasFlippedXBefore) {
                    this.HandleFlip(isFlippedX);
                }
                this.wasFlippedXBefore = isFlippedX;
            },
            /*Spine.Unity.ActivateBasedOnFlipDirection.FixedUpdate end.*/

            /*Spine.Unity.ActivateBasedOnFlipDirection.HandleFlip start.*/
            HandleFlip: function (isFlippedX) {
if ( TRACE ) { TRACE( "Spine.Unity.ActivateBasedOnFlipDirection#HandleFlip", this ); }

                var gameObjectToActivate = isFlippedX ? this.activeOnFlippedX : this.activeOnNormalX;
                var gameObjectToDeactivate = isFlippedX ? this.activeOnNormalX : this.activeOnFlippedX;

                gameObjectToActivate.SetActive(true);
                gameObjectToDeactivate.SetActive(false);

                this.ResetJointPositions(isFlippedX ? this.jointsFlippedX : this.jointsNormalX);
                this.ResetJointPositions(isFlippedX ? this.jointsNormalX : this.jointsFlippedX);
                this.CompensateMovementAfterFlipX(gameObjectToActivate.transform, gameObjectToDeactivate.transform);
            },
            /*Spine.Unity.ActivateBasedOnFlipDirection.HandleFlip end.*/

            /*Spine.Unity.ActivateBasedOnFlipDirection.ResetJointPositions start.*/
            ResetJointPositions: function (joints) {
if ( TRACE ) { TRACE( "Spine.Unity.ActivateBasedOnFlipDirection#ResetJointPositions", this ); }

                for (var i = 0; i < joints.length; i = (i + 1) | 0) {
                    var joint = joints[i];
                    var parent = joint.connectedBody.transform;
                    joint.transform.position = parent.TransformPoint$1(UnityEngine.Vector3.FromVector2(joint.connectedAnchor));
                }
            },
            /*Spine.Unity.ActivateBasedOnFlipDirection.ResetJointPositions end.*/

            /*Spine.Unity.ActivateBasedOnFlipDirection.CompensateMovementAfterFlipX start.*/
            CompensateMovementAfterFlipX: function (toActivate, toDeactivate) {
if ( TRACE ) { TRACE( "Spine.Unity.ActivateBasedOnFlipDirection#CompensateMovementAfterFlipX", this ); }

                var targetLocation = toDeactivate.GetChild(0);
                var currentLocation = toActivate.GetChild(0);
                toActivate.position = toActivate.position.$clone().add( targetLocation.position.$clone().sub( currentLocation.position ) );
            },
            /*Spine.Unity.ActivateBasedOnFlipDirection.CompensateMovementAfterFlipX end.*/


        }
    });
    /*Spine.Unity.ActivateBasedOnFlipDirection end.*/

    /*Spine.Unity.ISpineComponent start.*/
    Bridge.define("Spine.Unity.ISpineComponent", {
        $kind: 3
    });
    /*Spine.Unity.ISpineComponent end.*/

    /*Spine.Unity.AnimationTools.TimelineExtensions start.*/
    Bridge.define("Spine.Unity.AnimationTools.TimelineExtensions", {
        statics: {
            methods: {
                /*Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1:static start.*/
                /**
                 * Evaluates the resulting value of a TranslateTimeline at a given time.
                 SkeletonData can be accessed from Skeleton.Data or from SkeletonDataAsset.GetSkeletonData.
                 If no SkeletonData is provided, values are returned as difference to setup pose
                 instead of absolute values.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AnimationTools.TimelineExtensions
                 * @memberof Spine.Unity.AnimationTools.TimelineExtensions
                 * @param   {Spine.TranslateTimeline}    timeline        
                 * @param   {number}                     time            
                 * @param   {Spine.SkeletonData}         skeletonData
                 * @return  {UnityEngine.Vector2}
                 */
                Evaluate$1: function (timeline, time, skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationTools.TimelineExtensions#Evaluate$1", this ); }

                    var $t, $t1;
                    if (skeletonData === void 0) { skeletonData = null; }
                    if (time < ($t = timeline.Frames)[0]) {
                        return pc.Vec2.ZERO.clone();
                    }

                    var x = { }, y = { };
                    timeline.GetCurveValue(x, y, time);

                    if (skeletonData == null) {
                        return new pc.Vec2( x.v, y.v );
                    } else {
                        var boneData = ($t1 = skeletonData.Bones.Items)[timeline.BoneIndex];
                        return new pc.Vec2( boneData.X + x.v, boneData.Y + y.v );
                    }
                },
                /*Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1:static end.*/

                /*Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2:static start.*/
                /**
                 * Evaluates the resulting value of a pair of split translate timelines at a given time.
                 SkeletonData can be accessed from Skeleton.Data or from SkeletonDataAsset.GetSkeletonData.
                 If no SkeletonData is given, values are returned as difference to setup pose
                 instead of absolute values.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AnimationTools.TimelineExtensions
                 * @memberof Spine.Unity.AnimationTools.TimelineExtensions
                 * @param   {Spine.TranslateXTimeline}    xTimeline       
                 * @param   {Spine.TranslateYTimeline}    yTimeline       
                 * @param   {number}                      time            
                 * @param   {Spine.SkeletonData}          skeletonData
                 * @return  {UnityEngine.Vector2}
                 */
                Evaluate$2: function (xTimeline, yTimeline, time, skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationTools.TimelineExtensions#Evaluate$2", this ); }

                    var $t, $t1;
                    if (skeletonData === void 0) { skeletonData = null; }

                    var x = 0, y = 0;
                    if (xTimeline != null && time > ($t = xTimeline.Frames)[0]) {
                        x = xTimeline.GetCurveValue(time);
                    }
                    if (yTimeline != null && time > ($t1 = yTimeline.Frames)[0]) {
                        y = yTimeline.GetCurveValue(time);
                    }

                    if (skeletonData == null) {
                        return new pc.Vec2( x, y );
                    } else {
                        var bonesItems = skeletonData.Bones.Items;
                        var boneDataX = bonesItems[xTimeline.BoneIndex];
                        var boneDataY = bonesItems[yTimeline.BoneIndex];
                        return new pc.Vec2( boneDataX.X + x, boneDataY.Y + y );
                    }
                },
                /*Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2:static end.*/

                /*Spine.Unity.AnimationTools.TimelineExtensions.Evaluate:static start.*/
                /**
                 * Evaluates the resulting value of a RotateTimeline at a given time.
                 SkeletonData can be accessed from Skeleton.Data or from SkeletonDataAsset.GetSkeletonData.
                 If no SkeletonData is given, values are returned as difference to setup pose
                 instead of absolute values.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AnimationTools.TimelineExtensions
                 * @memberof Spine.Unity.AnimationTools.TimelineExtensions
                 * @param   {Spine.RotateTimeline}    timeline        
                 * @param   {number}                  time            
                 * @param   {Spine.SkeletonData}      skeletonData
                 * @return  {number}
                 */
                Evaluate: function (timeline, time, skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationTools.TimelineExtensions#Evaluate", this ); }

                    var $t, $t1;
                    if (skeletonData === void 0) { skeletonData = null; }
                    if (time < ($t = timeline.Frames)[0]) {
                        return 0.0;
                    }

                    var rotation = timeline.GetCurveValue(time);
                    if (skeletonData == null) {
                        return rotation;
                    } else {
                        var boneData = ($t1 = skeletonData.Bones.Items)[timeline.BoneIndex];
                        return (boneData.Rotation + rotation);
                    }
                },
                /*Spine.Unity.AnimationTools.TimelineExtensions.Evaluate:static end.*/

                /*Spine.Unity.AnimationTools.TimelineExtensions.EvaluateTranslateXYMix:static start.*/
                /**
                 * Evaluates the resulting X and Y translate mix values of a
                 TransformConstraintTimeline at a given time.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AnimationTools.TimelineExtensions
                 * @memberof Spine.Unity.AnimationTools.TimelineExtensions
                 * @param   {Spine.TransformConstraintTimeline}    timeline    
                 * @param   {number}                               time
                 * @return  {UnityEngine.Vector2}
                 */
                EvaluateTranslateXYMix: function (timeline, time) {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationTools.TimelineExtensions#EvaluateTranslateXYMix", this ); }

                    var $t;
                    if (time < ($t = timeline.Frames)[0]) {
                        return pc.Vec2.ZERO.clone();
                    }

                    var rotate = { }, mixX = { }, mixY = { }, scaleX = { }, scaleY = { }, shearY = { };
                    timeline.GetCurveValue(rotate, mixX, mixY, scaleX, scaleY, shearY, time);
                    return new pc.Vec2( mixX.v, mixY.v );
                },
                /*Spine.Unity.AnimationTools.TimelineExtensions.EvaluateTranslateXYMix:static end.*/

                /*Spine.Unity.AnimationTools.TimelineExtensions.EvaluateRotateMix:static start.*/
                /**
                 * Evaluates the resulting rotate mix values of a
                 TransformConstraintTimeline at a given time.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AnimationTools.TimelineExtensions
                 * @memberof Spine.Unity.AnimationTools.TimelineExtensions
                 * @param   {Spine.TransformConstraintTimeline}    timeline    
                 * @param   {number}                               time
                 * @return  {number}
                 */
                EvaluateRotateMix: function (timeline, time) {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationTools.TimelineExtensions#EvaluateRotateMix", this ); }

                    var $t;
                    if (time < ($t = timeline.Frames)[0]) {
                        return 0;
                    }

                    var rotate = { }, mixX = { }, mixY = { }, scaleX = { }, scaleY = { }, shearY = { };
                    timeline.GetCurveValue(rotate, mixX, mixY, scaleX, scaleY, shearY, time);
                    return rotate.v;
                },
                /*Spine.Unity.AnimationTools.TimelineExtensions.EvaluateRotateMix:static end.*/

                /*Spine.Unity.AnimationTools.TimelineExtensions.FindTranslateTimelineForBone:static start.*/
                /**
                 * Gets the translate timeline for a given boneIndex.
                 You can get the boneIndex using SkeletonData.FindBone().Index.
                 The root bone is always boneIndex 0.
                 This will return null if a TranslateTimeline is not found.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AnimationTools.TimelineExtensions
                 * @memberof Spine.Unity.AnimationTools.TimelineExtensions
                 * @param   {Spine.Animation}            a            
                 * @param   {number}                     boneIndex
                 * @return  {Spine.TranslateTimeline}
                 */
                FindTranslateTimelineForBone: function (a, boneIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationTools.TimelineExtensions#FindTranslateTimelineForBone", this ); }

                    var $t;
                    $t = Bridge.getEnumerator(a.Timelines);
                    try {
                        while ($t.moveNext()) {
                            var timeline = $t.Current;
                            if ((Bridge.getType(timeline).prototype instanceof Spine.TranslateTimeline)) {
                                continue;
                            }

                            var translateTimeline = Bridge.as(timeline, Spine.TranslateTimeline);
                            if (translateTimeline != null && translateTimeline.BoneIndex === boneIndex) {
                                return translateTimeline;
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    return null;
                },
                /*Spine.Unity.AnimationTools.TimelineExtensions.FindTranslateTimelineForBone:static end.*/

                /*Spine.Unity.AnimationTools.TimelineExtensions.FindTimelineForBone:static start.*/
                /**
                 * Gets the IBoneTimeline timeline of a given type for a given boneIndex.
                 You can get the boneIndex using SkeletonData.FindBoneIndex.
                 The root bone is always boneIndex 0.
                 This will return null if a timeline of the given type is not found.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AnimationTools.TimelineExtensions
                 * @memberof Spine.Unity.AnimationTools.TimelineExtensions
                 * @param   {Function}           T            
                 * @param   {Spine.Animation}    a            
                 * @param   {number}             boneIndex
                 * @return  {T}
                 */
                FindTimelineForBone: function (T, a, boneIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationTools.TimelineExtensions#FindTimelineForBone", this ); }

                    var $t;
                    $t = Bridge.getEnumerator(a.Timelines);
                    try {
                        while ($t.moveNext()) {
                            var timeline = $t.Current;
                            var translateTimeline = Bridge.as(timeline, T);
                            if (Bridge.rValue(translateTimeline) != null && Bridge.rValue(translateTimeline).Spine$IBoneTimeline$BoneIndex === boneIndex) {
                                return Bridge.rValue(translateTimeline);
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    return null;
                },
                /*Spine.Unity.AnimationTools.TimelineExtensions.FindTimelineForBone:static end.*/

                /*Spine.Unity.AnimationTools.TimelineExtensions.FindTransformConstraintTimeline:static start.*/
                /**
                 * Gets the transform constraint timeline for a given boneIndex.
                 You can get the boneIndex using SkeletonData.FindBone().Index.
                 The root bone is always boneIndex 0.
                 This will return null if a TranslateTimeline is not found.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AnimationTools.TimelineExtensions
                 * @memberof Spine.Unity.AnimationTools.TimelineExtensions
                 * @param   {Spine.Animation}                      a                           
                 * @param   {number}                               transformConstraintIndex
                 * @return  {Spine.TransformConstraintTimeline}
                 */
                FindTransformConstraintTimeline: function (a, transformConstraintIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationTools.TimelineExtensions#FindTransformConstraintTimeline", this ); }

                    var $t;
                    $t = Bridge.getEnumerator(a.Timelines);
                    try {
                        while ($t.moveNext()) {
                            var timeline = $t.Current;
                            if ((Bridge.getType(timeline).prototype instanceof Spine.TransformConstraintTimeline)) {
                                continue;
                            }

                            var transformConstraintTimeline = Bridge.as(timeline, Spine.TransformConstraintTimeline);
                            if (transformConstraintTimeline != null && transformConstraintTimeline.TransformConstraintIndex === transformConstraintIndex) {
                                return transformConstraintTimeline;
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    return null;
                },
                /*Spine.Unity.AnimationTools.TimelineExtensions.FindTransformConstraintTimeline:static end.*/


            }
        }
    });
    /*Spine.Unity.AnimationTools.TimelineExtensions end.*/

    /*Spine.Unity.AtlasAssetBase start.*/
    Bridge.define("Spine.Unity.AtlasAssetBase", {
        inherits: [UnityEngine.ScriptableObject],
        fields: {
            textureLoadingMode: 0,
            onDemandTextureLoader: null
        },
        props: {
            TextureLoadingMode: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AtlasAssetBase#TextureLoadingMode#get", this ); }

                    return this.textureLoadingMode;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.AtlasAssetBase#TextureLoadingMode#set", this ); }

                    this.textureLoadingMode = value;
                }
            },
            OnDemandTextureLoader: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AtlasAssetBase#OnDemandTextureLoader#get", this ); }

                    return this.onDemandTextureLoader;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.AtlasAssetBase#OnDemandTextureLoader#set", this ); }

                    this.onDemandTextureLoader = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AtlasAssetBase#init", this ); }

                this.textureLoadingMode = Spine.Unity.AtlasAssetBase.LoadingMode.Normal;
            }
        },
        methods: {
            /*Spine.Unity.AtlasAssetBase.BeginCustomTextureLoading start.*/
            BeginCustomTextureLoading: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AtlasAssetBase#BeginCustomTextureLoading", this ); }

                if (UnityEngine.Object.op_Implicit(this.onDemandTextureLoader)) {
                    this.onDemandTextureLoader.BeginCustomTextureLoading();
                }
            },
            /*Spine.Unity.AtlasAssetBase.BeginCustomTextureLoading end.*/

            /*Spine.Unity.AtlasAssetBase.EndCustomTextureLoading start.*/
            EndCustomTextureLoading: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AtlasAssetBase#EndCustomTextureLoading", this ); }

                if (UnityEngine.Object.op_Implicit(this.onDemandTextureLoader)) {
                    this.onDemandTextureLoader.EndCustomTextureLoading();
                }
            },
            /*Spine.Unity.AtlasAssetBase.EndCustomTextureLoading end.*/

            /*Spine.Unity.AtlasAssetBase.RequireTexturesLoaded start.*/
            RequireTexturesLoaded: function (material, overrideMaterial) {
if ( TRACE ) { TRACE( "Spine.Unity.AtlasAssetBase#RequireTexturesLoaded", this ); }

                if (UnityEngine.Object.op_Implicit(this.onDemandTextureLoader)) {
                    this.onDemandTextureLoader.RequestLoadMaterialTextures(material, overrideMaterial);
                }
            },
            /*Spine.Unity.AtlasAssetBase.RequireTexturesLoaded end.*/

            /*Spine.Unity.AtlasAssetBase.RequireTextureLoaded start.*/
            RequireTextureLoaded: function (placeholderTexture, replacementTexture, onTextureLoaded) {
if ( TRACE ) { TRACE( "Spine.Unity.AtlasAssetBase#RequireTextureLoaded", this ); }

                if (UnityEngine.Object.op_Implicit(this.onDemandTextureLoader)) {
                    this.onDemandTextureLoader.RequestLoadTexture(placeholderTexture, replacementTexture, onTextureLoaded);
                }
            },
            /*Spine.Unity.AtlasAssetBase.RequireTextureLoaded end.*/


        }
    });
    /*Spine.Unity.AtlasAssetBase end.*/

    /*Spine.Unity.AtlasAssetBase+LoadingMode start.*/
    Bridge.define("Spine.Unity.AtlasAssetBase.LoadingMode", {
        $kind: 1006,
        statics: {
            fields: {
                Normal: 0,
                OnDemand: 1
            }
        }
    });
    /*Spine.Unity.AtlasAssetBase+LoadingMode end.*/

    /*Spine.Unity.AttachmentTools.AtlasUtilities start.*/
    Bridge.define("Spine.Unity.AttachmentTools.AtlasUtilities", {
        statics: {
            fields: {
                SpineTextureFormat: 0,
                DefaultMipmapBias: 0,
                UseMipMaps: false,
                DefaultScale: 0,
                NonrenderingRegion: 0,
                existingRegions: null,
                regionIndices: null,
                originalRegions: null,
                repackedRegions: null,
                texturesToPackAtParam: null,
                inoutAttachments: null,
                CachedRegionTextures: null,
                CachedRegionTexturesList: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#init", this ); }

                    this.SpineTextureFormat = UnityEngine.TextureFormat.RGBA32;
                    this.DefaultMipmapBias = -0.5;
                    this.UseMipMaps = false;
                    this.DefaultScale = 0.01;
                    this.NonrenderingRegion = -1;
                    this.existingRegions = new (System.Collections.Generic.Dictionary$2(Spine.AtlasRegion,System.Int32)).ctor();
                    this.regionIndices = new (System.Collections.Generic.List$1(System.Int32)).ctor();
                    this.originalRegions = new (System.Collections.Generic.List$1(Spine.AtlasRegion)).ctor();
                    this.repackedRegions = new (System.Collections.Generic.List$1(Spine.AtlasRegion)).ctor();
                    this.texturesToPackAtParam = System.Array.init(1, null, System.Collections.Generic.List$1(UnityEngine.Texture2D));
                    this.inoutAttachments = new (System.Collections.Generic.List$1(Spine.Attachment)).ctor();
                    this.CachedRegionTextures = new (System.Collections.Generic.Dictionary$2(Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey,UnityEngine.Texture2D)).ctor();
                    this.CachedRegionTexturesList = new (System.Collections.Generic.List$1(UnityEngine.Texture2D)).ctor();
                }
            },
            methods: {
                /*Spine.Unity.AttachmentTools.AtlasUtilities.Init:static start.*/
                Init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#Init", this ); }

                    // handle disabled domain reload
                    Spine.Unity.AttachmentTools.AtlasUtilities.ClearCache();
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.Init:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$2:static start.*/
                ToAtlasRegion$2: function (t, materialPropertySource, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion$2", this ); }

                    if (scale === void 0) { scale = 0.01; }
                    return Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$3(t, materialPropertySource.shader, scale, materialPropertySource);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$2:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$3:static start.*/
                ToAtlasRegion$3: function (t, shader, scale, materialPropertySource) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion$3", this ); }

                    if (scale === void 0) { scale = 0.01; }
                    if (materialPropertySource === void 0) { materialPropertySource = null; }
                    var material = new UnityEngine.Material.$ctor2(shader);
                    if (materialPropertySource != null) {
                        material.CopyPropertiesFromMaterial(materialPropertySource);
                        material.shaderKeywords = materialPropertySource.shaderKeywords;
                    }

                    material.mainTexture = t;
                    var page = Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage(material);

                    var width = t.width;
                    var height = t.height;

                    var region = new Spine.AtlasRegion();
                    region.name = t.name;

                    // World space units
                    var boundsMin = pc.Vec2.ZERO.clone(), boundsMax = new pc.Vec2( width, height ).scale( scale );

                    // Texture space/pixel units
                    region.width = Bridge.Int.clip32(width);
                    region.originalWidth = Bridge.Int.clip32(width);
                    region.height = Bridge.Int.clip32(height);
                    region.originalHeight = Bridge.Int.clip32(height);
                    region.offsetX = width * (0.5 - Spine.Unity.AttachmentTools.AtlasUtilities.InverseLerp(boundsMin.x, boundsMax.x, 0));
                    region.offsetY = height * (0.5 - Spine.Unity.AttachmentTools.AtlasUtilities.InverseLerp(boundsMin.y, boundsMax.y, 0));

                    // Use the full area of the texture.
                    region.u = 0;
                    region.v = 1;
                    region.u2 = 1;
                    region.v2 = 0;
                    region.x = 0;
                    region.y = 0;

                    region.page = page;

                    return region;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$3:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion:static start.*/
                /**
                 * Creates a Spine.AtlasRegion from a UnityEngine.Sprite.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Sprite}    s       
                 * @param   {Spine.AtlasPage}       page
                 * @return  {Spine.AtlasRegion}
                 */
                ToAtlasRegion: function (s, page) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion", this ); }

                    if (page == null) {
                        throw new System.ArgumentNullException.$ctor3("page", "page cannot be null. AtlasPage determines which texture region belongs and how it should be rendered. You can use material.ToSpineAtlasPage() to get a shareable AtlasPage from a Material, or use the sprite.ToAtlasRegion(material) overload.");
                    }
                    var region = Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$4(s);
                    region.page = page;
                    return region;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$1:static start.*/
                /**
                 * Creates a Spine.AtlasRegion from a UnityEngine.Sprite. This creates a new AtlasPage object for every AtlasRegion you create. You can centralize Material control by creating a shared atlas page using Material.ToSpineAtlasPage and using the sprite.ToAtlasRegion(AtlasPage) overload.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Sprite}      s           
                 * @param   {UnityEngine.Material}    material
                 * @return  {Spine.AtlasRegion}
                 */
                ToAtlasRegion$1: function (s, material) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion$1", this ); }

                    var region = Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$4(s);
                    region.page = Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage(material);
                    return region;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$1:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$4:static start.*/
                ToAtlasRegion$4: function (s, isolatedTexture) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion$4", this ); }

                    if (isolatedTexture === void 0) { isolatedTexture = false; }
                    var region = new Spine.AtlasRegion();
                    region.name = s.name;
                    region.index = -1;
                    region.degrees = s.packed && s.packingRotation !== UnityEngine.SpritePackingRotation.None ? 90 : 0;

                    // World space units
                    var bounds = s.bounds;
                    var boundsMin = UnityEngine.Vector2.FromVector3(bounds.min.$clone()), boundsMax = UnityEngine.Vector2.FromVector3(bounds.max.$clone());

                    // Texture space/pixel units
                    var spineRect = Spine.Unity.AttachmentTools.AtlasUtilities.SpineUnityFlipRect(s.textureRect, s.texture.height);
                    var originalRect = s.rect.$clone();
                    region.width = Bridge.Int.clip32(spineRect.width);
                    region.originalWidth = Bridge.Int.clip32(originalRect.width);
                    region.height = Bridge.Int.clip32(spineRect.height);
                    region.originalHeight = Bridge.Int.clip32(originalRect.height);
                    region.offsetX = s.textureRectOffset.x + spineRect.width * (0.5 - Spine.Unity.AttachmentTools.AtlasUtilities.InverseLerp(boundsMin.x, boundsMax.x, 0));
                    region.offsetY = s.textureRectOffset.y + spineRect.height * (0.5 - Spine.Unity.AttachmentTools.AtlasUtilities.InverseLerp(boundsMin.y, boundsMax.y, 0));

                    if (isolatedTexture) {
                        region.u = 0;
                        region.v = 1;
                        region.u2 = 1;
                        region.v2 = 0;
                        region.x = 0;
                        region.y = 0;
                    } else {
                        var tex = s.texture;
                        var uvRect = Spine.Unity.AttachmentTools.AtlasUtilities.TextureRectToUVRect(s.textureRect.$clone(), tex.width, tex.height);
                        region.u = uvRect.xMin;
                        region.v = uvRect.yMax;
                        region.u2 = uvRect.xMax;
                        region.v2 = uvRect.yMin;
                        region.x = Bridge.Int.clip32(spineRect.x);
                        region.y = Bridge.Int.clip32(spineRect.y);
                    }

                    return region;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$4:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$2:static start.*/
                /**
                 * Creates a Spine.AtlasRegion that uses a premultiplied alpha duplicate of the Sprite's texture data.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Texture2D}        t                         
                 * @param   {UnityEngine.Material}         materialPropertySource    
                 * @param   {UnityEngine.TextureFormat}    textureFormat             
                 * @param   {boolean}                      mipmaps
                 * @return  {Spine.AtlasRegion}
                 */
                ToAtlasRegionPMAClone$2: function (t, materialPropertySource, textureFormat, mipmaps) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegionPMAClone$2", this ); }

                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    return Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$3(t, materialPropertySource.shader, textureFormat, mipmaps, materialPropertySource);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$2:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$3:static start.*/
                /**
                 * Creates a Spine.AtlasRegion that uses a premultiplied alpha duplicate of the Sprite's texture data.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Texture2D}        t                         
                 * @param   {UnityEngine.Shader}           shader                    
                 * @param   {UnityEngine.TextureFormat}    textureFormat             
                 * @param   {boolean}                      mipmaps                   
                 * @param   {UnityEngine.Material}         materialPropertySource
                 * @return  {Spine.AtlasRegion}
                 */
                ToAtlasRegionPMAClone$3: function (t, shader, textureFormat, mipmaps, materialPropertySource) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegionPMAClone$3", this ); }

                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (materialPropertySource === void 0) { materialPropertySource = null; }
                    var material = new UnityEngine.Material.$ctor2(shader);
                    if (materialPropertySource != null) {
                        material.CopyPropertiesFromMaterial(materialPropertySource);
                        material.shaderKeywords = materialPropertySource.shaderKeywords;
                    }
                    var newTexture = Spine.Unity.AttachmentTools.AtlasUtilities.GetClone(t, textureFormat, mipmaps, false, true);

                    newTexture.name = (t.name || "") + "-pma-";
                    material.name = (t.name || "") + (shader.name || "");

                    material.mainTexture = newTexture;
                    var page = Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage(material);

                    var region = Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$3(newTexture, shader);
                    region.page = page;

                    return region;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$3:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone:static start.*/
                ToAtlasRegionPMAClone: function (s, materialPropertySource, textureFormat, mipmaps) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegionPMAClone", this ); }

                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    return Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$1(s, materialPropertySource.shader, textureFormat, mipmaps, materialPropertySource);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$1:static start.*/
                /**
                 * Creates a Spine.AtlasRegion that uses a premultiplied alpha duplicate of the Sprite's texture data.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Sprite}           s                         
                 * @param   {UnityEngine.Shader}           shader                    
                 * @param   {UnityEngine.TextureFormat}    textureFormat             
                 * @param   {boolean}                      mipmaps                   
                 * @param   {UnityEngine.Material}         materialPropertySource
                 * @return  {Spine.AtlasRegion}
                 */
                ToAtlasRegionPMAClone$1: function (s, shader, textureFormat, mipmaps, materialPropertySource) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegionPMAClone$1", this ); }

                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (materialPropertySource === void 0) { materialPropertySource = null; }
                    var material = new UnityEngine.Material.$ctor2(shader);
                    if (materialPropertySource != null) {
                        material.CopyPropertiesFromMaterial(materialPropertySource);
                        material.shaderKeywords = materialPropertySource.shaderKeywords;
                    }

                    var tex = Spine.Unity.AttachmentTools.AtlasUtilities.ToTexture$1(s, textureFormat, mipmaps, false, true);
                    tex.name = (s.name || "") + "-pma-";
                    material.name = (tex.name || "") + (shader.name || "");

                    material.mainTexture = tex;
                    var page = Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage(material);

                    var region = Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$4(s, true);
                    region.page = page;

                    return region;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$1:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage:static start.*/
                /**
                 * Creates a new Spine.AtlasPage from a UnityEngine.Material. If the material has a preassigned texture, the page width and height will be set.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Material}    m
                 * @return  {Spine.AtlasPage}
                 */
                ToSpineAtlasPage: function (m) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToSpineAtlasPage", this ); }

                    var $t;
                    var newPage = ($t = new Spine.AtlasPage(), $t.rendererObject = m, $t.name = m.name, $t);

                    var t = m.mainTexture;
                    if (t != null) {
                        newPage.width = t.width;
                        newPage.height = t.height;
                    }

                    return newPage;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedAttachments:static start.*/
                /**
                 * Fills the outputAttachments list with new attachment objects based on the attachments in sourceAttachments,
                 but mapped to a new single texture using the same material.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {System.Collections.Generic.List$1}    sourceAttachments                     The list of attachments to be repacked.
                 * @param   {System.Collections.Generic.List$1}    outputAttachments                     The List(Attachment) to populate with the newly created Attachment objects.
                 May be equal to <pre><code>sourceAttachments</code></pre> for in-place operation.
                 * @param   {UnityEngine.Material}                 materialPropertySource                May be null. If no Material property source is provided, a material with
                 default parameters using the provided <pre><code>shader</code></pre> will be created.
                 * @param   {UnityEngine.Material}                 outputMaterial                        
                 * @param   {UnityEngine.Texture2D}                outputTexture                         
                 * @param   {number}                               maxAtlasSize                          
                 * @param   {number}                               padding                               
                 * @param   {UnityEngine.TextureFormat}            textureFormat                         
                 * @param   {boolean}                              mipmaps                               
                 * @param   {string}                               newAssetName                          
                 * @param   {boolean}                              clearCache                            When set to <pre><code>true</code></pre>, {@link } is called after
                 repacking to clear the texture cache. See remarks for additional info.
                 * @param   {boolean}                              useOriginalNonrenderables             
                 * @param   {Array.<number>}                       additionalTexturePropertyIDsToCopy    Optional additional textures (such as normal maps) to copy while repacking.
                 To copy e.g. the main texture and normal maps, pass 'new int[] { Shader.PropertyToID("_BumpMap") }' at this parameter.
                 * @param   {Array.<UnityEngine.Texture2D>}        additionalOutputTextures              When <pre><code>additionalTexturePropertyIDsToCopy</code></pre> is non-null,
                 this array will be filled with the resulting repacked texture for every property,
                 just as the main repacked texture is assigned to <pre><code>outputTexture</code></pre>.
                 * @param   {Array.<UnityEngine.TextureFormat>}    additionalTextureFormats              When <pre><code>additionalTexturePropertyIDsToCopy</code></pre> is non-null,
                 this array will be used as <pre><code>TextureFormat</code></pre> at the Texture at the respective property.
                 When <pre><code>additionalTextureFormats</code></pre> is <pre><code>null</code></pre> or when its array size is smaller,
                 <pre><code>textureFormat</code></pre> is used where there exists no corresponding array item.
                 * @param   {Array.<boolean>}                      additionalTextureIsLinear             When <pre><code>additionalTexturePropertyIDsToCopy</code></pre> is non-null,
                 this array will be used to determine whether <pre><code>linear</code></pre> or <pre><code>sRGB</code></pre> color space is used at the
                 Texture at the respective property. When <pre><code>additionalTextureIsLinear</code></pre> is <pre><code>null</code></pre>, <pre><code>linear</code></pre> color space
                 is assumed at every additional Texture element.
                 When e.g. packing the main texture and normal maps, pass 'new bool[] { true }' at this parameter, because normal maps use
                 linear color space.
                 * @return  {void}
                 */
                GetRepackedAttachments: function (sourceAttachments, outputAttachments, materialPropertySource, outputMaterial, outputTexture, maxAtlasSize, padding, textureFormat, mipmaps, newAssetName, clearCache, useOriginalNonrenderables, additionalTexturePropertyIDsToCopy, additionalOutputTextures, additionalTextureFormats, additionalTextureIsLinear) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetRepackedAttachments", this ); }

                    if (maxAtlasSize === void 0) { maxAtlasSize = 1024; }
                    if (padding === void 0) { padding = 2; }
                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (newAssetName === void 0) { newAssetName = "Repacked Attachments"; }
                    if (clearCache === void 0) { clearCache = false; }
                    if (useOriginalNonrenderables === void 0) { useOriginalNonrenderables = true; }
                    if (additionalTexturePropertyIDsToCopy === void 0) { additionalTexturePropertyIDsToCopy = null; }
                    if (additionalOutputTextures === void 0) { additionalOutputTextures = null; }
                    if (additionalTextureFormats === void 0) { additionalTextureFormats = null; }
                    if (additionalTextureIsLinear === void 0) { additionalTextureIsLinear = null; }

                    var shader = materialPropertySource == null ? UnityEngine.Shader.Find("Spine/Skeleton") : materialPropertySource.shader;
                    Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedAttachments$1(sourceAttachments, outputAttachments, shader, outputMaterial, outputTexture, maxAtlasSize, padding, textureFormat, mipmaps, newAssetName, materialPropertySource, clearCache, useOriginalNonrenderables, additionalTexturePropertyIDsToCopy, additionalOutputTextures, additionalTextureFormats, additionalTextureIsLinear);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedAttachments:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedAttachments$1:static start.*/
                /**
                 * Fills the outputAttachments list with new attachment objects based on the attachments in sourceAttachments,
                 but mapped to a new single texture using the same material.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {System.Collections.Generic.List$1}    sourceAttachments                     The list of attachments to be repacked.
                 * @param   {System.Collections.Generic.List$1}    outputAttachments                     The List(Attachment) to populate with the newly created Attachment objects.
                 May be equal to <pre><code>sourceAttachments</code></pre> for in-place operation.
                 * @param   {UnityEngine.Shader}                   shader                                
                 * @param   {UnityEngine.Material}                 outputMaterial                        
                 * @param   {UnityEngine.Texture2D}                outputTexture                         
                 * @param   {number}                               maxAtlasSize                          
                 * @param   {number}                               padding                               
                 * @param   {UnityEngine.TextureFormat}            textureFormat                         
                 * @param   {boolean}                              mipmaps                               
                 * @param   {string}                               newAssetName                          
                 * @param   {UnityEngine.Material}                 materialPropertySource                May be null. If no Material property source is provided, a material with
                 default parameters using the provided <pre><code>shader</code></pre> will be created.
                 * @param   {boolean}                              clearCache                            
                 * @param   {boolean}                              useOriginalNonrenderables             
                 * @param   {Array.<number>}                       additionalTexturePropertyIDsToCopy    Optional additional textures (such as normal maps) to copy while repacking.
                 To copy e.g. the main texture and normal maps, pass 'new int[] { Shader.PropertyToID("_BumpMap") }' at this parameter.
                 * @param   {Array.<UnityEngine.Texture2D>}        additionalOutputTextures              When <pre><code>additionalTexturePropertyIDsToCopy</code></pre> is non-null,
                 this array will be filled with the resulting repacked texture for every property,
                 just as the main repacked texture is assigned to <pre><code>outputTexture</code></pre>.
                 * @param   {Array.<UnityEngine.TextureFormat>}    additionalTextureFormats              When <pre><code>additionalTexturePropertyIDsToCopy</code></pre> is non-null,
                 this array will be used as <pre><code>TextureFormat</code></pre> at the Texture at the respective property.
                 When <pre><code>additionalTextureFormats</code></pre> is <pre><code>null</code></pre> or when its array size is smaller,
                 <pre><code>textureFormat</code></pre> is used where there exists no corresponding array item.
                 * @param   {Array.<boolean>}                      additionalTextureIsLinear             When <pre><code>additionalTexturePropertyIDsToCopy</code></pre> is non-null,
                 this array will be used to determine whether <pre><code>linear</code></pre> or <pre><code>sRGB</code></pre> color space is used at the
                 Texture at the respective property. When <pre><code>additionalTextureIsLinear</code></pre> is <pre><code>null</code></pre>, <pre><code>linear</code></pre> color space
                 is assumed at every additional Texture element.
                 When e.g. packing the main texture and normal maps, pass 'new bool[] { true }' at this parameter, because normal maps use
                 linear color space.
                 * @return  {void}
                 */
                GetRepackedAttachments$1: function (sourceAttachments, outputAttachments, shader, outputMaterial, outputTexture, maxAtlasSize, padding, textureFormat, mipmaps, newAssetName, materialPropertySource, clearCache, useOriginalNonrenderables, additionalTexturePropertyIDsToCopy, additionalOutputTextures, additionalTextureFormats, additionalTextureIsLinear) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetRepackedAttachments$1", this ); }

                    var $t, $t1;
                    if (maxAtlasSize === void 0) { maxAtlasSize = 1024; }
                    if (padding === void 0) { padding = 2; }
                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (newAssetName === void 0) { newAssetName = "Repacked Attachments"; }
                    if (materialPropertySource === void 0) { materialPropertySource = null; }
                    if (clearCache === void 0) { clearCache = false; }
                    if (useOriginalNonrenderables === void 0) { useOriginalNonrenderables = true; }
                    if (additionalTexturePropertyIDsToCopy === void 0) { additionalTexturePropertyIDsToCopy = null; }
                    if (additionalOutputTextures === void 0) { additionalOutputTextures = null; }
                    if (additionalTextureFormats === void 0) { additionalTextureFormats = null; }
                    if (additionalTextureIsLinear === void 0) { additionalTextureIsLinear = null; }

                    if (sourceAttachments == null) {
                        throw new System.ArgumentNullException.$ctor1("sourceAttachments");
                    }
                    if (outputAttachments == null) {
                        throw new System.ArgumentNullException.$ctor1("outputAttachments");
                    }
                    outputTexture.v = null;
                    if (additionalTexturePropertyIDsToCopy != null && additionalTextureIsLinear == null) {
                        additionalTextureIsLinear = System.Array.init(additionalTexturePropertyIDsToCopy.length, false, System.Boolean);
                        for (var i = 0; i < additionalTextureIsLinear.length; i = (i + 1) | 0) {
                            additionalTextureIsLinear[i] = true;
                        }
                    }

                    // Use these to detect and use shared regions.
                    Spine.Unity.AttachmentTools.AtlasUtilities.existingRegions.clear();
                    Spine.Unity.AttachmentTools.AtlasUtilities.regionIndices.clear();

                    // Collect all textures from original attachments.
                    var numTextureParamsToRepack = (1 + (additionalTexturePropertyIDsToCopy == null ? 0 : additionalTexturePropertyIDsToCopy.length)) | 0;
                    additionalOutputTextures = (additionalTexturePropertyIDsToCopy == null ? null : System.Array.init(additionalTexturePropertyIDsToCopy.length, null, UnityEngine.Texture2D));
                    if (Spine.Unity.AttachmentTools.AtlasUtilities.texturesToPackAtParam.length < numTextureParamsToRepack) {
                        System.Array.resize(Bridge.ref(Spine.Unity.AttachmentTools.AtlasUtilities, "texturesToPackAtParam"), numTextureParamsToRepack, null, System.Collections.Generic.List$1(UnityEngine.Texture2D));
                    }
                    for (var i1 = 0; i1 < numTextureParamsToRepack; i1 = (i1 + 1) | 0) {
                        if (Spine.Unity.AttachmentTools.AtlasUtilities.texturesToPackAtParam[i1] != null) {
                            Spine.Unity.AttachmentTools.AtlasUtilities.texturesToPackAtParam[i1].clear();
                        } else {
                            Spine.Unity.AttachmentTools.AtlasUtilities.texturesToPackAtParam[i1] = new (System.Collections.Generic.List$1(UnityEngine.Texture2D)).ctor();
                        }
                    }
                    Spine.Unity.AttachmentTools.AtlasUtilities.originalRegions.clear();

                    if (!Bridge.referenceEquals(sourceAttachments, outputAttachments)) {
                        outputAttachments.clear();
                        outputAttachments.AddRange(sourceAttachments);
                    }

                    var newRegionIndex = 0;
                    for (var attachmentIndex = 0, n = sourceAttachments.Count; attachmentIndex < n; attachmentIndex = (attachmentIndex + 1) | 0) {
                        var originalAttachment = sourceAttachments.getItem(attachmentIndex);

                        if (Bridge.is(originalAttachment, Spine.IHasTextureRegion)) {
                            var originalMeshAttachment = Bridge.as(originalAttachment, Spine.MeshAttachment);
                            var originalTextureAttachment = Bridge.cast(originalAttachment, Spine.IHasTextureRegion);

                            var newAttachment = (originalTextureAttachment.Spine$IHasTextureRegion$Sequence != null) ? originalAttachment : (originalMeshAttachment != null) ? originalMeshAttachment.NewLinkedMesh() : originalAttachment.Copy();
                            var newTextureAttachment = Bridge.cast(newAttachment, Spine.IHasTextureRegion);
                            var region = Bridge.as(newTextureAttachment.Spine$IHasTextureRegion$Region, Spine.AtlasRegion);
                            if (region == null && originalTextureAttachment.Spine$IHasTextureRegion$Sequence != null) {
                                region = Bridge.cast(($t = originalTextureAttachment.Spine$IHasTextureRegion$Sequence.Regions)[0], Spine.AtlasRegion);
                            }

                            var existingIndex = { };
                            if (Spine.Unity.AttachmentTools.AtlasUtilities.existingRegions.tryGetValue(region, existingIndex)) {
                                Spine.Unity.AttachmentTools.AtlasUtilities.regionIndices.add(existingIndex.v);
                            } else {
                                Spine.Unity.AttachmentTools.AtlasUtilities.existingRegions.add(region, newRegionIndex);
                                var originalSequence = originalTextureAttachment.Spine$IHasTextureRegion$Sequence;
                                if (originalSequence != null) {
                                    newTextureAttachment.Spine$IHasTextureRegion$Sequence = new Spine.Sequence.ctor(originalSequence);
                                    for (var i2 = 0, regionCount = originalSequence.Regions.length; i2 < regionCount; i2 = (i2 + 1) | 0) {
                                        var sequenceRegion = Bridge.cast(($t1 = originalSequence.Regions)[i2], Spine.AtlasRegion);
                                        Spine.Unity.AttachmentTools.AtlasUtilities.AddRegionTexturesToPack(numTextureParamsToRepack, sequenceRegion, textureFormat, mipmaps, additionalTextureFormats, additionalTexturePropertyIDsToCopy, additionalTextureIsLinear);
                                        Spine.Unity.AttachmentTools.AtlasUtilities.originalRegions.add(sequenceRegion);
                                        Spine.Unity.AttachmentTools.AtlasUtilities.regionIndices.add(newRegionIndex);
                                        newRegionIndex = (newRegionIndex + 1) | 0;
                                    }
                                } else {
                                    Spine.Unity.AttachmentTools.AtlasUtilities.AddRegionTexturesToPack(numTextureParamsToRepack, region, textureFormat, mipmaps, additionalTextureFormats, additionalTexturePropertyIDsToCopy, additionalTextureIsLinear);
                                    Spine.Unity.AttachmentTools.AtlasUtilities.originalRegions.add(region);
                                    Spine.Unity.AttachmentTools.AtlasUtilities.regionIndices.add(newRegionIndex);
                                    newRegionIndex = (newRegionIndex + 1) | 0;
                                }
                            }
                            outputAttachments.setItem(attachmentIndex, newAttachment);
                        } else {
                            outputAttachments.setItem(attachmentIndex, useOriginalNonrenderables ? originalAttachment : originalAttachment.Copy());
                            Spine.Unity.AttachmentTools.AtlasUtilities.regionIndices.add(Spine.Unity.AttachmentTools.AtlasUtilities.NonrenderingRegion); // Output attachments pairs with regionIndices list 1:1. Pad with a sentinel if the attachment doesn't have a region.
                        }
                    }

                    // Rehydrate the repacked textures as a Material, Spine atlas and Spine.AtlasAttachments
                    var newMaterial = new UnityEngine.Material.$ctor2(shader);
                    if (materialPropertySource != null) {
                        newMaterial.CopyPropertiesFromMaterial(materialPropertySource);
                        newMaterial.shaderKeywords = materialPropertySource.shaderKeywords;
                    }
                    newMaterial.name = newAssetName;

                    var rects = null;
                    for (var i3 = 0; i3 < numTextureParamsToRepack; i3 = (i3 + 1) | 0) {
                        // Fill a new texture with the collected attachment textures.
                        var newTexture = new UnityEngine.Texture2D.$ctor2(maxAtlasSize, maxAtlasSize, (i3 > 0 && additionalTextureFormats != null && ((i3 - 1) | 0) < additionalTextureFormats.length) ? additionalTextureFormats[((i3 - 1) | 0)] : textureFormat, mipmaps, (i3 > 0) ? additionalTextureIsLinear[((i3 - 1) | 0)] : false);
                        newTexture.mipMapBias = Spine.Unity.AttachmentTools.AtlasUtilities.DefaultMipmapBias;

                        var texturesToPack = Spine.Unity.AttachmentTools.AtlasUtilities.texturesToPackAtParam[i3];
                        if (texturesToPack.Count > 0) {
                            var sourceTexture = texturesToPack.getItem(0);
                            Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureAttributesFrom(newTexture, sourceTexture);
                        }
                        newTexture.name = newAssetName;
                        var rectsForTexParam = newTexture.PackTextures(texturesToPack.ToArray(), padding, maxAtlasSize);
                        if (i3 === 0) {
                            rects = rectsForTexParam;
                            newMaterial.mainTexture = newTexture;
                            outputTexture.v = newTexture;
                        } else {
                            newMaterial.SetTexture(additionalTexturePropertyIDsToCopy[((i3 - 1) | 0)], newTexture);
                            additionalOutputTextures[((i3 - 1) | 0)] = newTexture;
                        }
                    }

                    var page = Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage(newMaterial);
                    page.name = newAssetName;

                    Spine.Unity.AttachmentTools.AtlasUtilities.repackedRegions.clear();
                    for (var i4 = 0, n1 = Spine.Unity.AttachmentTools.AtlasUtilities.originalRegions.Count; i4 < n1; i4 = (i4 + 1) | 0) {
                        var oldRegion = Spine.Unity.AttachmentTools.AtlasUtilities.originalRegions.getItem(i4);
                        var newRegion = Spine.Unity.AttachmentTools.AtlasUtilities.UVRectToAtlasRegion(rects[i4], oldRegion, page);
                        Spine.Unity.AttachmentTools.AtlasUtilities.repackedRegions.add(newRegion);
                    }

                    // Map the cloned attachments to the repacked atlas.
                    for (var attachmentIndex1 = 0, repackedIndex = 0, n2 = outputAttachments.Count; attachmentIndex1 < n2; attachmentIndex1 = (attachmentIndex1 + 1) | 0, repackedIndex = (repackedIndex + 1) | 0) {

                        var attachment = outputAttachments.getItem(attachmentIndex1);
                        var textureAttachment = Bridge.as(attachment, Spine.IHasTextureRegion);
                        if (textureAttachment != null) {
                            if (textureAttachment.Spine$IHasTextureRegion$Sequence != null) {
                                var regions = textureAttachment.Spine$IHasTextureRegion$Sequence.Regions;
                                textureAttachment.Spine$IHasTextureRegion$Region = Spine.Unity.AttachmentTools.AtlasUtilities.repackedRegions.getItem(Spine.Unity.AttachmentTools.AtlasUtilities.regionIndices.getItem(repackedIndex));
                                for (var r = 0, regionCount1 = regions.length; r < regionCount1; r = (r + 1) | 0) {
                                    regions[r] = Spine.Unity.AttachmentTools.AtlasUtilities.repackedRegions.getItem(Spine.Unity.AttachmentTools.AtlasUtilities.regionIndices.getItem(Bridge.identity(repackedIndex, ((repackedIndex = (repackedIndex + 1) | 0)))));
                                }
                                repackedIndex = (repackedIndex - 1) | 0;
                            } else {
                                textureAttachment.Spine$IHasTextureRegion$Region = Spine.Unity.AttachmentTools.AtlasUtilities.repackedRegions.getItem(Spine.Unity.AttachmentTools.AtlasUtilities.regionIndices.getItem(repackedIndex));
                            }
                            textureAttachment.Spine$IHasTextureRegion$UpdateRegion();
                        }
                    }

                    // Clean up.
                    if (clearCache) {
                        Spine.Unity.AttachmentTools.AtlasUtilities.ClearCache();
                    }

                    outputMaterial.v = newMaterial;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedAttachments$1:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.AddRegionTexturesToPack:static start.*/
                AddRegionTexturesToPack: function (numTextureParamsToRepack, region, textureFormat, mipmaps, additionalTextureFormats, additionalTexturePropertyIDsToCopy, additionalTextureIsLinear) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#AddRegionTexturesToPack", this ); }


                    for (var i = 0; i < numTextureParamsToRepack; i = (i + 1) | 0) {
                        var regionTexture = (i === 0 ? Spine.Unity.AttachmentTools.AtlasUtilities.ToTexture(region, textureFormat, mipmaps) : Spine.Unity.AttachmentTools.AtlasUtilities.ToTexture(region, (additionalTextureFormats != null && ((i - 1) | 0) < additionalTextureFormats.length) ? additionalTextureFormats[((i - 1) | 0)] : textureFormat, mipmaps, additionalTexturePropertyIDsToCopy[((i - 1) | 0)], additionalTextureIsLinear[((i - 1) | 0)]));
                        Spine.Unity.AttachmentTools.AtlasUtilities.texturesToPackAtParam[i].add(regionTexture);
                    }
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.AddRegionTexturesToPack:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedSkin:static start.*/
                /**
                 * Creates and populates a duplicate skin with cloned attachments that are backed by a new packed texture atlas
                 comprised of all the regions from the original skin.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {Spine.Skin}                           o                                     
                 * @param   {string}                               newName                               
                 * @param   {UnityEngine.Material}                 materialPropertySource                
                 * @param   {UnityEngine.Material}                 outputMaterial                        
                 * @param   {UnityEngine.Texture2D}                outputTexture                         
                 * @param   {number}                               maxAtlasSize                          
                 * @param   {number}                               padding                               
                 * @param   {UnityEngine.TextureFormat}            textureFormat                         
                 * @param   {boolean}                              mipmaps                               
                 * @param   {boolean}                              useOriginalNonrenderables             
                 * @param   {boolean}                              clearCache                            When set to <pre><code>true</code></pre>, {@link } is called after
                 repacking to clear the texture cache. See remarks for additional info.
                 * @param   {Array.<number>}                       additionalTexturePropertyIDsToCopy    Optional additional textures (such as normal maps) to copy while repacking.
                 To copy e.g. the main texture and normal maps, pass 'new int[] { Shader.PropertyToID("_BumpMap") }' at this parameter.
                 * @param   {Array.<UnityEngine.Texture2D>}        additionalOutputTextures              When <pre><code>additionalTexturePropertyIDsToCopy</code></pre> is non-null,
                 this array will be filled with the resulting repacked texture for every property,
                 just as the main repacked texture is assigned to <pre><code>outputTexture</code></pre>.
                 * @param   {Array.<UnityEngine.TextureFormat>}    additionalTextureFormats              When <pre><code>additionalTexturePropertyIDsToCopy</code></pre> is non-null,
                 this array will be used as <pre><code>TextureFormat</code></pre> at the Texture at the respective property.
                 When <pre><code>additionalTextureFormats</code></pre> is <pre><code>null</code></pre> or when its array size is smaller,
                 <pre><code>textureFormat</code></pre> is used where there exists no corresponding array item.
                 * @param   {Array.<boolean>}                      additionalTextureIsLinear             When <pre><code>additionalTexturePropertyIDsToCopy</code></pre> is non-null,
                 this array will be used to determine whether <pre><code>linear</code></pre> or <pre><code>sRGB</code></pre> color space is used at the
                 Texture at the respective property. When <pre><code>additionalTextureIsLinear</code></pre> is <pre><code>null</code></pre>, <pre><code>linear</code></pre> color space
                 is assumed at every additional Texture element.
                 When e.g. packing the main texture and normal maps, pass 'new bool[] { true }' at this parameter, because normal maps use
                 linear color space.
                 * @return  {Spine.Skin}
                 */
                GetRepackedSkin: function (o, newName, materialPropertySource, outputMaterial, outputTexture, maxAtlasSize, padding, textureFormat, mipmaps, useOriginalNonrenderables, clearCache, additionalTexturePropertyIDsToCopy, additionalOutputTextures, additionalTextureFormats, additionalTextureIsLinear) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetRepackedSkin", this ); }

                    if (maxAtlasSize === void 0) { maxAtlasSize = 1024; }
                    if (padding === void 0) { padding = 2; }
                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (useOriginalNonrenderables === void 0) { useOriginalNonrenderables = true; }
                    if (clearCache === void 0) { clearCache = false; }
                    if (additionalTexturePropertyIDsToCopy === void 0) { additionalTexturePropertyIDsToCopy = null; }
                    if (additionalOutputTextures === void 0) { additionalOutputTextures = null; }
                    if (additionalTextureFormats === void 0) { additionalTextureFormats = null; }
                    if (additionalTextureIsLinear === void 0) { additionalTextureIsLinear = null; }

                    return Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedSkin$1(o, newName, materialPropertySource.shader, outputMaterial, outputTexture, maxAtlasSize, padding, textureFormat, mipmaps, materialPropertySource, clearCache, useOriginalNonrenderables, additionalTexturePropertyIDsToCopy, additionalOutputTextures, additionalTextureFormats, additionalTextureIsLinear);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedSkin:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedSkin$1:static start.*/
                /**
                 * Creates and populates a duplicate skin with cloned attachments that are backed by a new packed texture atlas
                 comprised of all the regions from the original skin.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {Spine.Skin}                           o                                     
                 * @param   {string}                               newName                               
                 * @param   {UnityEngine.Shader}                   shader                                
                 * @param   {UnityEngine.Material}                 outputMaterial                        
                 * @param   {UnityEngine.Texture2D}                outputTexture                         
                 * @param   {number}                               maxAtlasSize                          
                 * @param   {number}                               padding                               
                 * @param   {UnityEngine.TextureFormat}            textureFormat                         
                 * @param   {boolean}                              mipmaps                               
                 * @param   {UnityEngine.Material}                 materialPropertySource                
                 * @param   {boolean}                              clearCache                            
                 * @param   {boolean}                              useOriginalNonrenderables             
                 * @param   {Array.<number>}                       additionalTexturePropertyIDsToCopy    
                 * @param   {Array.<UnityEngine.Texture2D>}        additionalOutputTextures              
                 * @param   {Array.<UnityEngine.TextureFormat>}    additionalTextureFormats              
                 * @param   {Array.<boolean>}                      additionalTextureIsLinear
                 * @return  {Spine.Skin}
                 */
                GetRepackedSkin$1: function (o, newName, shader, outputMaterial, outputTexture, maxAtlasSize, padding, textureFormat, mipmaps, materialPropertySource, clearCache, useOriginalNonrenderables, additionalTexturePropertyIDsToCopy, additionalOutputTextures, additionalTextureFormats, additionalTextureIsLinear) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetRepackedSkin$1", this ); }

                    var $t, $t1;
                    if (maxAtlasSize === void 0) { maxAtlasSize = 1024; }
                    if (padding === void 0) { padding = 2; }
                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (materialPropertySource === void 0) { materialPropertySource = null; }
                    if (clearCache === void 0) { clearCache = false; }
                    if (useOriginalNonrenderables === void 0) { useOriginalNonrenderables = true; }
                    if (additionalTexturePropertyIDsToCopy === void 0) { additionalTexturePropertyIDsToCopy = null; }
                    if (additionalOutputTextures === void 0) { additionalOutputTextures = null; }
                    if (additionalTextureFormats === void 0) { additionalTextureFormats = null; }
                    if (additionalTextureIsLinear === void 0) { additionalTextureIsLinear = null; }

                    outputTexture.v = null;

                    if (o == null) {
                        throw new System.NullReferenceException.$ctor1("Skin was null");
                    }
                    var skinAttachments = o.Attachments;
                    var newSkin = new Spine.Skin(newName);

                    newSkin.Bones.AddRange(o.Bones);
                    newSkin.Constraints.AddRange(o.Constraints);

                    Spine.Unity.AttachmentTools.AtlasUtilities.inoutAttachments.clear();
                    $t = Bridge.getEnumerator(skinAttachments, Spine.Skin.SkinEntry);
                    try {
                        while ($t.moveNext()) {
                            var entry = $t.Current;
                            Spine.Unity.AttachmentTools.AtlasUtilities.inoutAttachments.add(entry.Attachment);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedAttachments(Spine.Unity.AttachmentTools.AtlasUtilities.inoutAttachments, Spine.Unity.AttachmentTools.AtlasUtilities.inoutAttachments, materialPropertySource, outputMaterial, outputTexture, maxAtlasSize, padding, textureFormat, mipmaps, newName, clearCache, useOriginalNonrenderables, additionalTexturePropertyIDsToCopy, additionalOutputTextures, additionalTextureFormats, additionalTextureIsLinear);
                    var i = 0;
                    $t1 = Bridge.getEnumerator(skinAttachments, Spine.Skin.SkinEntry);
                    try {
                        while ($t1.moveNext()) {
                            var originalSkinEntry = $t1.Current;
                            var newAttachment = Spine.Unity.AttachmentTools.AtlasUtilities.inoutAttachments.getItem(Bridge.identity(i, ((i = (i + 1) | 0))));
                            newSkin.SetAttachment(originalSkinEntry.SlotIndex, originalSkinEntry.Name, newAttachment);
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                    return newSkin;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedSkin$1:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToSprite:static start.*/
                ToSprite: function (ar, pixelsPerUnit) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToSprite", this ); }

                    if (pixelsPerUnit === void 0) { pixelsPerUnit = 100.0; }
                    return UnityEngine.Sprite.Create$1(Spine.Unity.AttachmentTools.AtlasUtilities.GetMainTexture(ar), Spine.Unity.AttachmentTools.AtlasUtilities.GetUnityRect(ar), new pc.Vec2( 0.5, 0.5 ), pixelsPerUnit);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToSprite:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ClearCache:static start.*/
                /**
                 * Frees up textures cached by repacking and remapping operations.
                 Calling {@link } with parameter <pre><code>premultiplyAlpha=true</code></pre>,
                 {@link } or {@link } will cache textures for later re-use,
                	which might steadily increase the texture memory footprint when used excessively.
                	You can clear this Texture cache by calling {@link }.
                 You may also want to call <pre><code>Resources.UnloadUnusedAssets()</code></pre> after that. Be aware that while this cleanup
                 frees up memory, it is also a costly operation and will likely cause a spike in the framerate.
                 Thus it is recommended to perform costly repacking and cleanup operations after e.g. a character customization
                 screen has been exited, and if required additionally after a certain number of <pre><code>GetRemappedClone()</code></pre> calls.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @return  {void}
                 */
                ClearCache: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ClearCache", this ); }

                    var $t;
                    $t = Bridge.getEnumerator(Spine.Unity.AttachmentTools.AtlasUtilities.CachedRegionTexturesList);
                    try {
                        while ($t.moveNext()) {
                            var t = $t.Current;
                            UnityEngine.Object.Destroy(t);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    Spine.Unity.AttachmentTools.AtlasUtilities.CachedRegionTextures.clear();
                    Spine.Unity.AttachmentTools.AtlasUtilities.CachedRegionTexturesList.clear();
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ClearCache:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToTexture:static start.*/
                /**
                 * Creates a new Texture2D object based on an AtlasRegion.
                 If applyImmediately is true, Texture2D.Apply is called immediately after the Texture2D is filled with data.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {Spine.AtlasRegion}            ar                   
                 * @param   {UnityEngine.TextureFormat}    textureFormat        
                 * @param   {boolean}                      mipmaps              
                 * @param   {number}                       texturePropertyId    
                 * @param   {boolean}                      linear               
                 * @param   {boolean}                      applyPMA
                 * @return  {UnityEngine.Texture2D}
                 */
                ToTexture: function (ar, textureFormat, mipmaps, texturePropertyId, linear, applyPMA) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToTexture", this ); }

                    var $t;
                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (texturePropertyId === void 0) { texturePropertyId = 0; }
                    if (linear === void 0) { linear = false; }
                    if (applyPMA === void 0) { applyPMA = false; }

                    var output = { };

                    var cacheKey = new Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey.$ctor1(texturePropertyId, ar);
                    Spine.Unity.AttachmentTools.AtlasUtilities.CachedRegionTextures.tryGetValue(cacheKey.$clone(), output);
                    if (output.v == null) {
                        var sourceTexture = texturePropertyId === 0 ? Spine.Unity.AttachmentTools.AtlasUtilities.GetMainTexture(ar) : Spine.Unity.AttachmentTools.AtlasUtilities.GetTexture(ar, texturePropertyId);
                        var r = Spine.Unity.AttachmentTools.AtlasUtilities.GetUnityRect(ar);
                        var width = Bridge.Int.clip32(r.width);
                        var height = Bridge.Int.clip32(r.height);
                        output.v = ($t = new UnityEngine.Texture2D.$ctor2(width, height, textureFormat, mipmaps, linear), $t.name = ar.name, $t);
                        Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureAttributesFrom(output.v, sourceTexture);
                        if (applyPMA) {
                            Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureApplyPMA(sourceTexture, r, output.v);
                        } else {
                            Spine.Unity.AttachmentTools.AtlasUtilities.CopyTexture(sourceTexture, r, output.v);
                        }
                        Spine.Unity.AttachmentTools.AtlasUtilities.CachedRegionTextures.add(cacheKey.$clone(), output.v);
                        Spine.Unity.AttachmentTools.AtlasUtilities.CachedRegionTexturesList.add(output.v);
                    }

                    return output.v;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToTexture:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToTexture$1:static start.*/
                ToTexture$1: function (s, textureFormat, mipmaps, linear, applyPMA) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToTexture$1", this ); }

                    var $t, $t1, $t2, $t3, $t4, $t5, $t6, $t7;
                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (linear === void 0) { linear = false; }
                    if (applyPMA === void 0) { applyPMA = false; }

                    var spriteTexture = s.texture;
                    var r = new UnityEngine.Rect();
                    if (!s.packed || s.packingMode === UnityEngine.SpritePackingMode.Rectangle) {
                        r = s.textureRect.$clone();
                    } else {
                        r = new UnityEngine.Rect.ctor();
                        r.xMin = Math.min(($t = s.uv)[0].x, ($t1 = s.uv)[1].x) * spriteTexture.width;
                        r.xMax = Math.max(($t2 = s.uv)[0].x, ($t3 = s.uv)[1].x) * spriteTexture.width;
                        r.yMin = Math.min(($t4 = s.uv)[0].y, ($t5 = s.uv)[2].y) * spriteTexture.height;
                        r.yMax = Math.max(($t6 = s.uv)[0].y, ($t7 = s.uv)[2].y) * spriteTexture.height;
                    }
                    var newTexture = new UnityEngine.Texture2D.$ctor2(Bridge.Int.clip32(r.width), Bridge.Int.clip32(r.height), textureFormat, mipmaps, linear);
                    Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureAttributesFrom(newTexture, spriteTexture);
                    if (applyPMA) {
                        Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureApplyPMA(spriteTexture, r, newTexture);
                    } else {
                        Spine.Unity.AttachmentTools.AtlasUtilities.CopyTexture(spriteTexture, r, newTexture);
                    }
                    return newTexture;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToTexture$1:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetClone:static start.*/
                GetClone: function (t, textureFormat, mipmaps, linear, applyPMA) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetClone", this ); }

                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (linear === void 0) { linear = false; }
                    if (applyPMA === void 0) { applyPMA = false; }

                    var newTexture = new UnityEngine.Texture2D.$ctor2(t.width, t.height, textureFormat, mipmaps, linear);
                    Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureAttributesFrom(newTexture, t);
                    if (applyPMA) {
                        Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureApplyPMA(t, new UnityEngine.Rect.$ctor1(0, 0, t.width, t.height), newTexture);
                    } else {
                        Spine.Unity.AttachmentTools.AtlasUtilities.CopyTexture(t, new UnityEngine.Rect.$ctor1(0, 0, t.width, t.height), newTexture);
                    }
                    return newTexture;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetClone:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.CopyTexture:static start.*/
                CopyTexture: function (source, sourceRect, destination) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#CopyTexture", this ); }

                    if (UnityEngine.SystemInfo.copyTextureSupport === UnityEngine.Rendering.CopyTextureSupport.None) {
                        // GetPixels fallback for old devices.
                        var pixelBuffer = source.GetPixels$2(Bridge.Int.clip32(sourceRect.x), Bridge.Int.clip32(sourceRect.y), Bridge.Int.clip32(sourceRect.width), Bridge.Int.clip32(sourceRect.height));
                        destination.SetPixels$1(pixelBuffer);
                        destination.Apply();
                    } else {
                        UnityEngine.Graphics.CopyTexture(source, 0, 0, Bridge.Int.clip32(sourceRect.x), Bridge.Int.clip32(sourceRect.y), Bridge.Int.clip32(sourceRect.width), Bridge.Int.clip32(sourceRect.height), destination, 0, 0, 0, 0);
                    }
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.CopyTexture:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureApplyPMA:static start.*/
                CopyTextureApplyPMA: function (source, sourceRect, destination) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#CopyTextureApplyPMA", this ); }

                    var pixelBuffer = source.GetPixels$2(Bridge.Int.clip32(sourceRect.x), Bridge.Int.clip32(sourceRect.y), Bridge.Int.clip32(sourceRect.width), Bridge.Int.clip32(sourceRect.height));
                    for (var i = 0, n = pixelBuffer.length; i < n; i = (i + 1) | 0) {
                        var p = pixelBuffer[i].$clone();
                        var a = p.a;
                        p.r = p.r * a;
                        p.g = p.g * a;
                        p.b = p.b * a;
                        pixelBuffer[i] = p.$clone();
                    }
                    destination.SetPixels$1(pixelBuffer);
                    destination.Apply();
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureApplyPMA:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.IsRenderable:static start.*/
                IsRenderable: function (a) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#IsRenderable", this ); }

                    return Bridge.is(a, Spine.IHasTextureRegion);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.IsRenderable:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.SpineUnityFlipRect:static start.*/
                /**
                 * Get a rect with flipped Y so that a Spine atlas rect gets converted to a Unity Sprite rect and vice versa.
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Rect}    rect             
                 * @param   {number}              textureHeight
                 * @return  {UnityEngine.Rect}
                 */
                SpineUnityFlipRect: function (rect, textureHeight) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#SpineUnityFlipRect", this ); }

                    rect.y = textureHeight - rect.y - rect.height;
                    return rect.$clone();
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.SpineUnityFlipRect:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetUnityRect:static start.*/
                /**
                 * Gets the Rect of an AtlasRegion according to Unity texture coordinates (x-right, y-up).
                 This overload relies on region.page.height being correctly set.
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {Spine.AtlasRegion}    region
                 * @return  {UnityEngine.Rect}
                 */
                GetUnityRect: function (region) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetUnityRect", this ); }

                    return Spine.Unity.AttachmentTools.AtlasUtilities.SpineUnityFlipRect(Spine.Unity.AttachmentTools.AtlasUtilities.GetSpineAtlasRect(region), region.page.height);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetUnityRect:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetUnityRect$1:static start.*/
                /**
                 * Gets the Rect of an AtlasRegion according to Unity texture coordinates (x-right, y-up).
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {Spine.AtlasRegion}    region           
                 * @param   {number}               textureHeight
                 * @return  {UnityEngine.Rect}
                 */
                GetUnityRect$1: function (region, textureHeight) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetUnityRect$1", this ); }

                    return Spine.Unity.AttachmentTools.AtlasUtilities.SpineUnityFlipRect(Spine.Unity.AttachmentTools.AtlasUtilities.GetSpineAtlasRect(region), textureHeight);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetUnityRect$1:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetSpineAtlasRect:static start.*/
                /**
                 * Returns a Rect of the AtlasRegion according to Spine texture coordinates. (x-right, y-down)
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {Spine.AtlasRegion}    region           
                 * @param   {boolean}              includeRotate
                 * @return  {UnityEngine.Rect}
                 */
                GetSpineAtlasRect: function (region, includeRotate) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetSpineAtlasRect", this ); }

                    if (includeRotate === void 0) { includeRotate = true; }
                    var width = region.packedWidth;
                    var height = region.packedHeight;
                    if (includeRotate && region.degrees === 270) {
                        width = region.packedHeight;
                        height = region.packedWidth;
                    }
                    return new UnityEngine.Rect.$ctor1(region.x, region.y, width, height);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetSpineAtlasRect:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.UVRectToTextureRect:static start.*/
                /**
                 * Denormalize a uvRect into a texture-space Rect.
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Rect}    uvRect       
                 * @param   {number}              texWidth     
                 * @param   {number}              texHeight
                 * @return  {UnityEngine.Rect}
                 */
                UVRectToTextureRect: function (uvRect, texWidth, texHeight) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#UVRectToTextureRect", this ); }

                    uvRect.x *= texWidth;
                    uvRect.width *= texWidth;
                    uvRect.y *= texHeight;
                    uvRect.height *= texHeight;
                    return uvRect.$clone();
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.UVRectToTextureRect:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.TextureRectToUVRect:static start.*/
                /**
                 * Normalize a texture Rect into UV coordinates.
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Rect}    textureRect    
                 * @param   {number}              texWidth       
                 * @param   {number}              texHeight
                 * @return  {UnityEngine.Rect}
                 */
                TextureRectToUVRect: function (textureRect, texWidth, texHeight) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#TextureRectToUVRect", this ); }

                    textureRect.x = pc.math.inverseLerp(0, texWidth, textureRect.x);
                    textureRect.y = pc.math.inverseLerp(0, texHeight, textureRect.y);
                    textureRect.width = pc.math.inverseLerp(0, texWidth, textureRect.width);
                    textureRect.height = pc.math.inverseLerp(0, texHeight, textureRect.height);
                    return textureRect.$clone();
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.TextureRectToUVRect:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.UVRectToAtlasRegion:static start.*/
                /**
                 * Creates a new Spine AtlasRegion according to a Unity UV Rect (x-right, y-up, uv-normalized).
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Rect}     uvRect             
                 * @param   {Spine.AtlasRegion}    referenceRegion    
                 * @param   {Spine.AtlasPage}      page
                 * @return  {Spine.AtlasRegion}
                 */
                UVRectToAtlasRegion: function (uvRect, referenceRegion, page) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#UVRectToAtlasRegion", this ); }

                    var $t;
                    var tr = Spine.Unity.AttachmentTools.AtlasUtilities.UVRectToTextureRect(uvRect.$clone(), page.width, page.height);
                    var rr = Spine.Unity.AttachmentTools.AtlasUtilities.SpineUnityFlipRect(tr, page.height);

                    var x = Bridge.Int.clip32(rr.x);
                    var y = Bridge.Int.clip32(rr.y);
                    var w = Bridge.Int.clip32(rr.width);
                    var h = Bridge.Int.clip32(rr.height);

                    if (referenceRegion.degrees === 270) {
                        var tempW = w;
                        w = h;
                        h = tempW;
                    }

                    // Note: originalW and originalH need to be scaled according to the
                    // repacked width and height, repacking can mess with aspect ratio, etc.
                    var originalW = Math.round(w * (referenceRegion.originalWidth / referenceRegion.width));
                    var originalH = Math.round(h * (referenceRegion.originalHeight / referenceRegion.height));

                    var offsetX = Math.round(referenceRegion.offsetX * (w / referenceRegion.width));
                    var offsetY = Math.round(referenceRegion.offsetY * (h / referenceRegion.height));

                    var u = uvRect.xMin;
                    var u2 = uvRect.xMax;
                    var v = uvRect.yMax;
                    var v2 = uvRect.yMin;

                    if (referenceRegion.degrees === 270) {
                        // at a 270 degree region, u2/v2 deltas and atlas width/height are swapped, and delta-v is negative.
                        var du = uvRect.width; // u2 - u;
                        var dv = uvRect.height; // v - v2;
                        var atlasAspectRatio = page.width / page.height;
                        u2 = u + (dv / atlasAspectRatio);
                        v2 = v - (du * atlasAspectRatio);
                    }

                    return ($t = new Spine.AtlasRegion(), $t.page = page, $t.name = referenceRegion.name, $t.u = u, $t.u2 = u2, $t.v = v, $t.v2 = v2, $t.index = -1, $t.width = w, $t.originalWidth = originalW, $t.height = h, $t.originalHeight = originalH, $t.offsetX = offsetX, $t.offsetY = offsetY, $t.x = x, $t.y = y, $t.rotate = referenceRegion.rotate, $t.degrees = referenceRegion.degrees, $t);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.UVRectToAtlasRegion:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetMainTexture:static start.*/
                /**
                 * Convenience method for getting the main texture of the material of the page of the region.
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {Spine.AtlasRegion}        region
                 * @return  {UnityEngine.Texture2D}
                 */
                GetMainTexture: function (region) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetMainTexture", this ); }

                    var material = (Bridge.as(region.page.rendererObject, UnityEngine.Material));
                    return Bridge.as(material.mainTexture, UnityEngine.Texture2D);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetMainTexture:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetTexture$1:static start.*/
                /**
                 * Convenience method for getting any texture of the material of the page of the region by texture property name.
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {Spine.AtlasRegion}        region                 
                 * @param   {string}                   texturePropertyName
                 * @return  {UnityEngine.Texture2D}
                 */
                GetTexture$1: function (region, texturePropertyName) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetTexture$1", this ); }

                    var material = (Bridge.as(region.page.rendererObject, UnityEngine.Material));
                    return Bridge.as(material.GetTexture$1(texturePropertyName), UnityEngine.Texture2D);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetTexture$1:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetTexture:static start.*/
                /**
                 * Convenience method for getting any texture of the material of the page of the region by texture property id.
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {Spine.AtlasRegion}        region               
                 * @param   {number}                   texturePropertyId
                 * @return  {UnityEngine.Texture2D}
                 */
                GetTexture: function (region, texturePropertyId) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetTexture", this ); }

                    var material = (Bridge.as(region.page.rendererObject, UnityEngine.Material));
                    return Bridge.as(material.GetTexture(texturePropertyId), UnityEngine.Texture2D);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetTexture:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureAttributesFrom:static start.*/
                CopyTextureAttributesFrom: function (destination, source) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#CopyTextureAttributesFrom", this ); }

                    destination.filterMode = source.filterMode;
                    destination.anisoLevel = source.anisoLevel;
                    destination.wrapModeU = source.wrapModeU;
                    destination.wrapModeV = source.wrapModeV;
                    destination.wrapModeW = source.wrapModeW;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureAttributesFrom:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.InverseLerp:static start.*/
                InverseLerp: function (a, b, value) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#InverseLerp", this ); }

                    return (value - a) / (b - a);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.InverseLerp:static end.*/


            }
        }
    });
    /*Spine.Unity.AttachmentTools.AtlasUtilities end.*/

    /*Spine.Unity.AttachmentTools.AtlasUtilities+IntAndAtlasRegionKey start.*/
    Bridge.define("Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#getDefaultValue", this ); }
 return new Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey(); }
            }
        },
        fields: {
            i: 0,
            region: null
        },
        ctors: {
            $ctor1: function (i, region) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#$ctor1", this ); }

                this.$initialize();
                this.i = i;
                this.region = region;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.Unity.AttachmentTools.AtlasUtilities+IntAndAtlasRegionKey.getHashCode start.*/
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#getHashCode", this ); }

                return Bridge.Int.mul(Bridge.getHashCode(this.i), 23) ^ Bridge.getHashCode(this.region);
            },
            /*Spine.Unity.AttachmentTools.AtlasUtilities+IntAndAtlasRegionKey.getHashCode end.*/

            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#equals", this ); }

                if (!Bridge.is(o, Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey)) {
                    return false;
                }
                return Bridge.equals(this.i, o.i) && Bridge.equals(this.region, o.region);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#$clone", this ); }

                var s = to || new Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey();
                s.i = this.i;
                s.region = this.region;
                return s;
            }
        },
        overloads: {
            "GetHashCode()": "getHashCode"
        }
    });
    /*Spine.Unity.AttachmentTools.AtlasUtilities+IntAndAtlasRegionKey end.*/

    /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions start.*/
    Bridge.define("Spine.Unity.AttachmentTools.AttachmentCloneExtensions", {
        statics: {
            methods: {
                /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetRemappedClone$1:static start.*/
                
                GetRemappedClone$1: function (o, sprite, sourceMaterial, premultiplyAlpha, cloneMeshAsLinked, useOriginalRegionSize, pivotShiftsMeshUVCoords, useOriginalRegionScale, pmaCloneTextureFormat, pmaCloneMipmaps) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentCloneExtensions#GetRemappedClone$1", this ); }

                    var $t;
                    if (premultiplyAlpha === void 0) { premultiplyAlpha = true; }
                    if (cloneMeshAsLinked === void 0) { cloneMeshAsLinked = true; }
                    if (useOriginalRegionSize === void 0) { useOriginalRegionSize = false; }
                    if (pivotShiftsMeshUVCoords === void 0) { pivotShiftsMeshUVCoords = true; }
                    if (useOriginalRegionScale === void 0) { useOriginalRegionScale = false; }
                    if (pmaCloneTextureFormat === void 0) { pmaCloneTextureFormat = 4; }
                    if (pmaCloneMipmaps === void 0) { pmaCloneMipmaps = false; }

                    var atlasRegion = premultiplyAlpha ? Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone(sprite, sourceMaterial, pmaCloneTextureFormat, pmaCloneMipmaps) : Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$1(sprite, ($t = new UnityEngine.Material.$ctor1(sourceMaterial), $t.mainTexture = sprite.texture, $t));
                    if (!pivotShiftsMeshUVCoords && Bridge.is(o, Spine.MeshAttachment)) {
                        // prevent non-central sprite pivot setting offsetX/Y and shifting uv coords out of mesh bounds
                        atlasRegion.offsetX = 0;
                        atlasRegion.offsetY = 0;
                    }
                    var scale = 1.0 / sprite.pixelsPerUnit;
                    if (useOriginalRegionScale) {
                        var regionAttachment = Bridge.as(o, Spine.RegionAttachment);
                        if (regionAttachment != null) {
                            scale = regionAttachment.Width / regionAttachment.Region.OriginalWidth;
                        }
                    }
                    return Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetRemappedClone(o, atlasRegion, cloneMeshAsLinked, useOriginalRegionSize, scale);
                },
                /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetRemappedClone$1:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetRemappedClone:static start.*/
                /**
                 * Gets a clone of the attachment remapped with an atlasRegion image.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentCloneExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentCloneExtensions
                 * @param   {Spine.Attachment}     o                        The original attachment.
                 * @param   {Spine.AtlasRegion}    atlasRegion              Atlas region.
                 * @param   {boolean}              cloneMeshAsLinked        If <pre><code>true</code></pre> MeshAttachments will be cloned as linked meshes and will inherit animation from the original attachment.
                 * @param   {boolean}              useOriginalRegionSize    If <pre><code>true</code></pre> the size of the original attachment will be followed, instead of using the Sprite size.
                 * @param   {number}               scale                    Unity units per pixel scale used to scale the atlas region size when not using the original region size.
                 * @return  {Spine.Attachment}                              The remapped clone.
                 */
                GetRemappedClone: function (o, atlasRegion, cloneMeshAsLinked, useOriginalRegionSize, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentCloneExtensions#GetRemappedClone", this ); }

                    if (cloneMeshAsLinked === void 0) { cloneMeshAsLinked = true; }
                    if (useOriginalRegionSize === void 0) { useOriginalRegionSize = false; }
                    if (scale === void 0) { scale = 0.01; }
                    var regionAttachment = Bridge.as(o, Spine.RegionAttachment);
                    if (regionAttachment != null) {
                        var newAttachment = Bridge.cast(regionAttachment.Copy(), Spine.RegionAttachment);
                        newAttachment.Region = atlasRegion;
                        if (!useOriginalRegionSize) {
                            newAttachment.Width = atlasRegion.width * scale;
                            newAttachment.Height = atlasRegion.height * scale;
                        }
                        newAttachment.UpdateRegion();
                        return newAttachment;
                    } else {
                        var meshAttachment = Bridge.as(o, Spine.MeshAttachment);
                        if (meshAttachment != null) {
                            var newAttachment1 = cloneMeshAsLinked ? meshAttachment.NewLinkedMesh() : Bridge.cast(meshAttachment.Copy(), Spine.MeshAttachment);
                            newAttachment1.Region = atlasRegion;
                            newAttachment1.UpdateRegion();
                            return newAttachment1;
                        }
                    }
                    return o.Copy();
                },
                /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetRemappedClone:static end.*/


            }
        }
    });
    /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions end.*/

    /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions start.*/
    Bridge.define("Spine.Unity.AttachmentTools.AttachmentRegionExtensions", {
        statics: {
            methods: {
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment$2:static start.*/
                /**
                 * Creates a RegionAttachment based on a sprite. This method creates a real, usable AtlasRegion. That AtlasRegion uses a new AtlasPage with the Material provided.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {UnityEngine.Sprite}        sprite      
                 * @param   {UnityEngine.Material}      material    
                 * @param   {number}                    rotation
                 * @return  {Spine.RegionAttachment}
                 */
                ToRegionAttachment$2: function (sprite, material, rotation) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachment$2", this ); }

                    if (rotation === void 0) { rotation = 0.0; }
                    return Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment$1(sprite, Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage(material), rotation);
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment$2:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment$1:static start.*/
                /**
                 * Creates a RegionAttachment based on a sprite. This method creates a real, usable AtlasRegion. That AtlasRegion uses the AtlasPage provided.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {UnityEngine.Sprite}        sprite      
                 * @param   {Spine.AtlasPage}           page        
                 * @param   {number}                    rotation
                 * @return  {Spine.RegionAttachment}
                 */
                ToRegionAttachment$1: function (sprite, page, rotation) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachment$1", this ); }

                    if (rotation === void 0) { rotation = 0.0; }
                    if (sprite == null) {
                        throw new System.ArgumentNullException.$ctor1("sprite");
                    }
                    if (page == null) {
                        throw new System.ArgumentNullException.$ctor1("page");
                    }
                    var region = Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion(sprite, page);
                    var unitsPerPixel = 1.0 / sprite.pixelsPerUnit;
                    return Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment(region, sprite.name, unitsPerPixel, rotation);
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment$1:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment:static start.*/
                /**
                 * Creates a new RegionAttachment from a given AtlasRegion.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {Spine.AtlasRegion}         region            
                 * @param   {string}                    attachmentName    
                 * @param   {number}                    scale             
                 * @param   {number}                    rotation
                 * @return  {Spine.RegionAttachment}
                 */
                ToRegionAttachment: function (region, attachmentName, scale, rotation) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachment", this ); }

                    if (scale === void 0) { scale = 0.01; }
                    if (rotation === void 0) { rotation = 0.0; }
                    if (System.String.isNullOrEmpty(attachmentName)) {
                        throw new System.ArgumentException.$ctor3("attachmentName can't be null or empty.", "attachmentName");
                    }
                    if (region == null) {
                        throw new System.ArgumentNullException.$ctor1("region");
                    }

                    // (AtlasAttachmentLoader.cs)
                    var attachment = new Spine.RegionAttachment.$ctor1(attachmentName);

                    attachment.Region = region;
                    attachment.Path = region.name;
                    attachment.ScaleX = 1;
                    attachment.ScaleY = 1;
                    attachment.Rotation = rotation;

                    attachment.R = 1;
                    attachment.G = 1;
                    attachment.B = 1;
                    attachment.A = 1;

                    // pass OriginalWidth and OriginalHeight because UpdateOffset uses it in its calculation.
                    var textreRegion = attachment.Region;
                    var atlasRegion = Bridge.as(textreRegion, Spine.AtlasRegion);
                    var originalWidth = atlasRegion != null ? atlasRegion.originalWidth : textreRegion.width;
                    var originalHeight = atlasRegion != null ? atlasRegion.originalHeight : textreRegion.height;
                    attachment.Width = originalWidth * scale;
                    attachment.Height = originalHeight * scale;

                    Spine.Unity.SkeletonExtensions.SetColor$2(attachment, new pc.Color( 1, 1, 1, 1 ));
                    attachment.UpdateRegion();
                    return attachment;
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachmentPMAClone$1:static start.*/
                /**
                 * Creates a Spine.AtlasRegion that uses a premultiplied alpha duplicate texture of the Sprite's texture data.
                 Returns a RegionAttachment that uses it. Use this if you plan to use a premultiply alpha shader such as "Spine/Skeleton".
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {UnityEngine.Sprite}           sprite                    
                 * @param   {UnityEngine.Shader}           shader                    
                 * @param   {UnityEngine.TextureFormat}    textureFormat             
                 * @param   {boolean}                      mipmaps                   
                 * @param   {UnityEngine.Material}         materialPropertySource    
                 * @param   {number}                       rotation
                 * @return  {Spine.RegionAttachment}
                 */
                ToRegionAttachmentPMAClone$1: function (sprite, shader, textureFormat, mipmaps, materialPropertySource, rotation) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachmentPMAClone$1", this ); }

                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (materialPropertySource === void 0) { materialPropertySource = null; }
                    if (rotation === void 0) { rotation = 0.0; }
                    if (sprite == null) {
                        throw new System.ArgumentNullException.$ctor1("sprite");
                    }
                    if (shader == null) {
                        throw new System.ArgumentNullException.$ctor1("shader");
                    }
                    var region = Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$1(sprite, shader, textureFormat, mipmaps, materialPropertySource);
                    var unitsPerPixel = 1.0 / sprite.pixelsPerUnit;
                    return Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment(region, sprite.name, unitsPerPixel, rotation);
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachmentPMAClone$1:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachmentPMAClone:static start.*/
                ToRegionAttachmentPMAClone: function (sprite, materialPropertySource, textureFormat, mipmaps, rotation) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachmentPMAClone", this ); }

                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (rotation === void 0) { rotation = 0.0; }
                    return Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachmentPMAClone$1(sprite, materialPropertySource.shader, textureFormat, mipmaps, materialPropertySource, rotation);
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachmentPMAClone:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetScale$1:static start.*/
                /**
                 * Sets the scale. Call regionAttachment.UpdateOffset to apply the change.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {Spine.RegionAttachment}    regionAttachment    
                 * @param   {UnityEngine.Vector2}       scale
                 * @return  {void}
                 */
                SetScale$1: function (regionAttachment, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetScale$1", this ); }

                    regionAttachment.ScaleX = scale.x;
                    regionAttachment.ScaleY = scale.y;
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetScale$1:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetScale:static start.*/
                /**
                 * Sets the scale. Call regionAttachment.UpdateOffset to apply the change.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {Spine.RegionAttachment}    regionAttachment    
                 * @param   {number}                    x                   
                 * @param   {number}                    y
                 * @return  {void}
                 */
                SetScale: function (regionAttachment, x, y) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetScale", this ); }

                    regionAttachment.ScaleX = x;
                    regionAttachment.ScaleY = y;
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetScale:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetPositionOffset$1:static start.*/
                /**
                 * Sets the position offset. Call regionAttachment.UpdateOffset to apply the change.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {Spine.RegionAttachment}    regionAttachment    
                 * @param   {UnityEngine.Vector2}       offset
                 * @return  {void}
                 */
                SetPositionOffset$1: function (regionAttachment, offset) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetPositionOffset$1", this ); }

                    regionAttachment.X = offset.x;
                    regionAttachment.Y = offset.y;
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetPositionOffset$1:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetPositionOffset:static start.*/
                /**
                 * Sets the position offset. Call regionAttachment.UpdateOffset to apply the change.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {Spine.RegionAttachment}    regionAttachment    
                 * @param   {number}                    x                   
                 * @param   {number}                    y
                 * @return  {void}
                 */
                SetPositionOffset: function (regionAttachment, x, y) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetPositionOffset", this ); }

                    regionAttachment.X = x;
                    regionAttachment.Y = y;
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetPositionOffset:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetRotation:static start.*/
                /**
                 * Sets the rotation. Call regionAttachment.UpdateOffset to apply the change.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {Spine.RegionAttachment}    regionAttachment    
                 * @param   {number}                    rotation
                 * @return  {void}
                 */
                SetRotation: function (regionAttachment, rotation) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetRotation", this ); }

                    regionAttachment.Rotation = rotation;
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetRotation:static end.*/


            }
        }
    });
    /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions end.*/

    /*Spine.Unity.BlendModeMaterials start.*/
    Bridge.define("Spine.Unity.BlendModeMaterials", {
        statics: {
            fields: {
                MATERIAL_SUFFIX_MULTIPLY: null,
                MATERIAL_SUFFIX_SCREEN: null,
                MATERIAL_SUFFIX_ADDITIVE: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterials#init", this ); }

                    this.MATERIAL_SUFFIX_MULTIPLY = "-Multiply";
                    this.MATERIAL_SUFFIX_SCREEN = "-Screen";
                    this.MATERIAL_SUFFIX_ADDITIVE = "-Additive";
                }
            },
            methods: {
                /*Spine.Unity.BlendModeMaterials.CreateAndAssignMaterials:static start.*/
                CreateAndAssignMaterials: function (skeletonDataAsset, templateMaterials, anyReplacementMaterialsChanged) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterials#CreateAndAssignMaterials", this ); }


                    return Spine.Unity.BlendModeMaterials.CreateAndAssignMaterials$1(skeletonDataAsset, templateMaterials, anyReplacementMaterialsChanged, function (asset) {
                        asset.Clear();
                    }, null, Spine.Unity.BlendModeMaterials.CreateForRegion);
                },
                /*Spine.Unity.BlendModeMaterials.CreateAndAssignMaterials:static end.*/

                /*Spine.Unity.BlendModeMaterials.CreateAndAssignMaterials$1:static start.*/
                CreateAndAssignMaterials$1: function (skeletonDataAsset, templateMaterials, anyReplacementMaterialsChanged, clearSkeletonDataAssetFunc, afterAssetModifiedFunc, createForRegionFunc) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterials#CreateAndAssignMaterials$1", this ); }

                    var $t, $t1, $t2;

                    var anyCreationFailed = false;
                    var blendModeMaterials = skeletonDataAsset.blendModeMaterials;
                    var applyAdditiveMaterial = blendModeMaterials.applyAdditiveMaterial;

                    var skinEntries = new (System.Collections.Generic.List$1(Spine.Skin.SkinEntry)).ctor();

                    clearSkeletonDataAssetFunc(skeletonDataAsset);
                    skeletonDataAsset.isUpgradingBlendModeMaterials = true;
                    var skeletonData = skeletonDataAsset.GetSkeletonData(true);

                    var slotsItems = skeletonData.Slots.Items;
                    for (var slotIndex = 0, slotCount = skeletonData.Slots.Count; slotIndex < slotCount; slotIndex = (slotIndex + 1) | 0) {
                        var slot = slotsItems[slotIndex];
                        if (slot.BlendMode === Spine.BlendMode.Normal) {
                            continue;
                        }
                        if (!applyAdditiveMaterial && slot.BlendMode === Spine.BlendMode.Additive) {
                            continue;
                        }

                        var replacementMaterials = { v : null };
                        var materialTemplate = null;
                        var materialSuffix = null;
                        switch (slot.BlendMode) {
                            case Spine.BlendMode.Multiply: 
                                replacementMaterials.v = blendModeMaterials.multiplyMaterials;
                                materialTemplate = templateMaterials.multiplyTemplate;
                                materialSuffix = Spine.Unity.BlendModeMaterials.MATERIAL_SUFFIX_MULTIPLY;
                                break;
                            case Spine.BlendMode.Screen: 
                                replacementMaterials.v = blendModeMaterials.screenMaterials;
                                materialTemplate = templateMaterials.screenTemplate;
                                materialSuffix = Spine.Unity.BlendModeMaterials.MATERIAL_SUFFIX_SCREEN;
                                break;
                            case Spine.BlendMode.Additive: 
                                replacementMaterials.v = blendModeMaterials.additiveMaterials;
                                materialTemplate = templateMaterials.additiveTemplate;
                                materialSuffix = Spine.Unity.BlendModeMaterials.MATERIAL_SUFFIX_ADDITIVE;
                                break;
                        }

                        skinEntries.clear();
                        $t = Bridge.getEnumerator(skeletonData.Skins);
                        try {
                            while ($t.moveNext()) {
                                var skin = $t.Current;
                                skin.GetAttachments(slotIndex, skinEntries);
                            }
                        } finally {
                            if (Bridge.is($t, System.IDisposable)) {
                                $t.System$IDisposable$Dispose();
                            }
                        }

                        $t1 = Bridge.getEnumerator(skinEntries);
                        try {
                            while ($t1.moveNext()) {
                                var entry = $t1.Current;
                                var renderableAttachment = Bridge.as(entry.Attachment, Spine.IHasTextureRegion);
                                if (renderableAttachment != null) {
                                    var originalRegion = Bridge.cast(renderableAttachment.Spine$IHasTextureRegion$Region, Spine.AtlasRegion);
                                    if (originalRegion != null) {
                                        anyCreationFailed = !!(anyCreationFailed | createForRegionFunc(replacementMaterials, anyReplacementMaterialsChanged, originalRegion, materialTemplate, materialSuffix, skeletonDataAsset));
                                    } else {
                                        var sequence = renderableAttachment.Spine$IHasTextureRegion$Sequence;
                                        if (sequence != null && sequence.Regions != null) {
                                            for (var i = 0, count = sequence.Regions.length; i < count; i = (i + 1) | 0) {
                                                originalRegion = Bridge.cast(($t2 = sequence.Regions)[i], Spine.AtlasRegion);
                                                anyCreationFailed = !!(anyCreationFailed | createForRegionFunc(replacementMaterials, anyReplacementMaterialsChanged, originalRegion, materialTemplate, materialSuffix, skeletonDataAsset));
                                            }
                                        }
                                    }
                                }
                            }
                        } finally {
                            if (Bridge.is($t1, System.IDisposable)) {
                                $t1.System$IDisposable$Dispose();
                            }
                        }
                    }
                    skeletonDataAsset.isUpgradingBlendModeMaterials = false;
                    if (!Bridge.staticEquals(afterAssetModifiedFunc, null)) {
                        afterAssetModifiedFunc(skeletonDataAsset);
                    }
                    return !anyCreationFailed;
                },
                /*Spine.Unity.BlendModeMaterials.CreateAndAssignMaterials$1:static end.*/

                /*Spine.Unity.BlendModeMaterials.CreateForRegion:static start.*/
                CreateForRegion: function (replacementMaterials, anyReplacementMaterialsChanged, originalRegion, materialTemplate, materialSuffix, skeletonDataAsset) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterials#CreateForRegion", this ); }


                    var anyCreationFailed = false;
                    var replacementExists = replacementMaterials.v.Exists(function (replacement) {
                        return Bridge.referenceEquals(replacement.pageName, originalRegion.page.name);
                    });
                    if (!replacementExists) {
                        var replacement = Spine.Unity.BlendModeMaterials.CreateReplacementMaterial(originalRegion, materialTemplate, materialSuffix);
                        if (replacement != null) {
                            replacementMaterials.v.add(replacement);
                            anyReplacementMaterialsChanged.v = true;
                        } else {
                            UnityEngine.Debug.LogError$2(System.String.format("Failed creating blend mode Material for SkeletonData asset '{0}', atlas page '{1}', template '{2}'.", skeletonDataAsset.name, originalRegion.page.name, materialTemplate.name), skeletonDataAsset);
                            anyCreationFailed = true;
                        }
                    }
                    return anyCreationFailed;
                },
                /*Spine.Unity.BlendModeMaterials.CreateForRegion:static end.*/

                /*Spine.Unity.BlendModeMaterials.CreateReplacementMaterial:static start.*/
                CreateReplacementMaterial: function (originalRegion, materialTemplate, materialSuffix) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterials#CreateReplacementMaterial", this ); }

                    var $t;

                    var newReplacement = new Spine.Unity.BlendModeMaterials.ReplacementMaterial();
                    var originalPage = originalRegion.page;
                    var originalMaterial = Bridge.as(originalPage.rendererObject, UnityEngine.Material);

                    newReplacement.pageName = originalPage.name;

                    var blendModeMaterial = ($t = new UnityEngine.Material.$ctor1(materialTemplate), $t.name = (originalMaterial.name || "") + " " + (materialTemplate.name || ""), $t.mainTexture = originalMaterial.mainTexture, $t);
                    newReplacement.material = blendModeMaterial;

                    if (UnityEngine.Object.op_Implicit(newReplacement.material)) {
                        return newReplacement;
                    } else {
                        return null;
                    }
                },
                /*Spine.Unity.BlendModeMaterials.CreateReplacementMaterial:static end.*/


            }
        },
        fields: {
            requiresBlendModeMaterials: false,
            applyAdditiveMaterial: false,
            additiveMaterials: null,
            multiplyMaterials: null,
            screenMaterials: null
        },
        props: {
            RequiresBlendModeMaterials: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterials#RequiresBlendModeMaterials#get", this ); }

                    return this.requiresBlendModeMaterials;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterials#RequiresBlendModeMaterials#set", this ); }

                    this.requiresBlendModeMaterials = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterials#init", this ); }

                this.requiresBlendModeMaterials = false;
                this.applyAdditiveMaterial = false;
                this.additiveMaterials = new (System.Collections.Generic.List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial)).ctor();
                this.multiplyMaterials = new (System.Collections.Generic.List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial)).ctor();
                this.screenMaterials = new (System.Collections.Generic.List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.BlendModeMaterials.BlendModeForMaterial start.*/
            BlendModeForMaterial: function (material) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterials#BlendModeForMaterial", this ); }

                var $t, $t1, $t2;
                $t = Bridge.getEnumerator(this.multiplyMaterials);
                try {
                    while ($t.moveNext()) {
                        var pair = $t.Current;
                        if (Bridge.referenceEquals(pair.material, material)) {
                            return Spine.BlendMode.Multiply;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                $t1 = Bridge.getEnumerator(this.additiveMaterials);
                try {
                    while ($t1.moveNext()) {
                        var pair1 = $t1.Current;
                        if (Bridge.referenceEquals(pair1.material, material)) {
                            return Spine.BlendMode.Additive;
                        }
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }
                $t2 = Bridge.getEnumerator(this.screenMaterials);
                try {
                    while ($t2.moveNext()) {
                        var pair2 = $t2.Current;
                        if (Bridge.referenceEquals(pair2.material, material)) {
                            return Spine.BlendMode.Screen;
                        }
                    }
                } finally {
                    if (Bridge.is($t2, System.IDisposable)) {
                        $t2.System$IDisposable$Dispose();
                    }
                }
                return Spine.BlendMode.Normal;
            },
            /*Spine.Unity.BlendModeMaterials.BlendModeForMaterial end.*/

            /*Spine.Unity.BlendModeMaterials.UpdateBlendmodeMaterialsRequiredState start.*/
            UpdateBlendmodeMaterialsRequiredState: function (skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterials#UpdateBlendmodeMaterialsRequiredState", this ); }

                var $t, $t1;
                this.requiresBlendModeMaterials = false;

                if (skeletonData == null) {
                    return false;
                }

                var skinEntries = new (System.Collections.Generic.List$1(Spine.Skin.SkinEntry)).ctor();
                var slotsItems = skeletonData.Slots.Items;
                for (var slotIndex = 0, slotCount = skeletonData.Slots.Count; slotIndex < slotCount; slotIndex = (slotIndex + 1) | 0) {
                    var slot = slotsItems[slotIndex];
                    if (slot.BlendMode === Spine.BlendMode.Normal) {
                        continue;
                    }
                    if (!this.applyAdditiveMaterial && slot.BlendMode === Spine.BlendMode.Additive) {
                        continue;
                    }

                    skinEntries.clear();
                    $t = Bridge.getEnumerator(skeletonData.Skins);
                    try {
                        while ($t.moveNext()) {
                            var skin = $t.Current;
                            skin.GetAttachments(slotIndex, skinEntries);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    $t1 = Bridge.getEnumerator(skinEntries);
                    try {
                        while ($t1.moveNext()) {
                            var entry = $t1.Current;
                            if (Bridge.is(entry.Attachment, Spine.IHasTextureRegion)) {
                                this.requiresBlendModeMaterials = true;
                                return true;
                            }
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                }
                return false;
            },
            /*Spine.Unity.BlendModeMaterials.UpdateBlendmodeMaterialsRequiredState end.*/

            /*Spine.Unity.BlendModeMaterials.ApplyMaterials start.*/
            ApplyMaterials: function (skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterials#ApplyMaterials", this ); }

                var $t, $t1;
                if (skeletonData == null) {
                    throw new System.ArgumentNullException.$ctor1("skeletonData");
                }
                if (!this.requiresBlendModeMaterials) {
                    return;
                }

                var skinEntries = new (System.Collections.Generic.List$1(Spine.Skin.SkinEntry)).ctor();
                var slotsItems = skeletonData.Slots.Items;
                for (var slotIndex = 0, slotCount = skeletonData.Slots.Count; slotIndex < slotCount; slotIndex = (slotIndex + 1) | 0) {
                    var slot = slotsItems[slotIndex];
                    if (slot.BlendMode === Spine.BlendMode.Normal) {
                        continue;
                    }
                    if (!this.applyAdditiveMaterial && slot.BlendMode === Spine.BlendMode.Additive) {
                        continue;
                    }

                    var replacementMaterials = null;
                    switch (slot.BlendMode) {
                        case Spine.BlendMode.Multiply: 
                            replacementMaterials = this.multiplyMaterials;
                            break;
                        case Spine.BlendMode.Screen: 
                            replacementMaterials = this.screenMaterials;
                            break;
                        case Spine.BlendMode.Additive: 
                            replacementMaterials = this.additiveMaterials;
                            break;
                    }
                    if (replacementMaterials == null) {
                        continue;
                    }

                    skinEntries.clear();
                    $t = Bridge.getEnumerator(skeletonData.Skins);
                    try {
                        while ($t.moveNext()) {
                            var skin = $t.Current;
                            skin.GetAttachments(slotIndex, skinEntries);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    $t1 = Bridge.getEnumerator(skinEntries);
                    try {
                        while ($t1.moveNext()) {
                            var entry = $t1.Current;
                            var renderableAttachment = Bridge.as(entry.Attachment, Spine.IHasTextureRegion);
                            if (renderableAttachment != null) {
                                if (renderableAttachment.Spine$IHasTextureRegion$Region != null) {
                                    renderableAttachment.Spine$IHasTextureRegion$Region = this.CloneAtlasRegionWithMaterial(Bridge.cast(renderableAttachment.Spine$IHasTextureRegion$Region, Spine.AtlasRegion), replacementMaterials);
                                } else {
                                    if (renderableAttachment.Spine$IHasTextureRegion$Sequence != null) {
                                        var regions = renderableAttachment.Spine$IHasTextureRegion$Sequence.Regions;
                                        for (var i = 0; i < regions.length; i = (i + 1) | 0) {
                                            regions[i] = this.CloneAtlasRegionWithMaterial(Bridge.cast(regions[i], Spine.AtlasRegion), replacementMaterials);
                                        }
                                    }
                                }
                            }
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                }
            },
            /*Spine.Unity.BlendModeMaterials.ApplyMaterials end.*/

            /*Spine.Unity.BlendModeMaterials.CloneAtlasRegionWithMaterial start.*/
            CloneAtlasRegionWithMaterial: function (originalRegion, replacementMaterials) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterials#CloneAtlasRegionWithMaterial", this ); }

                var $t;
                var newRegion = originalRegion.Clone();
                var material = null;
                $t = Bridge.getEnumerator(replacementMaterials);
                try {
                    while ($t.moveNext()) {
                        var replacement = $t.Current;
                        if (Bridge.referenceEquals(replacement.pageName, originalRegion.page.name)) {
                            material = replacement.material;
                            break;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                var originalPage = originalRegion.page;
                var newPage = originalPage.Clone();
                newPage.rendererObject = material;
                newRegion.page = newPage;
                return newRegion;
            },
            /*Spine.Unity.BlendModeMaterials.CloneAtlasRegionWithMaterial end.*/


        }
    });
    /*Spine.Unity.BlendModeMaterials end.*/

    /*Spine.Unity.BlendModeMaterials+ReplacementMaterial start.*/
    Bridge.define("Spine.Unity.BlendModeMaterials.ReplacementMaterial", {
        $kind: 1002,
        fields: {
            pageName: null,
            material: null
        }
    });
    /*Spine.Unity.BlendModeMaterials+ReplacementMaterial end.*/

    /*Spine.Unity.BlendModeMaterials+TemplateMaterials start.*/
    Bridge.define("Spine.Unity.BlendModeMaterials.TemplateMaterials", {
        $kind: 1002,
        fields: {
            additiveTemplate: null,
            multiplyTemplate: null,
            screenTemplate: null
        }
    });
    /*Spine.Unity.BlendModeMaterials+TemplateMaterials end.*/

    /*Spine.Unity.SkeletonDataModifierAsset start.*/
    /**
     * Can be stored by SkeletonDataAsset to automatically apply modifications to loaded SkeletonData.
     *
     * @abstract
     * @public
     * @class Spine.Unity.SkeletonDataModifierAsset
     * @augments UnityEngine.ScriptableObject
     */
    Bridge.define("Spine.Unity.SkeletonDataModifierAsset", {
        inherits: [UnityEngine.ScriptableObject]
    });
    /*Spine.Unity.SkeletonDataModifierAsset end.*/

    /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache start.*/
    Bridge.define("Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache", {
        inherits: [System.IDisposable],
        $kind: 1002,
        fields: {
            cache: null
        },
        alias: ["Dispose", "System$IDisposable$Dispose"],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#init", this ); }

                this.cache = new (System.Collections.Generic.Dictionary$2(System.Collections.Generic.KeyValuePair$2(Spine.AtlasPage,UnityEngine.Material),Spine.AtlasPage)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache.CloneAtlasRegionWithMaterial start.*/
            /**
             * Creates a clone of an AtlasRegion that uses different Material settings, while retaining the original texture.
             *
             * @instance
             * @public
             * @this Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache
             * @memberof Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache
             * @param   {Spine.AtlasRegion}       originalRegion      
             * @param   {UnityEngine.Material}    materialTemplate
             * @return  {Spine.AtlasRegion}
             */
            CloneAtlasRegionWithMaterial: function (originalRegion, materialTemplate) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#CloneAtlasRegionWithMaterial", this ); }

                var newRegion = originalRegion.Clone();
                newRegion.page = this.GetAtlasPageWithMaterial(originalRegion.page, materialTemplate);
                return newRegion;
            },
            /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache.CloneAtlasRegionWithMaterial end.*/

            /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache.GetAtlasPageWithMaterial start.*/
            GetAtlasPageWithMaterial: function (originalPage, materialTemplate) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#GetAtlasPageWithMaterial", this ); }

                var $t;
                if (originalPage == null) {
                    throw new System.ArgumentNullException.$ctor1("originalPage");
                }

                var newPage = { v : null };
                var key = new (System.Collections.Generic.KeyValuePair$2(Spine.AtlasPage,UnityEngine.Material)).$ctor1(originalPage, materialTemplate);
                this.cache.tryGetValue(key, newPage);

                if (newPage.v == null) {
                    newPage.v = originalPage.Clone();
                    var originalMaterial = Bridge.as(originalPage.rendererObject, UnityEngine.Material);
                    newPage.v.rendererObject = ($t = new UnityEngine.Material.$ctor1(materialTemplate), $t.name = (originalMaterial.name || "") + " " + (materialTemplate.name || ""), $t.mainTexture = originalMaterial.mainTexture, $t);
                    this.cache.add(key, newPage.v);
                }

                return newPage.v;
            },
            /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache.GetAtlasPageWithMaterial end.*/

            /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache.Dispose start.*/
            Dispose: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#Dispose", this ); }

                this.cache.clear();
            },
            /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache.Dispose end.*/


        }
    });
    /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache end.*/

    /*Spine.Unity.BoneFollower start.*/
    /**
     * Sets a GameObject's transform to match a bone on a Spine skeleton.
     *
     * @public
     * @class Spine.Unity.BoneFollower
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Spine.Unity.BoneFollower", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonRenderer: null,
            /**
             * If a bone isn't set in code, boneName is used to find the bone at the beginning. For runtime switching by name, use SetBoneByName. You can also set the BoneFollower.bone field directly.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.BoneFollower
             * @type string
             */
            boneName: null,
            followXYPosition: false,
            followZPosition: false,
            followBoneRotation: false,
            followSkeletonFlip: false,
            followLocalScale: false,
            followParentWorldScale: false,
            maintainedAxisOrientation: 0,
            initializeOnAwake: false,
            valid: false,
            bone: null,
            skeletonTransform: null,
            skeletonTransformIsParent: false
        },
        props: {
            SkeletonRenderer: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#SkeletonRenderer#get", this ); }

                    return this.skeletonRenderer;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#SkeletonRenderer#set", this ); }

                    this.skeletonRenderer = value;
                    this.Initialize();
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#init", this ); }

                this.followXYPosition = true;
                this.followZPosition = true;
                this.followBoneRotation = true;
                this.followSkeletonFlip = true;
                this.followLocalScale = false;
                this.followParentWorldScale = false;
                this.maintainedAxisOrientation = Spine.Unity.BoneFollower.AxisOrientation.XAxis;
                this.initializeOnAwake = true;
            }
        },
        methods: {
            /*Spine.Unity.BoneFollower.SetBone start.*/
            /**
             * Sets the target bone by its bone name. Returns false if no bone was found. To set the bone by reference, use BoneFollower.bone directly.
             *
             * @instance
             * @public
             * @this Spine.Unity.BoneFollower
             * @memberof Spine.Unity.BoneFollower
             * @param   {string}     name
             * @return  {boolean}
             */
            SetBone: function (name) {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#SetBone", this ); }

                this.bone = this.skeletonRenderer.skeleton.FindBone(name);
                if (this.bone == null) {
                    UnityEngine.Debug.LogError$2("Bone not found: " + (name || ""), this);
                    return false;
                }
                this.boneName = name;
                return true;
            },
            /*Spine.Unity.BoneFollower.SetBone end.*/

            /*Spine.Unity.BoneFollower.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#Awake", this ); }

                if (this.initializeOnAwake) {
                    this.Initialize();
                }
            },
            /*Spine.Unity.BoneFollower.Awake end.*/

            /*Spine.Unity.BoneFollower.HandleRebuildRenderer start.*/
            HandleRebuildRenderer: function (skeletonRenderer) {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#HandleRebuildRenderer", this ); }

                this.Initialize();
            },
            /*Spine.Unity.BoneFollower.HandleRebuildRenderer end.*/

            /*Spine.Unity.BoneFollower.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#Initialize", this ); }

                this.bone = null;
                this.valid = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) && this.skeletonRenderer.valid;
                if (!this.valid) {
                    return;
                }

                this.skeletonTransform = this.skeletonRenderer.transform;
                this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuildRenderer));
                this.skeletonRenderer.addOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuildRenderer));
                this.skeletonTransformIsParent = Bridge.referenceEquals(this.skeletonTransform, this.transform.parent);

                if (!System.String.isNullOrEmpty(this.boneName)) {
                    this.bone = this.skeletonRenderer.skeleton.FindBone(this.boneName);
                }

            },
            /*Spine.Unity.BoneFollower.Initialize end.*/

            /*Spine.Unity.BoneFollower.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#OnDestroy", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuildRenderer));
                }
            },
            /*Spine.Unity.BoneFollower.OnDestroy end.*/

            /*Spine.Unity.BoneFollower.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#LateUpdate", this ); }

                var $t, $t1;
                if (!this.valid) {
                    this.Initialize();
                    return;
                }


                if (this.bone == null) {
                    if (System.String.isNullOrEmpty(this.boneName)) {
                        return;
                    }
                    this.bone = this.skeletonRenderer.skeleton.FindBone(this.boneName);
                    if (!this.SetBone(this.boneName)) {
                        return;
                    }
                }

                var thisTransform = this.transform;
                var additionalFlipScale = 1;
                if (this.skeletonTransformIsParent) {
                    // Recommended setup: Use local transform properties if Spine GameObject is the immediate parent
                    thisTransform.localPosition = new pc.Vec3( this.followXYPosition ? this.bone.WorldX : thisTransform.localPosition.x, this.followXYPosition ? this.bone.WorldY : thisTransform.localPosition.y, this.followZPosition ? 0.0 : thisTransform.localPosition.z );
                    if (this.followBoneRotation) {
                        var halfRotation = Math.atan2(this.bone.C, this.bone.A) * 0.5;
                        if (this.followLocalScale && this.bone.ScaleX < 0) {
                            halfRotation += 1.57079637;
                        }

                        var q = Bridge.getDefaultValue(UnityEngine.Quaternion);
                        q.z = Math.sin(halfRotation);
                        q.w = Math.cos(halfRotation);
                        thisTransform.localRotation = q.$clone();
                    }
                } else {
                    // For special cases: Use transform world properties if transform relationship is complicated
                    var targetWorldPosition = this.skeletonTransform.TransformPoint$1(new pc.Vec3( this.bone.WorldX, this.bone.WorldY, 0.0 ));
                    if (!this.followZPosition) {
                        targetWorldPosition.z = thisTransform.position.z;
                    }
                    if (!this.followXYPosition) {
                        targetWorldPosition.x = thisTransform.position.x;
                        targetWorldPosition.y = thisTransform.position.y;
                    }

                    var skeletonLossyScale = this.skeletonTransform.lossyScale.$clone();
                    var transformParent = thisTransform.parent;
                    var parentLossyScale = UnityEngine.Component.op_Inequality(transformParent, null) ? transformParent.lossyScale.$clone() : new pc.Vec3( 1, 1, 1 );
                    if (this.followBoneRotation) {
                        var boneWorldRotation = this.bone.WorldRotationX;

                        if ((skeletonLossyScale.x * skeletonLossyScale.y) < 0) {
                            boneWorldRotation = -boneWorldRotation;
                        }

                        if (this.followSkeletonFlip || this.maintainedAxisOrientation === Spine.Unity.BoneFollower.AxisOrientation.XAxis) {
                            if ((skeletonLossyScale.x * parentLossyScale.x < 0)) {
                                boneWorldRotation += 180.0;
                            }
                        } else {
                            if ((skeletonLossyScale.y * parentLossyScale.y < 0)) {
                                boneWorldRotation += 180.0;
                            }
                        }

                        var worldRotation = this.skeletonTransform.rotation.getPositiveEulerAngles().$clone();
                        if (this.followLocalScale && this.bone.ScaleX < 0) {
                            boneWorldRotation += 180.0;
                        }
                        thisTransform.SetPositionAndRotation(targetWorldPosition, new pc.Quat().setFromEulerAngles_Unity( worldRotation.x, worldRotation.y, worldRotation.z + boneWorldRotation ));
                    } else {
                        thisTransform.position = targetWorldPosition.$clone();
                    }

                    additionalFlipScale = ($t = skeletonLossyScale.x * parentLossyScale.x * skeletonLossyScale.y * parentLossyScale.y, ($t === 0 ? 1 : Math.sign($t)));
                }

                var parentBone = this.bone.Parent;
                if (this.followParentWorldScale || this.followLocalScale || this.followSkeletonFlip) {
                    var localScale = new pc.Vec3( 1.0, 1.0, 1.0 );
                    if (this.followParentWorldScale && parentBone != null) {
                        localScale = new pc.Vec3( parentBone.WorldScaleX, parentBone.WorldScaleY, 1.0 );
                    }
                    if (this.followLocalScale) {
                        localScale.mul( new pc.Vec3( this.bone.ScaleX, this.bone.ScaleY, 1.0 ) );
                    }
                    if (this.followSkeletonFlip) {
                        localScale.y *= ($t1 = this.bone.Skeleton.ScaleX * this.bone.Skeleton.ScaleY, ($t1 === 0 ? 1 : Math.sign($t1))) * additionalFlipScale;
                    }
                    thisTransform.localScale = localScale.$clone();
                }
            },
            /*Spine.Unity.BoneFollower.LateUpdate end.*/


        }
    });
    /*Spine.Unity.BoneFollower end.*/

    /*Spine.Unity.BoneFollower+AxisOrientation start.*/
    Bridge.define("Spine.Unity.BoneFollower.AxisOrientation", {
        $kind: 1006,
        statics: {
            fields: {
                XAxis: 1,
                YAxis: 2
            }
        }
    });
    /*Spine.Unity.BoneFollower+AxisOrientation end.*/

    /*Spine.Unity.BoneFollowerGraphic start.*/
    Bridge.define("Spine.Unity.BoneFollowerGraphic", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonGraphic: null,
            initializeOnAwake: false,
            /**
             * If a bone isn't set in code, boneName is used to find the bone at the beginning. For runtime switching by name, use SetBoneByName. You can also set the BoneFollower.bone field directly.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.BoneFollowerGraphic
             * @type string
             */
            boneName: null,
            followBoneRotation: false,
            followSkeletonFlip: false,
            followLocalScale: false,
            followParentWorldScale: false,
            followXYPosition: false,
            followZPosition: false,
            maintainedAxisOrientation: 0,
            bone: null,
            skeletonTransform: null,
            skeletonTransformIsParent: false,
            valid: false
        },
        props: {
            SkeletonGraphic: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollowerGraphic#SkeletonGraphic#get", this ); }

                    return this.skeletonGraphic;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollowerGraphic#SkeletonGraphic#set", this ); }

                    this.skeletonGraphic = value;
                    this.Initialize();
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollowerGraphic#init", this ); }

                this.initializeOnAwake = true;
                this.followBoneRotation = true;
                this.followSkeletonFlip = true;
                this.followLocalScale = false;
                this.followParentWorldScale = false;
                this.followXYPosition = true;
                this.followZPosition = true;
                this.maintainedAxisOrientation = Spine.Unity.BoneFollower.AxisOrientation.XAxis;
            }
        },
        methods: {
            /*Spine.Unity.BoneFollowerGraphic.SetBone start.*/
            /**
             * Sets the target bone by its bone name. Returns false if no bone was found.
             *
             * @instance
             * @public
             * @this Spine.Unity.BoneFollowerGraphic
             * @memberof Spine.Unity.BoneFollowerGraphic
             * @param   {string}     name
             * @return  {boolean}
             */
            SetBone: function (name) {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollowerGraphic#SetBone", this ); }

                this.bone = this.skeletonGraphic.Skeleton.FindBone(name);
                if (this.bone == null) {
                    UnityEngine.Debug.LogError$2("Bone not found: " + (name || ""), this);
                    return false;
                }
                this.boneName = name;
                return true;
            },
            /*Spine.Unity.BoneFollowerGraphic.SetBone end.*/

            /*Spine.Unity.BoneFollowerGraphic.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollowerGraphic#Awake", this ); }

                if (this.initializeOnAwake) {
                    this.Initialize();
                }
            },
            /*Spine.Unity.BoneFollowerGraphic.Awake end.*/

            /*Spine.Unity.BoneFollowerGraphic.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollowerGraphic#Initialize", this ); }

                this.bone = null;
                this.valid = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null) && this.skeletonGraphic.IsValid;
                if (!this.valid) {
                    return;
                }

                this.skeletonTransform = this.skeletonGraphic.transform;
                //			skeletonGraphic.OnRebuild -= HandleRebuildRenderer;
                //			skeletonGraphic.OnRebuild += HandleRebuildRenderer;
                this.skeletonTransformIsParent = Bridge.referenceEquals(this.skeletonTransform, this.transform.parent);

                if (!System.String.isNullOrEmpty(this.boneName)) {
                    this.bone = this.skeletonGraphic.Skeleton.FindBone(this.boneName);
                }

            },
            /*Spine.Unity.BoneFollowerGraphic.Initialize end.*/

            /*Spine.Unity.BoneFollowerGraphic.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollowerGraphic#LateUpdate", this ); }

                var $t, $t1;
                if (!this.valid) {
                    this.Initialize();
                    return;
                }


                if (this.bone == null) {
                    if (System.String.isNullOrEmpty(this.boneName)) {
                        return;
                    }
                    this.bone = this.skeletonGraphic.Skeleton.FindBone(this.boneName);
                    if (!this.SetBone(this.boneName)) {
                        return;
                    }
                }

                var thisTransform = Bridge.as(this.transform, UnityEngine.RectTransform);
                if (UnityEngine.Component.op_Equality(thisTransform, null)) {
                    return;
                }

                var scale = this.skeletonGraphic.MeshScale;
                var offset = this.skeletonGraphic.MeshOffset.$clone();

                var additionalFlipScale = 1;
                if (this.skeletonTransformIsParent) {
                    // Recommended setup: Use local transform properties if Spine GameObject is the immediate parent
                    thisTransform.localPosition = new pc.Vec3( this.followXYPosition ? this.bone.WorldX * scale + offset.x : thisTransform.localPosition.x, this.followXYPosition ? this.bone.WorldY * scale + offset.y : thisTransform.localPosition.y, this.followZPosition ? 0.0 : thisTransform.localPosition.z );
                    if (this.followBoneRotation) {
                        thisTransform.localRotation = Spine.Unity.SkeletonExtensions.GetQuaternion(this.bone);
                    }
                } else {
                    // For special cases: Use transform world properties if transform relationship is complicated
                    var targetWorldPosition = this.skeletonTransform.TransformPoint$1(new pc.Vec3( this.bone.WorldX * scale + offset.x, this.bone.WorldY * scale + offset.y, 0.0 ));
                    if (!this.followZPosition) {
                        targetWorldPosition.z = thisTransform.position.z;
                    }
                    if (!this.followXYPosition) {
                        targetWorldPosition.x = thisTransform.position.x;
                        targetWorldPosition.y = thisTransform.position.y;
                    }

                    var skeletonLossyScale = this.skeletonTransform.lossyScale.$clone();
                    var transformParent = thisTransform.parent;
                    var parentLossyScale = UnityEngine.Component.op_Inequality(transformParent, null) ? transformParent.lossyScale.$clone() : new pc.Vec3( 1, 1, 1 );
                    if (this.followBoneRotation) {
                        var boneWorldRotation = this.bone.WorldRotationX;

                        if ((skeletonLossyScale.x * skeletonLossyScale.y) < 0) {
                            boneWorldRotation = -boneWorldRotation;
                        }

                        if (this.followSkeletonFlip || this.maintainedAxisOrientation === Spine.Unity.BoneFollower.AxisOrientation.XAxis) {
                            if ((skeletonLossyScale.x * parentLossyScale.x < 0)) {
                                boneWorldRotation += 180.0;
                            }
                        } else {
                            if ((skeletonLossyScale.y * parentLossyScale.y < 0)) {
                                boneWorldRotation += 180.0;
                            }
                        }

                        var worldRotation = this.skeletonTransform.rotation.getPositiveEulerAngles().$clone();
                        if (this.followLocalScale && this.bone.ScaleX < 0) {
                            boneWorldRotation += 180.0;
                        }
                        thisTransform.SetPositionAndRotation(targetWorldPosition, new pc.Quat().setFromEulerAngles_Unity( worldRotation.x, worldRotation.y, worldRotation.z + boneWorldRotation ));
                    } else {
                        thisTransform.position = targetWorldPosition.$clone();
                    }

                    additionalFlipScale = ($t = skeletonLossyScale.x * parentLossyScale.x * skeletonLossyScale.y * parentLossyScale.y, ($t === 0 ? 1 : Math.sign($t)));
                }

                var parentBone = this.bone.Parent;
                if (this.followParentWorldScale || this.followLocalScale || this.followSkeletonFlip) {
                    var localScale = new pc.Vec3( 1.0, 1.0, 1.0 );
                    if (this.followParentWorldScale && parentBone != null) {
                        localScale = new pc.Vec3( parentBone.WorldScaleX, parentBone.WorldScaleY, 1.0 );
                    }
                    if (this.followLocalScale) {
                        localScale.mul( new pc.Vec3( this.bone.ScaleX, this.bone.ScaleY, 1.0 ) );
                    }
                    if (this.followSkeletonFlip) {
                        localScale.y *= ($t1 = this.bone.Skeleton.ScaleX * this.bone.Skeleton.ScaleY, ($t1 === 0 ? 1 : Math.sign($t1))) * additionalFlipScale;
                    }
                    thisTransform.localScale = localScale.$clone();
                }
            },
            /*Spine.Unity.BoneFollowerGraphic.LateUpdate end.*/


        }
    });
    /*Spine.Unity.BoneFollowerGraphic end.*/

    /*Spine.Unity.BoundingBoxFollower start.*/
    Bridge.define("Spine.Unity.BoundingBoxFollower", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                DebugMessages: false
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#init", this ); }

                    this.DebugMessages = true;
                }
            }
        },
        fields: {
            skeletonRenderer: null,
            slotName: null,
            isTrigger: false,
            usedByEffector: false,
            usedByComposite: false,
            clearStateOnDisable: false,
            slot: null,
            currentAttachment: null,
            currentAttachmentName: null,
            currentCollider: null,
            colliderTable: null,
            nameTable: null
        },
        props: {
            Slot: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#Slot#get", this ); }

                    return this.slot;
                }
            },
            CurrentAttachment: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#CurrentAttachment#get", this ); }

                    return this.currentAttachment;
                }
            },
            CurrentAttachmentName: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#CurrentAttachmentName#get", this ); }

                    return this.currentAttachmentName;
                }
            },
            CurrentCollider: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#CurrentCollider#get", this ); }

                    return this.currentCollider;
                }
            },
            IsTrigger: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#IsTrigger#get", this ); }

                    return this.isTrigger;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#init", this ); }

                this.clearStateOnDisable = true;
                this.colliderTable = new (System.Collections.Generic.Dictionary$2(Spine.BoundingBoxAttachment,UnityEngine.PolygonCollider2D)).ctor();
                this.nameTable = new (System.Collections.Generic.Dictionary$2(Spine.BoundingBoxAttachment,System.String)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.BoundingBoxFollower.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#Start", this ); }

                this.Initialize();
            },
            /*Spine.Unity.BoundingBoxFollower.Start end.*/

            /*Spine.Unity.BoundingBoxFollower.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#OnEnable", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuild));
                    this.skeletonRenderer.addOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuild));
                }

                this.Initialize();
            },
            /*Spine.Unity.BoundingBoxFollower.OnEnable end.*/

            /*Spine.Unity.BoundingBoxFollower.HandleRebuild start.*/
            HandleRebuild: function (sr) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#HandleRebuild", this ); }

                //if (BoundingBoxFollower.DebugMessages) Debug.Log("Skeleton was rebuilt. Repopulating BoundingBoxFollower.");
                this.Initialize();
            },
            /*Spine.Unity.BoundingBoxFollower.HandleRebuild end.*/

            /*Spine.Unity.BoundingBoxFollower.Initialize start.*/
            /**
             * Initialize and instantiate the BoundingBoxFollower colliders. This is method checks if the BoundingBoxFollower has already been initialized for the skeleton instance and slotName and prevents overwriting unless it detects a new setup.
             *
             * @instance
             * @public
             * @this Spine.Unity.BoundingBoxFollower
             * @memberof Spine.Unity.BoundingBoxFollower
             * @param   {boolean}    overwrite
             * @return  {void}
             */
            Initialize: function (overwrite) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#Initialize", this ); }

                var $t;
                if (overwrite === void 0) { overwrite = false; }
                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    return;
                }

                this.skeletonRenderer.Initialize(false);

                if (System.String.isNullOrEmpty(this.slotName)) {
                    return;
                }

                // Don't reinitialize if the setup did not change.
                if (!overwrite && this.colliderTable.Count > 0 && this.slot != null && Bridge.referenceEquals(this.skeletonRenderer.skeleton, this.slot.Skeleton) && Bridge.referenceEquals(this.slotName, this.slot.Data.Name)) {
                    return;
                }

                this.slot = null;
                this.currentAttachment = null;
                this.currentAttachmentName = null;
                this.currentCollider = null;
                this.colliderTable.clear();
                this.nameTable.clear();

                var skeleton = this.skeletonRenderer.skeleton;
                if (skeleton == null) {
                    return;
                }
                this.slot = skeleton.FindSlot(this.slotName);
                if (this.slot == null) {
                    if (Spine.Unity.BoundingBoxFollower.DebugMessages) {
                        UnityEngine.Debug.LogWarning$1(System.String.format("Slot '{0}' not found for BoundingBoxFollower on '{1}'. (Previous colliders were disposed.)", this.slotName, this.gameObject.name));
                    }
                    return;
                }
                var slotIndex = this.slot.Data.Index;

                var requiredCollidersCount = { v : 0 };
                var colliders = this.GetComponents(UnityEngine.PolygonCollider2D);
                if (this.gameObject.activeInHierarchy) {
                    $t = Bridge.getEnumerator(skeleton.Data.Skins);
                    try {
                        while ($t.moveNext()) {
                            var skin = $t.Current;
                            this.AddCollidersForSkin(skin, slotIndex, colliders, requiredCollidersCount);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    if (skeleton.Skin != null) {
                        this.AddCollidersForSkin(skeleton.Skin, slotIndex, colliders, requiredCollidersCount);
                    }
                }
                this.DisposeExcessCollidersAfter(requiredCollidersCount.v);

                if (Spine.Unity.BoundingBoxFollower.DebugMessages) {
                    var valid = this.colliderTable.Count !== 0;
                    if (!valid) {
                        if (this.gameObject.activeInHierarchy) {
                            UnityEngine.Debug.LogWarning$1("Bounding Box Follower not valid! Slot [" + (this.slotName || "") + "] does not contain any Bounding Box Attachments!");
                        } else {
                            UnityEngine.Debug.LogWarning$1("Bounding Box Follower tried to rebuild as a prefab.");
                        }
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollower.Initialize end.*/

            /*Spine.Unity.BoundingBoxFollower.AddCollidersForSkin start.*/
            AddCollidersForSkin: function (skin, slotIndex, previousColliders, collidersCount) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#AddCollidersForSkin", this ); }

                var $t;
                if (skin == null) {
                    return;
                }
                var skinEntries = new (System.Collections.Generic.List$1(Spine.Skin.SkinEntry)).ctor();
                skin.GetAttachments(slotIndex, skinEntries);

                $t = Bridge.getEnumerator(skinEntries);
                try {
                    while ($t.moveNext()) {
                        var entry = $t.Current;
                        var attachment = skin.GetAttachment(slotIndex, entry.Name);
                        var boundingBoxAttachment = Bridge.as(attachment, Spine.BoundingBoxAttachment);

                        if (Spine.Unity.BoundingBoxFollower.DebugMessages && attachment != null && boundingBoxAttachment == null) {
                            UnityEngine.Debug.Log$1("BoundingBoxFollower tried to follow a slot that contains non-boundingbox attachments: " + (this.slotName || ""));
                        }

                        if (boundingBoxAttachment != null) {
                            if (!this.colliderTable.containsKey(boundingBoxAttachment)) {
                                var bbCollider = collidersCount.v < previousColliders.length ? previousColliders[collidersCount.v] : this.gameObject.AddComponent(UnityEngine.PolygonCollider2D);
                                collidersCount.v = (collidersCount.v + 1) | 0;
                                Spine.Unity.SkeletonUtility.SetColliderPointsLocal(bbCollider, this.slot, boundingBoxAttachment);
                                bbCollider.isTrigger = this.isTrigger;
                                bbCollider.usedByEffector = this.usedByEffector;
                                bbCollider.usedByComposite = this.usedByComposite;
                                bbCollider.enabled = false;
                                bbCollider.hideFlags = UnityEngine.HideFlags.NotEditable;
                                this.colliderTable.add(boundingBoxAttachment, bbCollider);
                                this.nameTable.add(boundingBoxAttachment, entry.Name);
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollower.AddCollidersForSkin end.*/

            /*Spine.Unity.BoundingBoxFollower.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#OnDisable", this ); }

                if (this.clearStateOnDisable) {
                    this.ClearState();
                }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuild));
                }
            },
            /*Spine.Unity.BoundingBoxFollower.OnDisable end.*/

            /*Spine.Unity.BoundingBoxFollower.ClearState start.*/
            ClearState: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#ClearState", this ); }

                var $t;
                if (this.colliderTable != null) {
                    $t = Bridge.getEnumerator(this.colliderTable.Values);
                    try {
                        while ($t.moveNext()) {
                            var col = $t.Current;
                            col.enabled = false;
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }

                this.currentAttachment = null;
                this.currentAttachmentName = null;
                this.currentCollider = null;
            },
            /*Spine.Unity.BoundingBoxFollower.ClearState end.*/

            /*Spine.Unity.BoundingBoxFollower.DisposeExcessCollidersAfter start.*/
            DisposeExcessCollidersAfter: function (requiredCount) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#DisposeExcessCollidersAfter", this ); }

                var colliders = this.GetComponents(UnityEngine.PolygonCollider2D);
                if (colliders.length === 0) {
                    return;
                }

                for (var i = requiredCount; i < colliders.length; i = (i + 1) | 0) {
                    var collider = colliders[i];
                    if (UnityEngine.Component.op_Inequality(collider, null)) {
                        UnityEngine.Object.Destroy(collider);
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollower.DisposeExcessCollidersAfter end.*/

            /*Spine.Unity.BoundingBoxFollower.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#LateUpdate", this ); }

                if (this.slot != null && !Bridge.referenceEquals(this.slot.Attachment, this.currentAttachment)) {
                    this.MatchAttachment(this.slot.Attachment);
                }
            },
            /*Spine.Unity.BoundingBoxFollower.LateUpdate end.*/

            /*Spine.Unity.BoundingBoxFollower.MatchAttachment start.*/
            /**
             * Sets the current collider to match attachment.
             *
             * @instance
             * @private
             * @this Spine.Unity.BoundingBoxFollower
             * @memberof Spine.Unity.BoundingBoxFollower
             * @param   {Spine.Attachment}    attachment    If the attachment is not a bounding box, it will be treated as null.
             * @return  {void}
             */
            MatchAttachment: function (attachment) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#MatchAttachment", this ); }

                var bbAttachment = Bridge.as(attachment, Spine.BoundingBoxAttachment);

                if (Spine.Unity.BoundingBoxFollower.DebugMessages && attachment != null && bbAttachment == null) {
                    UnityEngine.Debug.LogWarning$1("BoundingBoxFollower tried to match a non-boundingbox attachment. It will treat it as null.");
                }

                if (UnityEngine.Component.op_Inequality(this.currentCollider, null)) {
                    this.currentCollider.enabled = false;
                }

                if (bbAttachment == null) {
                    this.currentCollider = null;
                    this.currentAttachment = null;
                    this.currentAttachmentName = null;
                } else {
                    var foundCollider = { };
                    this.colliderTable.tryGetValue(bbAttachment, foundCollider);
                    if (UnityEngine.Component.op_Inequality(foundCollider.v, null)) {
                        this.currentCollider = foundCollider.v;
                        this.currentCollider.enabled = true;
                        this.currentAttachment = bbAttachment;
                        this.currentAttachmentName = this.nameTable.getItem(bbAttachment);
                    } else {
                        this.currentCollider = null;
                        this.currentAttachment = bbAttachment;
                        this.currentAttachmentName = null;
                        if (Spine.Unity.BoundingBoxFollower.DebugMessages) {
                            UnityEngine.Debug.LogFormat("Collider for BoundingBoxAttachment named '{0}' was not initialized. It is possibly from a new skin. currentAttachmentName will be null. You may need to call BoundingBoxFollower.Initialize(overwrite: true);", [bbAttachment.Name]);
                        }
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollower.MatchAttachment end.*/


        }
    });
    /*Spine.Unity.BoundingBoxFollower end.*/

    /*Spine.Unity.BoundingBoxFollowerGraphic start.*/
    Bridge.define("Spine.Unity.BoundingBoxFollowerGraphic", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                DebugMessages: false
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#init", this ); }

                    this.DebugMessages = true;
                }
            }
        },
        fields: {
            skeletonGraphic: null,
            slotName: null,
            isTrigger: false,
            usedByEffector: false,
            usedByComposite: false,
            clearStateOnDisable: false,
            slot: null,
            currentAttachment: null,
            currentAttachmentName: null,
            currentCollider: null,
            colliderTable: null,
            nameTable: null
        },
        props: {
            Slot: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#Slot#get", this ); }

                    return this.slot;
                }
            },
            CurrentAttachment: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#CurrentAttachment#get", this ); }

                    return this.currentAttachment;
                }
            },
            CurrentAttachmentName: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#CurrentAttachmentName#get", this ); }

                    return this.currentAttachmentName;
                }
            },
            CurrentCollider: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#CurrentCollider#get", this ); }

                    return this.currentCollider;
                }
            },
            IsTrigger: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#IsTrigger#get", this ); }

                    return this.isTrigger;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#init", this ); }

                this.clearStateOnDisable = true;
                this.colliderTable = new (System.Collections.Generic.Dictionary$2(Spine.BoundingBoxAttachment,UnityEngine.PolygonCollider2D)).ctor();
                this.nameTable = new (System.Collections.Generic.Dictionary$2(Spine.BoundingBoxAttachment,System.String)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.BoundingBoxFollowerGraphic.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#Start", this ); }

                this.Initialize();
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.Start end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#OnEnable", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    this.skeletonGraphic.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuild));
                    this.skeletonGraphic.addOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuild));
                }

                this.Initialize();
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.OnEnable end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.HandleRebuild start.*/
            HandleRebuild: function (sr) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#HandleRebuild", this ); }

                //if (BoundingBoxFollowerGraphic.DebugMessages) Debug.Log("Skeleton was rebuilt. Repopulating BoundingBoxFollowerGraphic.");
                this.Initialize();
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.HandleRebuild end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.Initialize start.*/
            /**
             * Initialize and instantiate the BoundingBoxFollowerGraphic colliders. This is method checks if the BoundingBoxFollowerGraphic has already been initialized for the skeleton instance and slotName and prevents overwriting unless it detects a new setup.
             *
             * @instance
             * @public
             * @this Spine.Unity.BoundingBoxFollowerGraphic
             * @memberof Spine.Unity.BoundingBoxFollowerGraphic
             * @param   {boolean}    overwrite
             * @return  {void}
             */
            Initialize: function (overwrite) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#Initialize", this ); }

                var $t;
                if (overwrite === void 0) { overwrite = false; }
                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    return;
                }

                this.skeletonGraphic.Initialize(false);

                if (System.String.isNullOrEmpty(this.slotName)) {
                    return;
                }

                // Don't reinitialize if the setup did not change.
                if (!overwrite && this.colliderTable.Count > 0 && this.slot != null && Bridge.referenceEquals(this.skeletonGraphic.Skeleton, this.slot.Skeleton) && Bridge.referenceEquals(this.slotName, this.slot.Data.Name)) {
                    return;
                }

                this.slot = null;
                this.currentAttachment = null;
                this.currentAttachmentName = null;
                this.currentCollider = null;
                this.colliderTable.clear();
                this.nameTable.clear();

                var skeleton = this.skeletonGraphic.Skeleton;
                if (skeleton == null) {
                    return;
                }
                this.slot = skeleton.FindSlot(this.slotName);
                if (this.slot == null) {
                    if (Spine.Unity.BoundingBoxFollowerGraphic.DebugMessages) {
                        UnityEngine.Debug.LogWarning$1(System.String.format("Slot '{0}' not found for BoundingBoxFollowerGraphic on '{1}'. (Previous colliders were disposed.)", this.slotName, this.gameObject.name));
                    }
                    return;
                }
                var slotIndex = this.slot.Data.Index;

                var requiredCollidersCount = { v : 0 };
                var colliders = this.GetComponents(UnityEngine.PolygonCollider2D);
                if (this.gameObject.activeInHierarchy) {
                    var scale = this.skeletonGraphic.MeshScale;
                    $t = Bridge.getEnumerator(skeleton.Data.Skins);
                    try {
                        while ($t.moveNext()) {
                            var skin = $t.Current;
                            this.AddCollidersForSkin(skin, slotIndex, colliders, scale, requiredCollidersCount);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    if (skeleton.Skin != null) {
                        this.AddCollidersForSkin(skeleton.Skin, slotIndex, colliders, scale, requiredCollidersCount);
                    }
                }
                this.DisposeExcessCollidersAfter(requiredCollidersCount.v);

                if (Spine.Unity.BoundingBoxFollowerGraphic.DebugMessages) {
                    var valid = this.colliderTable.Count !== 0;
                    if (!valid) {
                        if (this.gameObject.activeInHierarchy) {
                            UnityEngine.Debug.LogWarning$1("Bounding Box Follower not valid! Slot [" + (this.slotName || "") + "] does not contain any Bounding Box Attachments!");
                        } else {
                            UnityEngine.Debug.LogWarning$1("Bounding Box Follower tried to rebuild as a prefab.");
                        }
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.Initialize end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.AddCollidersForSkin start.*/
            AddCollidersForSkin: function (skin, slotIndex, previousColliders, scale, collidersCount) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#AddCollidersForSkin", this ); }

                var $t;
                if (skin == null) {
                    return;
                }
                var skinEntries = new (System.Collections.Generic.List$1(Spine.Skin.SkinEntry)).ctor();
                skin.GetAttachments(slotIndex, skinEntries);

                $t = Bridge.getEnumerator(skinEntries);
                try {
                    while ($t.moveNext()) {
                        var entry = $t.Current;
                        var attachment = skin.GetAttachment(slotIndex, entry.Name);
                        var boundingBoxAttachment = Bridge.as(attachment, Spine.BoundingBoxAttachment);

                        if (Spine.Unity.BoundingBoxFollowerGraphic.DebugMessages && attachment != null && boundingBoxAttachment == null) {
                            UnityEngine.Debug.Log$1("BoundingBoxFollowerGraphic tried to follow a slot that contains non-boundingbox attachments: " + (this.slotName || ""));
                        }

                        if (boundingBoxAttachment != null) {
                            if (!this.colliderTable.containsKey(boundingBoxAttachment)) {
                                var bbCollider = collidersCount.v < previousColliders.length ? previousColliders[collidersCount.v] : this.gameObject.AddComponent(UnityEngine.PolygonCollider2D);
                                collidersCount.v = (collidersCount.v + 1) | 0;
                                Spine.Unity.SkeletonUtility.SetColliderPointsLocal(bbCollider, this.slot, boundingBoxAttachment, scale);
                                bbCollider.isTrigger = this.isTrigger;
                                bbCollider.usedByEffector = this.usedByEffector;
                                bbCollider.usedByComposite = this.usedByComposite;
                                bbCollider.enabled = false;
                                bbCollider.hideFlags = UnityEngine.HideFlags.NotEditable;
                                this.colliderTable.add(boundingBoxAttachment, bbCollider);
                                this.nameTable.add(boundingBoxAttachment, entry.Name);
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.AddCollidersForSkin end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#OnDisable", this ); }

                if (this.clearStateOnDisable) {
                    this.ClearState();
                }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    this.skeletonGraphic.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuild));
                }
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.OnDisable end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.ClearState start.*/
            ClearState: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#ClearState", this ); }

                var $t;
                if (this.colliderTable != null) {
                    $t = Bridge.getEnumerator(this.colliderTable.Values);
                    try {
                        while ($t.moveNext()) {
                            var col = $t.Current;
                            col.enabled = false;
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }

                this.currentAttachment = null;
                this.currentAttachmentName = null;
                this.currentCollider = null;
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.ClearState end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.DisposeExcessCollidersAfter start.*/
            DisposeExcessCollidersAfter: function (requiredCount) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#DisposeExcessCollidersAfter", this ); }

                var colliders = this.GetComponents(UnityEngine.PolygonCollider2D);
                if (colliders.length === 0) {
                    return;
                }

                for (var i = requiredCount; i < colliders.length; i = (i + 1) | 0) {
                    var collider = colliders[i];
                    if (UnityEngine.Component.op_Inequality(collider, null)) {
                        UnityEngine.Object.Destroy(collider);
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.DisposeExcessCollidersAfter end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#LateUpdate", this ); }

                if (this.slot != null && !Bridge.referenceEquals(this.slot.Attachment, this.currentAttachment)) {
                    this.MatchAttachment(this.slot.Attachment);
                }
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.LateUpdate end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.MatchAttachment start.*/
            /**
             * Sets the current collider to match attachment.
             *
             * @instance
             * @private
             * @this Spine.Unity.BoundingBoxFollowerGraphic
             * @memberof Spine.Unity.BoundingBoxFollowerGraphic
             * @param   {Spine.Attachment}    attachment    If the attachment is not a bounding box, it will be treated as null.
             * @return  {void}
             */
            MatchAttachment: function (attachment) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#MatchAttachment", this ); }

                var bbAttachment = Bridge.as(attachment, Spine.BoundingBoxAttachment);

                if (Spine.Unity.BoundingBoxFollowerGraphic.DebugMessages && attachment != null && bbAttachment == null) {
                    UnityEngine.Debug.LogWarning$1("BoundingBoxFollowerGraphic tried to match a non-boundingbox attachment. It will treat it as null.");
                }

                if (UnityEngine.Component.op_Inequality(this.currentCollider, null)) {
                    this.currentCollider.enabled = false;
                }

                if (bbAttachment == null) {
                    this.currentCollider = null;
                    this.currentAttachment = null;
                    this.currentAttachmentName = null;
                } else {
                    var foundCollider = { };
                    this.colliderTable.tryGetValue(bbAttachment, foundCollider);
                    if (UnityEngine.Component.op_Inequality(foundCollider.v, null)) {
                        this.currentCollider = foundCollider.v;
                        this.currentCollider.enabled = true;
                        this.currentAttachment = bbAttachment;
                        this.currentAttachmentName = this.nameTable.getItem(bbAttachment);
                    } else {
                        this.currentCollider = null;
                        this.currentAttachment = bbAttachment;
                        this.currentAttachmentName = null;
                        if (Spine.Unity.BoundingBoxFollowerGraphic.DebugMessages) {
                            UnityEngine.Debug.LogFormat("Collider for BoundingBoxAttachment named '{0}' was not initialized. It is possibly from a new skin. currentAttachmentName will be null. You may need to call BoundingBoxFollowerGraphic.Initialize(overwrite: true);", [bbAttachment.Name]);
                        }
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.MatchAttachment end.*/


        }
    });
    /*Spine.Unity.BoundingBoxFollowerGraphic end.*/

    /*Spine.Unity.DoubleBuffered$1 start.*/
    Bridge.define("Spine.Unity.DoubleBuffered$1", function (T) { return {
        fields: {
            a: null,
            b: null,
            usingA: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.DoubleBuffered$1#init", this ); }

                this.a = Bridge.createInstance(T);
                this.b = Bridge.createInstance(T);
            }
        },
        methods: {
            /*Spine.Unity.DoubleBuffered$1.GetCurrent start.*/
            GetCurrent: function () {
if ( TRACE ) { TRACE( "Spine.Unity.DoubleBuffered$1#GetCurrent", this ); }

                return this.usingA ? Bridge.rValue(this.a) : Bridge.rValue(this.b);
            },
            /*Spine.Unity.DoubleBuffered$1.GetCurrent end.*/

            /*Spine.Unity.DoubleBuffered$1.GetNext start.*/
            GetNext: function () {
if ( TRACE ) { TRACE( "Spine.Unity.DoubleBuffered$1#GetNext", this ); }

                this.usingA = !this.usingA;
                return this.usingA ? Bridge.rValue(this.a) : Bridge.rValue(this.b);
            },
            /*Spine.Unity.DoubleBuffered$1.GetNext end.*/


        }
    }; });
    /*Spine.Unity.DoubleBuffered$1 end.*/

    /*Spine.Unity.EventDataReferenceAsset start.*/
    Bridge.define("Spine.Unity.EventDataReferenceAsset", {
        inherits: [UnityEngine.ScriptableObject],
        statics: {
            fields: {
                QuietSkeletonData: false
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.EventDataReferenceAsset#init", this ); }

                    this.QuietSkeletonData = true;
                }
            },
            methods: {
                op_Implicit: function (asset) {
if ( TRACE ) { TRACE( "Spine.Unity.EventDataReferenceAsset#op_Implicit", this ); }

                    return asset.EventData;
                }
            }
        },
        fields: {
            skeletonDataAsset: null,
            eventName: null,
            eventData: null
        },
        props: {
            EventData: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.EventDataReferenceAsset#EventData#get", this ); }

                    if (this.eventData == null) {
                        this.Initialize();
                    }
                    return this.eventData;
                }
            }
        },
        methods: {
            /*Spine.Unity.EventDataReferenceAsset.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.EventDataReferenceAsset#Initialize", this ); }

                if (this.skeletonDataAsset == null) {
                    return;
                }
                this.eventData = this.skeletonDataAsset.GetSkeletonData(Spine.Unity.EventDataReferenceAsset.QuietSkeletonData).FindEvent(this.eventName);
                if (this.eventData == null) {
                    UnityEngine.Debug.LogWarningFormat("Event Data '{0}' not found in SkeletonData : {1}.", [this.eventName, this.skeletonDataAsset.name]);
                }
            },
            /*Spine.Unity.EventDataReferenceAsset.Initialize end.*/


        }
    });
    /*Spine.Unity.EventDataReferenceAsset end.*/

    /*Spine.Unity.ISpineComponentExtensions start.*/
    Bridge.define("Spine.Unity.ISpineComponentExtensions", {
        statics: {
            methods: {
                /*Spine.Unity.ISpineComponentExtensions.IsNullOrDestroyed:static start.*/
                IsNullOrDestroyed: function (component) {
if ( TRACE ) { TRACE( "Spine.Unity.ISpineComponentExtensions#IsNullOrDestroyed", this ); }

                    if (component == null) {
                        return true;
                    }
                    return Bridge.cast(component, UnityEngine.Object) == null;
                },
                /*Spine.Unity.ISpineComponentExtensions.IsNullOrDestroyed:static end.*/


            }
        }
    });
    /*Spine.Unity.ISpineComponentExtensions end.*/

    /*Spine.Unity.MeshGenerator start.*/
    /**
     * Holds several methods to prepare and generate a UnityEngine mesh based on a skeleton. Contains buffers needed to perform the operation, and serializes settings for mesh generation.
     *
     * @public
     * @class Spine.Unity.MeshGenerator
     */
    Bridge.define("Spine.Unity.MeshGenerator", {
        statics: {
            fields: {
                BoundsMinDefault: 0,
                BoundsMaxDefault: 0,
                AttachmentVerts: null,
                AttachmentUVs: null,
                AttachmentColors32: null,
                AttachmentIndices: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#init", this ); }

                    this.BoundsMinDefault = Number.POSITIVE_INFINITY;
                    this.BoundsMaxDefault = Number.NEGATIVE_INFINITY;
                    this.AttachmentVerts = new (System.Collections.Generic.List$1(UnityEngine.Vector3)).ctor();
                    this.AttachmentUVs = new (System.Collections.Generic.List$1(UnityEngine.Vector2)).ctor();
                    this.AttachmentColors32 = new (System.Collections.Generic.List$1(UnityEngine.Color32)).ctor();
                    this.AttachmentIndices = new (System.Collections.Generic.List$1(System.Int32)).ctor();
                }
            },
            methods: {
                /*Spine.Unity.MeshGenerator.GenerateSingleSubmeshInstruction:static start.*/
                /**
                 * A specialized variant of {@link }.
                 Generates renderer instructions using a single submesh, using only a single material and texture.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.MeshGenerator
                 * @memberof Spine.Unity.MeshGenerator
                 * @param   {Spine.Unity.SkeletonRendererInstruction}    instructionOutput    The resulting instructions.
                 * @param   {Spine.Skeleton}                             skeleton             The skeleton to generate renderer instructions for.
                 * @param   {UnityEngine.Material}                       material             Material to be set at the renderer instruction. When null, the last attachment
                 in the draw order list is assigned as the instruction's material.
                 * @return  {void}
                 */
                GenerateSingleSubmeshInstruction: function (instructionOutput, skeleton, material) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#GenerateSingleSubmeshInstruction", this ); }

                    var $t;
                    var drawOrder = skeleton.DrawOrder;
                    var drawOrderCount = drawOrder.Count;

                    // Clear last state of attachments and submeshes
                    instructionOutput.Clear(); // submeshInstructions.Clear(); attachments.Clear();
                    var workingSubmeshInstructions = instructionOutput.submeshInstructions;

                    instructionOutput.attachments.Resize(drawOrderCount);
                    var workingAttachmentsItems = instructionOutput.attachments.Items;
                    var totalRawVertexCount = 0;

                    var current = ($t = new Spine.Unity.SubmeshInstruction(), $t.skeleton = skeleton, $t.preActiveClippingSlotSource = -1, $t.startSlot = 0, $t.rawFirstVertexIndex = 0, $t.material = material, $t.forceSeparate = false, $t.endSlot = drawOrderCount, $t);

                    var rendererObject = null;
                    var skeletonHasClipping = false;
                    var drawOrderItems = drawOrder.Items;
                    for (var i = 0; i < drawOrderCount; i = (i + 1) | 0) {
                        var slot = drawOrderItems[i];
                        if (!slot.Bone.Active || slot.A === 0.0) {
                            workingAttachmentsItems[i] = null;
                            continue;
                        }
                        if (slot.Data.BlendMode === Spine.BlendMode.Additive) {
                            current.hasPMAAdditiveSlot = true;
                        }
                        var attachment = slot.Attachment;

                        workingAttachmentsItems[i] = attachment;
                        var attachmentTriangleCount;
                        var attachmentVertexCount;

                        var regionAttachment = Bridge.as(attachment, Spine.RegionAttachment);
                        if (regionAttachment != null) {
                            if (regionAttachment.Sequence != null) {
                                regionAttachment.Sequence.Apply(slot, regionAttachment);
                            }
                            rendererObject = regionAttachment.Region;
                            attachmentVertexCount = 4;
                            attachmentTriangleCount = 6;
                        } else {
                            var meshAttachment = Bridge.as(attachment, Spine.MeshAttachment);
                            if (meshAttachment != null) {
                                if (meshAttachment.Sequence != null) {
                                    meshAttachment.Sequence.Apply(slot, meshAttachment);
                                }
                                rendererObject = meshAttachment.Region;
                                attachmentVertexCount = meshAttachment.WorldVerticesLength >> 1;
                                attachmentTriangleCount = meshAttachment.Triangles.length;
                            } else {
                                var clippingAttachment = Bridge.as(attachment, Spine.ClippingAttachment);
                                if (clippingAttachment != null) {
                                    current.hasClipping = true;
                                    skeletonHasClipping = true;
                                }
                                attachmentVertexCount = 0;
                                attachmentTriangleCount = 0;
                            }
                        }
                        current.rawTriangleCount = (current.rawTriangleCount + attachmentTriangleCount) | 0;
                        current.rawVertexCount = (current.rawVertexCount + attachmentVertexCount) | 0;
                        totalRawVertexCount = (totalRawVertexCount + attachmentVertexCount) | 0;
                    }

                    if (material == null && rendererObject != null) {
                        current.material = Bridge.cast(Bridge.cast(rendererObject, Spine.AtlasRegion).page.rendererObject, UnityEngine.Material);
                    }

                    instructionOutput.hasActiveClipping = skeletonHasClipping;
                    instructionOutput.rawVertexCount = totalRawVertexCount;

                    if (totalRawVertexCount > 0) {
                        workingSubmeshInstructions.Resize(1);
                        workingSubmeshInstructions.Items[0] = current.$clone();
                    } else {
                        workingSubmeshInstructions.Resize(0);
                    }
                },
                /*Spine.Unity.MeshGenerator.GenerateSingleSubmeshInstruction:static end.*/

                /*Spine.Unity.MeshGenerator.RequiresMultipleSubmeshesByDrawOrder:static start.*/
                RequiresMultipleSubmeshesByDrawOrder: function (skeleton) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#RequiresMultipleSubmeshesByDrawOrder", this ); }


                    var drawOrder = skeleton.DrawOrder;
                    var drawOrderCount = drawOrder.Count;
                    var drawOrderItems = drawOrder.Items;

                    var lastRendererMaterial = null;
                    for (var i = 0; i < drawOrderCount; i = (i + 1) | 0) {
                        var slot = drawOrderItems[i];
                        if (!slot.Bone.Active || slot.A === 0.0) {
                            continue;
                        }
                        var attachment = slot.Attachment;
                        var rendererAttachment = Bridge.as(attachment, Spine.IHasTextureRegion);
                        if (rendererAttachment != null) {
                            if (rendererAttachment.Spine$IHasTextureRegion$Sequence != null) {
                                rendererAttachment.Spine$IHasTextureRegion$Sequence.Apply(slot, rendererAttachment);
                            }
                            var atlasRegion = Bridge.cast(rendererAttachment.Spine$IHasTextureRegion$Region, Spine.AtlasRegion);
                            var material = Bridge.cast(atlasRegion.page.rendererObject, UnityEngine.Material);
                            if (!Bridge.referenceEquals(lastRendererMaterial, material)) {
                                if (lastRendererMaterial != null) {
                                    return true;
                                }
                                lastRendererMaterial = material;
                            }
                        }
                    }
                    return false;
                },
                /*Spine.Unity.MeshGenerator.RequiresMultipleSubmeshesByDrawOrder:static end.*/

                /*Spine.Unity.MeshGenerator.GenerateSkeletonRendererInstruction:static start.*/
                GenerateSkeletonRendererInstruction: function (instructionOutput, skeleton, customSlotMaterials, separatorSlots, generateMeshOverride, immutableTriangles) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#GenerateSkeletonRendererInstruction", this ); }

                    var $t;
                    if (immutableTriangles === void 0) { immutableTriangles = false; }
                    //			if (skeleton == null) throw new ArgumentNullException("skeleton");
                    //			if (instructionOutput == null) throw new ArgumentNullException("instructionOutput");

                    var drawOrder = skeleton.DrawOrder;
                    var drawOrderCount = drawOrder.Count;

                    // Clear last state of attachments and submeshes
                    instructionOutput.Clear(); // submeshInstructions.Clear(); attachments.Clear();
                    var workingSubmeshInstructions = instructionOutput.submeshInstructions;
                    instructionOutput.attachments.Resize(drawOrderCount);
                    var workingAttachmentsItems = instructionOutput.attachments.Items;
                    var totalRawVertexCount = 0;
                    var skeletonHasClipping = false;

                    var current = ($t = new Spine.Unity.SubmeshInstruction(), $t.skeleton = skeleton, $t.preActiveClippingSlotSource = -1, $t);

                    var isCustomSlotMaterialsPopulated = customSlotMaterials != null && customSlotMaterials.Count > 0;

                    var separatorCount = separatorSlots == null ? 0 : separatorSlots.Count;
                    var hasSeparators = separatorCount > 0;

                    var clippingAttachmentSource = -1;
                    var lastPreActiveClipping = -1; // The index of the last slot that had an active ClippingAttachment.
                    var clippingEndSlot = null;
                    var submeshIndex = 0;
                    var drawOrderItems = drawOrder.Items;
                    for (var i = 0; i < drawOrderCount; i = (i + 1) | 0) {
                        var slot = drawOrderItems[i];
                        if (!slot.Bone.Active || (slot.A === 0.0 && !Bridge.referenceEquals(slot.Data, clippingEndSlot))) {
                            workingAttachmentsItems[i] = null;
                            continue;
                        }
                        if (slot.Data.BlendMode === Spine.BlendMode.Additive) {
                            current.hasPMAAdditiveSlot = true;
                        }
                        var attachment = slot.Attachment;
                        workingAttachmentsItems[i] = attachment;
                        var attachmentVertexCount = 0, attachmentTriangleCount = 0;

                        var region = null;
                        var noRender = false; // Using this allows empty slots as separators, and keeps separated parts more stable despite slots being reordered

                        var regionAttachment = Bridge.as(attachment, Spine.RegionAttachment);
                        if (regionAttachment != null) {
                            if (regionAttachment.Sequence != null) {
                                regionAttachment.Sequence.Apply(slot, regionAttachment);
                            }
                            region = regionAttachment.Region;
                            attachmentVertexCount = 4;
                            attachmentTriangleCount = 6;
                        } else {
                            var meshAttachment = Bridge.as(attachment, Spine.MeshAttachment);
                            if (meshAttachment != null) {
                                if (meshAttachment.Sequence != null) {
                                    meshAttachment.Sequence.Apply(slot, meshAttachment);
                                }
                                region = meshAttachment.Region;
                                attachmentVertexCount = meshAttachment.WorldVerticesLength >> 1;
                                attachmentTriangleCount = meshAttachment.Triangles.length;
                            } else {
                                var clippingAttachment = Bridge.as(attachment, Spine.ClippingAttachment);
                                if (clippingAttachment != null) {
                                    clippingEndSlot = clippingAttachment.EndSlot;
                                    clippingAttachmentSource = i;
                                    current.hasClipping = true;
                                    skeletonHasClipping = true;
                                }
                                noRender = true;
                            }
                        }

                        // Create a new SubmeshInstruction when material changes. (or when forced to separate by a submeshSeparator)
                        // Slot with a separator/new material will become the starting slot of the next new instruction.
                        if (hasSeparators) { //current.forceSeparate = hasSeparators && separatorSlots.Contains(slot);
                            current.forceSeparate = false;
                            for (var s = 0; s < separatorCount; s = (s + 1) | 0) {
                                if (Bridge.referenceEquals(slot, separatorSlots.getItem(s))) {
                                    current.forceSeparate = true;
                                    break;
                                }
                            }
                        }

                        if (noRender) {
                            if (current.forceSeparate && generateMeshOverride) { // && current.rawVertexCount > 0) {
                                { // Add
                                    current.endSlot = i;
                                    current.preActiveClippingSlotSource = lastPreActiveClipping;

                                    workingSubmeshInstructions.Resize(((submeshIndex + 1) | 0));
                                    workingSubmeshInstructions.Items[submeshIndex] = current.$clone();

                                    submeshIndex = (submeshIndex + 1) | 0;
                                }

                                current.startSlot = i;
                                lastPreActiveClipping = clippingAttachmentSource;
                                current.rawTriangleCount = 0;
                                current.rawVertexCount = 0;
                                current.rawFirstVertexIndex = totalRawVertexCount;
                                current.hasClipping = clippingAttachmentSource >= 0;
                            }
                        } else {
                            var material = { };
                            if (isCustomSlotMaterialsPopulated) {
                                if (!customSlotMaterials.tryGetValue(slot, material)) {
                                    material.v = Bridge.cast(Bridge.cast(region, Spine.AtlasRegion).page.rendererObject, UnityEngine.Material);
                                }
                            } else {
                                material.v = Bridge.cast(Bridge.cast(region, Spine.AtlasRegion).page.rendererObject, UnityEngine.Material);
                            }

                            if (current.forceSeparate || (current.rawVertexCount > 0 && !Bridge.referenceEquals(current.material, material.v))) { // Material changed. Add the previous submesh.
                                { // Add
                                    current.endSlot = i;
                                    current.preActiveClippingSlotSource = lastPreActiveClipping;

                                    workingSubmeshInstructions.Resize(((submeshIndex + 1) | 0));
                                    workingSubmeshInstructions.Items[submeshIndex] = current.$clone();
                                    submeshIndex = (submeshIndex + 1) | 0;
                                }
                                current.startSlot = i;
                                lastPreActiveClipping = clippingAttachmentSource;
                                current.rawTriangleCount = 0;
                                current.rawVertexCount = 0;
                                current.rawFirstVertexIndex = totalRawVertexCount;
                                current.hasClipping = clippingAttachmentSource >= 0;
                            }

                            // Update state for the next Attachment.
                            current.material = material.v;
                            current.rawTriangleCount = (current.rawTriangleCount + attachmentTriangleCount) | 0;
                            current.rawVertexCount = (current.rawVertexCount + attachmentVertexCount) | 0;
                            current.rawFirstVertexIndex = totalRawVertexCount;
                            totalRawVertexCount = (totalRawVertexCount + attachmentVertexCount) | 0;
                        }

                        if (clippingEndSlot != null && Bridge.referenceEquals(slot.Data, clippingEndSlot) && i !== clippingAttachmentSource) {
                            clippingEndSlot = null;
                            clippingAttachmentSource = -1;
                        }
                    }

                    if (current.rawVertexCount > 0) {
                        { // Add last or only submesh.
                            current.endSlot = drawOrderCount;
                            current.preActiveClippingSlotSource = lastPreActiveClipping;
                            current.forceSeparate = false;

                            workingSubmeshInstructions.Resize(((submeshIndex + 1) | 0));
                            workingSubmeshInstructions.Items[submeshIndex] = current.$clone();
                            //submeshIndex++;
                        }
                    }

                    instructionOutput.hasActiveClipping = skeletonHasClipping;
                    instructionOutput.rawVertexCount = totalRawVertexCount;
                    instructionOutput.immutableTriangles = immutableTriangles;
                },
                /*Spine.Unity.MeshGenerator.GenerateSkeletonRendererInstruction:static end.*/

                /*Spine.Unity.MeshGenerator.TryReplaceMaterials:static start.*/
                TryReplaceMaterials: function (workingSubmeshInstructions, customMaterialOverride) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#TryReplaceMaterials", this ); }

                    // Material overrides are done here so they can be applied per submesh instead of per slot
                    // but they will still be passed through the GenerateMeshOverride delegate,
                    // and will still go through the normal material match check step in STEP 3.
                    var wsii = workingSubmeshInstructions.Items;
                    for (var i = 0; i < workingSubmeshInstructions.Count; i = (i + 1) | 0) {
                        var material = wsii[i].material;
                        if (material == null) {
                            continue;
                        }

                        var overrideMaterial = { };
                        if (customMaterialOverride.tryGetValue(material, overrideMaterial)) {
                            wsii[i].material = overrideMaterial.v;
                        }
                    }
                },
                /*Spine.Unity.MeshGenerator.TryReplaceMaterials:static end.*/

                /*Spine.Unity.MeshGenerator.SolveTangents2DEnsureSize:static start.*/
                /**
                 * Step 1 of solving tangents. Ensure you have buffers of the correct size.
                 *
                 * @static
                 * @this Spine.Unity.MeshGenerator
                 * @memberof Spine.Unity.MeshGenerator
                 * @param   {UnityEngine.Vector4}    tangentBuffer         Eventual Vector4[] tangent buffer to assign to Mesh.tangents.
                 * @param   {UnityEngine.Vector2}    tempTanBuffer         Temporary Vector2 buffer for calculating directions.
                 * @param   {number}                 vertexCount           Number of vertices that require tangents (or the size of the vertex array)
                 * @param   {number}                 vertexBufferLength
                 * @return  {void}
                 */
                SolveTangents2DEnsureSize: function (tangentBuffer, tempTanBuffer, vertexCount, vertexBufferLength) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#SolveTangents2DEnsureSize", this ); }

                    if (tangentBuffer.v == null || tangentBuffer.v.length !== vertexBufferLength) {
                        tangentBuffer.v = System.Array.init(vertexBufferLength, function (){
                            return new UnityEngine.Vector4();
                        }, UnityEngine.Vector4);
                    }

                    if (tempTanBuffer.v == null || tempTanBuffer.v.length < Bridge.Int.mul(vertexCount, 2)) {
                        tempTanBuffer.v = System.Array.init(Bridge.Int.mul(vertexCount, 2), function (){
                            return new UnityEngine.Vector2();
                        }, UnityEngine.Vector2);
                    } // two arrays in one.
                },
                /*Spine.Unity.MeshGenerator.SolveTangents2DEnsureSize:static end.*/

                /*Spine.Unity.MeshGenerator.SolveTangents2DTriangles:static start.*/
                /**
                 * Step 2 of solving tangents. Fills (part of) a temporary tangent-solution buffer based on the vertices and uvs defined by a submesh's triangle buffer. Only needs to be called once for single-submesh meshes.
                 *
                 * @static
                 * @this Spine.Unity.MeshGenerator
                 * @memberof Spine.Unity.MeshGenerator
                 * @param   {Array.<UnityEngine.Vector2>}    tempTanBuffer    A temporary Vector3[] for calculating tangents.
                 * @param   {Array.<number>}                 triangles        The mesh's current triangles buffer.
                 * @param   {number}                         triangleCount    The number of triangle indexes in the triangle array to be used.
                 * @param   {Array.<UnityEngine.Vector3>}    vertices         The mesh's current vertex position buffer.
                 * @param   {Array.<UnityEngine.Vector2>}    uvs              The mesh's current uvs buffer.
                 * @param   {number}                         vertexCount      Number of vertices that require tangents (or the size of the vertex array)
                 * @return  {void}
                 */
                SolveTangents2DTriangles: function (tempTanBuffer, triangles, triangleCount, vertices, uvs, vertexCount) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#SolveTangents2DTriangles", this ); }

                    var $t, $t1;
                    var sdir = new UnityEngine.Vector2();
                    var tdir = new UnityEngine.Vector2();
                    for (var t = 0; t < triangleCount; t = (t + 3) | 0) {
                        var i1 = triangles[((t + 0) | 0)];
                        var i2 = triangles[((t + 1) | 0)];
                        var i3 = triangles[((t + 2) | 0)];

                        var v1 = vertices[i1].$clone();
                        var v2 = vertices[i2].$clone();
                        var v3 = vertices[i3].$clone();

                        var w1 = uvs[i1].$clone();
                        var w2 = uvs[i2].$clone();
                        var w3 = uvs[i3].$clone();

                        var x1 = v2.x - v1.x;
                        var x2 = v3.x - v1.x;
                        var y1 = v2.y - v1.y;
                        var y2 = v3.y - v1.y;

                        var s1 = w2.x - w1.x;
                        var s2 = w3.x - w1.x;
                        var t1 = w2.y - w1.y;
                        var t2 = w3.y - w1.y;

                        var div = s1 * t2 - s2 * t1;
                        var r = (div === 0.0) ? 0.0 : 1.0 / div;

                        sdir.x = (t2 * x1 - t1 * x2) * r;
                        sdir.y = (t2 * y1 - t1 * y2) * r;
                        tempTanBuffer[i1] = ($t = (tempTanBuffer[i3] = sdir.$clone(), sdir.$clone()), tempTanBuffer[i2] = $t.$clone(), $t);

                        tdir.x = (s1 * x2 - s2 * x1) * r;
                        tdir.y = (s1 * y2 - s2 * y1) * r;
                        tempTanBuffer[((vertexCount + i1) | 0)] = ($t1 = (tempTanBuffer[((vertexCount + i3) | 0)] = tdir.$clone(), tdir.$clone()), tempTanBuffer[((vertexCount + i2) | 0)] = $t1.$clone(), $t1);
                    }
                },
                /*Spine.Unity.MeshGenerator.SolveTangents2DTriangles:static end.*/

                /*Spine.Unity.MeshGenerator.SolveTangents2DBuffer:static start.*/
                /**
                 * Step 3 of solving tangents. Fills a Vector4[] tangents array according to values calculated in step 2.
                 *
                 * @static
                 * @this Spine.Unity.MeshGenerator
                 * @memberof Spine.Unity.MeshGenerator
                 * @param   {Array.<UnityEngine.Vector4>}    tangents         A Vector4[] that will eventually be used to set Mesh.tangents
                 * @param   {Array.<UnityEngine.Vector2>}    tempTanBuffer    A temporary Vector3[] for calculating tangents.
                 * @param   {number}                         vertexCount      Number of vertices that require tangents (or the size of the vertex array)
                 * @return  {void}
                 */
                SolveTangents2DBuffer: function (tangents, tempTanBuffer, vertexCount) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#SolveTangents2DBuffer", this ); }

                    var tangent = new UnityEngine.Vector4();
                    tangent.z = 0;
                    for (var i = 0; i < vertexCount; i = (i + 1) | 0) {
                        var t = tempTanBuffer[i].$clone();

                        // t.Normalize() (aggressively inlined). Even better if offloaded to GPU via vertex shader.
                        var magnitude = Math.sqrt(t.x * t.x + t.y * t.y);
                        if (magnitude > 1E-05) {
                            var reciprocalMagnitude = 1.0 / magnitude;
                            t.x *= reciprocalMagnitude;
                            t.y *= reciprocalMagnitude;
                        }

                        var t2 = tempTanBuffer[((vertexCount + i) | 0)].$clone();
                        tangent.x = t.x;
                        tangent.y = t.y;
                        //tangent.z = 0;
                        tangent.w = (t.y * t2.x > t.x * t2.y) ? 1 : -1; // 2D direction calculation. Used for binormals.
                        tangents[i] = tangent.$clone();
                    }
                },
                /*Spine.Unity.MeshGenerator.SolveTangents2DBuffer:static end.*/

                /*Spine.Unity.MeshGenerator.FillMeshLocal$1:static start.*/
                /**
                 * Fills mesh vertex data to render a RegionAttachment.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.MeshGenerator
                 * @memberof Spine.Unity.MeshGenerator
                 * @param   {UnityEngine.Mesh}          mesh                
                 * @param   {Spine.RegionAttachment}    regionAttachment
                 * @return  {void}
                 */
                FillMeshLocal$1: function (mesh, regionAttachment) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#FillMeshLocal$1", this ); }

                    if (mesh == null) {
                        return;
                    }
                    if (regionAttachment == null) {
                        return;
                    }

                    Spine.Unity.MeshGenerator.AttachmentVerts.clear();
                    var offsets = regionAttachment.Offset;
                    Spine.Unity.MeshGenerator.AttachmentVerts.add(new pc.Vec3( offsets[Spine.RegionAttachment.BLX], offsets[Spine.RegionAttachment.BLY], 0 ));
                    Spine.Unity.MeshGenerator.AttachmentVerts.add(new pc.Vec3( offsets[Spine.RegionAttachment.ULX], offsets[Spine.RegionAttachment.ULY], 0 ));
                    Spine.Unity.MeshGenerator.AttachmentVerts.add(new pc.Vec3( offsets[Spine.RegionAttachment.URX], offsets[Spine.RegionAttachment.URY], 0 ));
                    Spine.Unity.MeshGenerator.AttachmentVerts.add(new pc.Vec3( offsets[Spine.RegionAttachment.BRX], offsets[Spine.RegionAttachment.BRY], 0 ));

                    Spine.Unity.MeshGenerator.AttachmentUVs.clear();
                    var uvs = regionAttachment.UVs;
                    Spine.Unity.MeshGenerator.AttachmentUVs.add(new pc.Vec2( uvs[Spine.RegionAttachment.ULX], uvs[Spine.RegionAttachment.ULY] ));
                    Spine.Unity.MeshGenerator.AttachmentUVs.add(new pc.Vec2( uvs[Spine.RegionAttachment.URX], uvs[Spine.RegionAttachment.URY] ));
                    Spine.Unity.MeshGenerator.AttachmentUVs.add(new pc.Vec2( uvs[Spine.RegionAttachment.BRX], uvs[Spine.RegionAttachment.BRY] ));
                    Spine.Unity.MeshGenerator.AttachmentUVs.add(new pc.Vec2( uvs[Spine.RegionAttachment.BLX], uvs[Spine.RegionAttachment.BLY] ));

                    Spine.Unity.MeshGenerator.AttachmentColors32.clear();
                    var c = UnityEngine.Color32.op_Implicit$1((new pc.Color( regionAttachment.R, regionAttachment.G, regionAttachment.B, regionAttachment.A )));
                    for (var i = 0; i < 4; i = (i + 1) | 0) {
                        Spine.Unity.MeshGenerator.AttachmentColors32.add(c.$clone());
                    }

                    Spine.Unity.MeshGenerator.AttachmentIndices.clear();
                    Spine.Unity.MeshGenerator.AttachmentIndices.AddRange(System.Array.init([0, 2, 1, 0, 3, 2], System.Int32));

                    mesh.Clear();
                    mesh.name = regionAttachment.Name;
                    mesh.SetVertices(Spine.Unity.MeshGenerator.AttachmentVerts);
                    mesh.SetUVs(0, Spine.Unity.MeshGenerator.AttachmentUVs);
                    mesh.SetColors$1(Spine.Unity.MeshGenerator.AttachmentColors32);
                    mesh.SetTriangles(Spine.Unity.MeshGenerator.AttachmentIndices, 0);
                    mesh.RecalculateBounds();

                    Spine.Unity.MeshGenerator.AttachmentVerts.clear();
                    Spine.Unity.MeshGenerator.AttachmentUVs.clear();
                    Spine.Unity.MeshGenerator.AttachmentColors32.clear();
                    Spine.Unity.MeshGenerator.AttachmentIndices.clear();
                },
                /*Spine.Unity.MeshGenerator.FillMeshLocal$1:static end.*/

                /*Spine.Unity.MeshGenerator.FillMeshLocal:static start.*/
                FillMeshLocal: function (mesh, meshAttachment, skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#FillMeshLocal", this ); }

                    var $t;
                    if (mesh == null) {
                        return;
                    }
                    if (meshAttachment == null) {
                        return;
                    }
                    var vertexCount = (Bridge.Int.div(meshAttachment.WorldVerticesLength, 2)) | 0;

                    Spine.Unity.MeshGenerator.AttachmentVerts.clear();
                    if (Spine.SpineSkeletonExtensions.IsWeighted(meshAttachment)) {
                        var count = meshAttachment.WorldVerticesLength;
                        var meshAttachmentBones = meshAttachment.Bones;
                        var v = 0;

                        var vertices = meshAttachment.Vertices;
                        for (var w = 0, b = 0; w < count; w = (w + 2) | 0) {
                            var wx = 0, wy = 0;
                            var n = meshAttachmentBones[Bridge.identity(v, ((v = (v + 1) | 0)))];
                            n = (n + v) | 0;
                            for (; v < n; v = (v + 1) | 0, b = (b + 3) | 0) {
                                var bm = Spine.BoneMatrix.CalculateSetupWorld(($t = skeletonData.Bones.Items)[meshAttachmentBones[v]]);
                                var vx = vertices[b], vy = vertices[((b + 1) | 0)], weight = vertices[((b + 2) | 0)];
                                wx += (vx * bm.a + vy * bm.b + bm.x) * weight;
                                wy += (vx * bm.c + vy * bm.d + bm.y) * weight;
                            }
                            Spine.Unity.MeshGenerator.AttachmentVerts.add(new pc.Vec3( wx, wy, 0 ));
                        }
                    } else {
                        var localVerts = meshAttachment.Vertices;
                        var pos = Bridge.getDefaultValue(UnityEngine.Vector3);
                        for (var i = 0; i < vertexCount; i = (i + 1) | 0) {
                            var ii = Bridge.Int.mul(i, 2);
                            pos.x = localVerts[ii];
                            pos.y = localVerts[((ii + 1) | 0)];
                            Spine.Unity.MeshGenerator.AttachmentVerts.add(pos.$clone());
                        }
                    }

                    var uvs = meshAttachment.UVs;
                    var uv = Bridge.getDefaultValue(UnityEngine.Vector2);
                    var c = UnityEngine.Color32.op_Implicit$1((new pc.Color( meshAttachment.R, meshAttachment.G, meshAttachment.B, meshAttachment.A )));
                    Spine.Unity.MeshGenerator.AttachmentUVs.clear();
                    Spine.Unity.MeshGenerator.AttachmentColors32.clear();
                    for (var i1 = 0; i1 < vertexCount; i1 = (i1 + 1) | 0) {
                        var ii1 = Bridge.Int.mul(i1, 2);
                        uv.x = uvs[ii1];
                        uv.y = uvs[((ii1 + 1) | 0)];
                        Spine.Unity.MeshGenerator.AttachmentUVs.add(uv.$clone());

                        Spine.Unity.MeshGenerator.AttachmentColors32.add(c.$clone());
                    }

                    Spine.Unity.MeshGenerator.AttachmentIndices.clear();
                    Spine.Unity.MeshGenerator.AttachmentIndices.AddRange(meshAttachment.Triangles);

                    mesh.Clear();
                    mesh.name = meshAttachment.Name;
                    mesh.SetVertices(Spine.Unity.MeshGenerator.AttachmentVerts);
                    mesh.SetUVs(0, Spine.Unity.MeshGenerator.AttachmentUVs);
                    mesh.SetColors$1(Spine.Unity.MeshGenerator.AttachmentColors32);
                    mesh.SetTriangles(Spine.Unity.MeshGenerator.AttachmentIndices, 0);
                    mesh.RecalculateBounds();

                    Spine.Unity.MeshGenerator.AttachmentVerts.clear();
                    Spine.Unity.MeshGenerator.AttachmentUVs.clear();
                    Spine.Unity.MeshGenerator.AttachmentColors32.clear();
                    Spine.Unity.MeshGenerator.AttachmentIndices.clear();
                },
                /*Spine.Unity.MeshGenerator.FillMeshLocal:static end.*/


            }
        },
        fields: {
            settings: null,
            vertexBuffer: null,
            uvBuffer: null,
            colorBuffer: null,
            submeshes: null,
            meshBoundsMin: null,
            meshBoundsMax: null,
            meshBoundsThickness: 0,
            submeshIndex: 0,
            clipper: null,
            tempVerts: null,
            regionTriangles: null,
            normals: null,
            tangents: null,
            tempTanBuffer: null,
            uv2: null,
            uv3: null
        },
        props: {
            /**
             * Optional vertex texture coordinates (UVs), second channel. To be used for UnityEngine.Mesh.uv2.
             Using this accessor automatically allocates and resizes the buffer accordingly.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.MeshGenerator
             * @function UV2
             * @type Array.<UnityEngine.Vector2>
             */
            UV2: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#UV2#get", this ); }

                    this.PrepareOptionalUVBuffer(Bridge.ref(this, "uv2"), this.vertexBuffer.Count);
                    return this.uv2.Items;
                }
            },
            /**
             * Optional vertex texture coordinates (UVs), third channel. To be used for UnityEngine.Mesh.uv3.
             Using this accessor automatically allocates and resizes the buffer accordingly.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.MeshGenerator
             * @function UV3
             * @type Array.<UnityEngine.Vector2>
             */
            UV3: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#UV3#get", this ); }

                    this.PrepareOptionalUVBuffer(Bridge.ref(this, "uv3"), this.vertexBuffer.Count);
                    return this.uv3.Items;
                }
            },
            VertexCount: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#VertexCount#get", this ); }

                    return this.vertexBuffer.Count;
                }
            },
            /**
             * A set of mesh arrays whose values are modifiable by the user. Modify these values before they are passed to the UnityEngine mesh object in order to see the effect.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.MeshGenerator
             * @function Buffers
             * @type Spine.Unity.MeshGeneratorBuffers
             */
            Buffers: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#Buffers#get", this ); }

                    var $t;
                    return ($t = new Spine.Unity.MeshGeneratorBuffers(), $t.vertexCount = this.VertexCount, $t.vertexBuffer = this.vertexBuffer.Items, $t.uvBuffer = this.uvBuffer.Items, $t.colorBuffer = this.colorBuffer.Items, $t.meshGenerator = this, $t);
                }
            },
            /**
             * Returns the {@link } used by this mesh generator for use with e.g.
             {@link }
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.MeshGenerator
             * @function SkeletonClipping
             * @type Spine.SkeletonClipping
             */
            SkeletonClipping: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#SkeletonClipping#get", this ); }

                    return this.clipper;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#init", this ); }

                this.settings = new Spine.Unity.MeshGenerator.Settings();
                this.meshBoundsMin = new UnityEngine.Vector2();
                this.meshBoundsMax = new UnityEngine.Vector2();
                this.settings = Spine.Unity.MeshGenerator.Settings.Default.$clone();
                this.vertexBuffer = new (Spine.ExposedList$1(UnityEngine.Vector3)).$ctor3(4);
                this.uvBuffer = new (Spine.ExposedList$1(UnityEngine.Vector2)).$ctor3(4);
                this.colorBuffer = new (Spine.ExposedList$1(UnityEngine.Color32)).$ctor3(4);
                this.submeshes = function (_o1) {
                        _o1.Add(new (Spine.ExposedList$1(System.Int32)).$ctor3(6));
                        return _o1;
                    }(new (Spine.ExposedList$1(Spine.ExposedList$1(System.Int32))).ctor());
                this.submeshIndex = 0;
                this.clipper = new Spine.SkeletonClipping();
                this.tempVerts = System.Array.init(8, 0, System.Single);
                this.regionTriangles = System.Array.init([
                    0, 
                    1, 
                    2, 
                    2, 
                    3, 
                    0
                ], System.Int32);
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#ctor", this ); }

                this.$initialize();
                this.submeshes.TrimExcess();
            }
        },
        methods: {
            /*Spine.Unity.MeshGenerator.SubmeshIndexCount start.*/
            SubmeshIndexCount: function (submeshIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#SubmeshIndexCount", this ); }

                var $t;
                return ($t = this.submeshes.Items)[submeshIndex].Count;
            },
            /*Spine.Unity.MeshGenerator.SubmeshIndexCount end.*/

            /*Spine.Unity.MeshGenerator.Begin start.*/
            Begin: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#Begin", this ); }

                this.vertexBuffer.Clear(false);
                this.colorBuffer.Clear(false);
                this.uvBuffer.Clear(false);
                this.clipper.ClipEnd();

                {
                    this.meshBoundsMin.x = Spine.Unity.MeshGenerator.BoundsMinDefault;
                    this.meshBoundsMin.y = Spine.Unity.MeshGenerator.BoundsMinDefault;
                    this.meshBoundsMax.x = Spine.Unity.MeshGenerator.BoundsMaxDefault;
                    this.meshBoundsMax.y = Spine.Unity.MeshGenerator.BoundsMaxDefault;
                    this.meshBoundsThickness = 0.0;
                }

                this.submeshIndex = 0;
                this.submeshes.Count = 1;
                //submeshes.Items[0].Clear(false);
            },
            /*Spine.Unity.MeshGenerator.Begin end.*/

            /*Spine.Unity.MeshGenerator.AddSubmesh start.*/
            AddSubmesh: function (instruction, updateTriangles) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#AddSubmesh", this ); }

                var $t, $t1, $t2;
                if (updateTriangles === void 0) { updateTriangles = true; }
                var settings = this.settings.$clone();

                var newSubmeshCount = (this.submeshIndex + 1) | 0;
                if (this.submeshes.Items.length < newSubmeshCount) {
                    this.submeshes.Resize(newSubmeshCount);
                }
                this.submeshes.Count = newSubmeshCount;
                var submesh = ($t = this.submeshes.Items)[this.submeshIndex];
                if (submesh == null) {
                    ($t1 = this.submeshes.Items)[this.submeshIndex] = (submesh = new (Spine.ExposedList$1(System.Int32)).ctor());
                }
                submesh.Clear(false);

                var skeleton = instruction.skeleton;
                var drawOrderItems = skeleton.DrawOrder.Items;

                var color = Bridge.getDefaultValue(UnityEngine.Color32);
                var skeletonA = skeleton.A, skeletonR = skeleton.R, skeletonG = skeleton.G, skeletonB = skeleton.B;
                var meshBoundsMin = this.meshBoundsMin.$clone(), meshBoundsMax = this.meshBoundsMax.$clone();

                // Settings
                var zSpacing = settings.zSpacing;
                var pmaVertexColors = settings.pmaVertexColors;
                var tintBlack = settings.tintBlack;
                var linearColorSpace = pc.QualitySettings.instance.activeColorSpace === UnityEngine.ColorSpace.Linear;

                var useClipping = settings.useClipping && instruction.hasClipping;
                var canvasGroupTintBlack = settings.tintBlack && settings.canvasGroupCompatible;

                if (useClipping) {
                    if (instruction.preActiveClippingSlotSource >= 0) {
                        var slot = drawOrderItems[instruction.preActiveClippingSlotSource];
                        this.clipper.ClipStart(slot, Bridge.as(slot.Attachment, Spine.ClippingAttachment));
                    }
                }

                for (var slotIndex = instruction.startSlot; slotIndex < instruction.endSlot; slotIndex = (slotIndex + 1) | 0) {
                    var slot1 = drawOrderItems[slotIndex];
                    if (!slot1.Bone.Active) {
                        this.clipper.ClipEnd$1(slot1);
                        continue;
                    }
                    var attachment = slot1.Attachment;
                    var z = zSpacing * slotIndex;

                    var workingVerts = this.tempVerts;
                    var uvs;
                    var attachmentTriangleIndices;
                    var attachmentVertexCount;
                    var attachmentIndexCount;

                    var c = Bridge.getDefaultValue(UnityEngine.Color);

                    // Identify and prepare values.
                    var region = Bridge.as(attachment, Spine.RegionAttachment);
                    if (region != null) {
                        region.ComputeWorldVertices(slot1, workingVerts, 0);
                        uvs = region.UVs;
                        attachmentTriangleIndices = this.regionTriangles;
                        c.r = region.R;
                        c.g = region.G;
                        c.b = region.B;
                        c.a = region.A;
                        attachmentVertexCount = 4;
                        attachmentIndexCount = 6;
                    } else {
                        var mesh = Bridge.as(attachment, Spine.MeshAttachment);
                        if (mesh != null) {
                            var meshVerticesLength = mesh.WorldVerticesLength;
                            if (workingVerts.length < meshVerticesLength) {
                                workingVerts = System.Array.init(meshVerticesLength, 0, System.Single);
                                this.tempVerts = workingVerts;
                            }
                            mesh.ComputeWorldVertices(slot1, 0, meshVerticesLength, workingVerts, 0); //meshAttachment.ComputeWorldVertices(slot, tempVerts);
                            uvs = mesh.UVs;
                            attachmentTriangleIndices = mesh.Triangles;
                            c.r = mesh.R;
                            c.g = mesh.G;
                            c.b = mesh.B;
                            c.a = mesh.A;
                            attachmentVertexCount = meshVerticesLength >> 1; // meshVertexCount / 2;
                            attachmentIndexCount = mesh.Triangles.length;
                        } else {
                            if (useClipping) {
                                var clippingAttachment = Bridge.as(attachment, Spine.ClippingAttachment);
                                if (clippingAttachment != null) {
                                    this.clipper.ClipStart(slot1, clippingAttachment);
                                    continue;
                                }
                            }

                            // If not any renderable attachment.
                            this.clipper.ClipEnd$1(slot1);
                            continue;
                        }
                    }

                    var tintBlackAlpha = 1.0;
                    if (pmaVertexColors) {
                        var alpha = skeletonA * slot1.A * c.a;
                        var isAdditiveSlot = slot1.Data.BlendMode === Spine.BlendMode.Additive;
                        if (linearColorSpace && isAdditiveSlot) {
                            alpha = UnityEngine.Mathf.LinearToGammaSpace(alpha);
                        } // compensate GammaToLinear performed in shader
                        color.a = Bridge.Int.clipu8(alpha * 255);
                        color.r = Bridge.Int.clipu8(skeletonR * slot1.R * c.r * color.a);
                        color.g = Bridge.Int.clipu8(skeletonG * slot1.G * c.g * color.a);
                        color.b = Bridge.Int.clipu8(skeletonB * slot1.B * c.b * color.a);
                        if (canvasGroupTintBlack) {
                            tintBlackAlpha = isAdditiveSlot ? 0 : alpha;
                            color.a = 255;
                        } else {
                            if (isAdditiveSlot) {
                                color.a = 0;
                            }
                        }
                    } else {
                        color.a = Bridge.Int.clipu8(skeletonA * slot1.A * c.a * 255);
                        color.r = Bridge.Int.clipu8(skeletonR * slot1.R * c.r * 255);
                        color.g = Bridge.Int.clipu8(skeletonG * slot1.G * c.g * 255);
                        color.b = Bridge.Int.clipu8(skeletonB * slot1.B * c.b * 255);
                    }

                    if (useClipping && this.clipper.IsClipping) {
                        this.clipper.ClipTriangles$1(workingVerts, attachmentTriangleIndices, attachmentIndexCount, uvs);
                        workingVerts = this.clipper.ClippedVertices.Items;
                        attachmentVertexCount = this.clipper.ClippedVertices.Count >> 1;
                        attachmentTriangleIndices = this.clipper.ClippedTriangles.Items;
                        attachmentIndexCount = this.clipper.ClippedTriangles.Count;
                        uvs = this.clipper.ClippedUVs.Items;
                    }

                    // Actually add slot/attachment data into buffers.
                    if (attachmentVertexCount !== 0 && attachmentIndexCount !== 0) {
                        if (tintBlack) {
                            var r2 = slot1.R2;
                            var g2 = slot1.G2;
                            var b2 = slot1.B2;
                            if (pmaVertexColors) {
                                var alpha1 = skeletonA * slot1.A * c.a;
                                var isAdditiveSlot1 = slot1.Data.BlendMode === Spine.BlendMode.Additive;
                                if (linearColorSpace && isAdditiveSlot1) {
                                    alpha1 = UnityEngine.Mathf.LinearToGammaSpace(alpha1);
                                } // compensate GammaToLinear performed in shader
                                r2 *= alpha1;
                                g2 *= alpha1;
                                b2 *= alpha1;
                            }
                            this.AddAttachmentTintBlack(r2, g2, b2, tintBlackAlpha, attachmentVertexCount);
                        }

                        //AddAttachment(workingVerts, uvs, color, attachmentTriangleIndices, attachmentVertexCount, attachmentIndexCount, ref meshBoundsMin, ref meshBoundsMax, z);
                        var ovc = this.vertexBuffer.Count;
                        // Add data to vertex buffers
                        {
                            var newVertexCount = (ovc + attachmentVertexCount) | 0;
                            var oldArraySize = this.vertexBuffer.Items.length;
                            if (newVertexCount > oldArraySize) {
                                var newArraySize = Bridge.Int.clip32(oldArraySize * 1.3);
                                if (newArraySize < newVertexCount) {
                                    newArraySize = newVertexCount;
                                }
                                System.Array.resize(Bridge.ref(this.vertexBuffer, "Items"), newArraySize, function () {
                                    return Bridge.getDefaultValue(UnityEngine.Vector3);
                                }, UnityEngine.Vector3);
                                System.Array.resize(Bridge.ref(this.uvBuffer, "Items"), newArraySize, function () {
                                    return Bridge.getDefaultValue(UnityEngine.Vector2);
                                }, UnityEngine.Vector2);
                                System.Array.resize(Bridge.ref(this.colorBuffer, "Items"), newArraySize, function () {
                                    return Bridge.getDefaultValue(UnityEngine.Color32);
                                }, UnityEngine.Color32);
                            }
                            this.vertexBuffer.Count = ($t2 = (this.colorBuffer.Count = newVertexCount, newVertexCount), this.uvBuffer.Count = $t2, $t2);
                        }

                        var vbi = this.vertexBuffer.Items;
                        var ubi = this.uvBuffer.Items;
                        var cbi = this.colorBuffer.Items;
                        if (ovc === 0) {
                            for (var i = 0; i < attachmentVertexCount; i = (i + 1) | 0) {
                                var vi = (ovc + i) | 0;
                                var i2 = i << 1; // i * 2
                                var x = workingVerts[i2];
                                var y = workingVerts[((i2 + 1) | 0)];

                                vbi[vi].x = x;
                                vbi[vi].y = y;
                                vbi[vi].z = z;
                                ubi[vi].x = uvs[i2];
                                ubi[vi].y = uvs[((i2 + 1) | 0)];
                                cbi[vi] = color.$clone();

                                // Calculate bounds.
                                if (x < meshBoundsMin.x) {
                                    meshBoundsMin.x = x;
                                }
                                if (x > meshBoundsMax.x) {
                                    meshBoundsMax.x = x;
                                }
                                if (y < meshBoundsMin.y) {
                                    meshBoundsMin.y = y;
                                }
                                if (y > meshBoundsMax.y) {
                                    meshBoundsMax.y = y;
                                }
                            }
                        } else {
                            for (var i1 = 0; i1 < attachmentVertexCount; i1 = (i1 + 1) | 0) {
                                var vi1 = (ovc + i1) | 0;
                                var i21 = i1 << 1; // i * 2
                                var x1 = workingVerts[i21];
                                var y1 = workingVerts[((i21 + 1) | 0)];

                                vbi[vi1].x = x1;
                                vbi[vi1].y = y1;
                                vbi[vi1].z = z;
                                ubi[vi1].x = uvs[i21];
                                ubi[vi1].y = uvs[((i21 + 1) | 0)];
                                cbi[vi1] = color.$clone();

                                // Calculate bounds.
                                if (x1 < meshBoundsMin.x) {
                                    meshBoundsMin.x = x1;
                                } else {
                                    if (x1 > meshBoundsMax.x) {
                                        meshBoundsMax.x = x1;
                                    }
                                }
                                if (y1 < meshBoundsMin.y) {
                                    meshBoundsMin.y = y1;
                                } else {
                                    if (y1 > meshBoundsMax.y) {
                                        meshBoundsMax.y = y1;
                                    }
                                }
                            }
                        }


                        // Add data to triangle buffer
                        if (updateTriangles) {
                            var oldTriangleCount = submesh.Count;
                            { //submesh.Resize(oldTriangleCount + attachmentIndexCount);
                                var newTriangleCount = (oldTriangleCount + attachmentIndexCount) | 0;
                                if (newTriangleCount > submesh.Items.length) {
                                    System.Array.resize(Bridge.ref(submesh, "Items"), newTriangleCount, 0, System.Int32);
                                }
                                submesh.Count = newTriangleCount;
                            }
                            var submeshItems = submesh.Items;
                            for (var i2 = 0; i2 < attachmentIndexCount; i2 = (i2 + 1) | 0) {
                                submeshItems[((oldTriangleCount + i2) | 0)] = (attachmentTriangleIndices[i2] + ovc) | 0;
                            }
                        }
                    }

                    this.clipper.ClipEnd$1(slot1);
                }
                this.clipper.ClipEnd();

                this.meshBoundsMin = meshBoundsMin.$clone();
                this.meshBoundsMax = meshBoundsMax.$clone();
                this.meshBoundsThickness = instruction.endSlot * zSpacing;

                // Trim or zero submesh triangles.
                var currentSubmeshItems = submesh.Items;
                for (var i3 = submesh.Count, n = currentSubmeshItems.length; i3 < n; i3 = (i3 + 1) | 0) {
                    currentSubmeshItems[i3] = 0;
                }

                this.submeshIndex = (this.submeshIndex + 1) | 0; // Next AddSubmesh will use a new submeshIndex value.
            },
            /*Spine.Unity.MeshGenerator.AddSubmesh end.*/

            /*Spine.Unity.MeshGenerator.BuildMesh start.*/
            BuildMesh: function (instruction, updateTriangles) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#BuildMesh", this ); }

                var wsii = instruction.submeshInstructions.Items;
                for (var i = 0, n = instruction.submeshInstructions.Count; i < n; i = (i + 1) | 0) {
                    this.AddSubmesh(wsii[i], updateTriangles);
                }
            },
            /*Spine.Unity.MeshGenerator.BuildMesh end.*/

            /*Spine.Unity.MeshGenerator.BuildMeshWithArrays start.*/
            BuildMeshWithArrays: function (instruction, updateTriangles) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#BuildMeshWithArrays", this ); }

                var $t, $t1, $t2, $t3, $t4;
                var settings = this.settings.$clone();
                var canvasGroupTintBlack = settings.tintBlack && settings.canvasGroupCompatible;
                var totalVertexCount = instruction.rawVertexCount;

                var linearColorSpace = pc.QualitySettings.instance.activeColorSpace === UnityEngine.ColorSpace.Linear;
                // Add data to vertex buffers
                {
                    if (totalVertexCount > this.vertexBuffer.Items.length) { // Manual ExposedList.Resize()
                        System.Array.resize(Bridge.ref(this.vertexBuffer, "Items"), totalVertexCount, function () {
                            return Bridge.getDefaultValue(UnityEngine.Vector3);
                        }, UnityEngine.Vector3);
                        System.Array.resize(Bridge.ref(this.uvBuffer, "Items"), totalVertexCount, function () {
                            return Bridge.getDefaultValue(UnityEngine.Vector2);
                        }, UnityEngine.Vector2);
                        System.Array.resize(Bridge.ref(this.colorBuffer, "Items"), totalVertexCount, function () {
                            return Bridge.getDefaultValue(UnityEngine.Color32);
                        }, UnityEngine.Color32);
                    }
                    this.vertexBuffer.Count = ($t = (this.colorBuffer.Count = totalVertexCount, totalVertexCount), this.uvBuffer.Count = $t, $t);
                }

                // Populate Verts
                var color = Bridge.getDefaultValue(UnityEngine.Color32);

                var vertexIndex = 0;
                var tempVerts = this.tempVerts;
                var bmin = this.meshBoundsMin.$clone();
                var bmax = this.meshBoundsMax.$clone();

                var vbi = this.vertexBuffer.Items;
                var ubi = this.uvBuffer.Items;
                var cbi = this.colorBuffer.Items;
                var lastSlotIndex = 0;

                // drawOrder[endSlot] is excluded
                for (var si = 0, n = instruction.submeshInstructions.Count; si < n; si = (si + 1) | 0) {
                    var submesh = ($t1 = instruction.submeshInstructions.Items)[si].$clone();
                    var skeleton = submesh.skeleton;
                    var drawOrderItems = skeleton.DrawOrder.Items;
                    var a = skeleton.A, r = skeleton.R, g = skeleton.G, b = skeleton.B;

                    var endSlot = submesh.endSlot;
                    var startSlot = submesh.startSlot;
                    lastSlotIndex = endSlot;

                    if (settings.tintBlack) {
                        var rg = new UnityEngine.Vector2(), b2 = new UnityEngine.Vector2();
                        var vi = vertexIndex;
                        b2.y = 1.0;

                        this.PrepareOptionalUVBuffer(Bridge.ref(this, "uv2"), totalVertexCount);
                        this.PrepareOptionalUVBuffer(Bridge.ref(this, "uv3"), totalVertexCount);

                        var uv2i = this.uv2.Items;
                        var uv3i = this.uv3.Items;

                        for (var slotIndex = startSlot; slotIndex < endSlot; slotIndex = (slotIndex + 1) | 0) {
                            var slot = drawOrderItems[slotIndex];
                            if (!slot.Bone.Active || slot.A === 0.0) {
                                continue;
                            }
                            var attachment = slot.Attachment;

                            rg.x = slot.R2; //r
                            rg.y = slot.G2; //g
                            b2.x = slot.B2; //b
                            b2.y = 1.0;

                            var regionAttachment = Bridge.as(attachment, Spine.RegionAttachment);
                            if (regionAttachment != null) {
                                if (settings.pmaVertexColors) {
                                    var alpha = a * slot.A * regionAttachment.A;
                                    var isAdditiveSlot = slot.Data.BlendMode === Spine.BlendMode.Additive;
                                    if (linearColorSpace && isAdditiveSlot) {
                                        alpha = UnityEngine.Mathf.LinearToGammaSpace(alpha);
                                    } // compensate GammaToLinear performed in shader
                                    rg.x *= alpha;
                                    rg.y *= alpha;
                                    b2.x *= alpha;
                                    b2.y = isAdditiveSlot ? 0 : alpha;
                                }
                                uv2i[vi] = rg.$clone();
                                uv2i[((vi + 1) | 0)] = rg.$clone();
                                uv2i[((vi + 2) | 0)] = rg.$clone();
                                uv2i[((vi + 3) | 0)] = rg.$clone();
                                uv3i[vi] = b2.$clone();
                                uv3i[((vi + 1) | 0)] = b2.$clone();
                                uv3i[((vi + 2) | 0)] = b2.$clone();
                                uv3i[((vi + 3) | 0)] = b2.$clone();
                                vi = (vi + 4) | 0;
                            } else { //} if (settings.renderMeshes) {
                                var meshAttachment = Bridge.as(attachment, Spine.MeshAttachment);
                                if (meshAttachment != null) {
                                    if (settings.pmaVertexColors) {
                                        var alpha1 = a * slot.A * meshAttachment.A;
                                        var isAdditiveSlot1 = slot.Data.BlendMode === Spine.BlendMode.Additive;
                                        if (linearColorSpace && isAdditiveSlot1) {
                                            alpha1 = UnityEngine.Mathf.LinearToGammaSpace(alpha1);
                                        } // compensate GammaToLinear performed in shader
                                        rg.x *= alpha1;
                                        rg.y *= alpha1;
                                        b2.x *= alpha1;
                                        b2.y = isAdditiveSlot1 ? 0 : alpha1;
                                    }
                                    var verticesArrayLength = meshAttachment.WorldVerticesLength;
                                    for (var iii = 0; iii < verticesArrayLength; iii = (iii + 2) | 0) {
                                        uv2i[vi] = rg.$clone();
                                        uv3i[vi] = b2.$clone();
                                        vi = (vi + 1) | 0;
                                    }
                                }
                            }
                        }
                    }

                    for (var slotIndex1 = startSlot; slotIndex1 < endSlot; slotIndex1 = (slotIndex1 + 1) | 0) {
                        var slot1 = drawOrderItems[slotIndex1];
                        if (!slot1.Bone.Active || slot1.A === 0.0) {
                            continue;
                        }
                        var attachment1 = slot1.Attachment;
                        var z = slotIndex1 * settings.zSpacing;

                        var regionAttachment1 = Bridge.as(attachment1, Spine.RegionAttachment);
                        if (regionAttachment1 != null) {
                            regionAttachment1.ComputeWorldVertices(slot1, tempVerts, 0);

                            var x1 = tempVerts[Spine.RegionAttachment.BLX], y1 = tempVerts[Spine.RegionAttachment.BLY];
                            var x2 = tempVerts[Spine.RegionAttachment.ULX], y2 = tempVerts[Spine.RegionAttachment.ULY];
                            var x3 = tempVerts[Spine.RegionAttachment.URX], y3 = tempVerts[Spine.RegionAttachment.URY];
                            var x4 = tempVerts[Spine.RegionAttachment.BRX], y4 = tempVerts[Spine.RegionAttachment.BRY];
                            vbi[vertexIndex].x = x1;
                            vbi[vertexIndex].y = y1;
                            vbi[vertexIndex].z = z;
                            vbi[((vertexIndex + 1) | 0)].x = x4;
                            vbi[((vertexIndex + 1) | 0)].y = y4;
                            vbi[((vertexIndex + 1) | 0)].z = z;
                            vbi[((vertexIndex + 2) | 0)].x = x2;
                            vbi[((vertexIndex + 2) | 0)].y = y2;
                            vbi[((vertexIndex + 2) | 0)].z = z;
                            vbi[((vertexIndex + 3) | 0)].x = x3;
                            vbi[((vertexIndex + 3) | 0)].y = y3;
                            vbi[((vertexIndex + 3) | 0)].z = z;

                            if (settings.pmaVertexColors) {
                                var alpha2 = a * slot1.A * regionAttachment1.A;
                                var isAdditiveSlot2 = slot1.Data.BlendMode === Spine.BlendMode.Additive;
                                if (linearColorSpace && isAdditiveSlot2) {
                                    alpha2 = UnityEngine.Mathf.LinearToGammaSpace(alpha2);
                                } // compensate GammaToLinear performed in shader
                                color.a = Bridge.Int.clipu8(alpha2 * 255);
                                color.r = Bridge.Int.clipu8(r * slot1.R * regionAttachment1.R * color.a);
                                color.g = Bridge.Int.clipu8(g * slot1.G * regionAttachment1.G * color.a);
                                color.b = Bridge.Int.clipu8(b * slot1.B * regionAttachment1.B * color.a);
                                if (canvasGroupTintBlack) {
                                    color.a = 255;
                                } else {
                                    if (isAdditiveSlot2) {
                                        color.a = 0;
                                    }
                                }

                            } else {
                                color.a = Bridge.Int.clipu8(a * slot1.A * regionAttachment1.A * 255);
                                color.r = Bridge.Int.clipu8(r * slot1.R * regionAttachment1.R * 255);
                                color.g = Bridge.Int.clipu8(g * slot1.G * regionAttachment1.G * 255);
                                color.b = Bridge.Int.clipu8(b * slot1.B * regionAttachment1.B * 255);
                            }

                            cbi[vertexIndex] = color.$clone();
                            cbi[((vertexIndex + 1) | 0)] = color.$clone();
                            cbi[((vertexIndex + 2) | 0)] = color.$clone();
                            cbi[((vertexIndex + 3) | 0)] = color.$clone();

                            var regionUVs = regionAttachment1.UVs;
                            ubi[vertexIndex].x = regionUVs[Spine.RegionAttachment.BLX];
                            ubi[vertexIndex].y = regionUVs[Spine.RegionAttachment.BLY];
                            ubi[((vertexIndex + 1) | 0)].x = regionUVs[Spine.RegionAttachment.BRX];
                            ubi[((vertexIndex + 1) | 0)].y = regionUVs[Spine.RegionAttachment.BRY];
                            ubi[((vertexIndex + 2) | 0)].x = regionUVs[Spine.RegionAttachment.ULX];
                            ubi[((vertexIndex + 2) | 0)].y = regionUVs[Spine.RegionAttachment.ULY];
                            ubi[((vertexIndex + 3) | 0)].x = regionUVs[Spine.RegionAttachment.URX];
                            ubi[((vertexIndex + 3) | 0)].y = regionUVs[Spine.RegionAttachment.URY];

                            if (x1 < bmin.x) {
                                bmin.x = x1;
                            } // Potential first attachment bounds initialization. Initial min should not block initial max. Same for Y below.
                            if (x1 > bmax.x) {
                                bmax.x = x1;
                            }
                            if (x2 < bmin.x) {
                                bmin.x = x2;
                            } else {
                                if (x2 > bmax.x) {
                                    bmax.x = x2;
                                }
                            }
                            if (x3 < bmin.x) {
                                bmin.x = x3;
                            } else {
                                if (x3 > bmax.x) {
                                    bmax.x = x3;
                                }
                            }
                            if (x4 < bmin.x) {
                                bmin.x = x4;
                            } else {
                                if (x4 > bmax.x) {
                                    bmax.x = x4;
                                }
                            }

                            if (y1 < bmin.y) {
                                bmin.y = y1;
                            }
                            if (y1 > bmax.y) {
                                bmax.y = y1;
                            }
                            if (y2 < bmin.y) {
                                bmin.y = y2;
                            } else {
                                if (y2 > bmax.y) {
                                    bmax.y = y2;
                                }
                            }
                            if (y3 < bmin.y) {
                                bmin.y = y3;
                            } else {
                                if (y3 > bmax.y) {
                                    bmax.y = y3;
                                }
                            }
                            if (y4 < bmin.y) {
                                bmin.y = y4;
                            } else {
                                if (y4 > bmax.y) {
                                    bmax.y = y4;
                                }
                            }

                            vertexIndex = (vertexIndex + 4) | 0;
                        } else { //if (settings.renderMeshes) {
                            var meshAttachment1 = Bridge.as(attachment1, Spine.MeshAttachment);
                            if (meshAttachment1 != null) {
                                var verticesArrayLength1 = meshAttachment1.WorldVerticesLength;
                                if (tempVerts.length < verticesArrayLength1) {
                                    this.tempVerts = (tempVerts = System.Array.init(verticesArrayLength1, 0, System.Single));
                                }
                                meshAttachment1.ComputeWorldVertices$1(slot1, tempVerts);

                                if (settings.pmaVertexColors) {
                                    var alpha3 = a * slot1.A * meshAttachment1.A;
                                    var isAdditiveSlot3 = slot1.Data.BlendMode === Spine.BlendMode.Additive;
                                    if (linearColorSpace && isAdditiveSlot3) {
                                        alpha3 = UnityEngine.Mathf.LinearToGammaSpace(alpha3);
                                    } // compensate GammaToLinear performed in shader
                                    color.a = Bridge.Int.clipu8(alpha3 * 255);
                                    color.r = Bridge.Int.clipu8(r * slot1.R * meshAttachment1.R * color.a);
                                    color.g = Bridge.Int.clipu8(g * slot1.G * meshAttachment1.G * color.a);
                                    color.b = Bridge.Int.clipu8(b * slot1.B * meshAttachment1.B * color.a);
                                    if (canvasGroupTintBlack) {
                                        color.a = 255;
                                    } else {
                                        if (isAdditiveSlot3) {
                                            color.a = 0;
                                        }
                                    }
                                } else {
                                    color.a = Bridge.Int.clipu8(a * slot1.A * meshAttachment1.A * 255);
                                    color.r = Bridge.Int.clipu8(r * slot1.R * meshAttachment1.R * 255);
                                    color.g = Bridge.Int.clipu8(g * slot1.G * meshAttachment1.G * 255);
                                    color.b = Bridge.Int.clipu8(b * slot1.B * meshAttachment1.B * 255);
                                }

                                var attachmentUVs = meshAttachment1.UVs;

                                // Potential first attachment bounds initialization. See conditions in RegionAttachment logic.
                                if (vertexIndex === 0) {
                                    // Initial min should not block initial max.
                                    // vi == vertexIndex does not always mean the bounds are fresh. It could be a submesh. Do not nuke old values by omitting the check.
                                    // Should know that this is the first attachment in the submesh. slotIndex == startSlot could be an empty slot.
                                    var fx = tempVerts[0], fy = tempVerts[1];
                                    if (fx < bmin.x) {
                                        bmin.x = fx;
                                    }
                                    if (fx > bmax.x) {
                                        bmax.x = fx;
                                    }
                                    if (fy < bmin.y) {
                                        bmin.y = fy;
                                    }
                                    if (fy > bmax.y) {
                                        bmax.y = fy;
                                    }
                                }

                                for (var iii1 = 0; iii1 < verticesArrayLength1; iii1 = (iii1 + 2) | 0) {
                                    var x = tempVerts[iii1], y = tempVerts[((iii1 + 1) | 0)];
                                    vbi[vertexIndex].x = x;
                                    vbi[vertexIndex].y = y;
                                    vbi[vertexIndex].z = z;
                                    cbi[vertexIndex] = color.$clone();
                                    ubi[vertexIndex].x = attachmentUVs[iii1];
                                    ubi[vertexIndex].y = attachmentUVs[((iii1 + 1) | 0)];

                                    if (x < bmin.x) {
                                        bmin.x = x;
                                    } else {
                                        if (x > bmax.x) {
                                            bmax.x = x;
                                        }
                                    }

                                    if (y < bmin.y) {
                                        bmin.y = y;
                                    } else {
                                        if (y > bmax.y) {
                                            bmax.y = y;
                                        }
                                    }

                                    vertexIndex = (vertexIndex + 1) | 0;
                                }
                            }
                        }
                    }
                }

                this.meshBoundsMin = bmin.$clone();
                this.meshBoundsMax = bmax.$clone();
                this.meshBoundsThickness = lastSlotIndex * settings.zSpacing;

                var submeshInstructionCount = instruction.submeshInstructions.Count;
                this.submeshes.Count = submeshInstructionCount;

                // Add triangles
                if (updateTriangles) {
                    // Match submesh buffers count with submeshInstruction count.
                    if (this.submeshes.Items.length < submeshInstructionCount) {
                        this.submeshes.Resize(submeshInstructionCount);
                        for (var i = 0, n1 = submeshInstructionCount; i < n1; i = (i + 1) | 0) {
                            var submeshBuffer = ($t2 = this.submeshes.Items)[i];
                            if (submeshBuffer == null) {
                                ($t3 = this.submeshes.Items)[i] = new (Spine.ExposedList$1(System.Int32)).ctor();
                            } else {
                                submeshBuffer.Clear(false);
                            }
                        }
                    }

                    var submeshInstructionsItems = instruction.submeshInstructions.Items; // This relies on the resize above.

                    // Fill the buffers.
                    var attachmentFirstVertex = 0;
                    for (var smbi = 0; smbi < submeshInstructionCount; smbi = (smbi + 1) | 0) {
                        var submeshInstruction = submeshInstructionsItems[smbi].$clone();
                        var currentSubmeshBuffer = ($t4 = this.submeshes.Items)[smbi];
                        { //submesh.Resize(submesh.rawTriangleCount);
                            var newTriangleCount = submeshInstruction.rawTriangleCount;
                            if (newTriangleCount > currentSubmeshBuffer.Items.length) {
                                System.Array.resize(Bridge.ref(currentSubmeshBuffer, "Items"), newTriangleCount, 0, System.Int32);
                            } else {
                                if (newTriangleCount < currentSubmeshBuffer.Items.length) {
                                    // Zero the extra.
                                    var sbi = currentSubmeshBuffer.Items;
                                    for (var ei = newTriangleCount, nn = sbi.length; ei < nn; ei = (ei + 1) | 0) {
                                        sbi[ei] = 0;
                                    }
                                }
                            }
                            currentSubmeshBuffer.Count = newTriangleCount;
                        }

                        var tris = currentSubmeshBuffer.Items;
                        var triangleIndex = 0;
                        var skeleton1 = submeshInstruction.skeleton;
                        var drawOrderItems1 = skeleton1.DrawOrder.Items;
                        for (var slotIndex2 = submeshInstruction.startSlot, endSlot1 = submeshInstruction.endSlot; slotIndex2 < endSlot1; slotIndex2 = (slotIndex2 + 1) | 0) {
                            var slot2 = drawOrderItems1[slotIndex2];
                            if (!slot2.Bone.Active || slot2.A === 0.0) {
                                continue;
                            }

                            var attachment2 = drawOrderItems1[slotIndex2].Attachment;
                            if (Bridge.is(attachment2, Spine.RegionAttachment)) {
                                tris[triangleIndex] = attachmentFirstVertex;
                                tris[((triangleIndex + 1) | 0)] = (attachmentFirstVertex + 2) | 0;
                                tris[((triangleIndex + 2) | 0)] = (attachmentFirstVertex + 1) | 0;
                                tris[((triangleIndex + 3) | 0)] = (attachmentFirstVertex + 2) | 0;
                                tris[((triangleIndex + 4) | 0)] = (attachmentFirstVertex + 3) | 0;
                                tris[((triangleIndex + 5) | 0)] = (attachmentFirstVertex + 1) | 0;
                                triangleIndex = (triangleIndex + 6) | 0;
                                attachmentFirstVertex = (attachmentFirstVertex + 4) | 0;
                                continue;
                            }
                            var meshAttachment2 = Bridge.as(attachment2, Spine.MeshAttachment);
                            if (meshAttachment2 != null) {
                                var attachmentTriangles = meshAttachment2.Triangles;
                                for (var ii = 0, nn1 = attachmentTriangles.length; ii < nn1; ii = (ii + 1) | 0, triangleIndex = (triangleIndex + 1) | 0) {
                                    tris[triangleIndex] = (attachmentFirstVertex + attachmentTriangles[ii]) | 0;
                                }
                                attachmentFirstVertex = (attachmentFirstVertex + (meshAttachment2.WorldVerticesLength >> 1)) | 0; // length/2;
                            }
                        }
                    }
                }
            },
            /*Spine.Unity.MeshGenerator.BuildMeshWithArrays end.*/

            /*Spine.Unity.MeshGenerator.ScaleVertexData start.*/
            ScaleVertexData: function (scale) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#ScaleVertexData", this ); }

                var vbi = this.vertexBuffer.Items;
                for (var i = 0, n = this.vertexBuffer.Count; i < n; i = (i + 1) | 0) {
                    vbi[i] = vbi[i].$clone().clone().scale( scale );
                }

                this.meshBoundsMin = this.meshBoundsMin.$clone().scale( scale );
                this.meshBoundsMax = this.meshBoundsMax.$clone().scale( scale );
                this.meshBoundsThickness *= scale;
            },
            /*Spine.Unity.MeshGenerator.ScaleVertexData end.*/

            /*Spine.Unity.MeshGenerator.ScaleAndOffsetVertexData start.*/
            ScaleAndOffsetVertexData: function (scale, offset2D) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#ScaleAndOffsetVertexData", this ); }

                var offset = new pc.Vec3( offset2D.x, offset2D.y, 0 );
                var vbi = this.vertexBuffer.Items;
                for (var i = 0, n = this.vertexBuffer.Count; i < n; i = (i + 1) | 0) {
                    vbi[i] = vbi[i].$clone().clone().scale( scale ).add( offset );
                }

                this.meshBoundsMin = this.meshBoundsMin.$clone().scale( scale );
                this.meshBoundsMax = this.meshBoundsMax.$clone().scale( scale );
                this.meshBoundsMin = this.meshBoundsMin.$clone().add( offset2D.$clone() );
                this.meshBoundsMax = this.meshBoundsMax.$clone().add( offset2D.$clone() );
                this.meshBoundsThickness *= scale;
            },
            /*Spine.Unity.MeshGenerator.ScaleAndOffsetVertexData end.*/

            /*Spine.Unity.MeshGenerator.GetMeshBounds start.*/
            GetMeshBounds: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#GetMeshBounds", this ); }

                var $t;
                if ((Math.abs(this.meshBoundsMin.x) === Number.POSITIVE_INFINITY)) { // meshBoundsMin.x == BoundsMinDefault // == doesn't work on float Infinity constants.
                    return new pc.BoundingBox.ctor();
                } else {
                    //mesh.bounds = ArraysMeshGenerator.ToBounds(meshBoundsMin, meshBoundsMax);
                    var halfWidth = (this.meshBoundsMax.x - this.meshBoundsMin.x) * 0.5;
                    var halfHeight = (this.meshBoundsMax.y - this.meshBoundsMin.y) * 0.5;
                    return ($t = new pc.BoundingBox.ctor(), $t.center = new pc.Vec3( this.meshBoundsMin.x + halfWidth, this.meshBoundsMin.y + halfHeight, 0 ), $t.halfExtents = new pc.Vec3( halfWidth, halfHeight, this.meshBoundsThickness * 0.5 ), $t);
                }
            },
            /*Spine.Unity.MeshGenerator.GetMeshBounds end.*/

            /*Spine.Unity.MeshGenerator.AddAttachmentTintBlack start.*/
            AddAttachmentTintBlack: function (r2, g2, b2, a, vertexCount) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#AddAttachmentTintBlack", this ); }

                var rg = new pc.Vec2( r2, g2 );
                var bo = new pc.Vec2( b2, a );

                var ovc = this.vertexBuffer.Count;
                var newVertexCount = (ovc + vertexCount) | 0;

                this.PrepareOptionalUVBuffer(Bridge.ref(this, "uv2"), newVertexCount);
                this.PrepareOptionalUVBuffer(Bridge.ref(this, "uv3"), newVertexCount);

                var uv2i = this.uv2.Items;
                var uv3i = this.uv3.Items;
                for (var i = 0; i < vertexCount; i = (i + 1) | 0) {
                    uv2i[((ovc + i) | 0)] = rg.$clone();
                    uv3i[((ovc + i) | 0)] = bo.$clone();
                }
            },
            /*Spine.Unity.MeshGenerator.AddAttachmentTintBlack end.*/

            /*Spine.Unity.MeshGenerator.PrepareOptionalUVBuffer start.*/
            PrepareOptionalUVBuffer: function (uvBuffer, vertexCount) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#PrepareOptionalUVBuffer", this ); }

                if (uvBuffer.v == null) {
                    uvBuffer.v = new (Spine.ExposedList$1(UnityEngine.Vector2)).ctor();
                }
                if (vertexCount > uvBuffer.v.Items.length) { // Manual ExposedList.Resize()
                    System.Array.resize(Bridge.ref(uvBuffer.v, "Items"), vertexCount, function () {
                        return Bridge.getDefaultValue(UnityEngine.Vector2);
                    }, UnityEngine.Vector2);
                }
                uvBuffer.v.Count = vertexCount;
            },
            /*Spine.Unity.MeshGenerator.PrepareOptionalUVBuffer end.*/

            /*Spine.Unity.MeshGenerator.ResizeOptionalUVBuffer start.*/
            ResizeOptionalUVBuffer: function (uvBuffer, vertexCount) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#ResizeOptionalUVBuffer", this ); }

                if (uvBuffer.v != null) {
                    if (vertexCount !== uvBuffer.v.Items.length) {
                        System.Array.resize(Bridge.ref(uvBuffer.v, "Items"), vertexCount, function () {
                            return Bridge.getDefaultValue(UnityEngine.Vector2);
                        }, UnityEngine.Vector2);
                        uvBuffer.v.Count = vertexCount;
                    }
                }
            },
            /*Spine.Unity.MeshGenerator.ResizeOptionalUVBuffer end.*/

            /*Spine.Unity.MeshGenerator.FillVertexData start.*/
            FillVertexData: function (mesh) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#FillVertexData", this ); }

                var vbi = this.vertexBuffer.Items;
                var ubi = this.uvBuffer.Items;
                var cbi = this.colorBuffer.Items;
                var vbiLength = vbi.length;

                // Zero the extra.
                {
                    var listCount = this.vertexBuffer.Count;
                    var vector3zero = pc.Vec3.ZERO.clone();
                    for (var i = listCount; i < vbiLength; i = (i + 1) | 0) {
                        vbi[i] = vector3zero.$clone();
                    }
                }

                // Set the vertex buffer.
                {
                    mesh.vertices = vbi;
                    mesh.uv = ubi;
                    mesh.colors32 = cbi;
                    mesh.bounds = this.GetMeshBounds();
                }

                {
                    if (this.settings.addNormals) {
                        var oldLength = 0;

                        if (this.normals == null) {
                            this.normals = System.Array.init(vbiLength, function (){
                                return new UnityEngine.Vector3();
                            }, UnityEngine.Vector3);
                        } else {
                            oldLength = this.normals.length;
                        }

                        if (oldLength !== vbiLength) {
                            System.Array.resize(Bridge.ref(this, "normals"), vbiLength, function () {
                                return Bridge.getDefaultValue(UnityEngine.Vector3);
                            }, UnityEngine.Vector3);
                            var localNormals = this.normals;
                            for (var i1 = oldLength; i1 < vbiLength; i1 = (i1 + 1) | 0) {
                                localNormals[i1] = new pc.Vec3( 0, 0, -1 );
                            }
                        }
                        mesh.normals = this.normals;
                    }

                    // Sometimes, the vertex buffer becomes smaller. We need to trim the size of
                    // the uv2 and uv3 buffers (used for tint black) to match.
                    this.ResizeOptionalUVBuffer(Bridge.ref(this, "uv2"), vbiLength);
                    this.ResizeOptionalUVBuffer(Bridge.ref(this, "uv3"), vbiLength);
                    mesh.uv2 = this.uv2 == null ? null : this.uv2.Items;
                    mesh.uv3 = this.uv3 == null ? null : this.uv3.Items;
                }
            },
            /*Spine.Unity.MeshGenerator.FillVertexData end.*/

            /*Spine.Unity.MeshGenerator.FillLateVertexData start.*/
            FillLateVertexData: function (mesh) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#FillLateVertexData", this ); }

                if (this.settings.calculateTangents) {
                    var vertexCount = this.vertexBuffer.Count;
                    var sbi = this.submeshes.Items;
                    var submeshCount = this.submeshes.Count;
                    var vbi = this.vertexBuffer.Items;
                    var ubi = this.uvBuffer.Items;

                    Spine.Unity.MeshGenerator.SolveTangents2DEnsureSize(Bridge.ref(this, "tangents"), Bridge.ref(this, "tempTanBuffer"), vertexCount, vbi.length);
                    for (var i = 0; i < submeshCount; i = (i + 1) | 0) {
                        var submesh = sbi[i].Items;
                        var triangleCount = sbi[i].Count;
                        Spine.Unity.MeshGenerator.SolveTangents2DTriangles(this.tempTanBuffer, submesh, triangleCount, vbi, ubi, vertexCount);
                    }
                    Spine.Unity.MeshGenerator.SolveTangents2DBuffer(this.tangents, this.tempTanBuffer, vertexCount);
                    mesh.tangents = this.tangents;
                }
            },
            /*Spine.Unity.MeshGenerator.FillLateVertexData end.*/

            /*Spine.Unity.MeshGenerator.FillTriangles start.*/
            FillTriangles: function (mesh) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#FillTriangles", this ); }

                var submeshCount = this.submeshes.Count;
                var submeshesItems = this.submeshes.Items;
                mesh.subMeshCount = submeshCount;

                for (var i = 0; i < submeshCount; i = (i + 1) | 0) {
                    mesh.SetTriangles$4(submeshesItems[i].Items, 0, submeshesItems[i].Count, i, false);
                }
            },
            /*Spine.Unity.MeshGenerator.FillTriangles end.*/

            /*Spine.Unity.MeshGenerator.EnsureVertexCapacity start.*/
            EnsureVertexCapacity: function (minimumVertexCount, inlcudeTintBlack, includeTangents, includeNormals) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#EnsureVertexCapacity", this ); }

                if (inlcudeTintBlack === void 0) { inlcudeTintBlack = false; }
                if (includeTangents === void 0) { includeTangents = false; }
                if (includeNormals === void 0) { includeNormals = false; }
                if (minimumVertexCount > this.vertexBuffer.Items.length) {
                    System.Array.resize(Bridge.ref(this.vertexBuffer, "Items"), minimumVertexCount, function () {
                        return Bridge.getDefaultValue(UnityEngine.Vector3);
                    }, UnityEngine.Vector3);
                    System.Array.resize(Bridge.ref(this.uvBuffer, "Items"), minimumVertexCount, function () {
                        return Bridge.getDefaultValue(UnityEngine.Vector2);
                    }, UnityEngine.Vector2);
                    System.Array.resize(Bridge.ref(this.colorBuffer, "Items"), minimumVertexCount, function () {
                        return Bridge.getDefaultValue(UnityEngine.Color32);
                    }, UnityEngine.Color32);

                    if (inlcudeTintBlack) {
                        if (this.uv2 == null) {
                            this.uv2 = new (Spine.ExposedList$1(UnityEngine.Vector2)).$ctor3(minimumVertexCount);
                            this.uv3 = new (Spine.ExposedList$1(UnityEngine.Vector2)).$ctor3(minimumVertexCount);
                        }
                        this.uv2.Resize(minimumVertexCount);
                        this.uv3.Resize(minimumVertexCount);
                    }

                    if (includeNormals) {
                        if (this.normals == null) {
                            this.normals = System.Array.init(minimumVertexCount, function (){
                                return new UnityEngine.Vector3();
                            }, UnityEngine.Vector3);
                        } else {
                            System.Array.resize(Bridge.ref(this, "normals"), minimumVertexCount, function () {
                                return Bridge.getDefaultValue(UnityEngine.Vector3);
                            }, UnityEngine.Vector3);
                        }

                    }

                    if (includeTangents) {
                        if (this.tangents == null) {
                            this.tangents = System.Array.init(minimumVertexCount, function (){
                                return new UnityEngine.Vector4();
                            }, UnityEngine.Vector4);
                        } else {
                            System.Array.resize(Bridge.ref(this, "tangents"), minimumVertexCount, function () {
                                return Bridge.getDefaultValue(UnityEngine.Vector4);
                            }, UnityEngine.Vector4);
                        }
                    }
                }
            },
            /*Spine.Unity.MeshGenerator.EnsureVertexCapacity end.*/

            /*Spine.Unity.MeshGenerator.TrimExcess start.*/
            /**
             * Trims internal buffers to reduce the resulting mesh data stream size.
             *
             * @instance
             * @public
             * @this Spine.Unity.MeshGenerator
             * @memberof Spine.Unity.MeshGenerator
             * @return  {void}
             */
            TrimExcess: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#TrimExcess", this ); }

                this.vertexBuffer.TrimExcess();
                this.uvBuffer.TrimExcess();
                this.colorBuffer.TrimExcess();

                if (this.uv2 != null) {
                    this.uv2.TrimExcess();
                }
                if (this.uv3 != null) {
                    this.uv3.TrimExcess();
                }

                var vbiLength = this.vertexBuffer.Items.length;
                if (this.normals != null) {
                    System.Array.resize(Bridge.ref(this, "normals"), vbiLength, function () {
                        return Bridge.getDefaultValue(UnityEngine.Vector3);
                    }, UnityEngine.Vector3);
                }
                if (this.tangents != null) {
                    System.Array.resize(Bridge.ref(this, "tangents"), vbiLength, function () {
                        return Bridge.getDefaultValue(UnityEngine.Vector4);
                    }, UnityEngine.Vector4);
                }
            },
            /*Spine.Unity.MeshGenerator.TrimExcess end.*/


        }
    });
    /*Spine.Unity.MeshGenerator end.*/

    /*Spine.Unity.MeshGenerator+Settings start.*/
    Bridge.define("Spine.Unity.MeshGenerator.Settings", {
        $kind: 1004,
        statics: {
            props: {
                Default: {
                    get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator.Settings#Default#get", this ); }

                        var $t;
                        return ($t = new Spine.Unity.MeshGenerator.Settings(), $t.pmaVertexColors = true, $t.zSpacing = 0.0, $t.useClipping = true, $t.tintBlack = false, $t.calculateTangents = false, $t.addNormals = false, $t.immutableTriangles = false, $t);
                    }
                }
            },
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator.Settings#getDefaultValue", this ); }
 return new Spine.Unity.MeshGenerator.Settings(); }
            }
        },
        fields: {
            useClipping: false,
            zSpacing: 0,
            tintBlack: false,
            canvasGroupCompatible: false,
            pmaVertexColors: false,
            addNormals: false,
            calculateTangents: false,
            immutableTriangles: false
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator.Settings#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator.Settings#getHashCode", this ); }

                var h = Bridge.addHash([3889943484, this.useClipping, this.zSpacing, this.tintBlack, this.canvasGroupCompatible, this.pmaVertexColors, this.addNormals, this.calculateTangents, this.immutableTriangles]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator.Settings#equals", this ); }

                if (!Bridge.is(o, Spine.Unity.MeshGenerator.Settings)) {
                    return false;
                }
                return Bridge.equals(this.useClipping, o.useClipping) && Bridge.equals(this.zSpacing, o.zSpacing) && Bridge.equals(this.tintBlack, o.tintBlack) && Bridge.equals(this.canvasGroupCompatible, o.canvasGroupCompatible) && Bridge.equals(this.pmaVertexColors, o.pmaVertexColors) && Bridge.equals(this.addNormals, o.addNormals) && Bridge.equals(this.calculateTangents, o.calculateTangents) && Bridge.equals(this.immutableTriangles, o.immutableTriangles);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator.Settings#$clone", this ); }

                var s = to || new Spine.Unity.MeshGenerator.Settings();
                s.useClipping = this.useClipping;
                s.zSpacing = this.zSpacing;
                s.tintBlack = this.tintBlack;
                s.canvasGroupCompatible = this.canvasGroupCompatible;
                s.pmaVertexColors = this.pmaVertexColors;
                s.addNormals = this.addNormals;
                s.calculateTangents = this.calculateTangents;
                s.immutableTriangles = this.immutableTriangles;
                return s;
            }
        }
    });
    /*Spine.Unity.MeshGenerator+Settings end.*/

    /*Spine.Unity.MeshGeneratorBuffers start.*/
    Bridge.define("Spine.Unity.MeshGeneratorBuffers", {
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGeneratorBuffers#getDefaultValue", this ); }
 return new Spine.Unity.MeshGeneratorBuffers(); }
            }
        },
        fields: {
            /**
             * The vertex count that will actually be used for the mesh. The Lengths of the buffer arrays may be larger than this number.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.MeshGeneratorBuffers
             * @type number
             */
            vertexCount: 0,
            /**
             * Vertex positions. To be used for UnityEngine.Mesh.vertices.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.MeshGeneratorBuffers
             * @type Array.<UnityEngine.Vector3>
             */
            vertexBuffer: null,
            /**
             * Vertex texture coordinates (UVs). To be used for UnityEngine.Mesh.uv.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.MeshGeneratorBuffers
             * @type Array.<UnityEngine.Vector2>
             */
            uvBuffer: null,
            /**
             * Vertex colors. To be used for UnityEngine.Mesh.colors32.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.MeshGeneratorBuffers
             * @type Array.<UnityEngine.Color32>
             */
            colorBuffer: null,
            /**
             * The Spine rendering component's MeshGenerator.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.MeshGeneratorBuffers
             * @type Spine.Unity.MeshGenerator
             */
            meshGenerator: null
        },
        props: {
            /**
             * Optional vertex texture coordinates (UVs), second channel. To be used for UnityEngine.Mesh.uv2.
             Using this accessor automatically allocates and resizes the buffer accordingly.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.MeshGeneratorBuffers
             * @function uv2Buffer
             * @type Array.<UnityEngine.Vector2>
             */
            uv2Buffer: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGeneratorBuffers#uv2Buffer#get", this ); }

                    return this.meshGenerator.UV2;
                }
            },
            /**
             * Optional vertex texture coordinates (UVs), third channel. To be used for UnityEngine.Mesh.uv3.
             Using this accessor automatically allocates and resizes the buffer accordingly.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.MeshGeneratorBuffers
             * @function uv3Buffer
             * @type Array.<UnityEngine.Vector2>
             */
            uv3Buffer: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGeneratorBuffers#uv3Buffer#get", this ); }

                    return this.meshGenerator.UV3;
                }
            }
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGeneratorBuffers#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGeneratorBuffers#getHashCode", this ); }

                var h = Bridge.addHash([8979862494, this.vertexCount, this.vertexBuffer, this.uvBuffer, this.colorBuffer, this.meshGenerator]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGeneratorBuffers#equals", this ); }

                if (!Bridge.is(o, Spine.Unity.MeshGeneratorBuffers)) {
                    return false;
                }
                return Bridge.equals(this.vertexCount, o.vertexCount) && Bridge.equals(this.vertexBuffer, o.vertexBuffer) && Bridge.equals(this.uvBuffer, o.uvBuffer) && Bridge.equals(this.colorBuffer, o.colorBuffer) && Bridge.equals(this.meshGenerator, o.meshGenerator);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGeneratorBuffers#$clone", this ); }

                var s = to || new Spine.Unity.MeshGeneratorBuffers();
                s.vertexCount = this.vertexCount;
                s.vertexBuffer = this.vertexBuffer;
                s.uvBuffer = this.uvBuffer;
                s.colorBuffer = this.colorBuffer;
                s.meshGenerator = this.meshGenerator;
                return s;
            }
        }
    });
    /*Spine.Unity.MeshGeneratorBuffers end.*/

    /*Spine.Unity.MeshRendererBuffers start.*/
    /**
     * A double-buffered Mesh, and a shared material array, bundled for use by Spine components that need to push a Mesh and materials to a Unity MeshRenderer and MeshFilter.
     *
     * @public
     * @class Spine.Unity.MeshRendererBuffers
     * @implements  System.IDisposable
     */
    Bridge.define("Spine.Unity.MeshRendererBuffers", {
        inherits: [System.IDisposable],
        fields: {
            doubleBufferedMesh: null,
            submeshMaterials: null,
            sharedMaterials: null
        },
        alias: ["Dispose", "System$IDisposable$Dispose"],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#init", this ); }

                this.submeshMaterials = new (Spine.ExposedList$1(UnityEngine.Material)).ctor();
                this.sharedMaterials = System.Array.init(0, null, UnityEngine.Material);
            }
        },
        methods: {
            /*Spine.Unity.MeshRendererBuffers.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#Initialize", this ); }

                if (this.doubleBufferedMesh != null) {
                    this.doubleBufferedMesh.GetNext().Clear();
                    this.doubleBufferedMesh.GetNext().Clear();
                    this.submeshMaterials.Clear();
                } else {
                    this.doubleBufferedMesh = new (Spine.Unity.DoubleBuffered$1(Spine.Unity.MeshRendererBuffers.SmartMesh))();
                }
            },
            /*Spine.Unity.MeshRendererBuffers.Initialize end.*/

            /*Spine.Unity.MeshRendererBuffers.GetUpdatedSharedMaterialsArray start.*/
            /**
             * Returns a sharedMaterials array for use on a MeshRenderer.
             *
             * @instance
             * @public
             * @this Spine.Unity.MeshRendererBuffers
             * @memberof Spine.Unity.MeshRendererBuffers
             * @return  {Array.<UnityEngine.Material>}
             */
            GetUpdatedSharedMaterialsArray: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#GetUpdatedSharedMaterialsArray", this ); }

                if (this.submeshMaterials.Count === this.sharedMaterials.length) {
                    this.submeshMaterials.CopyTo(this.sharedMaterials);
                } else {
                    this.sharedMaterials = this.submeshMaterials.ToArray();
                }

                return this.sharedMaterials;
            },
            /*Spine.Unity.MeshRendererBuffers.GetUpdatedSharedMaterialsArray end.*/

            /*Spine.Unity.MeshRendererBuffers.MaterialsChangedInLastUpdate start.*/
            /**
             * Returns true if the materials were modified since the buffers were last updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.MeshRendererBuffers
             * @memberof Spine.Unity.MeshRendererBuffers
             * @return  {boolean}
             */
            MaterialsChangedInLastUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#MaterialsChangedInLastUpdate", this ); }

                var newSubmeshMaterials = this.submeshMaterials.Count;
                var sharedMaterials = this.sharedMaterials;
                if (newSubmeshMaterials !== sharedMaterials.length) {
                    return true;
                }

                var submeshMaterialsItems = this.submeshMaterials.Items;
                for (var i = 0; i < newSubmeshMaterials; i = (i + 1) | 0) {
                    if (!Bridge.referenceEquals(submeshMaterialsItems[i], sharedMaterials[i])) {
                        return true;
                    }
                } //if (submeshMaterialsItems[i].GetInstanceID() != sharedMaterials[i].GetInstanceID()) return true;

                return false;
            },
            /*Spine.Unity.MeshRendererBuffers.MaterialsChangedInLastUpdate end.*/

            /*Spine.Unity.MeshRendererBuffers.UpdateSharedMaterials start.*/
            /**
             * Updates the internal shared materials array with the given instruction list.
             *
             * @instance
             * @public
             * @this Spine.Unity.MeshRendererBuffers
             * @memberof Spine.Unity.MeshRendererBuffers
             * @param   {Spine.ExposedList$1}    instructions
             * @return  {void}
             */
            UpdateSharedMaterials: function (instructions) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#UpdateSharedMaterials", this ); }

                var newSize = instructions.Count;
                { //submeshMaterials.Resize(instructions.Count);
                    if (newSize > this.submeshMaterials.Items.length) {
                        System.Array.resize(Bridge.ref(this.submeshMaterials, "Items"), newSize, null, UnityEngine.Material);
                    }
                    this.submeshMaterials.Count = newSize;
                }

                var submeshMaterialsItems = this.submeshMaterials.Items;
                var instructionsItems = instructions.Items;
                for (var i = 0; i < newSize; i = (i + 1) | 0) {
                    submeshMaterialsItems[i] = instructionsItems[i].material;
                }
            },
            /*Spine.Unity.MeshRendererBuffers.UpdateSharedMaterials end.*/

            /*Spine.Unity.MeshRendererBuffers.GetNextMesh start.*/
            GetNextMesh: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#GetNextMesh", this ); }

                return this.doubleBufferedMesh.GetNext();
            },
            /*Spine.Unity.MeshRendererBuffers.GetNextMesh end.*/

            /*Spine.Unity.MeshRendererBuffers.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#Clear", this ); }

                this.sharedMaterials = System.Array.init(0, null, UnityEngine.Material);
                this.submeshMaterials.Clear();
            },
            /*Spine.Unity.MeshRendererBuffers.Clear end.*/

            /*Spine.Unity.MeshRendererBuffers.Dispose start.*/
            Dispose: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#Dispose", this ); }

                if (this.doubleBufferedMesh == null) {
                    return;
                }
                this.doubleBufferedMesh.GetNext().Dispose();
                this.doubleBufferedMesh.GetNext().Dispose();
                this.doubleBufferedMesh = null;
            },
            /*Spine.Unity.MeshRendererBuffers.Dispose end.*/


        }
    });
    /*Spine.Unity.MeshRendererBuffers end.*/

    /*Spine.Unity.MeshRendererBuffers+SmartMesh start.*/
    /**
     * This is a Mesh that also stores the instructions SkeletonRenderer generated for it.
     *
     * @public
     * @class Spine.Unity.MeshRendererBuffers.SmartMesh
     * @implements  System.IDisposable
     */
    Bridge.define("Spine.Unity.MeshRendererBuffers.SmartMesh", {
        inherits: [System.IDisposable],
        $kind: 1002,
        fields: {
            mesh: null,
            instructionUsed: null
        },
        alias: ["Dispose", "System$IDisposable$Dispose"],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers.SmartMesh#init", this ); }

                this.mesh = Spine.Unity.SpineMesh.NewSkeletonMesh();
                this.instructionUsed = new Spine.Unity.SkeletonRendererInstruction();
            }
        },
        methods: {
            /*Spine.Unity.MeshRendererBuffers+SmartMesh.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers.SmartMesh#Clear", this ); }

                this.mesh.Clear();
                this.instructionUsed.Clear();
            },
            /*Spine.Unity.MeshRendererBuffers+SmartMesh.Clear end.*/

            /*Spine.Unity.MeshRendererBuffers+SmartMesh.Dispose start.*/
            Dispose: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers.SmartMesh#Dispose", this ); }

                if (this.mesh != null) {
                    UnityEngine.Object.Destroy(this.mesh);
                }
                this.mesh = null;
            },
            /*Spine.Unity.MeshRendererBuffers+SmartMesh.Dispose end.*/


        }
    });
    /*Spine.Unity.MeshRendererBuffers+SmartMesh end.*/

    /*Spine.Unity.OnDemandTextureLoader start.*/
    Bridge.define("Spine.Unity.OnDemandTextureLoader", {
        inherits: [UnityEngine.ScriptableObject],
        fields: {
            atlasAsset: null
        },
        events: {
            onTextureRequested: null,
            onTextureLoaded: null,
            onTextureLoadFailed: null,
            onTextureUnloaded: null
        },
        methods: {
            addTextureRequested: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.OnDemandTextureLoader#addTextureRequested", this ); }

                this.addonTextureRequested(value);
            },
            removeTextureRequested: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.OnDemandTextureLoader#removeTextureRequested", this ); }

                this.removeonTextureRequested(value);
            },
            addTextureLoaded: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.OnDemandTextureLoader#addTextureLoaded", this ); }

                this.addonTextureLoaded(value);
            },
            removeTextureLoaded: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.OnDemandTextureLoader#removeTextureLoaded", this ); }

                this.removeonTextureLoaded(value);
            },
            addTextureLoadFailed: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.OnDemandTextureLoader#addTextureLoadFailed", this ); }

                this.addonTextureLoadFailed(value);
            },
            removeTextureLoadFailed: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.OnDemandTextureLoader#removeTextureLoadFailed", this ); }

                this.removeonTextureLoadFailed(value);
            },
            addTextureUnloaded: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.OnDemandTextureLoader#addTextureUnloaded", this ); }

                this.addonTextureUnloaded(value);
            },
            removeTextureUnloaded: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.OnDemandTextureLoader#removeTextureUnloaded", this ); }

                this.removeonTextureUnloaded(value);
            },
            /*Spine.Unity.OnDemandTextureLoader.HasNullMainTexturesAssigned start.*/
            /**
             * Returns whether any main texture is null at a Material of the associated AtlasAssetBase.
             *
             * @instance
             * @public
             * @this Spine.Unity.OnDemandTextureLoader
             * @memberof Spine.Unity.OnDemandTextureLoader
             * @param   {System.Collections.Generic.List}    nullTextureMaterials    A newly created list of materials which has a null main texture assigned.
             * @return  {boolean}                                                    True, if any null main texture is assigned at a Material of the associated AtlasAssetBase.
             */
            HasNullMainTexturesAssigned: function (nullTextureMaterials) {
if ( TRACE ) { TRACE( "Spine.Unity.OnDemandTextureLoader#HasNullMainTexturesAssigned", this ); }

                var $t;
                nullTextureMaterials.v = null;
                if (!UnityEngine.Object.op_Implicit(this.atlasAsset)) {
                    return false;
                }

                var anyNullTexture = false;
                $t = Bridge.getEnumerator(this.atlasAsset.Materials, UnityEngine.Material);
                try {
                    while ($t.moveNext()) {
                        var material = $t.Current;
                        if (material.mainTexture == null) {
                            anyNullTexture = true;
                            if (nullTextureMaterials.v == null) {
                                nullTextureMaterials.v = new (System.Collections.Generic.List$1(UnityEngine.Material)).ctor();
                            }
                            nullTextureMaterials.v.add(material);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                return anyNullTexture;
            },
            /*Spine.Unity.OnDemandTextureLoader.HasNullMainTexturesAssigned end.*/

            /*Spine.Unity.OnDemandTextureLoader.OnTextureRequested start.*/
            OnTextureRequested: function (material, textureIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.OnDemandTextureLoader#OnTextureRequested", this ); }

                if (!Bridge.staticEquals(this.onTextureRequested, null)) {
                    this.onTextureRequested(this, material, textureIndex);
                }
            },
            /*Spine.Unity.OnDemandTextureLoader.OnTextureRequested end.*/

            /*Spine.Unity.OnDemandTextureLoader.OnTextureLoaded start.*/
            OnTextureLoaded: function (material, textureIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.OnDemandTextureLoader#OnTextureLoaded", this ); }

                if (!Bridge.staticEquals(this.onTextureLoaded, null)) {
                    this.onTextureLoaded(this, material, textureIndex);
                }
            },
            /*Spine.Unity.OnDemandTextureLoader.OnTextureLoaded end.*/

            /*Spine.Unity.OnDemandTextureLoader.OnTextureLoadFailed start.*/
            OnTextureLoadFailed: function (material, textureIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.OnDemandTextureLoader#OnTextureLoadFailed", this ); }

                if (!Bridge.staticEquals(this.onTextureLoadFailed, null)) {
                    this.onTextureLoadFailed(this, material, textureIndex);
                }
            },
            /*Spine.Unity.OnDemandTextureLoader.OnTextureLoadFailed end.*/

            /*Spine.Unity.OnDemandTextureLoader.OnTextureUnloaded start.*/
            OnTextureUnloaded: function (material, textureIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.OnDemandTextureLoader#OnTextureUnloaded", this ); }

                if (!Bridge.staticEquals(this.onTextureUnloaded, null)) {
                    this.onTextureUnloaded(this, material, textureIndex);
                }
            },
            /*Spine.Unity.OnDemandTextureLoader.OnTextureUnloaded end.*/


        }
    });
    /*Spine.Unity.OnDemandTextureLoader end.*/

    /*Spine.Unity.SkeletonDataAsset start.*/
    Bridge.define("Spine.Unity.SkeletonDataAsset", {
        inherits: [UnityEngine.ScriptableObject],
        statics: {
            methods: {
                /*Spine.Unity.SkeletonDataAsset.CreateRuntimeInstance:static start.*/
                /**
                 * Creates a runtime SkeletonDataAsset.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonDataAsset
                 * @memberof Spine.Unity.SkeletonDataAsset
                 * @param   {UnityEngine.TextAsset}            skeletonDataFile    
                 * @param   {Spine.Unity.AtlasAssetBase}       atlasAsset          
                 * @param   {boolean}                          initialize          
                 * @param   {number}                           scale
                 * @return  {Spine.Unity.SkeletonDataAsset}
                 */
                CreateRuntimeInstance: function (skeletonDataFile, atlasAsset, initialize, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#CreateRuntimeInstance", this ); }

                    if (scale === void 0) { scale = 0.01; }
                    return Spine.Unity.SkeletonDataAsset.CreateRuntimeInstance$1(skeletonDataFile, System.Array.init([atlasAsset], Spine.Unity.AtlasAssetBase), initialize, scale);
                },
                /*Spine.Unity.SkeletonDataAsset.CreateRuntimeInstance:static end.*/

                /*Spine.Unity.SkeletonDataAsset.CreateRuntimeInstance$1:static start.*/
                /**
                 * Creates a runtime SkeletonDataAsset.
                 If you require blend mode materials, call {@link } afterwards.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonDataAsset
                 * @memberof Spine.Unity.SkeletonDataAsset
                 * @param   {UnityEngine.TextAsset}                 skeletonDataFile    
                 * @param   {Array.<Spine.Unity.AtlasAssetBase>}    atlasAssets         
                 * @param   {boolean}                               initialize          
                 * @param   {number}                                scale
                 * @return  {Spine.Unity.SkeletonDataAsset}
                 */
                CreateRuntimeInstance$1: function (skeletonDataFile, atlasAssets, initialize, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#CreateRuntimeInstance$1", this ); }

                    if (scale === void 0) { scale = 0.01; }
                    var skeletonDataAsset = UnityEngine.ScriptableObject.CreateInstance(Spine.Unity.SkeletonDataAsset);
                    skeletonDataAsset.Clear();
                    skeletonDataAsset.skeletonJSON = skeletonDataFile;
                    skeletonDataAsset.atlasAssets = atlasAssets;
                    skeletonDataAsset.scale = scale;

                    if (initialize) {
                        skeletonDataAsset.GetSkeletonData(true);
                    }

                    return skeletonDataAsset;
                },
                /*Spine.Unity.SkeletonDataAsset.CreateRuntimeInstance$1:static end.*/

                /*Spine.Unity.SkeletonDataAsset.ReadSkeletonData:static start.*/
                ReadSkeletonData: function (bytes, attachmentLoader, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#ReadSkeletonData", this ); }

                    var $t;
                    var input = new System.IO.MemoryStream.$ctor1(bytes);
                    try {
                        var binary = ($t = new Spine.SkeletonBinary.$ctor1(attachmentLoader), $t.Scale = scale, $t);
                        return binary.ReadSkeletonData$1(input);
                    }
                    finally {
                        if (Bridge.hasValue(input)) {
                            input.System$IDisposable$Dispose();
                        }
                    }
                },
                /*Spine.Unity.SkeletonDataAsset.ReadSkeletonData:static end.*/

                /*Spine.Unity.SkeletonDataAsset.ReadSkeletonData$1:static start.*/
                ReadSkeletonData$1: function (text, attachmentLoader, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#ReadSkeletonData$1", this ); }

                    var $t;
                    var input = new System.IO.StringReader(text);
                    var json = ($t = new Spine.SkeletonJson.$ctor1(attachmentLoader), $t.Scale = scale, $t);
                    return json.ReadSkeletonData$1(input);
                },
                /*Spine.Unity.SkeletonDataAsset.ReadSkeletonData$1:static end.*/


            }
        },
        fields: {
            atlasAssets: null,
            scale: 0,
            skeletonJSON: null,
            isUpgradingBlendModeMaterials: false,
            blendModeMaterials: null,
            skeletonDataModifiers: null,
            fromAnimation: null,
            toAnimation: null,
            duration: null,
            defaultMix: 0,
            controller: null,
            skeletonData: null,
            stateData: null
        },
        props: {
            IsLoaded: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#IsLoaded#get", this ); }

                    return this.skeletonData != null;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#init", this ); }

                this.atlasAssets = System.Array.init(0, null, Spine.Unity.AtlasAssetBase);
                this.scale = 0.01;
                this.isUpgradingBlendModeMaterials = false;
                this.blendModeMaterials = new Spine.Unity.BlendModeMaterials();
                this.skeletonDataModifiers = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonDataModifierAsset)).ctor();
                this.fromAnimation = System.Array.init(0, null, System.String);
                this.toAnimation = System.Array.init(0, null, System.String);
                this.duration = System.Array.init(0, 0, System.Single);
            }
        },
        methods: {
            /*Spine.Unity.SkeletonDataAsset.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#Reset", this ); }

                this.Clear();
            },
            /*Spine.Unity.SkeletonDataAsset.Reset end.*/

            /*Spine.Unity.SkeletonDataAsset.SetupRuntimeBlendModeMaterials start.*/
            /**
             * If this SkeletonDataAsset has been created via {@link },
             this method sets up blend mode materials for it.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonDataAsset
             * @memberof Spine.Unity.SkeletonDataAsset
             * @param   {boolean}                                             applyAdditiveMaterial    
             * @param   {Spine.Unity.BlendModeMaterials.TemplateMaterials}    templateMaterials
             * @return  {void}
             */
            SetupRuntimeBlendModeMaterials: function (applyAdditiveMaterial, templateMaterials) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#SetupRuntimeBlendModeMaterials", this ); }

                this.blendModeMaterials.applyAdditiveMaterial = applyAdditiveMaterial;
                this.blendModeMaterials.UpdateBlendmodeMaterialsRequiredState(this.GetSkeletonData(true));
                var anyMaterialsChanged = { v : false };
                Spine.Unity.BlendModeMaterials.CreateAndAssignMaterials(this, templateMaterials, anyMaterialsChanged);

                this.Clear();
                this.GetSkeletonData(true);
            },
            /*Spine.Unity.SkeletonDataAsset.SetupRuntimeBlendModeMaterials end.*/

            /*Spine.Unity.SkeletonDataAsset.Clear start.*/
            /**
             * Clears the loaded SkeletonData and AnimationStateData. Use this to force a reload for the next time GetSkeletonData is called.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonDataAsset
             * @memberof Spine.Unity.SkeletonDataAsset
             * @return  {void}
             */
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#Clear", this ); }

                this.skeletonData = null;
                this.stateData = null;
            },
            /*Spine.Unity.SkeletonDataAsset.Clear end.*/

            /*Spine.Unity.SkeletonDataAsset.GetAnimationStateData start.*/
            GetAnimationStateData: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#GetAnimationStateData", this ); }

                if (this.stateData != null) {
                    return this.stateData;
                }
                this.GetSkeletonData(false);
                return this.stateData;
            },
            /*Spine.Unity.SkeletonDataAsset.GetAnimationStateData end.*/

            /*Spine.Unity.SkeletonDataAsset.GetSkeletonData start.*/
            /**
             * Loads, caches and returns the SkeletonData from the skeleton data file. Returns the cached SkeletonData after the first time it is called. Pass false to prevent direct errors from being logged.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonDataAsset
             * @memberof Spine.Unity.SkeletonDataAsset
             * @param   {boolean}               quiet
             * @return  {Spine.SkeletonData}
             */
            GetSkeletonData: function (quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#GetSkeletonData", this ); }

                var $t;
                if (this.skeletonJSON == null) {
                    if (!quiet) {
                        UnityEngine.Debug.LogError$2("Skeleton JSON file not set for SkeletonData asset: " + (this.name || ""), this);
                    }
                    this.Clear();
                    return null;
                }

                // Disabled to support attachmentless/skinless SkeletonData.
                //			if (atlasAssets == null) {
                //				atlasAssets = new AtlasAsset[0];
                //				if (!quiet)
                //					Debug.LogError("Atlas not set for SkeletonData asset: " + name, this);
                //				Clear();
                //				return null;
                //			}
                //			#if !SPINE_TK2D
                //			if (atlasAssets.Length == 0) {
                //				Clear();
                //				return null;
                //			}
                //			#else
                //			if (atlasAssets.Length == 0 && spriteCollection == null) {
                //				Clear();
                //				return null;
                //			}
                //			#endif

                if (this.skeletonData != null) {
                    return this.skeletonData;
                }

                var attachmentLoader;
                var skeletonDataScale;
                var atlasArray = this.GetAtlasArray();

                attachmentLoader = (atlasArray.length === 0) ? Bridge.cast(new Spine.Unity.RegionlessAttachmentLoader(), Spine.AttachmentLoader) : Bridge.cast(new Spine.AtlasAttachmentLoader(atlasArray), Spine.AttachmentLoader);
                skeletonDataScale = this.scale;

                var hasBinaryExtension = System.String.contains(this.skeletonJSON.name.toLowerCase(),".skel");
                var loadedSkeletonData = null;

                try {
                    if (hasBinaryExtension) {
                        loadedSkeletonData = Spine.Unity.SkeletonDataAsset.ReadSkeletonData(this.skeletonJSON.bytes, attachmentLoader, skeletonDataScale);
                    } else {
                        loadedSkeletonData = Spine.Unity.SkeletonDataAsset.ReadSkeletonData$1(this.skeletonJSON.text, attachmentLoader, skeletonDataScale);
                    }
                } catch (ex) {
                    ex = System.Exception.create(ex);
                    if (!quiet) {
                        UnityEngine.Debug.LogError$2("Error reading skeleton JSON file for SkeletonData asset: " + (this.name || "") + "\n" + (ex.Message || "") + "\n" + (ex.StackTrace || ""), this.skeletonJSON);
                    }
                }

                if (loadedSkeletonData == null) {
                    return null;
                }

                if (this.skeletonDataModifiers != null) {
                    $t = Bridge.getEnumerator(this.skeletonDataModifiers);
                    try {
                        while ($t.moveNext()) {
                            var modifier = $t.Current;
                            if (modifier != null && !(this.isUpgradingBlendModeMaterials && Bridge.is(modifier, Spine.Unity.BlendModeMaterialsAsset))) {
                                modifier.Apply(loadedSkeletonData);
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }
                if (!this.isUpgradingBlendModeMaterials) {
                    this.blendModeMaterials.ApplyMaterials(loadedSkeletonData);
                }

                this.InitializeWithData(loadedSkeletonData);

                return this.skeletonData;
            },
            /*Spine.Unity.SkeletonDataAsset.GetSkeletonData end.*/

            /*Spine.Unity.SkeletonDataAsset.InitializeWithData start.*/
            InitializeWithData: function (sd) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#InitializeWithData", this ); }

                this.skeletonData = sd;
                this.stateData = new Spine.AnimationStateData(this.skeletonData);
                this.FillStateData();
            },
            /*Spine.Unity.SkeletonDataAsset.InitializeWithData end.*/

            /*Spine.Unity.SkeletonDataAsset.FillStateData start.*/
            FillStateData: function (quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#FillStateData", this ); }

                if (quiet === void 0) { quiet = false; }
                if (this.stateData != null) {
                    this.stateData.DefaultMix = this.defaultMix;

                    for (var i = 0, n = this.fromAnimation.length; i < n; i = (i + 1) | 0) {
                        var fromAnimationName = this.fromAnimation[i];
                        var toAnimationName = this.toAnimation[i];
                        if (fromAnimationName.length === 0 || toAnimationName.length === 0) {
                            continue;
                        }
                        this.stateData.SetMix$1(fromAnimationName, toAnimationName, this.duration[i]);
                    }
                }
            },
            /*Spine.Unity.SkeletonDataAsset.FillStateData end.*/

            /*Spine.Unity.SkeletonDataAsset.GetAtlasArray start.*/
            GetAtlasArray: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#GetAtlasArray", this ); }

                var returnList = new (System.Collections.Generic.List$1(Spine.Atlas)).$ctor2(this.atlasAssets.length);
                for (var i = 0; i < this.atlasAssets.length; i = (i + 1) | 0) {
                    var aa = this.atlasAssets[i];
                    if (aa == null) {
                        continue;
                    }
                    var a = aa.GetAtlas();
                    if (a == null) {
                        continue;
                    }
                    returnList.add(a);
                }
                return returnList.ToArray();
            },
            /*Spine.Unity.SkeletonDataAsset.GetAtlasArray end.*/


        }
    });
    /*Spine.Unity.SkeletonDataAsset end.*/

    /*Spine.Unity.SkeletonDataCompatibility start.*/
    Bridge.define("Spine.Unity.SkeletonDataCompatibility");
    /*Spine.Unity.SkeletonDataCompatibility end.*/

    /*Spine.Unity.SkeletonDataCompatibility+CompatibilityProblemInfo start.*/
    Bridge.define("Spine.Unity.SkeletonDataCompatibility.CompatibilityProblemInfo", {
        $kind: 1002,
        fields: {
            actualVersion: null,
            compatibleVersions: null,
            explicitProblemDescription: null
        },
        methods: {
            /*Spine.Unity.SkeletonDataCompatibility+CompatibilityProblemInfo.DescriptionString start.*/
            DescriptionString: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataCompatibility.CompatibilityProblemInfo#DescriptionString", this ); }

                var $t, $t1, $t2;
                if (!System.String.isNullOrEmpty(this.explicitProblemDescription)) {
                    return this.explicitProblemDescription;
                }

                var compatibleVersionString = "";
                var optionalOr = null;
                $t = Bridge.getEnumerator(this.compatibleVersions);
                try {
                    while ($t.moveNext()) {
                        var version = $t.Current;
                        compatibleVersionString = (compatibleVersionString || "") + ((System.String.format("{0}{1}.{2}", optionalOr, Bridge.box(version[0], System.Int32), Bridge.box(version[1], System.Int32))) || "");
                        optionalOr = " or ";
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                return System.String.format("Skeleton data could not be loaded. Data version: {0}. Required version: {1}.\nPlease re-export skeleton data with Spine {1} or change runtime to version {2}.{3}.", this.actualVersion.rawVersion, compatibleVersionString, Bridge.box(($t1 = this.actualVersion.version)[0], System.Int32), Bridge.box(($t2 = this.actualVersion.version)[1], System.Int32));
            },
            /*Spine.Unity.SkeletonDataCompatibility+CompatibilityProblemInfo.DescriptionString end.*/


        }
    });
    /*Spine.Unity.SkeletonDataCompatibility+CompatibilityProblemInfo end.*/

    /*Spine.Unity.SkeletonDataCompatibility+SourceType start.*/
    Bridge.define("Spine.Unity.SkeletonDataCompatibility.SourceType", {
        $kind: 1006,
        statics: {
            fields: {
                Json: 0,
                Binary: 1
            }
        }
    });
    /*Spine.Unity.SkeletonDataCompatibility+SourceType end.*/

    /*Spine.Unity.SkeletonDataCompatibility+VersionInfo start.*/
    Bridge.define("Spine.Unity.SkeletonDataCompatibility.VersionInfo", {
        $kind: 1002,
        fields: {
            rawVersion: null,
            version: null,
            sourceType: 0
        }
    });
    /*Spine.Unity.SkeletonDataCompatibility+VersionInfo end.*/

    /*Spine.Unity.SkeletonExtensions start.*/
    Bridge.define("Spine.Unity.SkeletonExtensions", {
        statics: {
            fields: {
                ByteToFloat: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#init", this ); }

                    this.ByteToFloat = 0.003921569;
                }
            },
            methods: {
                /*Spine.Unity.SkeletonExtensions.GetColor$2:static start.*/
                GetColor$2: function (s) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetColor$2", this ); }

                    return new pc.Color( s.R, s.G, s.B, s.A );
                },
                /*Spine.Unity.SkeletonExtensions.GetColor$2:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetColor$1:static start.*/
                GetColor$1: function (a) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetColor$1", this ); }

                    return new pc.Color( a.R, a.G, a.B, a.A );
                },
                /*Spine.Unity.SkeletonExtensions.GetColor$1:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetColor:static start.*/
                GetColor: function (a) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetColor", this ); }

                    return new pc.Color( a.R, a.G, a.B, a.A );
                },
                /*Spine.Unity.SkeletonExtensions.GetColor:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetColor$3:static start.*/
                GetColor$3: function (s) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetColor$3", this ); }

                    return new pc.Color( s.R, s.G, s.B, s.A );
                },
                /*Spine.Unity.SkeletonExtensions.GetColor$3:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetColorTintBlack:static start.*/
                GetColorTintBlack: function (s) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetColorTintBlack", this ); }

                    return new pc.Color( s.R2, s.G2, s.B2, 1.0 );
                },
                /*Spine.Unity.SkeletonExtensions.GetColorTintBlack:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$4:static start.*/
                SetColor$4: function (skeleton, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor$4", this ); }

                    skeleton.A = color.a;
                    skeleton.R = color.r;
                    skeleton.G = color.g;
                    skeleton.B = color.b;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$4:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$5:static start.*/
                SetColor$5: function (skeleton, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor$5", this ); }

                    skeleton.A = color.a * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    skeleton.R = color.r * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    skeleton.G = color.g * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    skeleton.B = color.b * Spine.Unity.SkeletonExtensions.ByteToFloat;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$5:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$6:static start.*/
                SetColor$6: function (slot, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor$6", this ); }

                    slot.A = color.a;
                    slot.R = color.r;
                    slot.G = color.g;
                    slot.B = color.b;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$6:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$7:static start.*/
                SetColor$7: function (slot, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor$7", this ); }

                    slot.A = color.a * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    slot.R = color.r * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    slot.G = color.g * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    slot.B = color.b * Spine.Unity.SkeletonExtensions.ByteToFloat;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$7:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$2:static start.*/
                SetColor$2: function (attachment, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor$2", this ); }

                    attachment.A = color.a;
                    attachment.R = color.r;
                    attachment.G = color.g;
                    attachment.B = color.b;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$2:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$3:static start.*/
                SetColor$3: function (attachment, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor$3", this ); }

                    attachment.A = color.a * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    attachment.R = color.r * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    attachment.G = color.g * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    attachment.B = color.b * Spine.Unity.SkeletonExtensions.ByteToFloat;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$3:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor:static start.*/
                SetColor: function (attachment, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor", this ); }

                    attachment.A = color.a;
                    attachment.R = color.r;
                    attachment.G = color.g;
                    attachment.B = color.b;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$1:static start.*/
                SetColor$1: function (attachment, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor$1", this ); }

                    attachment.A = color.a * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    attachment.R = color.r * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    attachment.G = color.g * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    attachment.B = color.b * Spine.Unity.SkeletonExtensions.ByteToFloat;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$1:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetLocalScale:static start.*/
                /**
                 * Sets the Skeleton's local scale using a UnityEngine.Vector2. If only individual components need to be set, set Skeleton.ScaleX or Skeleton.ScaleY.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Skeleton}         skeleton    
                 * @param   {UnityEngine.Vector2}    scale
                 * @return  {void}
                 */
                SetLocalScale: function (skeleton, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetLocalScale", this ); }

                    skeleton.ScaleX = scale.x;
                    skeleton.ScaleY = scale.y;
                },
                /*Spine.Unity.SkeletonExtensions.SetLocalScale:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetMatrix4x4:static start.*/
                /**
                 * Gets the internal bone matrix as a Unity bonespace-to-skeletonspace transformation matrix.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}               bone
                 * @return  {UnityEngine.Matrix4x4}
                 */
                GetMatrix4x4: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetMatrix4x4", this ); }

                    var $t;
                    return ($t = new pc.Mat4.ctor(), $t.e00 = bone.A, $t.e01 = bone.B, $t.e03 = bone.WorldX, $t.e10 = bone.C, $t.e11 = bone.D, $t.e13 = bone.WorldY, $t.e33 = 1, $t);
                },
                /*Spine.Unity.SkeletonExtensions.GetMatrix4x4:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetLocalPosition:static start.*/
                /**
                 * Sets the bone's (local) X and Y according to a Vector2
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}             bone        
                 * @param   {UnityEngine.Vector2}    position
                 * @return  {void}
                 */
                SetLocalPosition: function (bone, position) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetLocalPosition", this ); }

                    bone.X = position.x;
                    bone.Y = position.y;
                },
                /*Spine.Unity.SkeletonExtensions.SetLocalPosition:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetLocalPosition$1:static start.*/
                /**
                 * Sets the bone's (local) X and Y according to a Vector3. The z component is ignored.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}             bone        
                 * @param   {UnityEngine.Vector3}    position
                 * @return  {void}
                 */
                SetLocalPosition$1: function (bone, position) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetLocalPosition$1", this ); }

                    bone.X = position.x;
                    bone.Y = position.y;
                },
                /*Spine.Unity.SkeletonExtensions.SetLocalPosition$1:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetLocalPosition:static start.*/
                /**
                 * Gets the bone's local X and Y as a Vector2.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}             bone
                 * @return  {UnityEngine.Vector2}
                 */
                GetLocalPosition: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetLocalPosition", this ); }

                    return new pc.Vec2( bone.X, bone.Y );
                },
                /*Spine.Unity.SkeletonExtensions.GetLocalPosition:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetSkeletonSpacePosition:static start.*/
                /**
                 * Gets the position of the bone in Skeleton-space.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}             bone
                 * @return  {UnityEngine.Vector2}
                 */
                GetSkeletonSpacePosition: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetSkeletonSpacePosition", this ); }

                    return new pc.Vec2( bone.WorldX, bone.WorldY );
                },
                /*Spine.Unity.SkeletonExtensions.GetSkeletonSpacePosition:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetSkeletonSpacePosition$1:static start.*/
                /**
                 * Gets a local offset from the bone and converts it into Skeleton-space.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}             bone         
                 * @param   {UnityEngine.Vector2}    boneLocal
                 * @return  {UnityEngine.Vector2}
                 */
                GetSkeletonSpacePosition$1: function (bone, boneLocal) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetSkeletonSpacePosition$1", this ); }

                    var o = new UnityEngine.Vector2();
                    bone.LocalToWorld(boneLocal.x, boneLocal.y, Bridge.ref(o, "x"), Bridge.ref(o, "y"));
                    return o.$clone();
                },
                /*Spine.Unity.SkeletonExtensions.GetSkeletonSpacePosition$1:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetWorldPosition:static start.*/
                /**
                 * Gets the bone's Unity World position using its Spine GameObject Transform. UpdateWorldTransform needs to have been called for this to return the correct, updated value.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}               bone                        
                 * @param   {UnityEngine.Transform}    spineGameObjectTransform
                 * @return  {UnityEngine.Vector3}
                 */
                GetWorldPosition: function (bone, spineGameObjectTransform) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetWorldPosition", this ); }

                    return spineGameObjectTransform.TransformPoint$1(new pc.Vec3( bone.WorldX, bone.WorldY, 0 ));
                },
                /*Spine.Unity.SkeletonExtensions.GetWorldPosition:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetWorldPosition$1:static start.*/
                GetWorldPosition$1: function (bone, spineGameObjectTransform, positionScale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetWorldPosition$1", this ); }

                    return spineGameObjectTransform.TransformPoint$1(new pc.Vec3( bone.WorldX * positionScale, bone.WorldY * positionScale, 0 ));
                },
                /*Spine.Unity.SkeletonExtensions.GetWorldPosition$1:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetWorldPosition$2:static start.*/
                GetWorldPosition$2: function (bone, spineGameObjectTransform, positionScale, positionOffset) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetWorldPosition$2", this ); }

                    return spineGameObjectTransform.TransformPoint$1(new pc.Vec3( bone.WorldX * positionScale + positionOffset.x, bone.WorldY * positionScale + positionOffset.y, 0 ));
                },
                /*Spine.Unity.SkeletonExtensions.GetWorldPosition$2:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetWorldPosition$4:static start.*/
                /**
                 * Gets the PointAttachment's Unity World position using its Spine GameObject Transform.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.PointAttachment}    attachment                  
                 * @param   {Spine.Slot}               slot                        
                 * @param   {UnityEngine.Transform}    spineGameObjectTransform
                 * @return  {UnityEngine.Vector3}
                 */
                GetWorldPosition$4: function (attachment, slot, spineGameObjectTransform) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetWorldPosition$4", this ); }

                    var skeletonSpacePosition = new UnityEngine.Vector3();
                    skeletonSpacePosition.z = 0;
                    attachment.ComputeWorldPosition(slot.Bone, Bridge.ref(skeletonSpacePosition, "x"), Bridge.ref(skeletonSpacePosition, "y"));
                    return spineGameObjectTransform.TransformPoint$1(skeletonSpacePosition);
                },
                /*Spine.Unity.SkeletonExtensions.GetWorldPosition$4:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetWorldPosition$3:static start.*/
                /**
                 * Gets the PointAttachment's Unity World position using its Spine GameObject Transform.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.PointAttachment}    attachment                  
                 * @param   {Spine.Bone}               bone                        
                 * @param   {UnityEngine.Transform}    spineGameObjectTransform
                 * @return  {UnityEngine.Vector3}
                 */
                GetWorldPosition$3: function (attachment, bone, spineGameObjectTransform) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetWorldPosition$3", this ); }

                    var skeletonSpacePosition = new UnityEngine.Vector3();
                    skeletonSpacePosition.z = 0;
                    attachment.ComputeWorldPosition(bone, Bridge.ref(skeletonSpacePosition, "x"), Bridge.ref(skeletonSpacePosition, "y"));
                    return spineGameObjectTransform.TransformPoint$1(skeletonSpacePosition);
                },
                /*Spine.Unity.SkeletonExtensions.GetWorldPosition$3:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetQuaternion:static start.*/
                /**
                 * Gets a skeleton space UnityEngine.Quaternion representation of bone.WorldRotationX.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}                bone
                 * @return  {UnityEngine.Quaternion}
                 */
                GetQuaternion: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetQuaternion", this ); }

                    var halfRotation = Math.atan2(bone.C, bone.A) * 0.5;
                    return new pc.Quat( 0, 0, Math.sin(halfRotation), Math.cos(halfRotation) );
                },
                /*Spine.Unity.SkeletonExtensions.GetQuaternion:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetLocalQuaternion:static start.*/
                /**
                 * Gets a bone-local space UnityEngine.Quaternion representation of bone.rotation.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}                bone
                 * @return  {UnityEngine.Quaternion}
                 */
                GetLocalQuaternion: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetLocalQuaternion", this ); }

                    var halfRotation = bone.Rotation * UnityEngine.Mathf.Deg2Rad * 0.5;
                    return new pc.Quat( 0, 0, Math.sin(halfRotation), Math.cos(halfRotation) );
                },
                /*Spine.Unity.SkeletonExtensions.GetLocalQuaternion:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetLocalScale:static start.*/
                /**
                 * Returns the Skeleton's local scale as a UnityEngine.Vector2. If only individual components are needed, use Skeleton.ScaleX or Skeleton.ScaleY.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Skeleton}         skeleton
                 * @return  {UnityEngine.Vector2}
                 */
                GetLocalScale: function (skeleton) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetLocalScale", this ); }

                    return new pc.Vec2( skeleton.ScaleX, skeleton.ScaleY );
                },
                /*Spine.Unity.SkeletonExtensions.GetLocalScale:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetWorldToLocalMatrix:static start.*/
                /**
                 * Calculates a 2x2 Transformation Matrix that can convert a skeleton-space position to a bone-local position.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}       bone    
                 * @param   {System.Single}    ia      
                 * @param   {System.Single}    ib      
                 * @param   {System.Single}    ic      
                 * @param   {System.Single}    id
                 * @return  {void}
                 */
                GetWorldToLocalMatrix: function (bone, ia, ib, ic, id) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetWorldToLocalMatrix", this ); }

                    var a = bone.A, b = bone.B, c = bone.C, d = bone.D;
                    var invDet = 1 / (a * d - b * c);
                    ia.v = invDet * d;
                    ib.v = invDet * -b;
                    ic.v = invDet * -c;
                    id.v = invDet * a;
                },
                /*Spine.Unity.SkeletonExtensions.GetWorldToLocalMatrix:static end.*/

                /*Spine.Unity.SkeletonExtensions.WorldToLocal:static start.*/
                /**
                 * UnityEngine.Vector2 override of Bone.WorldToLocal. This converts a skeleton-space position into a bone local position.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}             bone             
                 * @param   {UnityEngine.Vector2}    worldPosition
                 * @return  {UnityEngine.Vector2}
                 */
                WorldToLocal: function (bone, worldPosition) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#WorldToLocal", this ); }

                    var o = new UnityEngine.Vector2();
                    bone.WorldToLocal(worldPosition.x, worldPosition.y, Bridge.ref(o, "x"), Bridge.ref(o, "y"));
                    return o.$clone();
                },
                /*Spine.Unity.SkeletonExtensions.WorldToLocal:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetPositionSkeletonSpace:static start.*/
                /**
                 * Sets the skeleton-space position of a bone.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}             bone                     
                 * @param   {UnityEngine.Vector2}    skeletonSpacePosition
                 * @return  {UnityEngine.Vector2}                             The local position in its parent bone space, or in skeleton space if it is the root bone.
                 */
                SetPositionSkeletonSpace: function (bone, skeletonSpacePosition) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetPositionSkeletonSpace", this ); }

                    if (bone.Parent == null) { // root bone
                        Spine.Unity.SkeletonExtensions.SetLocalPosition(bone, skeletonSpacePosition.$clone());
                        return skeletonSpacePosition.$clone();
                    } else {
                        var parent = bone.Parent;
                        var parentLocal = Spine.Unity.SkeletonExtensions.WorldToLocal(parent, skeletonSpacePosition.$clone());
                        Spine.Unity.SkeletonExtensions.SetLocalPosition(bone, parentLocal.$clone());
                        return parentLocal.$clone();
                    }
                },
                /*Spine.Unity.SkeletonExtensions.SetPositionSkeletonSpace:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetMaterial:static start.*/
                GetMaterial: function (a) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetMaterial", this ); }

                    var rendererObject = null;
                    var renderableAttachment = Bridge.as(a, Spine.IHasTextureRegion);
                    if (renderableAttachment != null) {
                        rendererObject = renderableAttachment.Spine$IHasTextureRegion$Region;
                    }

                    if (rendererObject == null) {
                        return null;
                    }

                    return Bridge.cast(Bridge.cast(rendererObject, Spine.AtlasRegion).page.rendererObject, UnityEngine.Material);
                },
                /*Spine.Unity.SkeletonExtensions.GetMaterial:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetLocalVertices:static start.*/
                /**
                 * Fills a Vector2 buffer with local vertices.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.VertexAttachment}         va        The VertexAttachment
                 * @param   {Spine.Slot}                     slot      Slot where the attachment belongs.
                 * @param   {Array.<UnityEngine.Vector2>}    buffer    Correctly-sized buffer. Use attachment's .WorldVerticesLength to get the correct size. If null, a new Vector2[] of the correct size will be allocated.
                 * @return  {Array.<UnityEngine.Vector2>}
                 */
                GetLocalVertices: function (va, slot, buffer) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetLocalVertices", this ); }

                    var floatsCount = va.WorldVerticesLength;
                    var bufferTargetSize = floatsCount >> 1;
                    buffer = buffer || System.Array.init(bufferTargetSize, function (){
                        return new UnityEngine.Vector2();
                    }, UnityEngine.Vector2);
                    if (buffer.length < bufferTargetSize) {
                        throw new System.ArgumentException.$ctor3(System.String.format("Vector2 buffer too small. {0} requires an array of size {1}. Use the attachment's .WorldVerticesLength to get the correct size.", va.Name, Bridge.box(floatsCount, System.Int32)), "buffer");
                    }

                    if (va.Bones == null && slot.Deform.Count === 0) {
                        var localVerts = va.Vertices;
                        for (var i = 0; i < bufferTargetSize; i = (i + 1) | 0) {
                            var j = Bridge.Int.mul(i, 2);
                            buffer[i] = new pc.Vec2( localVerts[j], localVerts[((j + 1) | 0)] );
                        }
                    } else {
                        var floats = System.Array.init(floatsCount, 0, System.Single);
                        va.ComputeWorldVertices$1(slot, floats);

                        var sb = slot.Bone;
                        var ia = { }, ib = { }, ic = { }, id = { }, bwx = sb.WorldX, bwy = sb.WorldY;
                        Spine.Unity.SkeletonExtensions.GetWorldToLocalMatrix(sb, ia, ib, ic, id);

                        for (var i1 = 0; i1 < bufferTargetSize; i1 = (i1 + 1) | 0) {
                            var j1 = Bridge.Int.mul(i1, 2);
                            var x = floats[j1] - bwx, y = floats[((j1 + 1) | 0)] - bwy;
                            buffer[i1] = new pc.Vec2( x * ia.v + y * ib.v, x * ic.v + y * id.v );
                        }
                    }

                    return buffer;
                },
                /*Spine.Unity.SkeletonExtensions.GetLocalVertices:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetWorldVertices:static start.*/
                /**
                 * Calculates world vertices and fills a Vector2 buffer.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.VertexAttachment}         a         The VertexAttachment
                 * @param   {Spine.Slot}                     slot      Slot where the attachment belongs.
                 * @param   {Array.<UnityEngine.Vector2>}    buffer    Correctly-sized buffer. Use attachment's .WorldVerticesLength to get the correct size. If null, a new Vector2[] of the correct size will be allocated.
                 * @return  {Array.<UnityEngine.Vector2>}
                 */
                GetWorldVertices: function (a, slot, buffer) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetWorldVertices", this ); }

                    var worldVertsLength = a.WorldVerticesLength;
                    var bufferTargetSize = worldVertsLength >> 1;
                    buffer = buffer || System.Array.init(bufferTargetSize, function (){
                        return new UnityEngine.Vector2();
                    }, UnityEngine.Vector2);
                    if (buffer.length < bufferTargetSize) {
                        throw new System.ArgumentException.$ctor3(System.String.format("Vector2 buffer too small. {0} requires an array of size {1}. Use the attachment's .WorldVerticesLength to get the correct size.", a.Name, Bridge.box(worldVertsLength, System.Int32)), "buffer");
                    }

                    var floats = System.Array.init(worldVertsLength, 0, System.Single);
                    a.ComputeWorldVertices$1(slot, floats);

                    for (var i = 0, n = worldVertsLength >> 1; i < n; i = (i + 1) | 0) {
                        var j = Bridge.Int.mul(i, 2);
                        buffer[i] = new pc.Vec2( floats[j], floats[((j + 1) | 0)] );
                    }

                    return buffer;
                },
                /*Spine.Unity.SkeletonExtensions.GetWorldVertices:static end.*/


            }
        }
    });
    /*Spine.Unity.SkeletonExtensions end.*/

    /*Spine.Unity.SkeletonGraphic+LayoutMode start.*/
    Bridge.define("Spine.Unity.SkeletonGraphic.LayoutMode", {
        $kind: 1006,
        statics: {
            fields: {
                None: 0,
                WidthControlsHeight: 1,
                HeightControlsWidth: 2,
                FitInParent: 3,
                EnvelopeParent: 4
            }
        }
    });
    /*Spine.Unity.SkeletonGraphic+LayoutMode end.*/

    /*Spine.Unity.SkeletonGraphicCustomMaterials start.*/
    Bridge.define("Spine.Unity.SkeletonGraphicCustomMaterials", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonGraphic: null,
            customMaterialOverrides: null,
            customTextureOverrides: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials#init", this ); }

                this.customMaterialOverrides = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride)).ctor();
                this.customTextureOverrides = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonGraphicCustomMaterials.SetCustomMaterialOverrides start.*/
            SetCustomMaterialOverrides: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials#SetCustomMaterialOverrides", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    UnityEngine.Debug.LogError$2("skeletonGraphic == null");
                    return;
                }

                for (var i = 0; i < this.customMaterialOverrides.Count; i = (i + 1) | 0) {
                    var atlasMaterialOverride = this.customMaterialOverrides.getItem(i).$clone();
                    if (atlasMaterialOverride.overrideEnabled) {
                        this.skeletonGraphic.CustomMaterialOverride.setItem(atlasMaterialOverride.originalTexture, atlasMaterialOverride.replacementMaterial);
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials.SetCustomMaterialOverrides end.*/

            /*Spine.Unity.SkeletonGraphicCustomMaterials.RemoveCustomMaterialOverrides start.*/
            RemoveCustomMaterialOverrides: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials#RemoveCustomMaterialOverrides", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    UnityEngine.Debug.LogError$2("skeletonGraphic == null");
                    return;
                }

                for (var i = 0; i < this.customMaterialOverrides.Count; i = (i + 1) | 0) {
                    var atlasMaterialOverride = this.customMaterialOverrides.getItem(i).$clone();
                    var currentMaterial = { };

                    if (!this.skeletonGraphic.CustomMaterialOverride.tryGetValue(atlasMaterialOverride.originalTexture, currentMaterial)) {
                        continue;
                    }

                    // Do not revert the material if it was changed by something else
                    if (!Bridge.referenceEquals(currentMaterial.v, atlasMaterialOverride.replacementMaterial)) {
                        continue;
                    }

                    this.skeletonGraphic.CustomMaterialOverride.remove(atlasMaterialOverride.originalTexture);
                }
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials.RemoveCustomMaterialOverrides end.*/

            /*Spine.Unity.SkeletonGraphicCustomMaterials.SetCustomTextureOverrides start.*/
            SetCustomTextureOverrides: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials#SetCustomTextureOverrides", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    UnityEngine.Debug.LogError$2("skeletonGraphic == null");
                    return;
                }

                for (var i = 0; i < this.customTextureOverrides.Count; i = (i + 1) | 0) {
                    var atlasTextureOverride = this.customTextureOverrides.getItem(i).$clone();
                    if (atlasTextureOverride.overrideEnabled) {
                        this.skeletonGraphic.CustomTextureOverride.setItem(atlasTextureOverride.originalTexture, atlasTextureOverride.replacementTexture);
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials.SetCustomTextureOverrides end.*/

            /*Spine.Unity.SkeletonGraphicCustomMaterials.RemoveCustomTextureOverrides start.*/
            RemoveCustomTextureOverrides: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials#RemoveCustomTextureOverrides", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    UnityEngine.Debug.LogError$2("skeletonGraphic == null");
                    return;
                }

                for (var i = 0; i < this.customTextureOverrides.Count; i = (i + 1) | 0) {
                    var atlasTextureOverride = this.customTextureOverrides.getItem(i).$clone();
                    var currentTexture = { };

                    if (!this.skeletonGraphic.CustomTextureOverride.tryGetValue(atlasTextureOverride.originalTexture, currentTexture)) {
                        continue;
                    }

                    // Do not revert the material if it was changed by something else
                    if (!Bridge.referenceEquals(currentTexture.v, atlasTextureOverride.replacementTexture)) {
                        continue;
                    }

                    this.skeletonGraphic.CustomTextureOverride.remove(atlasTextureOverride.originalTexture);
                }
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials.RemoveCustomTextureOverrides end.*/

            /*Spine.Unity.SkeletonGraphicCustomMaterials.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials#OnEnable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    this.skeletonGraphic = this.GetComponent(Spine.Unity.SkeletonGraphic);
                }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    UnityEngine.Debug.LogError$2("skeletonGraphic == null");
                    return;
                }

                this.skeletonGraphic.Initialize(false);
                this.SetCustomMaterialOverrides();
                this.SetCustomTextureOverrides();
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials.OnEnable end.*/

            /*Spine.Unity.SkeletonGraphicCustomMaterials.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials#OnDisable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    UnityEngine.Debug.LogError$2("skeletonGraphic == null");
                    return;
                }

                this.RemoveCustomMaterialOverrides();
                this.RemoveCustomTextureOverrides();
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials.OnDisable end.*/


        }
    });
    /*Spine.Unity.SkeletonGraphicCustomMaterials end.*/

    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasMaterialOverride start.*/
    Bridge.define("Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride", {
        inherits: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#inherits", this ); }
 return [System.IEquatable$1(Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride)]; },
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#getDefaultValue", this ); }
 return new Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride(); }
            }
        },
        fields: {
            overrideEnabled: false,
            originalTexture: null,
            replacementMaterial: null
        },
        alias: ["equalsT", "System$IEquatable$1$Spine$Unity$SkeletonGraphicCustomMaterials$AtlasMaterialOverride$equalsT"],
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasMaterialOverride.equalsT start.*/
            equalsT: function (other) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#equalsT", this ); }

                return this.overrideEnabled === other.overrideEnabled && Bridge.referenceEquals(this.originalTexture, other.originalTexture) && Bridge.referenceEquals(this.replacementMaterial, other.replacementMaterial);
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasMaterialOverride.equalsT end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#getHashCode", this ); }

                var h = Bridge.addHash([8608216668, this.overrideEnabled, this.originalTexture, this.replacementMaterial]);
                return h;
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#$clone", this ); }

                var s = to || new Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride();
                s.overrideEnabled = this.overrideEnabled;
                s.originalTexture = this.originalTexture;
                s.replacementMaterial = this.replacementMaterial;
                return s;
            }
        },
        overloads: {
            "Equals(AtlasMaterialOverride)": "equalsT"
        }
    });
    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasMaterialOverride end.*/

    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasTextureOverride start.*/
    Bridge.define("Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride", {
        inherits: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#inherits", this ); }
 return [System.IEquatable$1(Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride)]; },
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#getDefaultValue", this ); }
 return new Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride(); }
            }
        },
        fields: {
            overrideEnabled: false,
            originalTexture: null,
            replacementTexture: null
        },
        alias: ["equalsT", "System$IEquatable$1$Spine$Unity$SkeletonGraphicCustomMaterials$AtlasTextureOverride$equalsT"],
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasTextureOverride.equalsT start.*/
            equalsT: function (other) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#equalsT", this ); }

                return this.overrideEnabled === other.overrideEnabled && Bridge.referenceEquals(this.originalTexture, other.originalTexture) && Bridge.referenceEquals(this.replacementTexture, other.replacementTexture);
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasTextureOverride.equalsT end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#getHashCode", this ); }

                var h = Bridge.addHash([8976735721, this.overrideEnabled, this.originalTexture, this.replacementTexture]);
                return h;
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#$clone", this ); }

                var s = to || new Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride();
                s.overrideEnabled = this.overrideEnabled;
                s.originalTexture = this.originalTexture;
                s.replacementTexture = this.replacementTexture;
                return s;
            }
        },
        overloads: {
            "Equals(AtlasTextureOverride)": "equalsT"
        }
    });
    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasTextureOverride end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator start.*/
    Bridge.define("Spine.Unity.SkeletonMecanim.MecanimTranslator", {
        $kind: 1002,
        statics: {
            fields: {
                WeightEpsilon: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#init", this ); }

                    this.WeightEpsilon = 0.0001;
                }
            },
            methods: {
                /*Spine.Unity.SkeletonMecanim+MecanimTranslator.AnimationTime:static start.*/
                AnimationTime: function (normalizedTime, clipLength, loop, reversed) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#AnimationTime", this ); }

                    var time = Spine.Unity.SkeletonMecanim.MecanimTranslator.ToSpineAnimationTime(normalizedTime, clipLength, loop, reversed);
                    if (loop) {
                        return time;
                    }
                    var EndSnapEpsilon = 0.0333333351; // Workaround for end-duration keys not being applied.
                    return (clipLength - time < EndSnapEpsilon) ? clipLength : time; // return a time snapped to clipLength;
                },
                /*Spine.Unity.SkeletonMecanim+MecanimTranslator.AnimationTime:static end.*/

                /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ToSpineAnimationTime:static start.*/
                ToSpineAnimationTime: function (normalizedTime, clipLength, loop, reversed) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#ToSpineAnimationTime", this ); }

                    if (reversed) {
                        normalizedTime = (1 - normalizedTime);
                    }
                    if (normalizedTime < 0.0) {
                        normalizedTime = loop ? (normalizedTime % 1.0) + 1.0 : 0.0;
                    }
                    return normalizedTime * clipLength;
                },
                /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ToSpineAnimationTime:static end.*/


            }
        },
        fields: {
            autoReset: false,
            useCustomMixMode: false,
            layerMixModes: null,
            layerBlendModes: null,
            animationTable: null,
            clipNameHashCodeTable: null,
            previousAnimations: null,
            layerClipInfos: null,
            animator: null
        },
        events: {
            _OnClipApplied: null
        },
        props: {
            Animator: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#Animator#get", this ); }

                    return this.animator;
                }
            },
            MecanimLayerCount: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#MecanimLayerCount#get", this ); }

                    if (!UnityEngine.Object.op_Implicit(this.animator)) {
                        return 0;
                    }
                    return this.animator.layerCount;
                }
            },
            MecanimLayerNames: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#MecanimLayerNames#get", this ); }

                    if (!UnityEngine.Object.op_Implicit(this.animator)) {
                        return System.Array.init(0, null, System.String);
                    }
                    var layerNames = System.Array.init(this.animator.layerCount, null, System.String);
                    for (var i = 0; i < this.animator.layerCount; i = (i + 1) | 0) {
                        layerNames[i] = this.animator.GetLayerName(i);
                    }
                    return layerNames;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#init", this ); }

                this.autoReset = true;
                this.useCustomMixMode = true;
                this.layerMixModes = System.Array.init(0, 0, Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode);
                this.layerBlendModes = System.Array.init(0, 0, Spine.MixBlend);
                this.animationTable = new (System.Collections.Generic.Dictionary$2(System.Int32,Spine.Animation)).$ctor3(Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer.Instance);
                this.clipNameHashCodeTable = new (System.Collections.Generic.Dictionary$2(UnityEngine.AnimationClip,System.Int32)).$ctor3(Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer.Instance);
                this.previousAnimations = new (System.Collections.Generic.List$1(Spine.Animation)).ctor();
                this.layerClipInfos = System.Array.init(0, null, Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos);
            }
        },
        methods: {
            addOnClipApplied: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#addOnClipApplied", this ); }

                this.add_OnClipApplied(value);
            },
            removeOnClipApplied: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#removeOnClipApplied", this ); }

                this.remove_OnClipApplied(value);
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.Initialize start.*/
            Initialize: function (animator, skeletonDataAsset) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#Initialize", this ); }

                var $t;
                this.animator = animator;

                this.previousAnimations.clear();

                this.animationTable.clear();
                var data = skeletonDataAsset.GetSkeletonData(true);
                $t = Bridge.getEnumerator(data.Animations);
                try {
                    while ($t.moveNext()) {
                        var a = $t.Current;
                        this.animationTable.add(Bridge.getHashCode(a.Name), a);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                this.clipNameHashCodeTable.clear();
                this.ClearClipInfosForLayers();
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.Initialize end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ApplyAnimation start.*/
            ApplyAnimation: function (skeleton, info, stateInfo, layerIndex, layerWeight, layerBlendMode, useClipWeight1) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#ApplyAnimation", this ); }

                if (useClipWeight1 === void 0) { useClipWeight1 = false; }
                var weight = info.weight * layerWeight;
                if (weight < Spine.Unity.SkeletonMecanim.MecanimTranslator.WeightEpsilon) {
                    return false;
                }

                var clip = this.GetAnimation(info.clip);
                if (clip == null) {
                    return false;
                }
                var time = Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationTime(stateInfo.normalizedTime, info.clip.length, info.clip.isLooping, stateInfo.speed < 0);
                weight = useClipWeight1 ? layerWeight : weight;
                clip.Apply(skeleton, 0, time, info.clip.isLooping, null, weight, layerBlendMode, Spine.MixDirection.In);
                if (!Bridge.staticEquals(this._OnClipApplied, null)) {
                    this.OnClipAppliedCallback(clip, stateInfo, layerIndex, time, info.clip.isLooping, weight);
                }
                return true;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ApplyAnimation end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ApplyInterruptionAnimation start.*/
            ApplyInterruptionAnimation: function (skeleton, interpolateWeightTo1, info, stateInfo, layerIndex, layerWeight, layerBlendMode, interruptingClipTimeAddition, useClipWeight1) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#ApplyInterruptionAnimation", this ); }

                if (useClipWeight1 === void 0) { useClipWeight1 = false; }

                var clipWeight = interpolateWeightTo1 ? (info.weight + 1.0) * 0.5 : info.weight;
                var weight = clipWeight * layerWeight;
                if (weight < Spine.Unity.SkeletonMecanim.MecanimTranslator.WeightEpsilon) {
                    return false;
                }

                var clip = this.GetAnimation(info.clip);
                if (clip == null) {
                    return false;
                }

                var time = Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationTime(stateInfo.normalizedTime + interruptingClipTimeAddition, info.clip.length, info.clip.isLooping, stateInfo.speed < 0);
                weight = useClipWeight1 ? layerWeight : weight;
                clip.Apply(skeleton, 0, time, info.clip.isLooping, null, weight, layerBlendMode, Spine.MixDirection.In);
                if (!Bridge.staticEquals(this._OnClipApplied, null)) {
                    this.OnClipAppliedCallback(clip, stateInfo, layerIndex, time, info.clip.isLooping, weight);
                }
                return true;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ApplyInterruptionAnimation end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.OnClipAppliedCallback start.*/
            OnClipAppliedCallback: function (clip, stateInfo, layerIndex, time, isLooping, weight) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#OnClipAppliedCallback", this ); }


                var speedFactor = stateInfo.speedMultiplier * stateInfo.speed;
                var lastTime = time - (UnityEngine.Time.deltaTime * speedFactor);
                var clipDuration = clip.Duration;
                if (isLooping && clipDuration !== 0) {
                    time %= clipDuration;
                    lastTime %= clipDuration;
                }
                this._OnClipApplied(clip, layerIndex, weight, time, lastTime, speedFactor < 0);
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.OnClipAppliedCallback end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.Apply start.*/
            Apply: function (skeleton) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#Apply", this ); }


                if (this.layerMixModes.length < this.animator.layerCount) {
                    var oldSize = this.layerMixModes.length;
                    System.Array.resize(Bridge.ref(this, "layerMixModes"), this.animator.layerCount, 0, Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode);
                    for (var layer = oldSize; layer < this.animator.layerCount; layer = (layer + 1) | 0) {
                        var isAdditiveLayer = false;
                        if (layer < this.layerBlendModes.length) {
                            isAdditiveLayer = this.layerBlendModes[layer] === Spine.MixBlend.Add;
                        }
                        this.layerMixModes[layer] = isAdditiveLayer ? Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.AlwaysMix : Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.MixNext;
                    }
                }

                this.InitClipInfosForLayers();
                for (var layer1 = 0, n = this.animator.layerCount; layer1 < n; layer1 = (layer1 + 1) | 0) {
                    this.GetStateUpdatesFromAnimator(layer1);
                }

                // Clear Previous
                if (this.autoReset) {
                    var previousAnimations = this.previousAnimations;
                    for (var i = 0, n1 = previousAnimations.Count; i < n1; i = (i + 1) | 0) {
                        previousAnimations.getItem(i).Apply(skeleton, 0, 0, false, null, 0, Spine.MixBlend.Setup, Spine.MixDirection.Out);
                    } // SetKeyedItemsToSetupPose

                    previousAnimations.clear();
                    for (var layer2 = 0, n2 = this.animator.layerCount; layer2 < n2; layer2 = (layer2 + 1) | 0) {
                        var layerWeight = (layer2 === 0) ? 1 : this.animator.GetLayerWeight(layer2); // Animator.GetLayerWeight always returns 0 on the first layer. Should be interpreted as 1.
                        if (layerWeight <= 0) {
                            continue;
                        }

                        var nextStateInfo = this.animator.GetNextAnimatorStateInfo(layer2);

                        var hasNext = nextStateInfo.fullPathHash !== 0;

                        var clipInfoCount = { }, nextClipInfoCount = { }, interruptingClipInfoCount = { };
                        var clipInfo = { }, nextClipInfo = { }, interruptingClipInfo = { };
                        var isInterruptionActive = { }, shallInterpolateWeightTo1 = { };
                        this.GetAnimatorClipInfos(layer2, isInterruptionActive, clipInfoCount, nextClipInfoCount, interruptingClipInfoCount, clipInfo, nextClipInfo, interruptingClipInfo, shallInterpolateWeightTo1);

                        for (var c = 0; c < clipInfoCount.v; c = (c + 1) | 0) {
                            var info = System.Array.getItem(clipInfo.v, c, UnityEngine.AnimatorClipInfo).$clone();
                            var weight = info.weight * layerWeight;
                            if (weight < Spine.Unity.SkeletonMecanim.MecanimTranslator.WeightEpsilon) {
                                continue;
                            }
                            var clip = this.GetAnimation(info.clip);
                            if (clip != null) {
                                previousAnimations.add(clip);
                            }
                        }

                        if (hasNext) {
                            for (var c1 = 0; c1 < nextClipInfoCount.v; c1 = (c1 + 1) | 0) {
                                var info1 = System.Array.getItem(nextClipInfo.v, c1, UnityEngine.AnimatorClipInfo).$clone();
                                var weight1 = info1.weight * layerWeight;
                                if (weight1 < Spine.Unity.SkeletonMecanim.MecanimTranslator.WeightEpsilon) {
                                    continue;
                                }
                                var clip1 = this.GetAnimation(info1.clip);
                                if (clip1 != null) {
                                    previousAnimations.add(clip1);
                                }
                            }
                        }

                        if (isInterruptionActive.v) {
                            for (var c2 = 0; c2 < interruptingClipInfoCount.v; c2 = (c2 + 1) | 0) {
                                var info2 = System.Array.getItem(interruptingClipInfo.v, c2, UnityEngine.AnimatorClipInfo).$clone();
                                var clipWeight = shallInterpolateWeightTo1.v ? (info2.weight + 1.0) * 0.5 : info2.weight;
                                var weight2 = clipWeight * layerWeight;
                                if (weight2 < Spine.Unity.SkeletonMecanim.MecanimTranslator.WeightEpsilon) {
                                    continue;
                                }
                                var clip2 = this.GetAnimation(info2.clip);
                                if (clip2 != null) {
                                    previousAnimations.add(clip2);
                                }
                            }
                        }
                    }
                }

                // Apply
                for (var layer3 = 0, n3 = this.animator.layerCount; layer3 < n3; layer3 = (layer3 + 1) | 0) {
                    var layerWeight1 = (layer3 === 0) ? 1 : this.animator.GetLayerWeight(layer3); // Animator.GetLayerWeight always returns 0 on the first layer. Should be interpreted as 1.

                    var isInterruptionActive1 = { };
                    var stateInfo = { };
                    var nextStateInfo1 = { };
                    var interruptingStateInfo = { };
                    var interruptingClipTimeAddition = { };
                    this.GetAnimatorStateInfos(layer3, isInterruptionActive1, stateInfo, nextStateInfo1, interruptingStateInfo, interruptingClipTimeAddition);

                    var hasNext1 = nextStateInfo1.v.fullPathHash !== 0;

                    var clipInfoCount1 = { }, nextClipInfoCount1 = { }, interruptingClipInfoCount1 = { };
                    var clipInfo1 = { }, nextClipInfo1 = { }, interruptingClipInfo1 = { };
                    var interpolateWeightTo1 = { };
                    this.GetAnimatorClipInfos(layer3, isInterruptionActive1, clipInfoCount1, nextClipInfoCount1, interruptingClipInfoCount1, clipInfo1, nextClipInfo1, interruptingClipInfo1, interpolateWeightTo1);

                    var layerBlendMode = (layer3 < this.layerBlendModes.length) ? this.layerBlendModes[layer3] : Spine.MixBlend.Replace;
                    var mode = this.GetMixMode(layer3, layerBlendMode);
                    if (mode === Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.AlwaysMix) {
                        // Always use Mix instead of Applying the first non-zero weighted clip.
                        for (var c3 = 0; c3 < clipInfoCount1.v; c3 = (c3 + 1) | 0) {
                            this.ApplyAnimation(skeleton, System.Array.getItem(clipInfo1.v, c3, UnityEngine.AnimatorClipInfo), stateInfo.v, layer3, layerWeight1, layerBlendMode);
                        }
                        if (hasNext1) {
                            for (var c4 = 0; c4 < nextClipInfoCount1.v; c4 = (c4 + 1) | 0) {
                                this.ApplyAnimation(skeleton, System.Array.getItem(nextClipInfo1.v, c4, UnityEngine.AnimatorClipInfo), nextStateInfo1.v, layer3, layerWeight1, layerBlendMode);
                            }
                        }
                        if (isInterruptionActive1.v) {
                            for (var c5 = 0; c5 < interruptingClipInfoCount1.v; c5 = (c5 + 1) | 0) {
                                this.ApplyInterruptionAnimation(skeleton, interpolateWeightTo1.v, System.Array.getItem(interruptingClipInfo1.v, c5, UnityEngine.AnimatorClipInfo), interruptingStateInfo.v, layer3, layerWeight1, layerBlendMode, interruptingClipTimeAddition.v);
                            }
                        }
                    } else { // case MixNext || Hard
                        // Apply first non-zero weighted clip
                        var c6 = 0;
                        for (; c6 < clipInfoCount1.v; c6 = (c6 + 1) | 0) {
                            if (!this.ApplyAnimation(skeleton, System.Array.getItem(clipInfo1.v, c6, UnityEngine.AnimatorClipInfo), stateInfo.v, layer3, layerWeight1, layerBlendMode, true)) {
                                continue;
                            }
                            c6 = (c6 + 1) | 0;
                            break;
                        }
                        // Mix the rest
                        for (; c6 < clipInfoCount1.v; c6 = (c6 + 1) | 0) {
                            this.ApplyAnimation(skeleton, System.Array.getItem(clipInfo1.v, c6, UnityEngine.AnimatorClipInfo), stateInfo.v, layer3, layerWeight1, layerBlendMode);
                        }

                        c6 = 0;
                        if (hasNext1) {
                            // Apply next clip directly instead of mixing (ie: no crossfade, ignores mecanim transition weights)
                            if (mode === Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.Hard) {
                                for (; c6 < nextClipInfoCount1.v; c6 = (c6 + 1) | 0) {
                                    if (!this.ApplyAnimation(skeleton, System.Array.getItem(nextClipInfo1.v, c6, UnityEngine.AnimatorClipInfo), nextStateInfo1.v, layer3, layerWeight1, layerBlendMode, true)) {
                                        continue;
                                    }
                                    c6 = (c6 + 1) | 0;
                                    break;
                                }
                            }
                            // Mix the rest
                            for (; c6 < nextClipInfoCount1.v; c6 = (c6 + 1) | 0) {
                                if (!this.ApplyAnimation(skeleton, System.Array.getItem(nextClipInfo1.v, c6, UnityEngine.AnimatorClipInfo), nextStateInfo1.v, layer3, layerWeight1, layerBlendMode)) {
                                    continue;
                                }
                            }
                        }

                        c6 = 0;
                        if (isInterruptionActive1.v) {
                            // Apply next clip directly instead of mixing (ie: no crossfade, ignores mecanim transition weights)
                            if (mode === Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.Hard) {
                                for (; c6 < interruptingClipInfoCount1.v; c6 = (c6 + 1) | 0) {
                                    if (this.ApplyInterruptionAnimation(skeleton, interpolateWeightTo1.v, System.Array.getItem(interruptingClipInfo1.v, c6, UnityEngine.AnimatorClipInfo), interruptingStateInfo.v, layer3, layerWeight1, layerBlendMode, interruptingClipTimeAddition.v, true)) {

                                        c6 = (c6 + 1) | 0;
                                        break;
                                    }
                                }
                            }
                            // Mix the rest
                            for (; c6 < interruptingClipInfoCount1.v; c6 = (c6 + 1) | 0) {
                                this.ApplyInterruptionAnimation(skeleton, interpolateWeightTo1.v, System.Array.getItem(interruptingClipInfo1.v, c6, UnityEngine.AnimatorClipInfo), interruptingStateInfo.v, layer3, layerWeight1, layerBlendMode, interruptingClipTimeAddition.v);
                            }
                        }
                    }
                }
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.Apply end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetActiveAnimationAndTime start.*/
            GetActiveAnimationAndTime: function (layer) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#GetActiveAnimationAndTime", this ); }

                if (layer >= this.layerClipInfos.length) {
                    return new (System.Collections.Generic.KeyValuePair$2(Spine.Animation,System.Single)).$ctor1(null, 0);
                }

                var layerInfos = this.layerClipInfos[layer];
                var isInterruptionActive = layerInfos.isInterruptionActive;
                var clip = null;
                var animation = null;
                var stateInfo;
                if (isInterruptionActive && layerInfos.interruptingClipInfoCount > 0) {
                    clip = layerInfos.interruptingClipInfos.getItem(0).$clone().clip;
                    stateInfo = layerInfos.interruptingStateInfo;
                } else {
                    clip = layerInfos.clipInfos.getItem(0).$clone().clip;
                    stateInfo = layerInfos.stateInfo;
                }
                animation = this.GetAnimation(clip);
                var time = Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationTime(stateInfo.normalizedTime, clip.length, clip.isLooping, stateInfo.speed < 0);
                return new (System.Collections.Generic.KeyValuePair$2(Spine.Animation,System.Single)).$ctor1(animation, time);
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetActiveAnimationAndTime end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.InitClipInfosForLayers start.*/
            InitClipInfosForLayers: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#InitClipInfosForLayers", this ); }

                if (this.layerClipInfos.length < this.animator.layerCount) {
                    System.Array.resize(Bridge.ref(this, "layerClipInfos"), this.animator.layerCount, null, Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos);
                    for (var layer = 0, n = this.animator.layerCount; layer < n; layer = (layer + 1) | 0) {
                        if (this.layerClipInfos[layer] == null) {
                            this.layerClipInfos[layer] = new Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos();
                        }
                    }
                }
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.InitClipInfosForLayers end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ClearClipInfosForLayers start.*/
            ClearClipInfosForLayers: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#ClearClipInfosForLayers", this ); }

                for (var layer = 0, n = this.layerClipInfos.length; layer < n; layer = (layer + 1) | 0) {
                    if (this.layerClipInfos[layer] == null) {
                        this.layerClipInfos[layer] = new Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos();
                    } else {
                        this.layerClipInfos[layer].isInterruptionActive = false;
                        this.layerClipInfos[layer].isLastFrameOfInterruption = false;
                        this.layerClipInfos[layer].clipInfos.clear();
                        this.layerClipInfos[layer].nextClipInfos.clear();
                        this.layerClipInfos[layer].interruptingClipInfos.clear();
                    }
                }
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ClearClipInfosForLayers end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetMixMode start.*/
            GetMixMode: function (layer, layerBlendMode) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#GetMixMode", this ); }

                if (this.useCustomMixMode) {
                    var mode = this.layerMixModes[layer];
                    // Note: at additive blending it makes no sense to use constant weight 1 at a fadeout anim add1 as
                    // with override layers, so we use AlwaysMix instead to use the proper weights.
                    // AlwaysMix leads to the expected result = lower_layer + lerp(add1, add2, transition_weight).
                    if (layerBlendMode === Spine.MixBlend.Add && mode === Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.MixNext) {
                        mode = Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.AlwaysMix;
                        this.layerMixModes[layer] = mode;
                    }
                    return mode;
                } else {
                    return layerBlendMode === Spine.MixBlend.Add ? Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.AlwaysMix : Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.MixNext;
                }
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetMixMode end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetStateUpdatesFromAnimator start.*/
            GetStateUpdatesFromAnimator: function (layer) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#GetStateUpdatesFromAnimator", this ); }


                var layerInfos = this.layerClipInfos[layer];
                var clipInfoCount = this.animator.GetCurrentAnimatorClipInfoCount(layer);
                var nextClipInfoCount = this.animator.GetNextAnimatorClipInfoCount(layer);

                var clipInfos = layerInfos.clipInfos;
                var nextClipInfos = layerInfos.nextClipInfos;
                var interruptingClipInfos = layerInfos.interruptingClipInfos;

                layerInfos.isInterruptionActive = (clipInfoCount === 0 && clipInfos.Count !== 0 && nextClipInfoCount === 0 && nextClipInfos.Count !== 0);

                // Note: during interruption, GetCurrentAnimatorClipInfoCount and GetNextAnimatorClipInfoCount
                // are returning 0 in calls above. Therefore we keep previous clipInfos and nextClipInfos
                // until the interruption is over.
                if (layerInfos.isInterruptionActive) {

                    // Note: The last frame of a transition interruption
                    // will have fullPathHash set to 0, therefore we have to use previous
                    // frame's infos about interruption clips and correct some values
                    // accordingly (normalizedTime and weight).
                    var interruptingStateInfo = this.animator.GetNextAnimatorStateInfo(layer);
                    layerInfos.isLastFrameOfInterruption = interruptingStateInfo.fullPathHash === 0;
                    if (!layerInfos.isLastFrameOfInterruption) {
                        this.animator.GetNextAnimatorClipInfo(layer, interruptingClipInfos);
                        layerInfos.interruptingClipInfoCount = interruptingClipInfos.Count;
                        var oldTime = layerInfos.interruptingStateInfo.normalizedTime;
                        var newTime = interruptingStateInfo.normalizedTime;
                        layerInfos.interruptingClipTimeAddition = newTime - oldTime;
                        layerInfos.interruptingStateInfo = interruptingStateInfo;
                    }
                } else {
                    layerInfos.clipInfoCount = clipInfoCount;
                    layerInfos.nextClipInfoCount = nextClipInfoCount;
                    layerInfos.interruptingClipInfoCount = 0;
                    layerInfos.isLastFrameOfInterruption = false;

                    if (clipInfos.Capacity < clipInfoCount) {
                        clipInfos.Capacity = clipInfoCount;
                    }
                    if (nextClipInfos.Capacity < nextClipInfoCount) {
                        nextClipInfos.Capacity = nextClipInfoCount;
                    }

                    this.animator.GetCurrentAnimatorClipInfo(layer, clipInfos);
                    this.animator.GetNextAnimatorClipInfo(layer, nextClipInfos);

                    layerInfos.stateInfo = this.animator.GetCurrentAnimatorStateInfo(layer);
                    layerInfos.nextStateInfo = this.animator.GetNextAnimatorStateInfo(layer);
                }
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetStateUpdatesFromAnimator end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetAnimatorClipInfos start.*/
            GetAnimatorClipInfos: function (layer, isInterruptionActive, clipInfoCount, nextClipInfoCount, interruptingClipInfoCount, clipInfo, nextClipInfo, interruptingClipInfo, shallInterpolateWeightTo1) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#GetAnimatorClipInfos", this ); }


                var layerInfos = this.layerClipInfos[layer];
                isInterruptionActive.v = layerInfos.isInterruptionActive;

                clipInfoCount.v = layerInfos.clipInfoCount;
                nextClipInfoCount.v = layerInfos.nextClipInfoCount;
                interruptingClipInfoCount.v = layerInfos.interruptingClipInfoCount;

                clipInfo.v = layerInfos.clipInfos;
                nextClipInfo.v = layerInfos.nextClipInfos;
                interruptingClipInfo.v = isInterruptionActive.v ? layerInfos.interruptingClipInfos : null;
                shallInterpolateWeightTo1.v = layerInfos.isLastFrameOfInterruption;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetAnimatorClipInfos end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetAnimatorStateInfos start.*/
            GetAnimatorStateInfos: function (layer, isInterruptionActive, stateInfo, nextStateInfo, interruptingStateInfo, interruptingClipTimeAddition) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#GetAnimatorStateInfos", this ); }


                var layerInfos = this.layerClipInfos[layer];
                isInterruptionActive.v = layerInfos.isInterruptionActive;

                stateInfo.v = layerInfos.stateInfo;
                nextStateInfo.v = layerInfos.nextStateInfo;
                interruptingStateInfo.v = layerInfos.interruptingStateInfo;
                interruptingClipTimeAddition.v = layerInfos.isLastFrameOfInterruption ? layerInfos.interruptingClipTimeAddition : 0;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetAnimatorStateInfos end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetAnimation start.*/
            GetAnimation: function (clip) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#GetAnimation", this ); }

                var clipNameHashCode = { };
                if (!this.clipNameHashCodeTable.tryGetValue(clip, clipNameHashCode)) {
                    clipNameHashCode.v = Bridge.getHashCode(clip.name);
                    this.clipNameHashCodeTable.add(clip, clipNameHashCode.v);
                }
                var animation = { };
                this.animationTable.tryGetValue(clipNameHashCode.v, animation);
                return animation.v;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetAnimation end.*/


        }
    });
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer start.*/
    Bridge.define("Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer", {
        inherits: [System.Collections.Generic.IEqualityComparer$1(UnityEngine.AnimationClip)],
        $kind: 1002,
        statics: {
            fields: {
                Instance: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer#init", this ); }

                    this.Instance = new Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer();
                }
            }
        },
        alias: [
            "equals2", ["System$Collections$Generic$IEqualityComparer$1$UnityEngine$AnimationClip$equals2", "System$Collections$Generic$IEqualityComparer$1$equals2"],
            "getHashCode2", ["System$Collections$Generic$IEqualityComparer$1$UnityEngine$AnimationClip$getHashCode2", "System$Collections$Generic$IEqualityComparer$1$getHashCode2"]
        ],
        methods: {
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer.equals2 start.*/
            equals2: function (x, y) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer#equals2", this ); }

                return x.GetInstanceID() === y.GetInstanceID();
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer.equals2 end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer.getHashCode2 start.*/
            getHashCode2: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer#getHashCode2", this ); }

                return o.GetInstanceID();
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer.getHashCode2 end.*/


        },
        overloads: {
            "Equals(AnimationClip, AnimationClip)": "equals2",
            "GetHashCode(AnimationClip)": "getHashCode2"
        }
    });
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+ClipInfos start.*/
    Bridge.define("Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos", {
        $kind: 1002,
        fields: {
            isInterruptionActive: false,
            isLastFrameOfInterruption: false,
            clipInfoCount: 0,
            nextClipInfoCount: 0,
            interruptingClipInfoCount: 0,
            clipInfos: null,
            nextClipInfos: null,
            interruptingClipInfos: null,
            stateInfo: null,
            nextStateInfo: null,
            interruptingStateInfo: null,
            interruptingClipTimeAddition: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos#init", this ); }

                this.isInterruptionActive = false;
                this.isLastFrameOfInterruption = false;
                this.clipInfoCount = 0;
                this.nextClipInfoCount = 0;
                this.interruptingClipInfoCount = 0;
                this.clipInfos = new (System.Collections.Generic.List$1(UnityEngine.AnimatorClipInfo)).ctor();
                this.nextClipInfos = new (System.Collections.Generic.List$1(UnityEngine.AnimatorClipInfo)).ctor();
                this.interruptingClipInfos = new (System.Collections.Generic.List$1(UnityEngine.AnimatorClipInfo)).ctor();
                this.interruptingClipTimeAddition = 0;
            }
        }
    });
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+ClipInfos end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer start.*/
    Bridge.define("Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer", {
        inherits: [System.Collections.Generic.IEqualityComparer$1(System.Int32)],
        $kind: 1002,
        statics: {
            fields: {
                Instance: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer#init", this ); }

                    this.Instance = new Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer();
                }
            }
        },
        alias: [
            "equals2", ["System$Collections$Generic$IEqualityComparer$1$System$Int32$equals2", "System$Collections$Generic$IEqualityComparer$1$equals2"],
            "getHashCode2", ["System$Collections$Generic$IEqualityComparer$1$System$Int32$getHashCode2", "System$Collections$Generic$IEqualityComparer$1$getHashCode2"]
        ],
        methods: {
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer.equals2 start.*/
            equals2: function (x, y) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer#equals2", this ); }

                return x === y;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer.equals2 end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer.getHashCode2 start.*/
            getHashCode2: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer#getHashCode2", this ); }

                return o;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer.getHashCode2 end.*/


        },
        overloads: {
            "Equals(int, int)": "equals2",
            "GetHashCode(int)": "getHashCode2"
        }
    });
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+MixMode start.*/
    Bridge.define("Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode", {
        $kind: 1006,
        statics: {
            fields: {
                AlwaysMix: 0,
                MixNext: 1,
                Hard: 2
            }
        }
    });
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+MixMode end.*/
    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.SkeletonRootMotionBase.RootMotionDelegate
     * @param   {Spine.Unity.SkeletonRootMotionBase}    component      
     * @param   {UnityEngine.Vector2}                   translation    
     * @param   {number}                                rotation
     * @return  {void}
     */


    /*Spine.Unity.SkeletonRootMotionBase start.*/
    /**
     * Base class for skeleton root motion components.
     *
     * @abstract
     * @public
     * @class Spine.Unity.SkeletonRootMotionBase
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Spine.Unity.SkeletonRootMotionBase", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            rootMotionBoneName: null,
            transformPositionX: false,
            transformPositionY: false,
            transformRotation: false,
            rootMotionScaleX: 0,
            rootMotionScaleY: 0,
            rootMotionScaleRotation: 0,
            /**
             * Skeleton space X translation per skeleton space Y translation root motion.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRootMotionBase
             * @default 0
             * @type number
             */
            rootMotionTranslateXPerY: 0,
            /**
             * Skeleton space Y translation per skeleton space X translation root motion.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRootMotionBase
             * @default 0
             * @type number
             */
            rootMotionTranslateYPerX: 0,
            rigidBody2D: null,
            applyRigidbody2DGravity: false,
            rigidBody: null,
            /**
             * When true, root-motion is not applied to the Transform or Rigidbody.
             Otherwise the delegate callbacks are issued additionally.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRootMotionBase
             * @default true
             * @type boolean
             */
            disableOnOverride: false,
            skeletonComponent: null,
            rootMotionBone: null,
            rootMotionBoneIndex: 0,
            transformConstraintIndices: null,
            transformConstraintLastPos: null,
            transformConstraintLastRotation: null,
            topLevelBones: null,
            initialOffset: null,
            accumulatedUntilFixedUpdate: false,
            tempSkeletonDisplacement: null,
            rigidbodyDisplacement: null,
            previousRigidbodyRootMotion: null,
            additionalRigidbody2DMovement: null,
            rigidbodyLocalRotation: null,
            rigidbody2DRotation: 0,
            initialOffsetRotation: 0,
            tempSkeletonRotation: 0
        },
        events: {
            /**
             * This callback can be used to apply root-motion in a custom way. It is raised after evaluating
             this animation frame's root-motion, before it is potentially applied (see {@link })
             to either Transform or Rigidbody.
             When {@link } is set to {@link }, multiple
             animation frames might take place before <pre><code>FixedUpdate</code></pre> is called once.
             The callback parameters <pre><code>translation</code></pre> and <pre><code>rotation</code></pre> are filled out with
             this animation frame's skeleton-space root-motion (not cumulated). You can use
             e.g. <pre><code>transform.TransformVector()</code></pre> to transform skeleton-space root-motion to world space.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRootMotionBase
             * @memberof Spine.Unity.SkeletonRootMotionBase
             * @function addProcessRootMotionOverride
             * @param   {Spine.Unity.SkeletonRootMotionBase.RootMotionDelegate}    value
             * @return  {void}
             * @see {@link PhysicsUpdateRootMotionOverride}
             */
            /**
             * This callback can be used to apply root-motion in a custom way. It is raised after evaluating
             this animation frame's root-motion, before it is potentially applied (see {@link })
             to either Transform or Rigidbody.
             When {@link } is set to {@link }, multiple
             animation frames might take place before <pre><code>FixedUpdate</code></pre> is called once.
             The callback parameters <pre><code>translation</code></pre> and <pre><code>rotation</code></pre> are filled out with
             this animation frame's skeleton-space root-motion (not cumulated). You can use
             e.g. <pre><code>transform.TransformVector()</code></pre> to transform skeleton-space root-motion to world space.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRootMotionBase
             * @memberof Spine.Unity.SkeletonRootMotionBase
             * @function removeProcessRootMotionOverride
             * @param   {Spine.Unity.SkeletonRootMotionBase.RootMotionDelegate}    value
             * @return  {void}
             * @see {@link PhysicsUpdateRootMotionOverride}
             */
            ProcessRootMotionOverride: null,
            /**
             * This callback can be used to apply root-motion in a custom way. It is raised in FixedUpdate
             after (when {@link } is set to false) or instead of when root-motion
             would be applied at the Rigidbody.
             When {@link } is set to {@link }, multiple
             animation frames might take place before before <pre><code>FixedUpdate</code></pre> is called once.
             The callback parameters <pre><code>translation</code></pre> and <pre><code>rotation</code></pre> are filled out with the
             (cumulated) skeleton-space root-motion since the the last <pre><code>FixedUpdate</code></pre> call. You can use
             e.g. <pre><code>transform.TransformVector()</code></pre> to transform skeleton-space root-motion to world space.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRootMotionBase
             * @memberof Spine.Unity.SkeletonRootMotionBase
             * @function addPhysicsUpdateRootMotionOverride
             * @param   {Spine.Unity.SkeletonRootMotionBase.RootMotionDelegate}    value
             * @return  {void}
             * @see {@link ProcessRootMotionOverride}
             */
            /**
             * This callback can be used to apply root-motion in a custom way. It is raised in FixedUpdate
             after (when {@link } is set to false) or instead of when root-motion
             would be applied at the Rigidbody.
             When {@link } is set to {@link }, multiple
             animation frames might take place before before <pre><code>FixedUpdate</code></pre> is called once.
             The callback parameters <pre><code>translation</code></pre> and <pre><code>rotation</code></pre> are filled out with the
             (cumulated) skeleton-space root-motion since the the last <pre><code>FixedUpdate</code></pre> call. You can use
             e.g. <pre><code>transform.TransformVector()</code></pre> to transform skeleton-space root-motion to world space.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRootMotionBase
             * @memberof Spine.Unity.SkeletonRootMotionBase
             * @function removePhysicsUpdateRootMotionOverride
             * @param   {Spine.Unity.SkeletonRootMotionBase.RootMotionDelegate}    value
             * @return  {void}
             * @see {@link ProcessRootMotionOverride}
             */
            PhysicsUpdateRootMotionOverride: null
        },
        props: {
            RootMotionBone: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#RootMotionBone#get", this ); }

                    return this.rootMotionBone;
                }
            },
            UsesRigidbody: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#UsesRigidbody#get", this ); }

                    return UnityEngine.Component.op_Inequality(this.rigidBody, null) || UnityEngine.Component.op_Inequality(this.rigidBody2D, null);
                }
            },
            /**
             * Root motion translation that has been applied in the preceding <pre><code>FixedUpdate</code></pre> call
             if a rigidbody is assigned at either <pre><code>rigidbody</code></pre> or <pre><code>rigidbody2D</code></pre>.
             Returns <pre><code>Vector2.zero</code></pre> when <pre><code>rigidbody</code></pre> and <pre><code>rigidbody2D</code></pre> are null.
             This can be necessary when multiple scripts call <pre><code>Rigidbody2D.MovePosition</code></pre>,
             where the last call overwrites the effect of preceding ones.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonRootMotionBase
             * @function PreviousRigidbodyRootMotion2D
             * @type UnityEngine.Vector2
             */
            PreviousRigidbodyRootMotion2D: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#PreviousRigidbodyRootMotion2D#get", this ); }

                    return new pc.Vec2( this.previousRigidbodyRootMotion.x, this.previousRigidbodyRootMotion.y );
                }
            },
            /**
             * Root motion translation that has been applied in the preceding <pre><code>FixedUpdate</code></pre> call
             if a rigidbody is assigned at either <pre><code>rigidbody</code></pre> or <pre><code>rigidbody2D</code></pre>.
             Returns <pre><code>Vector3.zero</code></pre> when <pre><code>rigidbody</code></pre> and <pre><code>rigidbody2D</code></pre> are null.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonRootMotionBase
             * @function PreviousRigidbodyRootMotion3D
             * @type UnityEngine.Vector3
             */
            PreviousRigidbodyRootMotion3D: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#PreviousRigidbodyRootMotion3D#get", this ); }

                    return this.previousRigidbodyRootMotion.$clone();
                }
            },
            /**
             * Additional translation to add to <pre><code>Rigidbody2D.MovePosition</code></pre>
             called in FixedUpdate. This can be necessary when multiple scripts call
             <pre><code>MovePosition</code></pre>, where the last call overwrites the effect of preceding ones.
             Has no effect if <pre><code>rigidBody2D</code></pre> is null.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRootMotionBase
             * @function AdditionalRigidbody2DMovement
             * @type UnityEngine.Vector2
             */
            AdditionalRigidbody2DMovement: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#AdditionalRigidbody2DMovement#get", this ); }

                    return this.additionalRigidbody2DMovement.$clone();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#AdditionalRigidbody2DMovement#set", this ); }

                    this.additionalRigidbody2DMovement = value.$clone();
                }
            },
            SkeletonAnimationUsesFixedUpdate: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#SkeletonAnimationUsesFixedUpdate#get", this ); }

                    var skeletonAnimation = Bridge.as(this.skeletonComponent, Spine.Unity.ISkeletonAnimation);
                    if (skeletonAnimation != null) {
                        return skeletonAnimation.Spine$Unity$ISkeletonAnimation$UpdateTiming === Spine.Unity.UpdateTiming.InFixedUpdate;
                    }
                    return false;
                }
            },
            AdditionalScale: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#AdditionalScale#get", this ); }

                    return 1.0;
                }
            },
            TargetSkeletonComponent: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#TargetSkeletonComponent#get", this ); }

                    if (this.skeletonComponent == null) {
                        this.skeletonComponent = this.GetComponent(Spine.Unity.ISkeletonComponent);
                    }
                    return this.skeletonComponent;
                }
            },
            TargetSkeletonAnimationComponent: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#TargetSkeletonAnimationComponent#get", this ); }

                    return Bridge.as(this.TargetSkeletonComponent, Spine.Unity.ISkeletonAnimation);
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#init", this ); }

                this.initialOffset = new UnityEngine.Vector2();
                this.tempSkeletonDisplacement = new UnityEngine.Vector2();
                this.rigidbodyDisplacement = new UnityEngine.Vector3();
                this.previousRigidbodyRootMotion = new UnityEngine.Vector3();
                this.additionalRigidbody2DMovement = new UnityEngine.Vector2();
                this.rigidbodyLocalRotation = new UnityEngine.Quaternion();
                this.rootMotionBoneName = "root";
                this.transformPositionX = true;
                this.transformPositionY = true;
                this.transformRotation = false;
                this.rootMotionScaleX = 1;
                this.rootMotionScaleY = 1;
                this.rootMotionScaleRotation = 1;
                this.rootMotionTranslateXPerY = 0;
                this.rootMotionTranslateYPerX = 0;
                this.applyRigidbody2DGravity = false;
                this.disableOnOverride = true;
                this.transformConstraintIndices = new (System.Collections.Generic.List$1(System.Int32)).ctor();
                this.transformConstraintLastPos = new (System.Collections.Generic.List$1(UnityEngine.Vector2)).ctor();
                this.transformConstraintLastRotation = new (System.Collections.Generic.List$1(System.Single)).ctor();
                this.topLevelBones = new (System.Collections.Generic.List$1(Spine.Bone)).ctor();
                this.initialOffset = pc.Vec2.ZERO.clone();
                this.accumulatedUntilFixedUpdate = false;
                this.previousRigidbodyRootMotion = UnityEngine.Vector3.FromVector2(pc.Vec2.ZERO.clone());
                this.additionalRigidbody2DMovement = pc.Vec2.ZERO.clone();
                this.rigidbodyLocalRotation = pc.Quat.IDENTITY.clone();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRootMotionBase.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#Reset", this ); }

                this.FindRigidbodyComponent();
            },
            /*Spine.Unity.SkeletonRootMotionBase.Reset end.*/

            /*Spine.Unity.SkeletonRootMotionBase.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#Start", this ); }

                this.Initialize();
            },
            /*Spine.Unity.SkeletonRootMotionBase.Start end.*/

            /*Spine.Unity.SkeletonRootMotionBase.InitializeOnRebuild start.*/
            InitializeOnRebuild: function (animatedSkeletonComponent) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#InitializeOnRebuild", this ); }

                this.Initialize();
            },
            /*Spine.Unity.SkeletonRootMotionBase.InitializeOnRebuild end.*/

            /*Spine.Unity.SkeletonRootMotionBase.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#Initialize", this ); }

                this.skeletonComponent = this.GetComponent(Spine.Unity.ISkeletonComponent);
                this.GatherTopLevelBones();
                this.SetRootMotionBone(this.rootMotionBoneName);
                if (this.rootMotionBone != null) {
                    this.initialOffset = new pc.Vec2( this.rootMotionBone.X, this.rootMotionBone.Y );
                    this.initialOffsetRotation = this.rootMotionBone.Rotation;
                }

                var skeletonAnimation = Bridge.as(this.skeletonComponent, Spine.Unity.ISkeletonAnimation);
                if (skeletonAnimation != null) {
                    skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateLocal(Bridge.fn.cacheBind(this, this.HandleUpdateLocal));
                    skeletonAnimation.Spine$Unity$ISkeletonAnimation$addUpdateLocal(Bridge.fn.cacheBind(this, this.HandleUpdateLocal));

                    skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeOnAnimationRebuild(Bridge.fn.cacheBind(this, this.InitializeOnRebuild));
                    skeletonAnimation.Spine$Unity$ISkeletonAnimation$addOnAnimationRebuild(Bridge.fn.cacheBind(this, this.InitializeOnRebuild));

                    var skeletonUtility = this.GetComponent(Spine.Unity.SkeletonUtility);
                    if (UnityEngine.MonoBehaviour.op_Inequality(skeletonUtility, null)) {
                        // SkeletonUtilityBone shall receive UpdateLocal callbacks for bone-following after root motion
                        // clears the root-bone position.
                        skeletonUtility.ResubscribeEvents();
                    }
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.Initialize end.*/

            /*Spine.Unity.SkeletonRootMotionBase.FixedUpdate start.*/
            FixedUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#FixedUpdate", this ); }

                // Root motion is only applied when component is enabled.
                if (!this.isActiveAndEnabled) {
                    return;
                }
                // When SkeletonAnimation component uses UpdateTiming.InFixedUpdate,
                // we directly call PhysicsUpdate in HandleUpdateLocal instead of here.
                if (!this.SkeletonAnimationUsesFixedUpdate) {
                    this.PhysicsUpdate(false);
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.FixedUpdate end.*/

            /*Spine.Unity.SkeletonRootMotionBase.PhysicsUpdate start.*/
            PhysicsUpdate: function (skeletonAnimationUsesFixedUpdate) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#PhysicsUpdate", this ); }

                var callbackDisplacement = this.tempSkeletonDisplacement.$clone();
                var callbackRotation = this.tempSkeletonRotation;

                var isApplyAtRigidbodyAllowed = Bridge.staticEquals(this.PhysicsUpdateRootMotionOverride, null) || !this.disableOnOverride;
                if (isApplyAtRigidbodyAllowed) {
                    if (UnityEngine.Component.op_Inequality(this.rigidBody2D, null)) {
                        var gravityAndVelocityMovement = pc.Vec2.ZERO.clone();
                        if (this.applyRigidbody2DGravity) {
                            var deltaTime = UnityEngine.Time.fixedDeltaTime;
                            var deltaTimeSquared = (deltaTime * deltaTime);

                            this.rigidBody2D.velocity = this.rigidBody2D.velocity.$clone().add( UnityEngine.Physics2D.gravity.$clone().scale( this.rigidBody2D.gravityScale ).scale( deltaTime ) );
                            gravityAndVelocityMovement = UnityEngine.Physics2D.gravity.$clone().scale( 0.5 * this.rigidBody2D.gravityScale ).scale( deltaTimeSquared ).add( this.rigidBody2D.velocity.$clone().scale( deltaTime ) );
                        }

                        var rigidbodyDisplacement2D = new pc.Vec2( this.rigidbodyDisplacement.x, this.rigidbodyDisplacement.y );
                        // Note: MovePosition seems to be the only precise and reliable way to set movement delta,
                        // for both 2D and 3D rigidbodies.
                        // Setting velocity like "rigidBody2D.velocity = movement/deltaTime" works perfectly in mid-air
                        // without gravity and ground collision, unfortunately when on the ground, friction causes severe
                        // slowdown. Using a zero-friction PhysicsMaterial leads to sliding endlessly along the ground as
                        // soon as forces are applied. Additionally, there is no rigidBody2D.isGrounded, requiring our own
                        // checks.
                        this.rigidBody2D.MovePosition(gravityAndVelocityMovement.$clone().add( new pc.Vec2( this.rigidBody2D.position.x, this.rigidBody2D.position.y ) ).add( rigidbodyDisplacement2D ).add( this.additionalRigidbody2DMovement ));
                        this.rigidBody2D.MoveRotation(this.rigidbody2DRotation + this.rigidBody2D.rotation);
                    } else if (UnityEngine.Component.op_Inequality(this.rigidBody, null)) {
                        this.rigidBody.MovePosition(this.rigidBody.position.$clone().add( new pc.Vec3( this.rigidbodyDisplacement.x, this.rigidbodyDisplacement.y, this.rigidbodyDisplacement.z ) ));
                        this.rigidBody.MoveRotation(this.rigidBody.rotation.clone().mul( this.rigidbodyLocalRotation ));
                    }
                }

                this.previousRigidbodyRootMotion = this.rigidbodyDisplacement.$clone();
                if (this.accumulatedUntilFixedUpdate) {
                    var parentBoneScale = { v : new UnityEngine.Vector2() };
                    this.GetScaleAffectingRootMotion$1(parentBoneScale);
                    this.ClearEffectiveBoneOffsets(parentBoneScale.v);
                    this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton.UpdateWorldTransform(Spine.Skeleton.Physics.Pose);
                }
                this.ClearRigidbodyTempMovement();

                if (!Bridge.staticEquals(this.PhysicsUpdateRootMotionOverride, null)) {
                    this.PhysicsUpdateRootMotionOverride(this, callbackDisplacement.$clone(), callbackRotation);
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.PhysicsUpdate end.*/

            /*Spine.Unity.SkeletonRootMotionBase.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#OnDisable", this ); }

                this.ClearRigidbodyTempMovement();
            },
            /*Spine.Unity.SkeletonRootMotionBase.OnDisable end.*/

            /*Spine.Unity.SkeletonRootMotionBase.FindRigidbodyComponent start.*/
            FindRigidbodyComponent: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#FindRigidbodyComponent", this ); }

                this.rigidBody2D = this.GetComponent(UnityEngine.Rigidbody2D);
                if (!UnityEngine.Object.op_Implicit(this.rigidBody2D)) {
                    this.rigidBody = this.GetComponent(UnityEngine.Rigidbody);
                }

                if (!UnityEngine.Object.op_Implicit(this.rigidBody2D) && !UnityEngine.Object.op_Implicit(this.rigidBody)) {
                    this.rigidBody2D = this.GetComponentInParent(UnityEngine.Rigidbody2D);
                    if (!UnityEngine.Object.op_Implicit(this.rigidBody2D)) {
                        this.rigidBody = this.GetComponentInParent(UnityEngine.Rigidbody);
                    }
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.FindRigidbodyComponent end.*/

            /*Spine.Unity.SkeletonRootMotionBase.CalculateAnimationsRotationDelta start.*/
            CalculateAnimationsRotationDelta: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#CalculateAnimationsRotationDelta", this ); }

                return 0;
            },
            /*Spine.Unity.SkeletonRootMotionBase.CalculateAnimationsRotationDelta end.*/

            /*Spine.Unity.SkeletonRootMotionBase.SetRootMotionBone start.*/
            SetRootMotionBone: function (name) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#SetRootMotionBone", this ); }

                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                var bone = skeleton.FindBone(name);
                if (bone != null) {
                    this.rootMotionBoneIndex = bone.Data.Index;
                    this.rootMotionBone = bone;
                    this.FindTransformConstraintsAffectingBone();
                } else {
                    UnityEngine.Debug.Log$1("Bone named \"" + (name || "") + "\" could not be found. " + "Set 'skeletonRootMotion.rootMotionBoneName' before calling 'skeletonAnimation.Initialize(true)'.");
                    this.rootMotionBoneIndex = 0;
                    this.rootMotionBone = skeleton.RootBone;
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.SetRootMotionBone end.*/

            /*Spine.Unity.SkeletonRootMotionBase.AdjustRootMotionToDistance start.*/
            AdjustRootMotionToDistance: function (distanceToTarget, trackIndex, adjustX, adjustY, minX, maxX, minY, maxY, allowXTranslation, allowYTranslation) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#AdjustRootMotionToDistance", this ); }

                if (trackIndex === void 0) { trackIndex = 0; }
                if (adjustX === void 0) { adjustX = true; }
                if (adjustY === void 0) { adjustY = true; }
                if (minX === void 0) { minX = 0.0; }
                if (maxX === void 0) { maxX = 3.40282347E+38; }
                if (minY === void 0) { minY = 0.0; }
                if (maxY === void 0) { maxY = 3.40282347E+38; }
                if (allowXTranslation === void 0) { allowXTranslation = false; }
                if (allowYTranslation === void 0) { allowYTranslation = false; }

                var distanceToTargetSkeletonSpace = UnityEngine.Vector2.FromVector3(this.transform.InverseTransformVector(UnityEngine.Vector3.FromVector2(distanceToTarget)));
                var scaleAffectingRootMotion = this.GetScaleAffectingRootMotion();
                if (this.UsesRigidbody) {
                    distanceToTargetSkeletonSpace = distanceToTargetSkeletonSpace.$clone().sub( this.tempSkeletonDisplacement.$clone() );
                }

                var remainingRootMotionSkeletonSpace = this.GetRemainingRootMotion(trackIndex);
                remainingRootMotionSkeletonSpace.mul( scaleAffectingRootMotion );
                if (remainingRootMotionSkeletonSpace.x === 0) {
                    remainingRootMotionSkeletonSpace.x = 0.0001;
                }
                if (remainingRootMotionSkeletonSpace.y === 0) {
                    remainingRootMotionSkeletonSpace.y = 0.0001;
                }

                if (adjustX) {
                    this.rootMotionScaleX = Math.min(maxX, Math.max(minX, distanceToTargetSkeletonSpace.x / remainingRootMotionSkeletonSpace.x));
                }
                if (adjustY) {
                    this.rootMotionScaleY = Math.min(maxY, Math.max(minY, distanceToTargetSkeletonSpace.y / remainingRootMotionSkeletonSpace.y));
                }

                if (allowXTranslation) {
                    this.rootMotionTranslateXPerY = (distanceToTargetSkeletonSpace.x - remainingRootMotionSkeletonSpace.x * this.rootMotionScaleX) / remainingRootMotionSkeletonSpace.y;
                }
                if (allowYTranslation) {
                    this.rootMotionTranslateYPerX = (distanceToTargetSkeletonSpace.y - remainingRootMotionSkeletonSpace.y * this.rootMotionScaleY) / remainingRootMotionSkeletonSpace.x;
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.AdjustRootMotionToDistance end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotion start.*/
            GetAnimationRootMotion: function (animation) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotion", this ); }

                return this.GetAnimationRootMotion$1(0, animation.Duration, animation);
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotion end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotion$1 start.*/
            GetAnimationRootMotion$1: function (startTime, endTime, animation) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotion$1", this ); }

                var $t, $t1;

                if (startTime === endTime) {
                    return pc.Vec2.ZERO.clone();
                }

                var translateTimeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTranslateTimelineForBone(animation, this.rootMotionBoneIndex);
                var xTimeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTimelineForBone(Spine.TranslateXTimeline, animation, this.rootMotionBoneIndex);
                var yTimeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTimelineForBone(Spine.TranslateYTimeline, animation, this.rootMotionBoneIndex);

                // Non-looped base
                var endPos = { v : pc.Vec2.ZERO.clone() };
                var startPos = { v : pc.Vec2.ZERO.clone() };
                if (translateTimeline != null) {
                    endPos.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(translateTimeline, endTime);
                    startPos.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(translateTimeline, startTime);
                } else if (xTimeline != null || yTimeline != null) {
                    endPos.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, endTime);
                    startPos.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, startTime);
                }
                var transformConstraintsItems = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton.TransformConstraints.Items;
                $t = Bridge.getEnumerator(this.transformConstraintIndices);
                try {
                    while ($t.moveNext()) {
                        var constraintIndex = $t.Current;
                        var constraint = transformConstraintsItems[constraintIndex];
                        this.ApplyConstraintToPos(animation, constraint, constraintIndex, endTime, false, endPos);
                        this.ApplyConstraintToPos(animation, constraint, constraintIndex, startTime, true, startPos);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                var currentDelta = endPos.v.$clone().sub( startPos.v );

                // Looped additions
                if (startTime > endTime) {
                    var loopPos = { v : pc.Vec2.ZERO.clone() };
                    var zeroPos = { v : pc.Vec2.ZERO.clone() };
                    if (translateTimeline != null) {
                        loopPos.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(translateTimeline, animation.Duration);
                        zeroPos.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(translateTimeline, 0);
                    } else if (xTimeline != null || yTimeline != null) {
                        loopPos.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, animation.Duration);
                        zeroPos.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, 0);
                    }
                    $t1 = Bridge.getEnumerator(this.transformConstraintIndices);
                    try {
                        while ($t1.moveNext()) {
                            var constraintIndex1 = $t1.Current;
                            var constraint1 = transformConstraintsItems[constraintIndex1];
                            this.ApplyConstraintToPos(animation, constraint1, constraintIndex1, animation.Duration, false, loopPos);
                            this.ApplyConstraintToPos(animation, constraint1, constraintIndex1, 0, false, zeroPos);
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                    currentDelta = currentDelta.$clone().add( loopPos.v.$clone().sub( zeroPos.v ) );
                }
                this.UpdateLastConstraintPos(transformConstraintsItems);
                return currentDelta.$clone();
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotion$1 end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotionRotation start.*/
            GetAnimationRootMotionRotation: function (animation) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotionRotation", this ); }

                return this.GetAnimationRootMotionRotation$1(0, animation.Duration, animation);
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotionRotation end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotionRotation$1 start.*/
            GetAnimationRootMotionRotation$1: function (startTime, endTime, animation) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotionRotation$1", this ); }

                var $t, $t1;

                if (startTime === endTime) {
                    return 0;
                }

                var rotateTimeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTimelineForBone(Spine.RotateTimeline, animation, this.rootMotionBoneIndex);

                // Non-looped base
                var endRotation = { v : 0 };
                var startRotation = { v : 0 };
                if (rotateTimeline != null) {
                    endRotation.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate(rotateTimeline, endTime);
                    startRotation.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate(rotateTimeline, startTime);
                }
                var transformConstraintsItems = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton.TransformConstraints.Items;
                $t = Bridge.getEnumerator(this.transformConstraintIndices);
                try {
                    while ($t.moveNext()) {
                        var constraintIndex = $t.Current;
                        var constraint = transformConstraintsItems[constraintIndex];
                        this.ApplyConstraintToRotation(animation, constraint, constraintIndex, endTime, false, endRotation);
                        this.ApplyConstraintToRotation(animation, constraint, constraintIndex, startTime, true, startRotation);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                var currentDelta = endRotation.v - startRotation.v;

                // Looped additions
                if (startTime > endTime) {
                    var loopRotation = { v : 0 };
                    var zeroPos = { v : 0 };
                    if (rotateTimeline != null) {
                        loopRotation.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate(rotateTimeline, animation.Duration);
                        zeroPos.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate(rotateTimeline, 0);
                    }
                    $t1 = Bridge.getEnumerator(this.transformConstraintIndices);
                    try {
                        while ($t1.moveNext()) {
                            var constraintIndex1 = $t1.Current;
                            var constraint1 = transformConstraintsItems[constraintIndex1];
                            this.ApplyConstraintToRotation(animation, constraint1, constraintIndex1, animation.Duration, false, loopRotation);
                            this.ApplyConstraintToRotation(animation, constraint1, constraintIndex1, 0, false, zeroPos);
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                    currentDelta += loopRotation.v - zeroPos.v;
                }
                this.UpdateLastConstraintRotation(transformConstraintsItems);
                return currentDelta;
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotionRotation$1 end.*/

            /*Spine.Unity.SkeletonRootMotionBase.ApplyConstraintToPos start.*/
            ApplyConstraintToPos: function (animation, constraint, constraintIndex, time, useLastConstraintPos, pos) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#ApplyConstraintToPos", this ); }

                var timeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTransformConstraintTimeline(animation, constraintIndex);
                if (timeline == null) {
                    return;
                }
                var mixXY = Spine.Unity.AnimationTools.TimelineExtensions.EvaluateTranslateXYMix(timeline, time);
                var invMixXY = Spine.Unity.AnimationTools.TimelineExtensions.EvaluateTranslateXYMix(timeline, time);
                var constraintPos = new UnityEngine.Vector2();
                if (useLastConstraintPos) {
                    constraintPos = this.transformConstraintLastPos.getItem(this.GetConstraintLastPosIndex(constraintIndex)).$clone();
                } else {
                    var targetBone = constraint.Target;
                    constraintPos = new pc.Vec2( targetBone.X, targetBone.Y );
                }
                pos.v = new pc.Vec2( pos.v.x * invMixXY.x + constraintPos.x * mixXY.x, pos.v.y * invMixXY.y + constraintPos.y * mixXY.y );
            },
            /*Spine.Unity.SkeletonRootMotionBase.ApplyConstraintToPos end.*/

            /*Spine.Unity.SkeletonRootMotionBase.ApplyConstraintToRotation start.*/
            ApplyConstraintToRotation: function (animation, constraint, constraintIndex, time, useLastConstraintRotation, rotation) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#ApplyConstraintToRotation", this ); }

                var timeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTransformConstraintTimeline(animation, constraintIndex);
                if (timeline == null) {
                    return;
                }
                var mixRotate = Spine.Unity.AnimationTools.TimelineExtensions.EvaluateRotateMix(timeline, time);
                var invMixRotate = Spine.Unity.AnimationTools.TimelineExtensions.EvaluateRotateMix(timeline, time);
                var constraintRotation;
                if (useLastConstraintRotation) {
                    constraintRotation = this.transformConstraintLastRotation.getItem(this.GetConstraintLastPosIndex(constraintIndex));
                } else {
                    var targetBone = constraint.Target;
                    constraintRotation = targetBone.Rotation;
                }
                rotation.v = rotation.v * invMixRotate + constraintRotation * mixRotate;
            },
            /*Spine.Unity.SkeletonRootMotionBase.ApplyConstraintToRotation end.*/

            /*Spine.Unity.SkeletonRootMotionBase.UpdateLastConstraintPos start.*/
            UpdateLastConstraintPos: function (transformConstraintsItems) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#UpdateLastConstraintPos", this ); }

                var $t;
                $t = Bridge.getEnumerator(this.transformConstraintIndices);
                try {
                    while ($t.moveNext()) {
                        var constraintIndex = $t.Current;
                        var constraint = transformConstraintsItems[constraintIndex];
                        var targetBone = constraint.Target;
                        this.transformConstraintLastPos.setItem(this.GetConstraintLastPosIndex(constraintIndex), new pc.Vec2( targetBone.X, targetBone.Y ));
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.UpdateLastConstraintPos end.*/

            /*Spine.Unity.SkeletonRootMotionBase.UpdateLastConstraintRotation start.*/
            UpdateLastConstraintRotation: function (transformConstraintsItems) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#UpdateLastConstraintRotation", this ); }

                var $t;
                $t = Bridge.getEnumerator(this.transformConstraintIndices);
                try {
                    while ($t.moveNext()) {
                        var constraintIndex = $t.Current;
                        var constraint = transformConstraintsItems[constraintIndex];
                        var targetBone = constraint.Target;
                        this.transformConstraintLastRotation.setItem(this.GetConstraintLastPosIndex(constraintIndex), targetBone.Rotation);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.UpdateLastConstraintRotation end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotionInfo start.*/
            GetAnimationRootMotionInfo: function (animation, currentTime) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotionInfo", this ); }

                var rootMotion = new Spine.Unity.SkeletonRootMotionBase.RootMotionInfo();
                var duration = animation.Duration;
                var mid = duration * 0.5;
                rootMotion.timeIsPastMid = currentTime > mid;
                var timeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTranslateTimelineForBone(animation, this.rootMotionBoneIndex);
                if (timeline != null) {
                    rootMotion.start = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(timeline, 0);
                    rootMotion.current = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(timeline, currentTime);
                    rootMotion.mid = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(timeline, mid);
                    rootMotion.end = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(timeline, duration);
                    return rootMotion.$clone();
                }
                var xTimeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTimelineForBone(Spine.TranslateXTimeline, animation, this.rootMotionBoneIndex);
                var yTimeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTimelineForBone(Spine.TranslateYTimeline, animation, this.rootMotionBoneIndex);
                if (xTimeline != null || yTimeline != null) {
                    rootMotion.start = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, 0);
                    rootMotion.current = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, currentTime);
                    rootMotion.mid = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, mid);
                    rootMotion.end = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, duration);
                    return rootMotion.$clone();
                }
                return rootMotion.$clone();
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotionInfo end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetConstraintLastPosIndex start.*/
            GetConstraintLastPosIndex: function (constraintIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetConstraintLastPosIndex", this ); }

                var constraints = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton.TransformConstraints;
                return this.transformConstraintIndices.FindIndex$2(function (addedIndex) {
                    return addedIndex === constraintIndex;
                });
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetConstraintLastPosIndex end.*/

            /*Spine.Unity.SkeletonRootMotionBase.FindTransformConstraintsAffectingBone start.*/
            FindTransformConstraintsAffectingBone: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#FindTransformConstraintsAffectingBone", this ); }

                var constraints = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton.TransformConstraints;
                var constraintsItems = constraints.Items;
                for (var i = 0, n = constraints.Count; i < n; i = (i + 1) | 0) {
                    var constraint = constraintsItems[i];
                    if (constraint.Bones.Contains(this.rootMotionBone)) {
                        this.transformConstraintIndices.add(i);
                        var targetBone = constraint.Target;
                        var constraintPos = new pc.Vec2( targetBone.X, targetBone.Y );
                        this.transformConstraintLastPos.add(constraintPos.$clone());
                        this.transformConstraintLastRotation.add(targetBone.Rotation);
                    }
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.FindTransformConstraintsAffectingBone end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetTimelineMovementDelta start.*/
            GetTimelineMovementDelta: function (startTime, endTime, xTimeline, yTimeline, animation) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetTimelineMovementDelta", this ); }


                var currentDelta = new UnityEngine.Vector2();
                if (startTime > endTime) {
                    currentDelta = (Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, animation.Duration).sub( Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, startTime) )).add( (Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, endTime).sub( Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, 0) )) );
                } else {
                    if (startTime !== endTime) {
                        currentDelta = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, endTime).sub( Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, startTime) );
                    } else {
                        currentDelta = pc.Vec2.ZERO.clone();
                    }
                }
                return currentDelta.$clone();
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetTimelineMovementDelta end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GatherTopLevelBones start.*/
            GatherTopLevelBones: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GatherTopLevelBones", this ); }

                var $t;
                this.topLevelBones.clear();
                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                $t = Bridge.getEnumerator(skeleton.Bones);
                try {
                    while ($t.moveNext()) {
                        var bone = $t.Current;
                        if (bone.Parent == null) {
                            this.topLevelBones.add(bone);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.GatherTopLevelBones end.*/

            /*Spine.Unity.SkeletonRootMotionBase.HandleUpdateLocal start.*/
            HandleUpdateLocal: function (animatedSkeletonComponent) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#HandleUpdateLocal", this ); }

                if (!this.isActiveAndEnabled) {
                    return;
                } // Root motion is only applied when component is enabled.

                var boneLocalDelta = this.CalculateAnimationsMovementDelta();
                var parentBoneScale = { v : new UnityEngine.Vector2() };
                var totalScale = { v : new UnityEngine.Vector2() };
                var skeletonTranslationDelta = this.GetSkeletonSpaceMovementDelta(boneLocalDelta.$clone(), parentBoneScale, totalScale);
                var skeletonRotationDelta = 0;
                if (this.transformRotation) {
                    var boneLocalDeltaRotation = this.CalculateAnimationsRotationDelta();
                    boneLocalDeltaRotation *= this.rootMotionScaleRotation;
                    skeletonRotationDelta = this.GetSkeletonSpaceRotationDelta(boneLocalDeltaRotation, totalScale.v);
                }

                var usesFixedUpdate = this.SkeletonAnimationUsesFixedUpdate;
                this.ApplyRootMotion(skeletonTranslationDelta, skeletonRotationDelta, parentBoneScale.v, usesFixedUpdate);

                if (usesFixedUpdate) {
                    this.PhysicsUpdate(usesFixedUpdate);
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.HandleUpdateLocal end.*/

            /*Spine.Unity.SkeletonRootMotionBase.ApplyRootMotion start.*/
            ApplyRootMotion: function (skeletonTranslationDelta, skeletonRotationDelta, parentBoneScale, skeletonAnimationUsesFixedUpdate) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#ApplyRootMotion", this ); }


                // Accumulated displacement is applied on the next Physics update in FixedUpdate.
                // Until the next Physics update, tempSkeletonDisplacement and tempSkeletonRotation
                // are offsetting bone locations to prevent stutter which would otherwise occur if
                // we don't move every Update.
                var usesRigidbody = this.UsesRigidbody;
                var applyToTransform = !usesRigidbody && (Bridge.staticEquals(this.ProcessRootMotionOverride, null) || !this.disableOnOverride);
                this.accumulatedUntilFixedUpdate = !applyToTransform && !skeletonAnimationUsesFixedUpdate;

                if (!Bridge.staticEquals(this.ProcessRootMotionOverride, null)) {
                    this.ProcessRootMotionOverride(this, skeletonTranslationDelta.$clone(), skeletonRotationDelta);
                }

                // Apply root motion to Transform or update values applied to RigidBody later (must happen in FixedUpdate).
                if (usesRigidbody) {
                    this.rigidbodyDisplacement = this.rigidbodyDisplacement.$clone().add( this.transform.TransformVector(UnityEngine.Vector3.FromVector2(skeletonTranslationDelta)) );
                    if (skeletonRotationDelta !== 0.0) {
                        if (UnityEngine.Component.op_Inequality(this.rigidBody, null)) {
                            var addedWorldRotation = new pc.Quat().setFromEulerAngles_Unity( 0, 0, skeletonRotationDelta );
                            this.rigidbodyLocalRotation = this.rigidbodyLocalRotation.clone().mul( addedWorldRotation );
                        } else if (UnityEngine.Component.op_Inequality(this.rigidBody2D, null)) {
                            var lossyScale = this.transform.lossyScale.$clone();
                            var rotationSign = lossyScale.x * lossyScale.y > 0 ? 1 : -1;
                            this.rigidbody2DRotation += rotationSign * skeletonRotationDelta;
                        }
                    }
                } else if (applyToTransform) {
                    this.transform.position = this.transform.position.$clone().add( this.transform.TransformVector(UnityEngine.Vector3.FromVector2(skeletonTranslationDelta)) );
                    if (skeletonRotationDelta !== 0.0) {
                        var lossyScale1 = this.transform.lossyScale.$clone();
                        var rotationSign1 = lossyScale1.x * lossyScale1.y > 0 ? 1 : -1;
                        this.transform.Rotate(0, 0, rotationSign1 * skeletonRotationDelta);
                    }
                }

                this.tempSkeletonDisplacement = this.tempSkeletonDisplacement.$clone().add( skeletonTranslationDelta.$clone() );
                this.tempSkeletonRotation += skeletonRotationDelta;
                if (this.accumulatedUntilFixedUpdate) {
                    this.SetEffectiveBoneOffsetsTo(this.tempSkeletonDisplacement, this.tempSkeletonRotation, parentBoneScale);
                } else {
                    this.ClearEffectiveBoneOffsets(parentBoneScale);
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.ApplyRootMotion end.*/

            /*Spine.Unity.SkeletonRootMotionBase.ApplyTransformConstraints start.*/
            ApplyTransformConstraints: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#ApplyTransformConstraints", this ); }

                var $t;
                this.rootMotionBone.AX = this.rootMotionBone.X;
                this.rootMotionBone.AY = this.rootMotionBone.Y;
                this.rootMotionBone.AppliedRotation = this.rootMotionBone.Rotation;
                var transformConstraintsItems = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton.TransformConstraints.Items;
                $t = Bridge.getEnumerator(this.transformConstraintIndices);
                try {
                    while ($t.moveNext()) {
                        var constraintIndex = $t.Current;
                        var constraint = transformConstraintsItems[constraintIndex];
                        // apply the constraint and sets Bone.ax, Bone.ay and Bone.arotation values.
                        constraint.Update(Spine.Skeleton.Physics.None);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.ApplyTransformConstraints end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetScaleAffectingRootMotion start.*/
            GetScaleAffectingRootMotion: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetScaleAffectingRootMotion", this ); }

                var parentBoneScale = { v : new UnityEngine.Vector2() };
                return this.GetScaleAffectingRootMotion$1(parentBoneScale);
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetScaleAffectingRootMotion end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetScaleAffectingRootMotion$1 start.*/
            GetScaleAffectingRootMotion$1: function (parentBoneScale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetScaleAffectingRootMotion$1", this ); }

                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                var totalScale = pc.Vec2.ONE.clone();
                totalScale.x *= skeleton.ScaleX;
                totalScale.y *= skeleton.ScaleY;

                parentBoneScale.v = pc.Vec2.ONE.clone();
                var scaleBone = this.rootMotionBone;
                while (((scaleBone = scaleBone.Parent)) != null) {
                    parentBoneScale.v.x *= scaleBone.AScaleX;
                    parentBoneScale.v.y *= scaleBone.AScaleY;
                }
                totalScale = new pc.Vec2( totalScale.x * parentBoneScale.v.x, totalScale.y * parentBoneScale.v.y );
                totalScale = totalScale.$clone().scale( this.AdditionalScale );
                return totalScale.$clone();
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetScaleAffectingRootMotion$1 end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetSkeletonSpaceMovementDelta start.*/
            GetSkeletonSpaceMovementDelta: function (boneLocalDelta, parentBoneScale, totalScale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetSkeletonSpaceMovementDelta", this ); }

                var skeletonDelta = boneLocalDelta.$clone();
                totalScale.v = this.GetScaleAffectingRootMotion$1(parentBoneScale);
                skeletonDelta.mul( totalScale.v );

                var rootMotionTranslation = new pc.Vec2( this.rootMotionTranslateXPerY * skeletonDelta.y, this.rootMotionTranslateYPerX * skeletonDelta.x );

                skeletonDelta.x *= this.rootMotionScaleX;
                skeletonDelta.y *= this.rootMotionScaleY;
                skeletonDelta.x += rootMotionTranslation.x;
                skeletonDelta.y += rootMotionTranslation.y;

                if (!this.transformPositionX) {
                    skeletonDelta.x = 0.0;
                }
                if (!this.transformPositionY) {
                    skeletonDelta.y = 0.0;
                }
                return skeletonDelta.$clone();
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetSkeletonSpaceMovementDelta end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetSkeletonSpaceRotationDelta start.*/
            GetSkeletonSpaceRotationDelta: function (boneLocalDelta, totalScaleAffectingRootMotion) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetSkeletonSpaceRotationDelta", this ); }

                var rotationSign = totalScaleAffectingRootMotion.x * totalScaleAffectingRootMotion.y > 0 ? 1 : -1;
                return rotationSign * boneLocalDelta;
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetSkeletonSpaceRotationDelta end.*/

            /*Spine.Unity.SkeletonRootMotionBase.SetEffectiveBoneOffsetsTo start.*/
            SetEffectiveBoneOffsetsTo: function (displacementSkeletonSpace, rotationSkeletonSpace, parentBoneScale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#SetEffectiveBoneOffsetsTo", this ); }

                var $t;

                this.ApplyTransformConstraints();

                // Move top level bones in opposite direction of the root motion bone
                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                $t = Bridge.getEnumerator(this.topLevelBones);
                try {
                    while ($t.moveNext()) {
                        var topLevelBone = $t.Current;
                        if (Bridge.referenceEquals(topLevelBone, this.rootMotionBone)) {
                            if (this.transformPositionX) {
                                topLevelBone.X = displacementSkeletonSpace.x / skeleton.ScaleX;
                            }
                            if (this.transformPositionY) {
                                topLevelBone.Y = displacementSkeletonSpace.y / skeleton.ScaleY;
                            }
                            if (this.transformRotation) {
                                var rotationSign = skeleton.ScaleX * skeleton.ScaleY > 0 ? 1 : -1;
                                topLevelBone.Rotation = rotationSign * rotationSkeletonSpace;
                            }
                        } else {
                            var useAppliedTransform = this.transformConstraintIndices.Count > 0;
                            var rootMotionBoneX = useAppliedTransform ? this.rootMotionBone.AX : this.rootMotionBone.X;
                            var rootMotionBoneY = useAppliedTransform ? this.rootMotionBone.AY : this.rootMotionBone.Y;

                            var offsetX = (this.initialOffset.x - rootMotionBoneX) * parentBoneScale.x;
                            var offsetY = (this.initialOffset.y - rootMotionBoneY) * parentBoneScale.y;

                            if (this.transformPositionX) {
                                topLevelBone.X = (displacementSkeletonSpace.x / skeleton.ScaleX) + offsetX;
                            }
                            if (this.transformPositionY) {
                                topLevelBone.Y = (displacementSkeletonSpace.y / skeleton.ScaleY) + offsetY;
                            }

                            if (this.transformRotation) {
                                var rootMotionBoneRotation = useAppliedTransform ? this.rootMotionBone.AppliedRotation : this.rootMotionBone.Rotation;

                                var parentBoneRotationSign = (parentBoneScale.x * parentBoneScale.y > 0 ? 1 : -1);
                                var offsetRotation = (this.initialOffsetRotation - rootMotionBoneRotation) * parentBoneRotationSign;

                                var skeletonRotationSign = skeleton.ScaleX * skeleton.ScaleY > 0 ? 1 : -1;
                                topLevelBone.Rotation = (rotationSkeletonSpace * skeletonRotationSign) + offsetRotation;
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.SetEffectiveBoneOffsetsTo end.*/

            /*Spine.Unity.SkeletonRootMotionBase.ClearEffectiveBoneOffsets start.*/
            ClearEffectiveBoneOffsets: function (parentBoneScale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#ClearEffectiveBoneOffsets", this ); }

                this.SetEffectiveBoneOffsetsTo(pc.Vec2.ZERO.clone(), 0, parentBoneScale);
            },
            /*Spine.Unity.SkeletonRootMotionBase.ClearEffectiveBoneOffsets end.*/

            /*Spine.Unity.SkeletonRootMotionBase.ClearRigidbodyTempMovement start.*/
            ClearRigidbodyTempMovement: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#ClearRigidbodyTempMovement", this ); }

                this.rigidbodyDisplacement = UnityEngine.Vector3.FromVector2(pc.Vec2.ZERO.clone());
                this.tempSkeletonDisplacement = pc.Vec2.ZERO.clone();
                this.rigidbodyLocalRotation = pc.Quat.IDENTITY.clone();
                this.rigidbody2DRotation = 0;
                this.tempSkeletonRotation = 0;
            },
            /*Spine.Unity.SkeletonRootMotionBase.ClearRigidbodyTempMovement end.*/


        },
        overloads: {
            "GetAnimationRootMotion(float, float, Animation)": "GetAnimationRootMotion$1",
            "GetAnimationRootMotionRotation(float, float, Animation)": "GetAnimationRootMotionRotation$1",
            "GetScaleAffectingRootMotion(Vector2)": "GetScaleAffectingRootMotion$1"
        }
    });
    /*Spine.Unity.SkeletonRootMotionBase end.*/
    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.SkeletonPartsRenderer.SkeletonPartsRendererDelegate
     * @param   {Spine.Unity.SkeletonPartsRenderer}    skeletonPartsRenderer
     * @return  {void}
     */


    /*Spine.Unity.SkeletonPartsRenderer start.*/
    Bridge.define("Spine.Unity.SkeletonPartsRenderer", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            methods: {
                /*Spine.Unity.SkeletonPartsRenderer.NewPartsRendererGameObject:static start.*/
                NewPartsRendererGameObject: function (parent, name, sortingOrder) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#NewPartsRendererGameObject", this ); }

                    if (sortingOrder === void 0) { sortingOrder = 0; }
                    var go = new UnityEngine.GameObject.$ctor4(name, [UnityEngine.MeshFilter, UnityEngine.MeshRenderer]);
                    go.transform.SetParent(parent, false);
                    var returnComponent = go.AddComponent(Spine.Unity.SkeletonPartsRenderer);
                    returnComponent.MeshRenderer.sortingOrder = sortingOrder;

                    return returnComponent;
                },
                /*Spine.Unity.SkeletonPartsRenderer.NewPartsRendererGameObject:static end.*/


            }
        },
        fields: {
            meshGenerator: null,
            meshRenderer: null,
            meshFilter: null,
            buffers: null,
            currentInstructions: null
        },
        events: {
            /**
             * OnMeshAndMaterialsUpdated is called at the end of LateUpdate after the Mesh and
             all materials have been updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonPartsRenderer
             * @memberof Spine.Unity.SkeletonPartsRenderer
             * @function addOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonPartsRenderer.SkeletonPartsRendererDelegate}    value
             * @return  {void}
             */
            /**
             * OnMeshAndMaterialsUpdated is called at the end of LateUpdate after the Mesh and
             all materials have been updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonPartsRenderer
             * @memberof Spine.Unity.SkeletonPartsRenderer
             * @function removeOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonPartsRenderer.SkeletonPartsRendererDelegate}    value
             * @return  {void}
             */
            OnMeshAndMaterialsUpdated: null
        },
        props: {
            MeshGenerator: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#MeshGenerator#get", this ); }

                    this.LazyIntialize();
                    return this.meshGenerator;
                }
            },
            MeshRenderer: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#MeshRenderer#get", this ); }

                    this.LazyIntialize();
                    return this.meshRenderer;
                }
            },
            MeshFilter: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#MeshFilter#get", this ); }

                    this.LazyIntialize();
                    return this.meshFilter;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#init", this ); }

                this.currentInstructions = new Spine.Unity.SkeletonRendererInstruction();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonPartsRenderer.LazyIntialize start.*/
            LazyIntialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#LazyIntialize", this ); }

                if (this.buffers == null) {
                    this.buffers = new Spine.Unity.MeshRendererBuffers();
                    this.buffers.Initialize();

                    if (this.meshGenerator != null) {
                        return;
                    }
                    this.meshGenerator = new Spine.Unity.MeshGenerator();
                    this.meshFilter = this.GetComponent(UnityEngine.MeshFilter);
                    this.meshRenderer = this.GetComponent(UnityEngine.MeshRenderer);
                    this.currentInstructions.Clear();
                }
            },
            /*Spine.Unity.SkeletonPartsRenderer.LazyIntialize end.*/

            /*Spine.Unity.SkeletonPartsRenderer.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#OnDestroy", this ); }

                if (this.buffers != null) {
                    this.buffers.Dispose();
                }
            },
            /*Spine.Unity.SkeletonPartsRenderer.OnDestroy end.*/

            /*Spine.Unity.SkeletonPartsRenderer.ClearMesh start.*/
            ClearMesh: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#ClearMesh", this ); }

                this.LazyIntialize();
                this.meshFilter.sharedMesh = null;
            },
            /*Spine.Unity.SkeletonPartsRenderer.ClearMesh end.*/

            /*Spine.Unity.SkeletonPartsRenderer.RenderParts start.*/
            RenderParts: function (instructions, startSubmesh, endSubmesh) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#RenderParts", this ); }

                this.LazyIntialize();

                // STEP 1: Create instruction
                var smartMesh = this.buffers.GetNextMesh();
                this.currentInstructions.SetWithSubset(instructions, startSubmesh, endSubmesh);
                var updateTriangles = Spine.Unity.SkeletonRendererInstruction.GeometryNotEqual(this.currentInstructions, smartMesh.instructionUsed);

                // STEP 2: Generate mesh buffers.
                var currentInstructionsSubmeshesItems = this.currentInstructions.submeshInstructions.Items;
                this.meshGenerator.Begin();
                if (this.currentInstructions.hasActiveClipping) {
                    for (var i = 0; i < this.currentInstructions.submeshInstructions.Count; i = (i + 1) | 0) {
                        this.meshGenerator.AddSubmesh(currentInstructionsSubmeshesItems[i], updateTriangles);
                    }
                } else {
                    this.meshGenerator.BuildMeshWithArrays(this.currentInstructions, updateTriangles);
                }

                this.buffers.UpdateSharedMaterials(this.currentInstructions.submeshInstructions);

                // STEP 3: modify mesh.
                var mesh = smartMesh.mesh;

                if (this.meshGenerator.VertexCount <= 0) { // Clear an empty mesh
                    updateTriangles = false;
                    mesh.Clear();
                } else {
                    this.meshGenerator.FillVertexData(mesh);
                    if (updateTriangles) {
                        this.meshGenerator.FillTriangles(mesh);
                        this.meshRenderer.sharedMaterials = this.buffers.GetUpdatedSharedMaterialsArray();
                    } else if (this.buffers.MaterialsChangedInLastUpdate()) {
                        this.meshRenderer.sharedMaterials = this.buffers.GetUpdatedSharedMaterialsArray();
                    }
                    this.meshGenerator.FillLateVertexData(mesh);
                }

                this.meshFilter.sharedMesh = mesh;
                smartMesh.instructionUsed.Set(this.currentInstructions);

                if (!Bridge.staticEquals(this.OnMeshAndMaterialsUpdated, null)) {
                    this.OnMeshAndMaterialsUpdated(this);
                }
            },
            /*Spine.Unity.SkeletonPartsRenderer.RenderParts end.*/

            /*Spine.Unity.SkeletonPartsRenderer.SetPropertyBlock start.*/
            SetPropertyBlock: function (block) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#SetPropertyBlock", this ); }

                this.LazyIntialize();
                this.meshRenderer.SetPropertyBlock(block);
            },
            /*Spine.Unity.SkeletonPartsRenderer.SetPropertyBlock end.*/


        }
    });
    /*Spine.Unity.SkeletonPartsRenderer end.*/

    /*Spine.Unity.SkeletonRenderer+SpriteMaskInteractionMaterials start.*/
    Bridge.define("Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials", {
        $kind: 1002,
        fields: {
            /**
             * Material references for switching material sets at runtime when {@link } changes to {@link }.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials
             * @type Array.<UnityEngine.Material>
             */
            materialsMaskDisabled: null,
            /**
             * Material references for switching material sets at runtime when {@link } changes to {@link }.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials
             * @type Array.<UnityEngine.Material>
             */
            materialsInsideMask: null,
            /**
             * Material references for switching material sets at runtime when {@link } changes to {@link }.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials
             * @type Array.<UnityEngine.Material>
             */
            materialsOutsideMask: null
        },
        props: {
            AnyMaterialCreated: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials#AnyMaterialCreated#get", this ); }

                    return this.materialsMaskDisabled.length > 0 || this.materialsInsideMask.length > 0 || this.materialsOutsideMask.length > 0;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials#init", this ); }

                this.materialsMaskDisabled = System.Array.init(0, null, UnityEngine.Material);
                this.materialsInsideMask = System.Array.init(0, null, UnityEngine.Material);
                this.materialsOutsideMask = System.Array.init(0, null, UnityEngine.Material);
            }
        }
    });
    /*Spine.Unity.SkeletonRenderer+SpriteMaskInteractionMaterials end.*/

    /*Spine.Unity.SkeletonRendererCustomMaterials start.*/
    Bridge.define("Spine.Unity.SkeletonRendererCustomMaterials", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonRenderer: null,
            customSlotMaterials: null,
            customMaterialOverrides: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials#init", this ); }

                this.customSlotMaterials = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride)).ctor();
                this.customMaterialOverrides = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRendererCustomMaterials.SetCustomSlotMaterials start.*/
            SetCustomSlotMaterials: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials#SetCustomSlotMaterials", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    UnityEngine.Debug.LogError$2("skeletonRenderer == null");
                    return;
                }

                for (var i = 0; i < this.customSlotMaterials.Count; i = (i + 1) | 0) {
                    var slotMaterialOverride = this.customSlotMaterials.getItem(i).$clone();
                    if (slotMaterialOverride.overrideDisabled || System.String.isNullOrEmpty(slotMaterialOverride.slotName)) {
                        continue;
                    }

                    var slotObject = this.skeletonRenderer.skeleton.FindSlot(slotMaterialOverride.slotName);
                    if (slotObject != null) {
                        this.skeletonRenderer.CustomSlotMaterials.setItem(slotObject, slotMaterialOverride.material);
                    }
                }
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials.SetCustomSlotMaterials end.*/

            /*Spine.Unity.SkeletonRendererCustomMaterials.RemoveCustomSlotMaterials start.*/
            RemoveCustomSlotMaterials: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials#RemoveCustomSlotMaterials", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    UnityEngine.Debug.LogError$2("skeletonRenderer == null");
                    return;
                }

                for (var i = 0; i < this.customSlotMaterials.Count; i = (i + 1) | 0) {
                    var slotMaterialOverride = this.customSlotMaterials.getItem(i).$clone();
                    if (System.String.isNullOrEmpty(slotMaterialOverride.slotName)) {
                        continue;
                    }

                    var slotObject = this.skeletonRenderer.skeleton.FindSlot(slotMaterialOverride.slotName);
                    if (slotObject == null) {
                        continue;
                    }
                    var currentMaterial = { };
                    if (!this.skeletonRenderer.CustomSlotMaterials.tryGetValue(slotObject, currentMaterial)) {
                        continue;
                    }

                    // Do not revert the material if it was changed by something else
                    if (!Bridge.referenceEquals(currentMaterial.v, slotMaterialOverride.material)) {
                        continue;
                    }

                    this.skeletonRenderer.CustomSlotMaterials.remove(slotObject);
                }
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials.RemoveCustomSlotMaterials end.*/

            /*Spine.Unity.SkeletonRendererCustomMaterials.SetCustomMaterialOverrides start.*/
            SetCustomMaterialOverrides: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials#SetCustomMaterialOverrides", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    UnityEngine.Debug.LogError$2("skeletonRenderer == null");
                    return;
                }

                for (var i = 0; i < this.customMaterialOverrides.Count; i = (i + 1) | 0) {
                    var atlasMaterialOverride = this.customMaterialOverrides.getItem(i).$clone();
                    if (atlasMaterialOverride.overrideDisabled) {
                        continue;
                    }

                    this.skeletonRenderer.CustomMaterialOverride.setItem(atlasMaterialOverride.originalMaterial, atlasMaterialOverride.replacementMaterial);
                }
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials.SetCustomMaterialOverrides end.*/

            /*Spine.Unity.SkeletonRendererCustomMaterials.RemoveCustomMaterialOverrides start.*/
            RemoveCustomMaterialOverrides: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials#RemoveCustomMaterialOverrides", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    UnityEngine.Debug.LogError$2("skeletonRenderer == null");
                    return;
                }

                for (var i = 0; i < this.customMaterialOverrides.Count; i = (i + 1) | 0) {
                    var atlasMaterialOverride = this.customMaterialOverrides.getItem(i).$clone();
                    var currentMaterial = { };

                    if (!this.skeletonRenderer.CustomMaterialOverride.tryGetValue(atlasMaterialOverride.originalMaterial, currentMaterial)) {
                        continue;
                    }

                    // Do not revert the material if it was changed by something else
                    if (!Bridge.referenceEquals(currentMaterial.v, atlasMaterialOverride.replacementMaterial)) {
                        continue;
                    }

                    this.skeletonRenderer.CustomMaterialOverride.remove(atlasMaterialOverride.originalMaterial);
                }
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials.RemoveCustomMaterialOverrides end.*/

            /*Spine.Unity.SkeletonRendererCustomMaterials.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials#OnEnable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer = this.GetComponent(Spine.Unity.SkeletonRenderer);
                }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    UnityEngine.Debug.LogError$2("skeletonRenderer == null");
                    return;
                }

                this.skeletonRenderer.Initialize(false);
                this.SetCustomMaterialOverrides();
                this.SetCustomSlotMaterials();
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials.OnEnable end.*/

            /*Spine.Unity.SkeletonRendererCustomMaterials.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials#OnDisable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    UnityEngine.Debug.LogError$2("skeletonRenderer == null");
                    return;
                }

                this.RemoveCustomMaterialOverrides();
                this.RemoveCustomSlotMaterials();
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials.OnDisable end.*/


        }
    });
    /*Spine.Unity.SkeletonRendererCustomMaterials end.*/

    /*Spine.Unity.SkeletonRendererCustomMaterials+AtlasMaterialOverride start.*/
    Bridge.define("Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride", {
        inherits: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#inherits", this ); }
 return [System.IEquatable$1(Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride)]; },
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#getDefaultValue", this ); }
 return new Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride(); }
            }
        },
        fields: {
            overrideDisabled: false,
            originalMaterial: null,
            replacementMaterial: null
        },
        alias: ["equalsT", "System$IEquatable$1$Spine$Unity$SkeletonRendererCustomMaterials$AtlasMaterialOverride$equalsT"],
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRendererCustomMaterials+AtlasMaterialOverride.equalsT start.*/
            equalsT: function (other) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#equalsT", this ); }

                return this.overrideDisabled === other.overrideDisabled && Bridge.referenceEquals(this.originalMaterial, other.originalMaterial) && Bridge.referenceEquals(this.replacementMaterial, other.replacementMaterial);
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials+AtlasMaterialOverride.equalsT end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#getHashCode", this ); }

                var h = Bridge.addHash([8608216668, this.overrideDisabled, this.originalMaterial, this.replacementMaterial]);
                return h;
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#$clone", this ); }

                var s = to || new Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride();
                s.overrideDisabled = this.overrideDisabled;
                s.originalMaterial = this.originalMaterial;
                s.replacementMaterial = this.replacementMaterial;
                return s;
            }
        },
        overloads: {
            "Equals(AtlasMaterialOverride)": "equalsT"
        }
    });
    /*Spine.Unity.SkeletonRendererCustomMaterials+AtlasMaterialOverride end.*/

    /*Spine.Unity.SkeletonRendererCustomMaterials+SlotMaterialOverride start.*/
    Bridge.define("Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride", {
        inherits: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#inherits", this ); }
 return [System.IEquatable$1(Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride)]; },
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#getDefaultValue", this ); }
 return new Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride(); }
            }
        },
        fields: {
            overrideDisabled: false,
            slotName: null,
            material: null
        },
        alias: ["equalsT", "System$IEquatable$1$Spine$Unity$SkeletonRendererCustomMaterials$SlotMaterialOverride$equalsT"],
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRendererCustomMaterials+SlotMaterialOverride.equalsT start.*/
            equalsT: function (other) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#equalsT", this ); }

                return this.overrideDisabled === other.overrideDisabled && Bridge.referenceEquals(this.slotName, other.slotName) && Bridge.referenceEquals(this.material, other.material);
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials+SlotMaterialOverride.equalsT end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#getHashCode", this ); }

                var h = Bridge.addHash([9094239955, this.overrideDisabled, this.slotName, this.material]);
                return h;
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#$clone", this ); }

                var s = to || new Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride();
                s.overrideDisabled = this.overrideDisabled;
                s.slotName = this.slotName;
                s.material = this.material;
                return s;
            }
        },
        overloads: {
            "Equals(SlotMaterialOverride)": "equalsT"
        }
    });
    /*Spine.Unity.SkeletonRendererCustomMaterials+SlotMaterialOverride end.*/

    /*Spine.Unity.SkeletonRendererInstruction start.*/
    /**
     * Instructions used by a SkeletonRenderer to render a mesh.
     *
     * @public
     * @class Spine.Unity.SkeletonRendererInstruction
     */
    Bridge.define("Spine.Unity.SkeletonRendererInstruction", {
        statics: {
            methods: {
                /*Spine.Unity.SkeletonRendererInstruction.GeometryNotEqual:static start.*/
                GeometryNotEqual: function (a, b) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererInstruction#GeometryNotEqual", this ); }


                    if (a.hasActiveClipping || b.hasActiveClipping) {
                        return true;
                    } // Triangles are unpredictable when clipping is active.

                    // Everything below assumes the raw vertex and triangle counts were used. (ie, no clipping was done)
                    if (a.rawVertexCount !== b.rawVertexCount) {
                        return true;
                    }

                    if (a.immutableTriangles !== b.immutableTriangles) {
                        return true;
                    }

                    var attachmentCountB = b.attachments.Count;
                    if (a.attachments.Count !== attachmentCountB) {
                        return true;
                    } // Bounds check for the looped storedAttachments count below.

                    // Submesh count changed
                    var submeshCountA = a.submeshInstructions.Count;
                    var submeshCountB = b.submeshInstructions.Count;
                    if (submeshCountA !== submeshCountB) {
                        return true;
                    }

                    // Submesh Instruction mismatch
                    var submeshInstructionsItemsA = a.submeshInstructions.Items;
                    var submeshInstructionsItemsB = b.submeshInstructions.Items;

                    var attachmentsA = a.attachments.Items;
                    var attachmentsB = b.attachments.Items;
                    for (var i = 0; i < attachmentCountB; i = (i + 1) | 0) {
                        if (!Bridge.referenceEquals(attachmentsA[i], attachmentsB[i])) {
                            return true;
                        }
                    }

                    for (var i1 = 0; i1 < submeshCountB; i1 = (i1 + 1) | 0) {
                        var submeshA = submeshInstructionsItemsA[i1].$clone();
                        var submeshB = submeshInstructionsItemsB[i1].$clone();

                        if (!(submeshA.rawVertexCount === submeshB.rawVertexCount && submeshA.startSlot === submeshB.startSlot && submeshA.endSlot === submeshB.endSlot && submeshA.rawTriangleCount === submeshB.rawTriangleCount && submeshA.rawFirstVertexIndex === submeshB.rawFirstVertexIndex)) {
                            return true;
                        }
                    }

                    return false;
                },
                /*Spine.Unity.SkeletonRendererInstruction.GeometryNotEqual:static end.*/


            }
        },
        fields: {
            submeshInstructions: null,
            immutableTriangles: false,
            hasActiveClipping: false,
            rawVertexCount: 0,
            attachments: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererInstruction#init", this ); }

                this.submeshInstructions = new (Spine.ExposedList$1(Spine.Unity.SubmeshInstruction)).ctor();
                this.rawVertexCount = -1;
                this.attachments = new (Spine.ExposedList$1(Spine.Attachment)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRendererInstruction.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererInstruction#Clear", this ); }

                this.attachments.Clear(false);
                this.rawVertexCount = -1;
                this.hasActiveClipping = false;
                this.submeshInstructions.Clear(false);
            },
            /*Spine.Unity.SkeletonRendererInstruction.Clear end.*/

            /*Spine.Unity.SkeletonRendererInstruction.Dispose start.*/
            Dispose: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererInstruction#Dispose", this ); }

                this.attachments.Clear(true);
            },
            /*Spine.Unity.SkeletonRendererInstruction.Dispose end.*/

            /*Spine.Unity.SkeletonRendererInstruction.SetWithSubset start.*/
            SetWithSubset: function (instructions, startSubmesh, endSubmesh) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererInstruction#SetWithSubset", this ); }

                var runningVertexCount = 0;

                var submeshes = this.submeshInstructions;
                submeshes.Clear(false);
                var submeshCount = (endSubmesh - startSubmesh) | 0;
                submeshes.Resize(submeshCount);
                var submeshesItems = submeshes.Items;
                var instructionsItems = instructions.Items;
                for (var i = 0; i < submeshCount; i = (i + 1) | 0) {
                    var instruction = instructionsItems[((startSubmesh + i) | 0)].$clone();
                    submeshesItems[i] = instruction.$clone();
                    this.hasActiveClipping = !!(this.hasActiveClipping | instruction.hasClipping);
                    submeshesItems[i].rawFirstVertexIndex = runningVertexCount; // Ensure current instructions have correct cached values.
                    runningVertexCount = (runningVertexCount + instruction.rawVertexCount) | 0; // vertexCount will also be used for the rest of this method.
                }
                this.rawVertexCount = runningVertexCount;

                // assumption: instructions are contiguous. start and end are valid within instructions.

                var startSlot = instructionsItems[startSubmesh].startSlot;
                var endSlot = instructionsItems[((endSubmesh - 1) | 0)].endSlot;
                this.attachments.Clear(false);
                var attachmentCount = (endSlot - startSlot) | 0;
                this.attachments.Resize(attachmentCount);
                var attachmentsItems = this.attachments.Items;

                var drawOrderItems = instructionsItems[0].skeleton.DrawOrder.Items;
                for (var i1 = 0; i1 < attachmentCount; i1 = (i1 + 1) | 0) {
                    var slot = drawOrderItems[((startSlot + i1) | 0)];
                    if (!slot.Bone.Active || slot.A === 0.0) {
                        attachmentsItems[i1] = null;
                        continue;
                    }
                    attachmentsItems[i1] = slot.Attachment;
                }

            },
            /*Spine.Unity.SkeletonRendererInstruction.SetWithSubset end.*/

            /*Spine.Unity.SkeletonRendererInstruction.Set start.*/
            Set: function (other) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererInstruction#Set", this ); }

                this.immutableTriangles = other.immutableTriangles;

                this.hasActiveClipping = other.hasActiveClipping;
                this.rawVertexCount = other.rawVertexCount;
                this.attachments.Clear(false);
                this.attachments.EnsureCapacity(other.attachments.Capacity);
                this.attachments.Count = other.attachments.Count;
                other.attachments.CopyTo(this.attachments.Items);

                this.submeshInstructions.Clear(false);
                this.submeshInstructions.EnsureCapacity(other.submeshInstructions.Capacity);
                this.submeshInstructions.Count = other.submeshInstructions.Count;
                other.submeshInstructions.CopyTo(this.submeshInstructions.Items);
            },
            /*Spine.Unity.SkeletonRendererInstruction.Set end.*/


        }
    });
    /*Spine.Unity.SkeletonRendererInstruction end.*/
    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.SkeletonRenderer.SkeletonRendererDelegate
     * @param   {Spine.Unity.SkeletonRenderer}    skeletonRenderer
     * @return  {void}
     */


    /*Spine.Unity.SkeletonRenderSeparator start.*/
    Bridge.define("Spine.Unity.SkeletonRenderSeparator", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                DefaultSortingOrderIncrement: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#init", this ); }

                    this.DefaultSortingOrderIncrement = 5;
                }
            },
            methods: {
                /*Spine.Unity.SkeletonRenderSeparator.AddToSkeletonRenderer:static start.*/
                /**
                 * Adds a SkeletonRenderSeparator and child SkeletonPartsRenderer GameObjects to a given SkeletonRenderer.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonRenderSeparator
                 * @memberof Spine.Unity.SkeletonRenderSeparator
                 * @param   {Spine.Unity.SkeletonRenderer}           skeletonRenderer            The target SkeletonRenderer or SkeletonAnimation.
                 * @param   {number}                                 sortingLayerID              Sorting layer to be used for the parts renderers.
                 * @param   {number}                                 extraPartsRenderers         Number of additional SkeletonPartsRenderers on top of the ones determined by counting the number of separator slots.
                 * @param   {number}                                 sortingOrderIncrement       The integer to increment the sorting order per SkeletonPartsRenderer to separate them.
                 * @param   {number}                                 baseSortingOrder            The sorting order value of the first SkeletonPartsRenderer.
                 * @param   {boolean}                                addMinimumPartsRenderers    If set to <pre><code>true</code></pre>, a minimum number of SkeletonPartsRenderer GameObjects (determined by separatorSlots.Count + 1) will be added.
                 * @return  {Spine.Unity.SkeletonRenderSeparator}                                The to skeleton renderer.
                 */
                AddToSkeletonRenderer: function (skeletonRenderer, sortingLayerID, extraPartsRenderers, sortingOrderIncrement, baseSortingOrder, addMinimumPartsRenderers) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#AddToSkeletonRenderer", this ); }

                    if (sortingLayerID === void 0) { sortingLayerID = 0; }
                    if (extraPartsRenderers === void 0) { extraPartsRenderers = 0; }
                    if (sortingOrderIncrement === void 0) { sortingOrderIncrement = 5; }
                    if (baseSortingOrder === void 0) { baseSortingOrder = 0; }
                    if (addMinimumPartsRenderers === void 0) { addMinimumPartsRenderers = true; }
                    if (UnityEngine.MonoBehaviour.op_Equality(skeletonRenderer, null)) {
                        UnityEngine.Debug.Log$1("Tried to add SkeletonRenderSeparator to a null SkeletonRenderer reference.");
                        return null;
                    }

                    var srs = skeletonRenderer.gameObject.AddComponent(Spine.Unity.SkeletonRenderSeparator);
                    srs.skeletonRenderer = skeletonRenderer;

                    skeletonRenderer.Initialize(false);
                    var count = extraPartsRenderers;
                    if (addMinimumPartsRenderers) {
                        count = (((extraPartsRenderers + skeletonRenderer.separatorSlots.Count) | 0) + 1) | 0;
                    }

                    var skeletonRendererTransform = skeletonRenderer.transform;
                    var componentRenderers = srs.partsRenderers;

                    for (var i = 0; i < count; i = (i + 1) | 0) {
                        var spr = Spine.Unity.SkeletonPartsRenderer.NewPartsRendererGameObject(skeletonRendererTransform, Bridge.toString(i));
                        var mr = spr.MeshRenderer;
                        mr.sortingLayerID = sortingLayerID;
                        mr.sortingOrder = (baseSortingOrder + (Bridge.Int.mul(i, sortingOrderIncrement))) | 0;
                        componentRenderers.add(spr);
                    }

                    srs.OnEnable();


                    return srs;
                },
                /*Spine.Unity.SkeletonRenderSeparator.AddToSkeletonRenderer:static end.*/


            }
        },
        fields: {
            skeletonRenderer: null,
            mainMeshRenderer: null,
            copyPropertyBlock: false,
            copyMeshRendererFlags: false,
            partsRenderers: null,
            isVisible: false,
            copiedBlock: null
        },
        events: {
            /**
             * OnMeshAndMaterialsUpdated is called at the end of LateUpdate after the Mesh and
             all materials have been updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderSeparator
             * @memberof Spine.Unity.SkeletonRenderSeparator
             * @function addOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonRenderer.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            /**
             * OnMeshAndMaterialsUpdated is called at the end of LateUpdate after the Mesh and
             all materials have been updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderSeparator
             * @memberof Spine.Unity.SkeletonRenderSeparator
             * @function removeOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonRenderer.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            OnMeshAndMaterialsUpdated: null
        },
        props: {
            SkeletonRenderer: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#SkeletonRenderer#get", this ); }

                    return this.skeletonRenderer;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#SkeletonRenderer#set", this ); }

                    if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                        this.skeletonRenderer.removeGenerateMeshOverride(Bridge.fn.cacheBind(this, this.HandleRender));
                    }

                    this.skeletonRenderer = value;
                    if (UnityEngine.MonoBehaviour.op_Equality(value, null)) {
                        this.enabled = false;
                    }
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#init", this ); }

                this.copyPropertyBlock = true;
                this.copyMeshRendererFlags = true;
                this.partsRenderers = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonPartsRenderer)).ctor();
                this.isVisible = true;
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRenderSeparator.AddPartsRenderer start.*/
            /**
             * Add a child SkeletonPartsRenderer GameObject to this SkeletonRenderSeparator.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderSeparator
             * @memberof Spine.Unity.SkeletonRenderSeparator
             * @param   {number}                               sortingOrderIncrement    
             * @param   {string}                               name
             * @return  {Spine.Unity.SkeletonPartsRenderer}
             */
            AddPartsRenderer: function (sortingOrderIncrement, name) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#AddPartsRenderer", this ); }

                if (sortingOrderIncrement === void 0) { sortingOrderIncrement = 5; }
                if (name === void 0) { name = null; }
                var sortingLayerID = 0;
                var sortingOrder = 0;
                if (this.partsRenderers.Count > 0) {
                    var previous = this.partsRenderers.getItem(((this.partsRenderers.Count - 1) | 0));
                    var previousMeshRenderer = previous.MeshRenderer;
                    sortingLayerID = previousMeshRenderer.sortingLayerID;
                    sortingOrder = (previousMeshRenderer.sortingOrder + sortingOrderIncrement) | 0;
                }

                if (System.String.isNullOrEmpty(name)) {
                    name = Bridge.toString(this.partsRenderers.Count);
                }

                var spr = Spine.Unity.SkeletonPartsRenderer.NewPartsRendererGameObject(this.skeletonRenderer.transform, name);
                this.partsRenderers.add(spr);

                var mr = spr.MeshRenderer;
                mr.sortingLayerID = sortingLayerID;
                mr.sortingOrder = sortingOrder;

                return spr;
            },
            /*Spine.Unity.SkeletonRenderSeparator.AddPartsRenderer end.*/

            /*Spine.Unity.SkeletonRenderSeparator.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#OnEnable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    return;
                }
                if (this.copiedBlock == null) {
                    this.copiedBlock = new UnityEngine.MaterialPropertyBlock();
                }
                this.mainMeshRenderer = this.skeletonRenderer.GetComponent(UnityEngine.MeshRenderer);

                this.skeletonRenderer.removeGenerateMeshOverride(Bridge.fn.cacheBind(this, this.HandleRender));
                this.skeletonRenderer.addGenerateMeshOverride(Bridge.fn.cacheBind(this, this.HandleRender));

                if (this.copyMeshRendererFlags) {
                    var lightProbeUsage = this.mainMeshRenderer.lightProbeUsage;
                    var receiveShadows = this.mainMeshRenderer.receiveShadows;
                    var reflectionProbeUsage = this.mainMeshRenderer.reflectionProbeUsage;
                    var shadowCastingMode = this.mainMeshRenderer.shadowCastingMode;
                    var motionVectorGenerationMode = this.mainMeshRenderer.motionVectorGenerationMode;
                    var probeAnchor = this.mainMeshRenderer.probeAnchor;

                    for (var i = 0; i < this.partsRenderers.Count; i = (i + 1) | 0) {
                        var currentRenderer = this.partsRenderers.getItem(i);
                        if (UnityEngine.MonoBehaviour.op_Equality(currentRenderer, null)) {
                            continue;
                        } // skip null items.

                        var mr = currentRenderer.MeshRenderer;
                        mr.lightProbeUsage = lightProbeUsage;
                        mr.receiveShadows = receiveShadows;
                        mr.reflectionProbeUsage = reflectionProbeUsage;
                        mr.shadowCastingMode = shadowCastingMode;
                        mr.motionVectorGenerationMode = motionVectorGenerationMode;
                        mr.probeAnchor = probeAnchor;
                    }
                }

                if (this.skeletonRenderer.updateWhenInvisible !== Spine.Unity.UpdateMode.FullUpdate) {
                    this.skeletonRenderer.LateUpdateMesh();
                }
            },
            /*Spine.Unity.SkeletonRenderSeparator.OnEnable end.*/

            /*Spine.Unity.SkeletonRenderSeparator.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#Update", this ); }

                this.UpdateVisibility();
            },
            /*Spine.Unity.SkeletonRenderSeparator.Update end.*/

            /*Spine.Unity.SkeletonRenderSeparator.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#OnDisable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    return;
                }
                this.skeletonRenderer.removeGenerateMeshOverride(Bridge.fn.cacheBind(this, this.HandleRender));
                this.skeletonRenderer.LateUpdateMesh();
                this.ClearPartsRendererMeshes();
            },
            /*Spine.Unity.SkeletonRenderSeparator.OnDisable end.*/

            /*Spine.Unity.SkeletonRenderSeparator.UpdateVisibility start.*/
            UpdateVisibility: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#UpdateVisibility", this ); }

                var $t;
                $t = Bridge.getEnumerator(this.partsRenderers);
                try {
                    while ($t.moveNext()) {
                        var partsRenderer = $t.Current;
                        if (UnityEngine.MonoBehaviour.op_Equality(partsRenderer, null)) {
                            continue;
                        }

                        if (partsRenderer.MeshRenderer.isVisible) {
                            if (!this.isVisible) {
                                this.skeletonRenderer.OnBecameVisible();
                                this.isVisible = true;
                            }
                            return;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                if (this.isVisible) {
                    this.isVisible = false;
                    this.skeletonRenderer.OnBecameInvisible();
                }
            },
            /*Spine.Unity.SkeletonRenderSeparator.UpdateVisibility end.*/

            /*Spine.Unity.SkeletonRenderSeparator.HandleRender start.*/
            HandleRender: function (instruction) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#HandleRender", this ); }

                var $t;
                var rendererCount = this.partsRenderers.Count;
                if (rendererCount <= 0) {
                    return;
                }

                var assignPropertyBlock = this.copyPropertyBlock && this.mainMeshRenderer.HasPropertyBlock();
                if (assignPropertyBlock) {
                    this.mainMeshRenderer.GetPropertyBlock(this.copiedBlock);
                }

                var settings = ($t = new Spine.Unity.MeshGenerator.Settings(), $t.addNormals = this.skeletonRenderer.addNormals, $t.calculateTangents = this.skeletonRenderer.calculateTangents, $t.immutableTriangles = false, $t.pmaVertexColors = this.skeletonRenderer.pmaVertexColors, $t.tintBlack = this.skeletonRenderer.tintBlack, $t.useClipping = true, $t.zSpacing = this.skeletonRenderer.zSpacing, $t);

                var submeshInstructions = instruction.submeshInstructions;
                var submeshInstructionsItems = submeshInstructions.Items;
                var lastSubmeshInstruction = (submeshInstructions.Count - 1) | 0;

                var rendererIndex = 0;
                var currentRenderer = this.partsRenderers.getItem(rendererIndex);
                for (var si = 0, start = 0; si <= lastSubmeshInstruction; si = (si + 1) | 0) {
                    if (UnityEngine.MonoBehaviour.op_Equality(currentRenderer, null)) {
                        continue;
                    }
                    if (submeshInstructionsItems[si].forceSeparate || si === lastSubmeshInstruction) {
                        // Apply properties
                        var meshGenerator = currentRenderer.MeshGenerator;
                        meshGenerator.settings = settings.$clone();

                        if (assignPropertyBlock) {
                            currentRenderer.SetPropertyBlock(this.copiedBlock);
                        }
                        // Render
                        currentRenderer.RenderParts(instruction.submeshInstructions, start, ((si + 1) | 0));

                        start = (si + 1) | 0;
                        rendererIndex = (rendererIndex + 1) | 0;
                        if (rendererIndex < rendererCount) {
                            currentRenderer = this.partsRenderers.getItem(rendererIndex);
                        } else {
                            // Not enough renderers. Skip the rest of the instructions.
                            break;
                        }
                    }
                }

                if (!Bridge.staticEquals(this.OnMeshAndMaterialsUpdated, null)) {
                    this.OnMeshAndMaterialsUpdated(this.skeletonRenderer);
                }

                // Clear extra renderers if they exist.
                for (; rendererIndex < rendererCount; rendererIndex = (rendererIndex + 1) | 0) {
                    currentRenderer = this.partsRenderers.getItem(rendererIndex);
                    if (UnityEngine.MonoBehaviour.op_Inequality(currentRenderer, null)) {
                        this.partsRenderers.getItem(rendererIndex).ClearMesh();
                    }
                }
            },
            /*Spine.Unity.SkeletonRenderSeparator.HandleRender end.*/

            /*Spine.Unity.SkeletonRenderSeparator.ClearPartsRendererMeshes start.*/
            ClearPartsRendererMeshes: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#ClearPartsRendererMeshes", this ); }

                var $t;
                $t = Bridge.getEnumerator(this.partsRenderers);
                try {
                    while ($t.moveNext()) {
                        var partsRenderer = $t.Current;
                        if (UnityEngine.MonoBehaviour.op_Inequality(partsRenderer, null)) {
                            partsRenderer.ClearMesh();
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonRenderSeparator.ClearPartsRendererMeshes end.*/


        }
    });
    /*Spine.Unity.SkeletonRenderSeparator end.*/

    /*Spine.Unity.SkeletonRootMotionBase+RootMotionInfo start.*/
    Bridge.define("Spine.Unity.SkeletonRootMotionBase.RootMotionInfo", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#getDefaultValue", this ); }
 return new Spine.Unity.SkeletonRootMotionBase.RootMotionInfo(); }
            }
        },
        fields: {
            start: null,
            current: null,
            mid: null,
            end: null,
            timeIsPastMid: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#init", this ); }

                this.start = new UnityEngine.Vector2();
                this.current = new UnityEngine.Vector2();
                this.mid = new UnityEngine.Vector2();
                this.end = new UnityEngine.Vector2();
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#getHashCode", this ); }

                var h = Bridge.addHash([5573033076, this.start, this.current, this.mid, this.end, this.timeIsPastMid]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#equals", this ); }

                if (!Bridge.is(o, Spine.Unity.SkeletonRootMotionBase.RootMotionInfo)) {
                    return false;
                }
                return Bridge.equals(this.start, o.start) && Bridge.equals(this.current, o.current) && Bridge.equals(this.mid, o.mid) && Bridge.equals(this.end, o.end) && Bridge.equals(this.timeIsPastMid, o.timeIsPastMid);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#$clone", this ); }

                var s = to || new Spine.Unity.SkeletonRootMotionBase.RootMotionInfo();
                s.start = this.start.$clone();
                s.current = this.current.$clone();
                s.mid = this.mid.$clone();
                s.end = this.end.$clone();
                s.timeIsPastMid = this.timeIsPastMid;
                return s;
            }
        }
    });
    /*Spine.Unity.SkeletonRootMotionBase+RootMotionInfo end.*/

    /*Spine.Unity.SkeletonSubmeshGraphic start.*/
    /**
     * A minimal MaskableGraphic subclass for rendering multiple submeshes
     at a {@link }.
     *
     * @public
     * @class Spine.Unity.SkeletonSubmeshGraphic
     * @augments UnityEngine.UI.MaskableGraphic
     */
    Bridge.define("Spine.Unity.SkeletonSubmeshGraphic", {
        inherits: [UnityEngine.UI.MaskableGraphic],
        methods: {
            /*Spine.Unity.SkeletonSubmeshGraphic.SetMaterialDirty start.*/
            SetMaterialDirty: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonSubmeshGraphic#SetMaterialDirty", this ); }
 },
            /*Spine.Unity.SkeletonSubmeshGraphic.SetMaterialDirty end.*/

            /*Spine.Unity.SkeletonSubmeshGraphic.SetVerticesDirty start.*/
            SetVerticesDirty: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonSubmeshGraphic#SetVerticesDirty", this ); }
 },
            /*Spine.Unity.SkeletonSubmeshGraphic.SetVerticesDirty end.*/

            /*Spine.Unity.SkeletonSubmeshGraphic.OnPopulateMesh start.*/
            OnPopulateMesh: function (vh) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonSubmeshGraphic#OnPopulateMesh", this ); }

                vh.Clear();
            },
            /*Spine.Unity.SkeletonSubmeshGraphic.OnPopulateMesh end.*/

            /*Spine.Unity.SkeletonSubmeshGraphic.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonSubmeshGraphic#OnDisable", this ); }

                UnityEngine.UI.MaskableGraphic.prototype.OnDisable.call(this);
                this.canvasRenderer.cull = true;
            },
            /*Spine.Unity.SkeletonSubmeshGraphic.OnDisable end.*/

            /*Spine.Unity.SkeletonSubmeshGraphic.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonSubmeshGraphic#OnEnable", this ); }

                UnityEngine.UI.MaskableGraphic.prototype.OnEnable.call(this);
                this.canvasRenderer.cull = false;
            },
            /*Spine.Unity.SkeletonSubmeshGraphic.OnEnable end.*/


        }
    });
    /*Spine.Unity.SkeletonSubmeshGraphic end.*/

    /*Spine.Unity.SkeletonUtility start.*/
    Bridge.define("Spine.Unity.SkeletonUtility", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            methods: {
                /*Spine.Unity.SkeletonUtility.AddBoundingBoxGameObject:static start.*/
                AddBoundingBoxGameObject: function (skeleton, skinName, slotName, attachmentName, parent, isTrigger) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#AddBoundingBoxGameObject", this ); }

                    if (isTrigger === void 0) { isTrigger = true; }
                    var skin = System.String.isNullOrEmpty(skinName) ? skeleton.Data.DefaultSkin : skeleton.Data.FindSkin(skinName);
                    if (skin == null) {
                        UnityEngine.Debug.LogError$2("Skin " + (skinName || "") + " not found!");
                        return null;
                    }

                    var slot = skeleton.FindSlot(slotName);
                    var attachment = slot != null ? skin.GetAttachment(slot.Data.Index, attachmentName) : null;
                    if (attachment == null) {
                        UnityEngine.Debug.LogFormat("Attachment in slot '{0}' named '{1}' not found in skin '{2}'.", [slotName, attachmentName, skin.Name]);
                        return null;
                    }

                    var box = Bridge.as(attachment, Spine.BoundingBoxAttachment);
                    if (box != null) {
                        return Spine.Unity.SkeletonUtility.AddBoundingBoxGameObject$1(box.Name, box, slot, parent, isTrigger);
                    } else {
                        UnityEngine.Debug.LogFormat("Attachment '{0}' was not a Bounding Box.", [attachmentName]);
                        return null;
                    }
                },
                /*Spine.Unity.SkeletonUtility.AddBoundingBoxGameObject:static end.*/

                /*Spine.Unity.SkeletonUtility.AddBoundingBoxGameObject$1:static start.*/
                AddBoundingBoxGameObject$1: function (name, box, slot, parent, isTrigger) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#AddBoundingBoxGameObject$1", this ); }

                    if (isTrigger === void 0) { isTrigger = true; }
                    var go = new UnityEngine.GameObject.$ctor2("[BoundingBox]" + ((System.String.isNullOrEmpty(name) ? box.Name : name) || ""));
                    var got = go.transform;
                    got.parent = parent;
                    got.localPosition = pc.Vec3.ZERO.clone();
                    got.localRotation = pc.Quat.IDENTITY.clone();
                    got.localScale = new pc.Vec3( 1, 1, 1 );
                    return Spine.Unity.SkeletonUtility.AddBoundingBoxAsComponent(box, slot, go, isTrigger);
                },
                /*Spine.Unity.SkeletonUtility.AddBoundingBoxGameObject$1:static end.*/

                /*Spine.Unity.SkeletonUtility.AddBoundingBoxAsComponent:static start.*/
                AddBoundingBoxAsComponent: function (box, slot, gameObject, isTrigger) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#AddBoundingBoxAsComponent", this ); }

                    if (isTrigger === void 0) { isTrigger = true; }
                    if (box == null) {
                        return null;
                    }
                    var collider = gameObject.AddComponent(UnityEngine.PolygonCollider2D);
                    collider.isTrigger = isTrigger;
                    Spine.Unity.SkeletonUtility.SetColliderPointsLocal(collider, slot, box);
                    return collider;
                },
                /*Spine.Unity.SkeletonUtility.AddBoundingBoxAsComponent:static end.*/

                /*Spine.Unity.SkeletonUtility.SetColliderPointsLocal:static start.*/
                SetColliderPointsLocal: function (collider, slot, box, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#SetColliderPointsLocal", this ); }

                    if (scale === void 0) { scale = 1.0; }
                    if (box == null) {
                        return;
                    }
                    if (Spine.SpineSkeletonExtensions.IsWeighted(box)) {
                        UnityEngine.Debug.LogWarning$1("UnityEngine.PolygonCollider2D does not support weighted or animated points. Collider points will not be animated and may have incorrect orientation. If you want to use it as a collider, please remove weights and animations from the bounding box in Spine editor.");
                    }
                    var verts = Spine.Unity.SkeletonExtensions.GetLocalVertices(box, slot, null);
                    if (scale !== 1.0) {
                        for (var i = 0, n = verts.length; i < n; i = (i + 1) | 0) {
                            verts[i] = verts[i].$clone().scale( scale );
                        }
                    }
                    collider.SetPath$1(0, verts);
                },
                /*Spine.Unity.SkeletonUtility.SetColliderPointsLocal:static end.*/

                /*Spine.Unity.SkeletonUtility.GetBoundingBoxBounds:static start.*/
                GetBoundingBoxBounds: function (boundingBox, depth) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#GetBoundingBoxBounds", this ); }

                    if (depth === void 0) { depth = 0.0; }
                    var floats = boundingBox.Vertices;
                    var floatCount = floats.length;

                    var bounds = new pc.BoundingBox.ctor();

                    bounds.center = new pc.Vec3( floats[0], floats[1], 0 );
                    for (var i = 2; i < floatCount; i = (i + 2) | 0) {
                        bounds.expandToPoint( new pc.Vec3( floats[i], floats[((i + 1) | 0)], 0 ) );
                    }

                    var size = bounds.halfExtents.$clone().scale( 2 ).$clone();
                    size.z = depth;
                    bounds.halfExtents = size.$clone().$clone().scale( 0.5 );

                    return bounds;
                },
                /*Spine.Unity.SkeletonUtility.GetBoundingBoxBounds:static end.*/

                /*Spine.Unity.SkeletonUtility.AddBoneRigidbody2D:static start.*/
                AddBoneRigidbody2D: function (gameObject, isKinematic, gravityScale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#AddBoneRigidbody2D", this ); }

                    if (isKinematic === void 0) { isKinematic = true; }
                    if (gravityScale === void 0) { gravityScale = 0.0; }
                    var rb = gameObject.GetComponent(UnityEngine.Rigidbody2D);
                    if (UnityEngine.Component.op_Equality(rb, null)) {
                        rb = gameObject.AddComponent(UnityEngine.Rigidbody2D);
                        rb.isKinematic = isKinematic;
                        rb.gravityScale = gravityScale;
                    }
                    return rb;
                },
                /*Spine.Unity.SkeletonUtility.AddBoneRigidbody2D:static end.*/


            }
        },
        fields: {
            boneRoot: null,
            /**
             * If true, {@link } and {@link } are followed
             by 180 degree rotation. If false, negative Transform scale is used.
             Note that using negative scale is consistent with previous behaviour (hence the default),
             however causes serious problems with rigidbodies and physics. Therefore, it is recommended to
             enable this parameter where possible. When creating hinge chains for a chain of skeleton bones
             via {@link }, it is mandatory to have <pre><code>flipBy180DegreeRotation</code></pre> enabled.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonUtility
             * @default false
             * @type boolean
             */
            flipBy180DegreeRotation: false,
            skeletonRenderer: null,
            skeletonGraphic: null,
            skeletonAnimation: null,
            skeletonComponent: null,
            boneComponents: null,
            constraintComponents: null,
            positionScale: 0,
            lastPositionScale: 0,
            positionOffset: null,
            hasOverrideBones: false,
            hasConstraints: false,
            needToReprocessBones: false
        },
        events: {
            OnReset: null
        },
        props: {
            SkeletonComponent: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#SkeletonComponent#get", this ); }

                    if (this.skeletonComponent == null) {
                        this.skeletonComponent = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) ? this.skeletonRenderer.GetComponent(Spine.Unity.ISkeletonComponent) : UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null) ? this.skeletonGraphic.GetComponent(Spine.Unity.ISkeletonComponent) : this.GetComponent(Spine.Unity.ISkeletonComponent);
                    }
                    return this.skeletonComponent;
                }
            },
            Skeleton: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#Skeleton#get", this ); }

                    if (this.SkeletonComponent == null) {
                        return null;
                    }
                    return this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                }
            },
            IsValid: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#IsValid#get", this ); }

                    return (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) && this.skeletonRenderer.valid) || (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null) && this.skeletonGraphic.IsValid);
                }
            },
            PositionScale: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#PositionScale#get", this ); }

                    return this.positionScale;
                }
            },
            PositionOffset: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#PositionOffset#get", this ); }

                    return this.positionOffset.$clone();
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#init", this ); }

                this.positionOffset = new UnityEngine.Vector2();
                this.flipBy180DegreeRotation = false;
                this.boneComponents = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonUtilityBone)).ctor();
                this.constraintComponents = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonUtilityConstraint)).ctor();
                this.positionScale = 1.0;
                this.lastPositionScale = 1.0;
                this.positionOffset = pc.Vec2.ZERO.clone();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonUtility.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#Update", this ); }

                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                if (skeleton != null && UnityEngine.Component.op_Inequality(this.boneRoot, null)) {

                    if (this.flipBy180DegreeRotation) {
                        this.boneRoot.localScale = new pc.Vec3( Math.abs(skeleton.ScaleX), Math.abs(skeleton.ScaleY), 1.0 );
                        this.boneRoot.eulerAngles = new pc.Vec3( skeleton.ScaleY > 0 ? 0 : 180, skeleton.ScaleX > 0 ? 0 : 180, 0 );
                    } else {
                        this.boneRoot.localScale = new pc.Vec3( skeleton.ScaleX, skeleton.ScaleY, 1.0 );
                    }
                }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    this.positionScale = this.skeletonGraphic.MeshScale;
                    this.lastPositionScale = this.positionScale;
                    if (UnityEngine.Object.op_Implicit(this.boneRoot)) {
                        this.positionOffset = this.skeletonGraphic.MeshOffset.$clone();
                        if (!pc.Vec2.equals( this.positionOffset, pc.Vec2.ZERO.clone() )) {
                            this.boneRoot.localPosition = UnityEngine.Vector3.FromVector2(this.positionOffset.$clone());
                        }
                    }
                }
            },
            /*Spine.Unity.SkeletonUtility.Update end.*/

            /*Spine.Unity.SkeletonUtility.UpdateToMeshScaleAndOffset start.*/
            UpdateToMeshScaleAndOffset: function (ignoredParameter) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#UpdateToMeshScaleAndOffset", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    return;
                }

                this.positionScale = this.skeletonGraphic.MeshScale;
                if (UnityEngine.Object.op_Implicit(this.boneRoot)) {
                    this.positionOffset = this.skeletonGraphic.MeshOffset.$clone();
                    if (!pc.Vec2.equals( this.positionOffset, pc.Vec2.ZERO.clone() )) {
                        this.boneRoot.localPosition = UnityEngine.Vector3.FromVector2(this.positionOffset.$clone());
                    }
                }

                // Note: skeletonGraphic.MeshScale and MeshOffset can be one frame behind in Update() above.
                // Unfortunately update order is:
                // 1. SkeletonGraphic.Update updating skeleton bones and calling UpdateWorld callback,
                //    calling SkeletonUtilityBone.DoUpdate() reading hierarchy.PositionScale.
                // 2. Layout change triggers SkeletonGraphic.Rebuild, updating MeshScale and MeshOffset.
                // Thus to prevent a one-frame-behind offset after a layout change affecting mesh scale,
                // we have to re-evaluate the callbacks via the lines below.
                if (this.lastPositionScale !== this.positionScale) {
                    this.UpdateLocal(this.skeletonAnimation);
                    this.UpdateWorld(this.skeletonAnimation);
                    this.UpdateComplete(this.skeletonAnimation);
                }
            },
            /*Spine.Unity.SkeletonUtility.UpdateToMeshScaleAndOffset end.*/

            /*Spine.Unity.SkeletonUtility.ResubscribeEvents start.*/
            ResubscribeEvents: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#ResubscribeEvents", this ); }

                this.ResubscribeIndependentEvents();
                this.ResubscribeDependentEvents();
            },
            /*Spine.Unity.SkeletonUtility.ResubscribeEvents end.*/

            /*Spine.Unity.SkeletonUtility.ResubscribeIndependentEvents start.*/
            ResubscribeIndependentEvents: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#ResubscribeIndependentEvents", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRendererReset$1));
                    this.skeletonRenderer.addOnRebuild(Bridge.fn.cacheBind(this, this.HandleRendererReset$1));
                } else if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    this.skeletonGraphic.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRendererReset));
                    this.skeletonGraphic.addOnRebuild(Bridge.fn.cacheBind(this, this.HandleRendererReset));
                    this.skeletonGraphic.removeOnPostProcessVertices(Bridge.fn.cacheBind(this, this.UpdateToMeshScaleAndOffset));
                    this.skeletonGraphic.addOnPostProcessVertices(Bridge.fn.cacheBind(this, this.UpdateToMeshScaleAndOffset));
                }

                if (this.skeletonAnimation != null) {
                    this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateLocal(Bridge.fn.cacheBind(this, this.UpdateLocal));
                    this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$addUpdateLocal(Bridge.fn.cacheBind(this, this.UpdateLocal));
                }
            },
            /*Spine.Unity.SkeletonUtility.ResubscribeIndependentEvents end.*/

            /*Spine.Unity.SkeletonUtility.ResubscribeDependentEvents start.*/
            ResubscribeDependentEvents: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#ResubscribeDependentEvents", this ); }

                if (this.skeletonAnimation != null) {
                    this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateWorld(Bridge.fn.cacheBind(this, this.UpdateWorld));
                    this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateComplete(Bridge.fn.cacheBind(this, this.UpdateComplete));

                    if (this.hasOverrideBones || this.hasConstraints) {
                        this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$addUpdateWorld(Bridge.fn.cacheBind(this, this.UpdateWorld));
                    }
                    if (this.hasConstraints) {
                        this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$addUpdateComplete(Bridge.fn.cacheBind(this, this.UpdateComplete));
                    }
                }
            },
            /*Spine.Unity.SkeletonUtility.ResubscribeDependentEvents end.*/

            /*Spine.Unity.SkeletonUtility.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#OnEnable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer = this.GetComponent(Spine.Unity.SkeletonRenderer);
                }
                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    this.skeletonGraphic = this.GetComponent(Spine.Unity.SkeletonGraphic);
                }
                if (this.skeletonAnimation == null) {
                    this.skeletonAnimation = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) ? this.skeletonRenderer.GetComponent(Spine.Unity.ISkeletonAnimation) : UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null) ? this.skeletonGraphic.GetComponent(Spine.Unity.ISkeletonAnimation) : this.GetComponent(Spine.Unity.ISkeletonAnimation);
                }
                if (this.skeletonComponent == null) {
                    this.skeletonComponent = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) ? this.skeletonRenderer.GetComponent(Spine.Unity.ISkeletonComponent) : UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null) ? this.skeletonGraphic.GetComponent(Spine.Unity.ISkeletonComponent) : this.GetComponent(Spine.Unity.ISkeletonComponent);
                }
                this.CollectBones();
                this.ResubscribeEvents();
            },
            /*Spine.Unity.SkeletonUtility.OnEnable end.*/

            /*Spine.Unity.SkeletonUtility.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#Start", this ); }

                //recollect because order of operations failure when switching between game mode and edit mode...
                this.CollectBones();
            },
            /*Spine.Unity.SkeletonUtility.Start end.*/

            /*Spine.Unity.SkeletonUtility.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#OnDisable", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRendererReset$1));
                }
                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    this.skeletonGraphic.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRendererReset));
                    this.skeletonGraphic.removeOnPostProcessVertices(Bridge.fn.cacheBind(this, this.UpdateToMeshScaleAndOffset));
                }

                if (this.skeletonAnimation != null) {
                    this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateLocal(Bridge.fn.cacheBind(this, this.UpdateLocal));
                    this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateWorld(Bridge.fn.cacheBind(this, this.UpdateWorld));
                    this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateComplete(Bridge.fn.cacheBind(this, this.UpdateComplete));
                }
            },
            /*Spine.Unity.SkeletonUtility.OnDisable end.*/

            /*Spine.Unity.SkeletonUtility.HandleRendererReset$1 start.*/
            HandleRendererReset$1: function (r) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#HandleRendererReset$1", this ); }

                if (!Bridge.staticEquals(this.OnReset, null)) {
                    this.OnReset();
                }
                this.CollectBones();
            },
            /*Spine.Unity.SkeletonUtility.HandleRendererReset$1 end.*/

            /*Spine.Unity.SkeletonUtility.HandleRendererReset start.*/
            HandleRendererReset: function (g) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#HandleRendererReset", this ); }

                if (!Bridge.staticEquals(this.OnReset, null)) {
                    this.OnReset();
                }
                this.CollectBones();
            },
            /*Spine.Unity.SkeletonUtility.HandleRendererReset end.*/

            /*Spine.Unity.SkeletonUtility.RegisterBone start.*/
            RegisterBone: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#RegisterBone", this ); }

                if (this.boneComponents.contains(bone)) {
                    return;
                } else {
                    this.boneComponents.add(bone);
                    this.needToReprocessBones = true;
                }
            },
            /*Spine.Unity.SkeletonUtility.RegisterBone end.*/

            /*Spine.Unity.SkeletonUtility.UnregisterBone start.*/
            UnregisterBone: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#UnregisterBone", this ); }

                this.boneComponents.remove(bone);
            },
            /*Spine.Unity.SkeletonUtility.UnregisterBone end.*/

            /*Spine.Unity.SkeletonUtility.RegisterConstraint start.*/
            RegisterConstraint: function (constraint) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#RegisterConstraint", this ); }

                if (this.constraintComponents.contains(constraint)) {
                    return;
                } else {
                    this.constraintComponents.add(constraint);
                    this.needToReprocessBones = true;
                }
            },
            /*Spine.Unity.SkeletonUtility.RegisterConstraint end.*/

            /*Spine.Unity.SkeletonUtility.UnregisterConstraint start.*/
            UnregisterConstraint: function (constraint) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#UnregisterConstraint", this ); }

                this.constraintComponents.remove(constraint);
            },
            /*Spine.Unity.SkeletonUtility.UnregisterConstraint end.*/

            /*Spine.Unity.SkeletonUtility.CollectBones start.*/
            CollectBones: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#CollectBones", this ); }

                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                if (skeleton == null) {
                    return;
                }

                if (UnityEngine.Component.op_Inequality(this.boneRoot, null)) {
                    var constraintTargets = new (System.Collections.Generic.List$1(System.Object)).ctor();
                    var ikConstraints = skeleton.IkConstraints;
                    for (var i = 0, n = ikConstraints.Count; i < n; i = (i + 1) | 0) {
                        constraintTargets.add(ikConstraints.Items[i].Target);
                    }

                    var transformConstraints = skeleton.TransformConstraints;
                    for (var i1 = 0, n1 = transformConstraints.Count; i1 < n1; i1 = (i1 + 1) | 0) {
                        constraintTargets.add(transformConstraints.Items[i1].Target);
                    }

                    var boneComponents = this.boneComponents;
                    for (var i2 = 0, n2 = boneComponents.Count; i2 < n2; i2 = (i2 + 1) | 0) {
                        var b = boneComponents.getItem(i2);
                        if (b.bone == null) {
                            b.DoUpdate(Spine.Unity.SkeletonUtilityBone.UpdatePhase.Local);
                            if (b.bone == null) {
                                continue;
                            }
                        }
                        this.hasOverrideBones = !!(this.hasOverrideBones | (b.mode === Spine.Unity.SkeletonUtilityBone.Mode.Override));
                        this.hasConstraints = !!(this.hasConstraints | constraintTargets.contains(b.bone));
                    }

                    this.hasConstraints = !!(this.hasConstraints | this.constraintComponents.Count > 0);
                    this.needToReprocessBones = false;
                } else {
                    this.boneComponents.clear();
                    this.constraintComponents.clear();
                }
                this.ResubscribeDependentEvents();
            },
            /*Spine.Unity.SkeletonUtility.CollectBones end.*/

            /*Spine.Unity.SkeletonUtility.UpdateLocal start.*/
            UpdateLocal: function (anim) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#UpdateLocal", this ); }

                if (this.needToReprocessBones) {
                    this.CollectBones();
                }

                var boneComponents = this.boneComponents;
                if (boneComponents == null) {
                    return;
                }
                for (var i = 0, n = boneComponents.Count; i < n; i = (i + 1) | 0) {
                    boneComponents.getItem(i).transformLerpComplete = false;
                }

                this.UpdateAllBones(Spine.Unity.SkeletonUtilityBone.UpdatePhase.Local);
            },
            /*Spine.Unity.SkeletonUtility.UpdateLocal end.*/

            /*Spine.Unity.SkeletonUtility.UpdateWorld start.*/
            UpdateWorld: function (anim) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#UpdateWorld", this ); }

                this.UpdateAllBones(Spine.Unity.SkeletonUtilityBone.UpdatePhase.World);
                for (var i = 0, n = this.constraintComponents.Count; i < n; i = (i + 1) | 0) {
                    this.constraintComponents.getItem(i).DoUpdate();
                }
            },
            /*Spine.Unity.SkeletonUtility.UpdateWorld end.*/

            /*Spine.Unity.SkeletonUtility.UpdateComplete start.*/
            UpdateComplete: function (anim) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#UpdateComplete", this ); }

                this.UpdateAllBones(Spine.Unity.SkeletonUtilityBone.UpdatePhase.Complete);
            },
            /*Spine.Unity.SkeletonUtility.UpdateComplete end.*/

            /*Spine.Unity.SkeletonUtility.UpdateAllBones start.*/
            UpdateAllBones: function (phase) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#UpdateAllBones", this ); }

                if (UnityEngine.Component.op_Equality(this.boneRoot, null)) {
                    this.CollectBones();
                }

                var boneComponents = this.boneComponents;
                if (boneComponents == null) {
                    return;
                }
                for (var i = 0, n = boneComponents.Count; i < n; i = (i + 1) | 0) {
                    boneComponents.getItem(i).DoUpdate(phase);
                }
            },
            /*Spine.Unity.SkeletonUtility.UpdateAllBones end.*/

            /*Spine.Unity.SkeletonUtility.GetBoneRoot start.*/
            GetBoneRoot: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#GetBoneRoot", this ); }

                if (UnityEngine.Component.op_Inequality(this.boneRoot, null)) {
                    return this.boneRoot;
                }

                var boneRootObject = new UnityEngine.GameObject.$ctor2("SkeletonUtility-SkeletonRoot");
                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    boneRootObject.AddComponent(UnityEngine.RectTransform);
                }

                this.boneRoot = boneRootObject.transform;
                this.boneRoot.SetParent(this.transform);
                this.boneRoot.localPosition = pc.Vec3.ZERO.clone();
                this.boneRoot.localRotation = pc.Quat.IDENTITY.clone();
                this.boneRoot.localScale = new pc.Vec3( 1, 1, 1 );

                return this.boneRoot;
            },
            /*Spine.Unity.SkeletonUtility.GetBoneRoot end.*/

            /*Spine.Unity.SkeletonUtility.SpawnRoot start.*/
            SpawnRoot: function (mode, pos, rot, sca) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#SpawnRoot", this ); }

                this.GetBoneRoot();
                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;

                var go = this.SpawnBone(skeleton.RootBone, this.boneRoot, mode, pos, rot, sca);
                this.CollectBones();
                return go;
            },
            /*Spine.Unity.SkeletonUtility.SpawnRoot end.*/

            /*Spine.Unity.SkeletonUtility.SpawnHierarchy start.*/
            SpawnHierarchy: function (mode, pos, rot, sca) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#SpawnHierarchy", this ); }

                this.GetBoneRoot();
                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                var go = this.SpawnBoneRecursively(skeleton.RootBone, this.boneRoot, mode, pos, rot, sca);
                this.CollectBones();
                return go;
            },
            /*Spine.Unity.SkeletonUtility.SpawnHierarchy end.*/

            /*Spine.Unity.SkeletonUtility.SpawnBoneRecursively start.*/
            SpawnBoneRecursively: function (bone, parent, mode, pos, rot, sca) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#SpawnBoneRecursively", this ); }

                var go = this.SpawnBone(bone, parent, mode, pos, rot, sca);

                var childrenBones = bone.Children;
                for (var i = 0, n = childrenBones.Count; i < n; i = (i + 1) | 0) {
                    var child = childrenBones.Items[i];
                    this.SpawnBoneRecursively(child, go.transform, mode, pos, rot, sca);
                }

                return go;
            },
            /*Spine.Unity.SkeletonUtility.SpawnBoneRecursively end.*/

            /*Spine.Unity.SkeletonUtility.SpawnBone start.*/
            SpawnBone: function (bone, parent, mode, pos, rot, sca) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#SpawnBone", this ); }

                var go = new UnityEngine.GameObject.$ctor2(bone.Data.Name);
                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    go.AddComponent(UnityEngine.RectTransform);
                }

                var goTransform = go.transform;
                goTransform.SetParent(parent);

                var b = go.AddComponent(Spine.Unity.SkeletonUtilityBone);
                b.hierarchy = this;
                b.position = pos;
                b.rotation = rot;
                b.scale = sca;
                b.mode = mode;
                b.zPosition = true;
                b.Reset();
                b.bone = bone;
                b.boneName = bone.Data.Name;
                b.valid = true;

                if (mode === Spine.Unity.SkeletonUtilityBone.Mode.Override) {
                    if (rot) {
                        goTransform.localRotation = new pc.Quat().setFromEulerAngles_Unity( 0, 0, b.bone.AppliedRotation );
                    }
                    if (pos) {
                        goTransform.localPosition = new pc.Vec3( b.bone.X * this.positionScale + this.positionOffset.x, b.bone.Y * this.positionScale + this.positionOffset.y, 0 );
                    }
                    goTransform.localScale = new pc.Vec3( b.bone.ScaleX, b.bone.ScaleY, 0 );
                }

                return go;
            },
            /*Spine.Unity.SkeletonUtility.SpawnBone end.*/


        },
        overloads: {
            "HandleRendererReset(SkeletonRenderer)": "HandleRendererReset$1"
        }
    });
    /*Spine.Unity.SkeletonUtility end.*/

    /*Spine.Unity.SkeletonUtilityBone start.*/
    /**
     * Sets a GameObject's transform to match a bone on a Spine skeleton.
     *
     * @public
     * @class Spine.Unity.SkeletonUtilityBone
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Spine.Unity.SkeletonUtilityBone", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            methods: {
                /*Spine.Unity.SkeletonUtilityBone.BoneTransformModeIncompatible:static start.*/
                BoneTransformModeIncompatible: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#BoneTransformModeIncompatible", this ); }

                    return !Spine.SpineSkeletonExtensions.InheritsScale(bone.Data.Inherit);
                },
                /*Spine.Unity.SkeletonUtilityBone.BoneTransformModeIncompatible:static end.*/


            }
        },
        fields: {
            /**
             * If a bone isn't set, boneName is used to find the bone.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonUtilityBone
             * @type string
             */
            boneName: null,
            parentReference: null,
            mode: 0,
            position: false,
            rotation: false,
            scale: false,
            zPosition: false,
            overrideAlpha: 0,
            hierarchy: null,
            bone: null,
            transformLerpComplete: false,
            valid: false,
            cachedTransform: null,
            skeletonTransform: null,
            incompatibleTransformMode: false
        },
        props: {
            IncompatibleTransformMode: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#IncompatibleTransformMode#get", this ); }

                    return this.incompatibleTransformMode;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#init", this ); }

                this.zPosition = true;
                this.overrideAlpha = 1;
            }
        },
        methods: {
            /*Spine.Unity.SkeletonUtilityBone.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#Reset", this ); }

                this.bone = null;
                this.cachedTransform = this.transform;
                this.valid = UnityEngine.MonoBehaviour.op_Inequality(this.hierarchy, null) && this.hierarchy.IsValid;
                if (!this.valid) {
                    return;
                }
                this.skeletonTransform = this.hierarchy.transform;
                this.hierarchy.removeOnReset(Bridge.fn.cacheBind(this, this.HandleOnReset));
                this.hierarchy.addOnReset(Bridge.fn.cacheBind(this, this.HandleOnReset));
                this.DoUpdate(Spine.Unity.SkeletonUtilityBone.UpdatePhase.Local);
            },
            /*Spine.Unity.SkeletonUtilityBone.Reset end.*/

            /*Spine.Unity.SkeletonUtilityBone.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#OnEnable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.hierarchy, null)) {
                    this.hierarchy = this.transform.GetComponentInParent(Spine.Unity.SkeletonUtility);
                }
                if (UnityEngine.MonoBehaviour.op_Equality(this.hierarchy, null)) {
                    return;
                }

                this.hierarchy.RegisterBone(this);
                this.hierarchy.addOnReset(Bridge.fn.cacheBind(this, this.HandleOnReset));
            },
            /*Spine.Unity.SkeletonUtilityBone.OnEnable end.*/

            /*Spine.Unity.SkeletonUtilityBone.HandleOnReset start.*/
            HandleOnReset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#HandleOnReset", this ); }

                this.Reset();
            },
            /*Spine.Unity.SkeletonUtilityBone.HandleOnReset end.*/

            /*Spine.Unity.SkeletonUtilityBone.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#OnDisable", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.hierarchy, null)) {
                    this.hierarchy.removeOnReset(Bridge.fn.cacheBind(this, this.HandleOnReset));
                    this.hierarchy.UnregisterBone(this);
                }
            },
            /*Spine.Unity.SkeletonUtilityBone.OnDisable end.*/

            /*Spine.Unity.SkeletonUtilityBone.DoUpdate start.*/
            DoUpdate: function (phase) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#DoUpdate", this ); }

                var $t;
                if (!this.valid) {
                    this.Reset();
                    return;
                }

                var skeleton = this.hierarchy.Skeleton;

                if (this.bone == null) {
                    if (System.String.isNullOrEmpty(this.boneName)) {
                        return;
                    }
                    this.bone = skeleton.FindBone(this.boneName);
                    if (this.bone == null) {
                        UnityEngine.Debug.LogError$2("Bone not found: " + (this.boneName || ""), this);
                        return;
                    }
                }
                if (!this.bone.Active) {
                    return;
                }

                var positionScale = this.hierarchy.PositionScale;

                var thisTransform = this.cachedTransform;
                var skeletonFlipRotation = ($t = skeleton.ScaleX * skeleton.ScaleY, ($t === 0 ? 1 : Math.sign($t)));
                if (this.mode === Spine.Unity.SkeletonUtilityBone.Mode.Follow) {
                    switch (phase) {
                        case Spine.Unity.SkeletonUtilityBone.UpdatePhase.Local: 
                            if (this.position) {
                                thisTransform.localPosition = new pc.Vec3( this.bone.X * positionScale, this.bone.Y * positionScale, this.zPosition ? 0 : thisTransform.localPosition.z );
                            }
                            if (this.rotation) {
                                if (Spine.SpineSkeletonExtensions.InheritsRotation(this.bone.Data.Inherit)) {
                                    thisTransform.localRotation = new pc.Quat().setFromEulerAngles_Unity( 0, 0, this.bone.Rotation );
                                } else {
                                    var euler = this.skeletonTransform.rotation.getPositiveEulerAngles().$clone();
                                    thisTransform.rotation = new pc.Quat().setFromEulerAngles_Unity( euler.x, euler.y, euler.z + (this.bone.WorldRotationX * skeletonFlipRotation) );
                                }
                            }
                            if (this.scale) {
                                thisTransform.localScale = new pc.Vec3( this.bone.ScaleX, this.bone.ScaleY, 1.0 );
                                this.incompatibleTransformMode = Spine.Unity.SkeletonUtilityBone.BoneTransformModeIncompatible(this.bone);
                            }
                            break;
                        case Spine.Unity.SkeletonUtilityBone.UpdatePhase.World: 
                        case Spine.Unity.SkeletonUtilityBone.UpdatePhase.Complete: 
                            if (this.position) {
                                thisTransform.localPosition = new pc.Vec3( this.bone.AX * positionScale, this.bone.AY * positionScale, this.zPosition ? 0 : thisTransform.localPosition.z );
                            }
                            if (this.rotation) {
                                if (Spine.SpineSkeletonExtensions.InheritsRotation(this.bone.Data.Inherit)) {
                                    thisTransform.localRotation = new pc.Quat().setFromEulerAngles_Unity( 0, 0, this.bone.AppliedRotation );
                                } else {
                                    var euler1 = this.skeletonTransform.rotation.getPositiveEulerAngles().$clone();
                                    thisTransform.rotation = new pc.Quat().setFromEulerAngles_Unity( euler1.x, euler1.y, euler1.z + (this.bone.WorldRotationX * skeletonFlipRotation) );
                                }
                            }
                            if (this.scale) {
                                thisTransform.localScale = new pc.Vec3( this.bone.AScaleX, this.bone.AScaleY, 1.0 );
                                this.incompatibleTransformMode = Spine.Unity.SkeletonUtilityBone.BoneTransformModeIncompatible(this.bone);
                            }
                            break;
                    }

                } else if (this.mode === Spine.Unity.SkeletonUtilityBone.Mode.Override) {
                    if (this.transformLerpComplete) {
                        return;
                    }

                    if (UnityEngine.Component.op_Equality(this.parentReference, null)) {
                        if (this.position) {
                            var clp = thisTransform.localPosition.$clone().scale( 1.0 / ( positionScale ) );
                            this.bone.X = pc.math.lerp(this.bone.X, clp.x, this.overrideAlpha);
                            this.bone.Y = pc.math.lerp(this.bone.Y, clp.y, this.overrideAlpha);
                        }

                        if (this.rotation) {
                            var angle = UnityEngine.Mathf.LerpAngle(this.bone.Rotation, thisTransform.localRotation.getPositiveEulerAngles().z, this.overrideAlpha);
                            this.bone.Rotation = angle;
                            this.bone.AppliedRotation = angle;
                        }

                        if (this.scale) {
                            var cls = thisTransform.localScale.$clone();
                            this.bone.ScaleX = pc.math.lerp(this.bone.ScaleX, cls.x, this.overrideAlpha);
                            this.bone.ScaleY = pc.math.lerp(this.bone.ScaleY, cls.y, this.overrideAlpha);
                        }

                    } else {
                        if (this.transformLerpComplete) {
                            return;
                        }

                        if (this.position) {
                            var pos = this.parentReference.InverseTransformPoint(thisTransform.position).scale( 1.0 / ( positionScale ) );
                            this.bone.X = pc.math.lerp(this.bone.X, pos.x, this.overrideAlpha);
                            this.bone.Y = pc.math.lerp(this.bone.Y, pos.y, this.overrideAlpha);
                        }

                        if (this.rotation) {
                            var angle1 = UnityEngine.Mathf.LerpAngle(this.bone.Rotation, new pc.Quat().setLookAt( new pc.Vec3( 0, 0, 1 ), this.parentReference.InverseTransformDirection(thisTransform.up) ).getPositiveEulerAngles().z, this.overrideAlpha);
                            this.bone.Rotation = angle1;
                            this.bone.AppliedRotation = angle1;
                        }

                        if (this.scale) {
                            var cls1 = thisTransform.localScale.$clone();
                            this.bone.ScaleX = pc.math.lerp(this.bone.ScaleX, cls1.x, this.overrideAlpha);
                            this.bone.ScaleY = pc.math.lerp(this.bone.ScaleY, cls1.y, this.overrideAlpha);
                        }

                        this.incompatibleTransformMode = Spine.Unity.SkeletonUtilityBone.BoneTransformModeIncompatible(this.bone);
                    }

                    this.transformLerpComplete = true;
                }
            },
            /*Spine.Unity.SkeletonUtilityBone.DoUpdate end.*/

            /*Spine.Unity.SkeletonUtilityBone.AddBoundingBox start.*/
            AddBoundingBox: function (skinName, slotName, attachmentName) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#AddBoundingBox", this ); }

                Spine.Unity.SkeletonUtility.AddBoneRigidbody2D(this.transform.gameObject);
                Spine.Unity.SkeletonUtility.AddBoundingBoxGameObject(this.bone.Skeleton, skinName, slotName, attachmentName, this.transform);
            },
            /*Spine.Unity.SkeletonUtilityBone.AddBoundingBox end.*/


        }
    });
    /*Spine.Unity.SkeletonUtilityBone end.*/

    /*Spine.Unity.SkeletonUtilityBone+Mode start.*/
    Bridge.define("Spine.Unity.SkeletonUtilityBone.Mode", {
        $kind: 1006,
        statics: {
            fields: {
                Follow: 0,
                Override: 1
            }
        }
    });
    /*Spine.Unity.SkeletonUtilityBone+Mode end.*/

    /*Spine.Unity.SkeletonUtilityBone+UpdatePhase start.*/
    Bridge.define("Spine.Unity.SkeletonUtilityBone.UpdatePhase", {
        $kind: 1006,
        statics: {
            fields: {
                Local: 0,
                World: 1,
                Complete: 2
            }
        }
    });
    /*Spine.Unity.SkeletonUtilityBone+UpdatePhase end.*/

    /*Spine.Unity.SkeletonUtilityConstraint start.*/
    Bridge.define("Spine.Unity.SkeletonUtilityConstraint", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            bone: null,
            hierarchy: null
        },
        methods: {
            /*Spine.Unity.SkeletonUtilityConstraint.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityConstraint#OnEnable", this ); }

                this.bone = this.GetComponent(Spine.Unity.SkeletonUtilityBone);
                this.hierarchy = this.transform.GetComponentInParent(Spine.Unity.SkeletonUtility);
                this.hierarchy.RegisterConstraint(this);
            },
            /*Spine.Unity.SkeletonUtilityConstraint.OnEnable end.*/

            /*Spine.Unity.SkeletonUtilityConstraint.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityConstraint#OnDisable", this ); }

                this.hierarchy.UnregisterConstraint(this);
            },
            /*Spine.Unity.SkeletonUtilityConstraint.OnDisable end.*/


        }
    });
    /*Spine.Unity.SkeletonUtilityConstraint end.*/

    /*Spine.Unity.SpineAttributeBase start.*/
    Bridge.define("Spine.Unity.SpineAttributeBase", {
        inherits: [UnityEngine.PropertyAttribute],
        fields: {
            dataField: null,
            startsWith: null,
            includeNone: false,
            fallbackToTextField: false,
            avoidGenericMenu: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttributeBase#init", this ); }

                this.dataField = "";
                this.startsWith = "";
                this.includeNone = true;
                this.fallbackToTextField = false;
                this.avoidGenericMenu = false;
            }
        }
    });
    /*Spine.Unity.SpineAttributeBase end.*/

    /*Spine.Unity.SpineAtlasRegion start.*/
    Bridge.define("Spine.Unity.SpineAtlasRegion", {
        inherits: [UnityEngine.PropertyAttribute],
        fields: {
            atlasAssetField: null
        },
        ctors: {
            ctor: function (atlasAssetField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasRegion#ctor", this ); }

                if (atlasAssetField === void 0) { atlasAssetField = ""; }

                this.$initialize();
                UnityEngine.PropertyAttribute.ctor.call(this);
                this.atlasAssetField = atlasAssetField;
            }
        }
    });
    /*Spine.Unity.SpineAtlasRegion end.*/

    /*Spine.Unity.SpineAttachment+Hierarchy start.*/
    /**
     * A struct that represents 3 strings that help identify and locate an attachment in a skeleton.
     *
     * @public
     * @class Spine.Unity.SpineAttachment.Hierarchy
     */
    Bridge.define("Spine.Unity.SpineAttachment.Hierarchy", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment.Hierarchy#getDefaultValue", this ); }
 return new Spine.Unity.SpineAttachment.Hierarchy(); }
            }
        },
        fields: {
            skin: null,
            slot: null,
            name: null
        },
        ctors: {
            $ctor1: function (fullPath) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment.Hierarchy#$ctor1", this ); }

                this.$initialize();
                var chunks = System.String.split(fullPath, System.Array.init([47], System.Char).map(function (i) {{ return String.fromCharCode(i); }}), null, 1);
                if (chunks.length === 0) {
                    this.skin = "";
                    this.slot = "";
                    this.name = "";
                    return;
                } else if (chunks.length < 2) {
                    throw new System.Exception("Cannot generate Attachment Hierarchy from string! Not enough components! [" + (fullPath || "") + "]");
                }
                this.skin = chunks[0];
                this.slot = chunks[1];
                this.name = "";
                for (var i = 2; i < chunks.length; i = (i + 1) | 0) {
                    this.name = (this.name || "") + (chunks[i] || "");
                }
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment.Hierarchy#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment.Hierarchy#getHashCode", this ); }

                var h = Bridge.addHash([3670596642, this.skin, this.slot, this.name]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment.Hierarchy#equals", this ); }

                if (!Bridge.is(o, Spine.Unity.SpineAttachment.Hierarchy)) {
                    return false;
                }
                return Bridge.equals(this.skin, o.skin) && Bridge.equals(this.slot, o.slot) && Bridge.equals(this.name, o.name);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment.Hierarchy#$clone", this ); }

                var s = to || new Spine.Unity.SpineAttachment.Hierarchy();
                s.skin = this.skin;
                s.slot = this.slot;
                s.name = this.name;
                return s;
            }
        }
    });
    /*Spine.Unity.SpineAttachment+Hierarchy end.*/

    /*Spine.Unity.SpineMesh start.*/
    Bridge.define("Spine.Unity.SpineMesh", {
        statics: {
            fields: {
                MeshHideflags: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineMesh#init", this ); }

                    this.MeshHideflags = 20;
                }
            },
            methods: {
                /*Spine.Unity.SpineMesh.NewSkeletonMesh:static start.*/
                /**
                 * Factory method for creating a new mesh for use in Spine components. This can be called in field initializers.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SpineMesh
                 * @memberof Spine.Unity.SpineMesh
                 * @return  {UnityEngine.Mesh}
                 */
                NewSkeletonMesh: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineMesh#NewSkeletonMesh", this ); }

                    var m = new UnityEngine.Mesh.ctor();
                    m.MarkDynamic();
                    m.name = "Skeleton Mesh";
                    m.hideFlags = Spine.Unity.SpineMesh.MeshHideflags;
                    return m;
                },
                /*Spine.Unity.SpineMesh.NewSkeletonMesh:static end.*/


            }
        }
    });
    /*Spine.Unity.SpineMesh end.*/

    /*Spine.Unity.SpineSpriteAtlasAsset+SavedRegionInfo start.*/
    Bridge.define("Spine.Unity.SpineSpriteAtlasAsset.SavedRegionInfo", {
        $kind: 1002,
        fields: {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            packingRotation: 0
        }
    });
    /*Spine.Unity.SpineSpriteAtlasAsset+SavedRegionInfo end.*/

    /*Spine.Unity.SubmeshInstruction start.*/
    /**
     * Instructions for how to generate a mesh or submesh: "Render this skeleton's slots: start slot, up to but not including endSlot, using this material."
     *
     * @public
     * @class Spine.Unity.SubmeshInstruction
     */
    Bridge.define("Spine.Unity.SubmeshInstruction", {
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SubmeshInstruction#getDefaultValue", this ); }
 return new Spine.Unity.SubmeshInstruction(); }
            }
        },
        fields: {
            skeleton: null,
            startSlot: 0,
            endSlot: 0,
            material: null,
            forceSeparate: false,
            preActiveClippingSlotSource: 0,
            rawTriangleCount: 0,
            rawVertexCount: 0,
            rawFirstVertexIndex: 0,
            hasClipping: false,
            hasPMAAdditiveSlot: false
        },
        props: {
            /**
             * The number of slots in this SubmeshInstruction's range. Not necessarily the number of attachments.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SubmeshInstruction
             * @function SlotCount
             * @type number
             */
            SlotCount: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SubmeshInstruction#SlotCount#get", this ); }

                    return ((this.endSlot - this.startSlot) | 0);
                }
            }
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SubmeshInstruction#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.Unity.SubmeshInstruction.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SubmeshInstruction#toString", this ); }

                return System.String.format("[SubmeshInstruction: slots {0} to {1}. (Material){2}. preActiveClippingSlotSource:{3}]", Bridge.box(this.startSlot, System.Int32), Bridge.box(((this.endSlot - 1) | 0), System.Int32), this.material == null ? "<none>" : this.material.name, Bridge.box(this.preActiveClippingSlotSource, System.Int32));
            },
            /*Spine.Unity.SubmeshInstruction.toString end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SubmeshInstruction#getHashCode", this ); }

                var h = Bridge.addHash([6756249098, this.skeleton, this.startSlot, this.endSlot, this.material, this.forceSeparate, this.preActiveClippingSlotSource, this.rawTriangleCount, this.rawVertexCount, this.rawFirstVertexIndex, this.hasClipping, this.hasPMAAdditiveSlot]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.SubmeshInstruction#equals", this ); }

                if (!Bridge.is(o, Spine.Unity.SubmeshInstruction)) {
                    return false;
                }
                return Bridge.equals(this.skeleton, o.skeleton) && Bridge.equals(this.startSlot, o.startSlot) && Bridge.equals(this.endSlot, o.endSlot) && Bridge.equals(this.material, o.material) && Bridge.equals(this.forceSeparate, o.forceSeparate) && Bridge.equals(this.preActiveClippingSlotSource, o.preActiveClippingSlotSource) && Bridge.equals(this.rawTriangleCount, o.rawTriangleCount) && Bridge.equals(this.rawVertexCount, o.rawVertexCount) && Bridge.equals(this.rawFirstVertexIndex, o.rawFirstVertexIndex) && Bridge.equals(this.hasClipping, o.hasClipping) && Bridge.equals(this.hasPMAAdditiveSlot, o.hasPMAAdditiveSlot);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.SubmeshInstruction#$clone", this ); }

                var s = to || new Spine.Unity.SubmeshInstruction();
                s.skeleton = this.skeleton;
                s.startSlot = this.startSlot;
                s.endSlot = this.endSlot;
                s.material = this.material;
                s.forceSeparate = this.forceSeparate;
                s.preActiveClippingSlotSource = this.preActiveClippingSlotSource;
                s.rawTriangleCount = this.rawTriangleCount;
                s.rawVertexCount = this.rawVertexCount;
                s.rawFirstVertexIndex = this.rawFirstVertexIndex;
                s.hasClipping = this.hasClipping;
                s.hasPMAAdditiveSlot = this.hasPMAAdditiveSlot;
                return s;
            }
        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.Unity.SubmeshInstruction end.*/

    /*Spine.Unity.UpdateMode start.*/
    Bridge.define("Spine.Unity.UpdateMode", {
        $kind: 6,
        statics: {
            fields: {
                Nothing: 0,
                OnlyAnimationStatus: 1,
                OnlyEventTimelines: 4,
                EverythingExceptMesh: 2,
                FullUpdate: 3
            }
        }
    });
    /*Spine.Unity.UpdateMode end.*/

    /*Spine.Unity.UpdateTiming start.*/
    Bridge.define("Spine.Unity.UpdateTiming", {
        $kind: 6,
        statics: {
            fields: {
                ManualUpdate: 0,
                InUpdate: 1,
                InFixedUpdate: 2,
                InLateUpdate: 3
            }
        }
    });
    /*Spine.Unity.UpdateTiming end.*/

    /*Spine.Unity.WaitForSpineAnimation start.*/
    /**
     * Use this as a condition-blocking yield instruction for Unity Coroutines.
     The routine will pause until the AnimationState.TrackEntry fires any of the
     configured events.
     <p />
     See the {@link }
     and {@link }
     for more information on when track events will be triggered.
     *
     * @public
     * @class Spine.Unity.WaitForSpineAnimation
     * @implements  System.Collections.IEnumerator
     */
    Bridge.define("Spine.Unity.WaitForSpineAnimation", {
        inherits: [System.Collections.IEnumerator],
        fields: {
            m_WasFired: false
        },
        props: {
            System$Collections$IEnumerator$Current: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimation#System$Collections$IEnumerator$Current#get", this ); }

                    return null;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimation#init", this ); }

                this.m_WasFired = false;
            },
            ctor: function (trackEntry, eventsToWaitFor) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimation#ctor", this ); }

                this.$initialize();
                this.SafeSubscribe(trackEntry, eventsToWaitFor);
            }
        },
        methods: {
            /*Spine.Unity.WaitForSpineAnimation.NowWaitFor start.*/
            /**
             * One optimization high-frequency YieldInstruction returns is to cache instances to minimize GC pressure.
             Use NowWaitFor to reuse the same instance of WaitForSpineAnimationComplete.
             *
             * @instance
             * @public
             * @this Spine.Unity.WaitForSpineAnimation
             * @memberof Spine.Unity.WaitForSpineAnimation
             * @param   {Spine.TrackEntry}                     trackEntry         
             * @param   {number}                               eventsToWaitFor
             * @return  {Spine.Unity.WaitForSpineAnimation}
             */
            NowWaitFor: function (trackEntry, eventsToWaitFor) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimation#NowWaitFor", this ); }

                this.SafeSubscribe(trackEntry, eventsToWaitFor);
                return this;
            },
            /*Spine.Unity.WaitForSpineAnimation.NowWaitFor end.*/

            /*Spine.Unity.WaitForSpineAnimation.System$Collections$IEnumerator$moveNext start.*/
            System$Collections$IEnumerator$moveNext: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimation#System$Collections$IEnumerator$moveNext", this ); }

                if (this.m_WasFired) {
                    Bridge.cast(this, System.Collections.IEnumerator).System$Collections$IEnumerator$reset(); // auto-reset for YieldInstruction reuse
                    return false;
                }

                return true;
            },
            /*Spine.Unity.WaitForSpineAnimation.System$Collections$IEnumerator$moveNext end.*/

            /*Spine.Unity.WaitForSpineAnimation.System$Collections$IEnumerator$reset start.*/
            System$Collections$IEnumerator$reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimation#System$Collections$IEnumerator$reset", this ); }

                this.m_WasFired = false;
            },
            /*Spine.Unity.WaitForSpineAnimation.System$Collections$IEnumerator$reset end.*/

            /*Spine.Unity.WaitForSpineAnimation.SafeSubscribe start.*/
            SafeSubscribe: function (trackEntry, eventsToWaitFor) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimation#SafeSubscribe", this ); }

                if (trackEntry == null) {
                    // Break immediately if trackEntry is null.
                    UnityEngine.Debug.LogWarning$1("TrackEntry was null. Coroutine will continue immediately.");
                    this.m_WasFired = true;
                } else {
                    if ((eventsToWaitFor & Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.Start) !== 0) {
                        trackEntry.addStart(Bridge.fn.cacheBind(this, this.HandleComplete));
                    }
                    if ((eventsToWaitFor & Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.Interrupt) !== 0) {
                        trackEntry.addInterrupt(Bridge.fn.cacheBind(this, this.HandleComplete));
                    }
                    if ((eventsToWaitFor & Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.End) !== 0) {
                        trackEntry.addEnd(Bridge.fn.cacheBind(this, this.HandleComplete));
                    }
                    if ((eventsToWaitFor & Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.Dispose) !== 0) {
                        trackEntry.addDispose(Bridge.fn.cacheBind(this, this.HandleComplete));
                    }
                    if ((eventsToWaitFor & Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.Complete) !== 0) {
                        trackEntry.addComplete(Bridge.fn.cacheBind(this, this.HandleComplete));
                    }
                }
            },
            /*Spine.Unity.WaitForSpineAnimation.SafeSubscribe end.*/

            /*Spine.Unity.WaitForSpineAnimation.HandleComplete start.*/
            HandleComplete: function (trackEntry) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimation#HandleComplete", this ); }

                this.m_WasFired = true;
            },
            /*Spine.Unity.WaitForSpineAnimation.HandleComplete end.*/


        }
    });
    /*Spine.Unity.WaitForSpineAnimation end.*/

    /*Spine.Unity.WaitForSpineAnimation+AnimationEventTypes start.*/
    Bridge.define("Spine.Unity.WaitForSpineAnimation.AnimationEventTypes", {
        $kind: 1006,
        statics: {
            fields: {
                Start: 1,
                Interrupt: 2,
                End: 4,
                Dispose: 8,
                Complete: 16
            }
        },
        $flags: true
    });
    /*Spine.Unity.WaitForSpineAnimation+AnimationEventTypes end.*/

    /*Spine.Unity.WaitForSpineEvent start.*/
    /**
     * Use this as a condition-blocking yield instruction for Unity Coroutines.
     The routine will pause until the AnimationState fires an event matching the given event name or EventData reference.
     *
     * @public
     * @class Spine.Unity.WaitForSpineEvent
     * @implements  System.Collections.IEnumerator
     */
    Bridge.define("Spine.Unity.WaitForSpineEvent", {
        inherits: [System.Collections.IEnumerator],
        fields: {
            m_TargetEvent: null,
            m_EventName: null,
            m_AnimationState: null,
            m_WasFired: false,
            m_unsubscribeAfterFiring: false
        },
        props: {
            /**
             * By default, WaitForSpineEvent will unsubscribe from the event immediately after it fires a correct matching event.
             If you want to reuse this WaitForSpineEvent instance on the same event, you can set this to false.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.WaitForSpineEvent
             * @function WillUnsubscribeAfterFiring
             * @type boolean
             */
            WillUnsubscribeAfterFiring: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#WillUnsubscribeAfterFiring#get", this ); }

                    return this.m_unsubscribeAfterFiring;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#WillUnsubscribeAfterFiring#set", this ); }

                    this.m_unsubscribeAfterFiring = value;
                }
            },
            System$Collections$IEnumerator$Current: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#System$Collections$IEnumerator$Current#get", this ); }

                    return null;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#init", this ); }

                this.m_WasFired = false;
                this.m_unsubscribeAfterFiring = false;
            },
            ctor: function (state, eventDataReference, unsubscribeAfterFiring) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#ctor", this ); }

                if (unsubscribeAfterFiring === void 0) { unsubscribeAfterFiring = true; }

                this.$initialize();
                this.Subscribe(state, eventDataReference, unsubscribeAfterFiring);
            },
            $ctor2: function (skeletonAnimation, eventDataReference, unsubscribeAfterFiring) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#$ctor2", this ); }

                if (unsubscribeAfterFiring === void 0) { unsubscribeAfterFiring = true; }

                this.$initialize();
                // If skeletonAnimation is invalid, its state will be null. Subscribe handles null states just fine.
                this.Subscribe(skeletonAnimation.state, eventDataReference, unsubscribeAfterFiring);
            },
            $ctor1: function (state, eventName, unsubscribeAfterFiring) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#$ctor1", this ); }

                if (unsubscribeAfterFiring === void 0) { unsubscribeAfterFiring = true; }

                this.$initialize();
                this.SubscribeByName(state, eventName, unsubscribeAfterFiring);
            },
            $ctor3: function (skeletonAnimation, eventName, unsubscribeAfterFiring) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#$ctor3", this ); }

                if (unsubscribeAfterFiring === void 0) { unsubscribeAfterFiring = true; }

                this.$initialize();
                // If skeletonAnimation is invalid, its state will be null. Subscribe handles null states just fine.
                this.SubscribeByName(skeletonAnimation.state, eventName, unsubscribeAfterFiring);
            }
        },
        methods: {
            /*Spine.Unity.WaitForSpineEvent.Subscribe start.*/
            Subscribe: function (state, eventDataReference, unsubscribe) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#Subscribe", this ); }

                if (state == null) {
                    UnityEngine.Debug.LogWarning$1("AnimationState argument was null. Coroutine will continue immediately.");
                    this.m_WasFired = true;
                    return;
                } else if (eventDataReference == null) {
                    UnityEngine.Debug.LogWarning$1("eventDataReference argument was null. Coroutine will continue immediately.");
                    this.m_WasFired = true;
                    return;
                }

                this.m_AnimationState = state;
                this.m_TargetEvent = eventDataReference;
                state.addEvent(Bridge.fn.cacheBind(this, this.HandleAnimationStateEvent));

                this.m_unsubscribeAfterFiring = unsubscribe;

            },
            /*Spine.Unity.WaitForSpineEvent.Subscribe end.*/

            /*Spine.Unity.WaitForSpineEvent.SubscribeByName start.*/
            SubscribeByName: function (state, eventName, unsubscribe) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#SubscribeByName", this ); }

                if (state == null) {
                    UnityEngine.Debug.LogWarning$1("AnimationState argument was null. Coroutine will continue immediately.");
                    this.m_WasFired = true;
                    return;
                } else if (System.String.isNullOrEmpty(eventName)) {
                    UnityEngine.Debug.LogWarning$1("eventName argument was null. Coroutine will continue immediately.");
                    this.m_WasFired = true;
                    return;
                }

                this.m_AnimationState = state;
                this.m_EventName = eventName;
                state.addEvent(Bridge.fn.cacheBind(this, this.HandleAnimationStateEventByName));

                this.m_unsubscribeAfterFiring = unsubscribe;
            },
            /*Spine.Unity.WaitForSpineEvent.SubscribeByName end.*/

            /*Spine.Unity.WaitForSpineEvent.HandleAnimationStateEventByName start.*/
            HandleAnimationStateEventByName: function (trackEntry, e) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#HandleAnimationStateEventByName", this ); }

                this.m_WasFired = !!(this.m_WasFired | (Bridge.referenceEquals(e.Data.Name, this.m_EventName))); // Check event name string match.
                if (this.m_WasFired && this.m_unsubscribeAfterFiring) {
                    this.m_AnimationState.removeEvent(Bridge.fn.cacheBind(this, this.HandleAnimationStateEventByName));
                } // Unsubscribe after correct event fires.
            },
            /*Spine.Unity.WaitForSpineEvent.HandleAnimationStateEventByName end.*/

            /*Spine.Unity.WaitForSpineEvent.HandleAnimationStateEvent start.*/
            HandleAnimationStateEvent: function (trackEntry, e) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#HandleAnimationStateEvent", this ); }

                this.m_WasFired = !!(this.m_WasFired | (Bridge.referenceEquals(e.Data, this.m_TargetEvent))); // Check event data reference match.
                if (this.m_WasFired && this.m_unsubscribeAfterFiring) {
                    this.m_AnimationState.removeEvent(Bridge.fn.cacheBind(this, this.HandleAnimationStateEvent));
                } // Usubscribe after correct event fires.
            },
            /*Spine.Unity.WaitForSpineEvent.HandleAnimationStateEvent end.*/

            /*Spine.Unity.WaitForSpineEvent.NowWaitFor start.*/
            NowWaitFor: function (state, eventDataReference, unsubscribeAfterFiring) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#NowWaitFor", this ); }

                if (unsubscribeAfterFiring === void 0) { unsubscribeAfterFiring = true; }
                Bridge.cast(this, System.Collections.IEnumerator).System$Collections$IEnumerator$reset();
                this.Clear(state);
                this.Subscribe(state, eventDataReference, unsubscribeAfterFiring);

                return this;
            },
            /*Spine.Unity.WaitForSpineEvent.NowWaitFor end.*/

            /*Spine.Unity.WaitForSpineEvent.NowWaitFor$1 start.*/
            NowWaitFor$1: function (state, eventName, unsubscribeAfterFiring) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#NowWaitFor$1", this ); }

                if (unsubscribeAfterFiring === void 0) { unsubscribeAfterFiring = true; }
                Bridge.cast(this, System.Collections.IEnumerator).System$Collections$IEnumerator$reset();
                this.Clear(state);
                this.SubscribeByName(state, eventName, unsubscribeAfterFiring);

                return this;
            },
            /*Spine.Unity.WaitForSpineEvent.NowWaitFor$1 end.*/

            /*Spine.Unity.WaitForSpineEvent.Clear start.*/
            Clear: function (state) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#Clear", this ); }

                state.removeEvent(Bridge.fn.cacheBind(this, this.HandleAnimationStateEvent));
                state.removeEvent(Bridge.fn.cacheBind(this, this.HandleAnimationStateEventByName));
            },
            /*Spine.Unity.WaitForSpineEvent.Clear end.*/

            /*Spine.Unity.WaitForSpineEvent.System$Collections$IEnumerator$moveNext start.*/
            System$Collections$IEnumerator$moveNext: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#System$Collections$IEnumerator$moveNext", this ); }

                if (this.m_WasFired) {
                    Bridge.cast(this, System.Collections.IEnumerator).System$Collections$IEnumerator$reset(); // auto-reset for YieldInstruction reuse
                    return false;
                }

                return true;
            },
            /*Spine.Unity.WaitForSpineEvent.System$Collections$IEnumerator$moveNext end.*/

            /*Spine.Unity.WaitForSpineEvent.System$Collections$IEnumerator$reset start.*/
            System$Collections$IEnumerator$reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#System$Collections$IEnumerator$reset", this ); }

                this.m_WasFired = false;
            },
            /*Spine.Unity.WaitForSpineEvent.System$Collections$IEnumerator$reset end.*/


        },
        overloads: {
            "NowWaitFor(Spine.AnimationState, string, bool)": "NowWaitFor$1"
        }
    });
    /*Spine.Unity.WaitForSpineEvent end.*/

    /*Spine.Unity.WaitForSpineTrackEntryEnd start.*/
    /**
     * Use this as a condition-blocking yield instruction for Unity Coroutines.
     The routine will pause until the AnimationState.TrackEntry fires its End event.
     *
     * @public
     * @class Spine.Unity.WaitForSpineTrackEntryEnd
     * @implements  System.Collections.IEnumerator
     */
    Bridge.define("Spine.Unity.WaitForSpineTrackEntryEnd", {
        inherits: [System.Collections.IEnumerator],
        fields: {
            m_WasFired: false
        },
        props: {
            System$Collections$IEnumerator$Current: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineTrackEntryEnd#System$Collections$IEnumerator$Current#get", this ); }

                    return null;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineTrackEntryEnd#init", this ); }

                this.m_WasFired = false;
            },
            ctor: function (trackEntry) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineTrackEntryEnd#ctor", this ); }

                this.$initialize();
                this.SafeSubscribe(trackEntry);
            }
        },
        methods: {
            /*Spine.Unity.WaitForSpineTrackEntryEnd.HandleEnd start.*/
            HandleEnd: function (trackEntry) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineTrackEntryEnd#HandleEnd", this ); }

                this.m_WasFired = true;
            },
            /*Spine.Unity.WaitForSpineTrackEntryEnd.HandleEnd end.*/

            /*Spine.Unity.WaitForSpineTrackEntryEnd.SafeSubscribe start.*/
            SafeSubscribe: function (trackEntry) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineTrackEntryEnd#SafeSubscribe", this ); }

                if (trackEntry == null) {
                    // Break immediately if trackEntry is null.
                    UnityEngine.Debug.LogWarning$1("TrackEntry was null. Coroutine will continue immediately.");
                    this.m_WasFired = true;
                } else {
                    trackEntry.addEnd(Bridge.fn.cacheBind(this, this.HandleEnd));
                }
            },
            /*Spine.Unity.WaitForSpineTrackEntryEnd.SafeSubscribe end.*/

            /*Spine.Unity.WaitForSpineTrackEntryEnd.NowWaitFor start.*/
            /**
             * One optimization high-frequency YieldInstruction returns is to cache instances to minimize GC pressure.
             Use NowWaitFor to reuse the same instance of WaitForSpineAnimationEnd.
             *
             * @instance
             * @public
             * @this Spine.Unity.WaitForSpineTrackEntryEnd
             * @memberof Spine.Unity.WaitForSpineTrackEntryEnd
             * @param   {Spine.TrackEntry}                         trackEntry
             * @return  {Spine.Unity.WaitForSpineTrackEntryEnd}
             */
            NowWaitFor: function (trackEntry) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineTrackEntryEnd#NowWaitFor", this ); }

                this.SafeSubscribe(trackEntry);
                return this;
            },
            /*Spine.Unity.WaitForSpineTrackEntryEnd.NowWaitFor end.*/

            /*Spine.Unity.WaitForSpineTrackEntryEnd.System$Collections$IEnumerator$moveNext start.*/
            System$Collections$IEnumerator$moveNext: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineTrackEntryEnd#System$Collections$IEnumerator$moveNext", this ); }

                if (this.m_WasFired) {
                    Bridge.cast(this, System.Collections.IEnumerator).System$Collections$IEnumerator$reset(); // auto-reset for YieldInstruction reuse
                    return false;
                }

                return true;
            },
            /*Spine.Unity.WaitForSpineTrackEntryEnd.System$Collections$IEnumerator$moveNext end.*/

            /*Spine.Unity.WaitForSpineTrackEntryEnd.System$Collections$IEnumerator$reset start.*/
            System$Collections$IEnumerator$reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineTrackEntryEnd#System$Collections$IEnumerator$reset", this ); }

                this.m_WasFired = false;
            },
            /*Spine.Unity.WaitForSpineTrackEntryEnd.System$Collections$IEnumerator$reset end.*/


        }
    });
    /*Spine.Unity.WaitForSpineTrackEntryEnd end.*/

    /*store start.*/
    Bridge.define("store", {
        inherits: [UnityEngine.MonoBehaviour],
        methods: {
            /*store.click start.*/
            click: function () {
if ( TRACE ) { TRACE( "store#click", this ); }

                Luna.Unity.LifeCycle.GameEnded();
                Luna.Unity.Playable.InstallFullGame();
                Luna.Unity.Analytics.LogEvent$1("Store", 0);
                LevelController.Instance.store.SetActive(true);
            },
            /*store.click end.*/


        }
    });
    /*store end.*/

    /*UIFollowObject start.*/
    Bridge.define("UIFollowObject", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            target: null
        },
        methods: {
            /*UIFollowObject.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "UIFollowObject#Update", this ); }

                this.transform.position = UnityEngine.Camera.main.WorldToScreenPoint(this.target.transform.position);
            },
            /*UIFollowObject.Update end.*/


        }
    });
    /*UIFollowObject end.*/

    /*UserConfig start.*/
    Bridge.define("UserConfig", {
        statics: {
            fields: {
                _instance: null
            },
            props: {
                Instance: {
                    get: function () {
if ( TRACE ) { TRACE( "UserConfig#Instance#get", this ); }

                        if (UserConfig._instance == null) {
                            UserConfig._instance = new UserConfig();
                        }
                        return UserConfig._instance;
                    }
                }
            }
        },
        fields: {
            curLevel: 0,
            bestLevel: 0,
            coin: 0,
            rate: false,
            music: false,
            sound: false,
            vibrate: false,
            hasAds: false,
            dailyLogin: 0,
            totalSpend: 0,
            totalEarn: 0,
            winLevel: 0,
            levelShowRemoveAds: 0,
            amountScrewdrive: 0,
            amountBomb: 0,
            amountInter: 0,
            amountPlay: 0,
            isLoading: false,
            isNewDay: false,
            isNewUser: false
        },
        props: {
            CurLevel: {
                get: function () {
if ( TRACE ) { TRACE( "UserConfig#CurLevel#get", this ); }

                    return this.curLevel;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UserConfig#CurLevel#set", this ); }

                    this.curLevel = value;
                    if (this.curLevel > this.BestLevel) {
                        this.BestLevel = value;
                    }
                }
            },
            RetendDay: {
                get: function () {
if ( TRACE ) { TRACE( "UserConfig#RetendDay#get", this ); }

                    return UnityEngine.PlayerPrefs.GetInt(GameplayVariables.retendDay, 0);
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UserConfig#RetendDay#set", this ); }

                    UnityEngine.PlayerPrefs.SetInt(GameplayVariables.retendDay, value);
                }
            },
            DayPlayed: {
                get: function () {
if ( TRACE ) { TRACE( "UserConfig#DayPlayed#get", this ); }

                    return UnityEngine.PlayerPrefs.GetInt(GameplayVariables.dayPlayed, 0);
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UserConfig#DayPlayed#set", this ); }

                    UnityEngine.PlayerPrefs.SetInt(GameplayVariables.dayPlayed, value);
                }
            },
            Sound: {
                get: function () {
if ( TRACE ) { TRACE( "UserConfig#Sound#get", this ); }

                    return this.sound;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UserConfig#Sound#set", this ); }

                    this.sound = value;
                    UnityEngine.PlayerPrefs.SetInt(GameplayVariables.sound, value ? 1 : 0);
                }
            },
            Music: {
                get: function () {
if ( TRACE ) { TRACE( "UserConfig#Music#get", this ); }

                    return this.music;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UserConfig#Music#set", this ); }

                    this.music = value;
                    UnityEngine.PlayerPrefs.SetInt(GameplayVariables.music, value ? 1 : 0);
                }
            },
            Vibrate: {
                get: function () {
if ( TRACE ) { TRACE( "UserConfig#Vibrate#get", this ); }

                    return this.vibrate;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UserConfig#Vibrate#set", this ); }

                    this.vibrate = value;
                    UnityEngine.PlayerPrefs.SetInt(GameplayVariables.vibrate, value ? 1 : 0);
                }
            },
            BestLevel: {
                get: function () {
if ( TRACE ) { TRACE( "UserConfig#BestLevel#get", this ); }

                    return this.bestLevel;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UserConfig#BestLevel#set", this ); }

                    this.bestLevel = value;
                    /* CGTeamBridge.instance.SetPropertyLevel((bestLevel - 1).ToString());*/
                    UnityEngine.PlayerPrefs.SetInt(GameplayVariables.bestLevel, value);
                }
            },
            Coin: {
                get: function () {
if ( TRACE ) { TRACE( "UserConfig#Coin#get", this ); }

                    return this.coin;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UserConfig#Coin#set", this ); }

                    this.coin = value;
                    UnityEngine.PlayerPrefs.SetInt(GameplayVariables.coin, value);
                }
            },
            Rate: {
                get: function () {
if ( TRACE ) { TRACE( "UserConfig#Rate#get", this ); }

                    return this.rate;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UserConfig#Rate#set", this ); }

                    this.rate = value;
                    UnityEngine.PlayerPrefs.SetInt(GameplayVariables.rate, value ? 1 : 0);
                }
            },
            HasAds: {
                get: function () {
if ( TRACE ) { TRACE( "UserConfig#HasAds#get", this ); }

                    return this.hasAds;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UserConfig#HasAds#set", this ); }

                    this.hasAds = value;
                    UnityEngine.PlayerPrefs.SetInt(GameplayVariables.hasAds, value ? 1 : 0);
                }
            },
            DailyLogin: {
                get: function () {
if ( TRACE ) { TRACE( "UserConfig#DailyLogin#get", this ); }

                    return this.dailyLogin;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UserConfig#DailyLogin#set", this ); }

                    this.dailyLogin = value;
                    UnityEngine.PlayerPrefs.SetInt(GameplayVariables.dailyLogin, value);
                }
            },
            TotalSpend: {
                get: function () {
if ( TRACE ) { TRACE( "UserConfig#TotalSpend#get", this ); }

                    return this.totalSpend;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UserConfig#TotalSpend#set", this ); }

                    this.totalSpend = value;
                    /* CGTeamBridge.instance.SetPropertyCoinEarn(totalSpend.ToString());*/
                    UnityEngine.PlayerPrefs.SetInt(GameplayVariables.totalSpend, value);
                }
            },
            TotalEarn: {
                get: function () {
if ( TRACE ) { TRACE( "UserConfig#TotalEarn#get", this ); }

                    return this.totalEarn;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UserConfig#TotalEarn#set", this ); }

                    this.totalEarn = value;
                    /* CGTeamBridge.instance.SetPropertyCoinEarn(totalEarn.ToString());*/
                    UnityEngine.PlayerPrefs.SetInt(GameplayVariables.totalEarn, value);
                }
            },
            WinLevel: {
                get: function () {
if ( TRACE ) { TRACE( "UserConfig#WinLevel#get", this ); }

                    return this.winLevel;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UserConfig#WinLevel#set", this ); }

                    this.winLevel = value;
                    UnityEngine.PlayerPrefs.SetInt(GameplayVariables.winLevel, value);
                }
            },
            AmountInter: {
                get: function () {
if ( TRACE ) { TRACE( "UserConfig#AmountInter#get", this ); }

                    return this.amountInter;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UserConfig#AmountInter#set", this ); }

                    this.amountInter = value;
                    UnityEngine.PlayerPrefs.SetInt(GameplayVariables.amountInter, value);
                }
            },
            AmountBomb: {
                get: function () {
if ( TRACE ) { TRACE( "UserConfig#AmountBomb#get", this ); }

                    return this.amountBomb;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UserConfig#AmountBomb#set", this ); }

                    this.amountBomb = value;
                    UnityEngine.PlayerPrefs.SetInt(GameplayVariables.amountBomb, value);
                }
            },
            AmountScrewdrive: {
                get: function () {
if ( TRACE ) { TRACE( "UserConfig#AmountScrewdrive#get", this ); }

                    return this.amountScrewdrive;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UserConfig#AmountScrewdrive#set", this ); }

                    this.amountScrewdrive = value;
                    UnityEngine.PlayerPrefs.SetInt(GameplayVariables.amountScrewdrive, value);
                }
            },
            LevelShowRemoveAds: {
                get: function () {
if ( TRACE ) { TRACE( "UserConfig#LevelShowRemoveAds#get", this ); }

                    return this.levelShowRemoveAds;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UserConfig#LevelShowRemoveAds#set", this ); }

                    this.levelShowRemoveAds = value;
                    UnityEngine.PlayerPrefs.SetInt(GameplayVariables.levelShowRemoveAds, value);
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "UserConfig#init", this ); }

                this.amountPlay = 0;
                this.isLoading = true;
                this.isNewDay = false;
                this.isNewUser = false;
            }
        },
        methods: {
            /*UserConfig.Init start.*/
            Init: function () {
if ( TRACE ) { TRACE( "UserConfig#Init", this ); }

                if (UnityEngine.PlayerPrefs.GetInt("IsFirstPlay") === 0) {
                    UnityEngine.PlayerPrefs.SetInt("IsFirstPlay", 1);
                    this.isNewUser = true;
                }

                this.isLoading = true;

                this.bestLevel = UnityEngine.PlayerPrefs.GetInt(GameplayVariables.bestLevel, 1);
                this.coin = UnityEngine.PlayerPrefs.GetInt(GameplayVariables.coin, 0);
                this.amountInter = UnityEngine.PlayerPrefs.GetInt(GameplayVariables.amountInter, 0);
                this.dailyLogin = UnityEngine.PlayerPrefs.GetInt(GameplayVariables.dailyLogin, 0);
                this.totalSpend = UnityEngine.PlayerPrefs.GetInt(GameplayVariables.totalSpend, 0);
                this.totalEarn = UnityEngine.PlayerPrefs.GetInt(GameplayVariables.totalEarn, 0);
                this.winLevel = UnityEngine.PlayerPrefs.GetInt(GameplayVariables.winLevel, 0);
                this.amountScrewdrive = UnityEngine.PlayerPrefs.GetInt(GameplayVariables.amountScrewdrive, 2);
                this.amountBomb = UnityEngine.PlayerPrefs.GetInt(GameplayVariables.amountBomb, 2);
                this.levelShowRemoveAds = UnityEngine.PlayerPrefs.GetInt(GameplayVariables.levelShowRemoveAds, 0);
                this.rate = UnityEngine.PlayerPrefs.GetInt(GameplayVariables.rate, 0) === 1 ? true : false;
                this.music = UnityEngine.PlayerPrefs.GetInt(GameplayVariables.music, 1) === 1 ? true : false;
                this.sound = UnityEngine.PlayerPrefs.GetInt(GameplayVariables.sound, 1) === 1 ? true : false;
                this.vibrate = UnityEngine.PlayerPrefs.GetInt(GameplayVariables.vibrate, 1) === 1 ? true : false;
                this.hasAds = UnityEngine.PlayerPrefs.GetInt(GameplayVariables.hasAds, 1) === 1 ? true : false;

                this.curLevel = this.bestLevel;
            },
            /*UserConfig.Init end.*/

            /*UserConfig.CanShowDailyBonus start.*/
            CanShowDailyBonus: function () {
if ( TRACE ) { TRACE( "UserConfig#CanShowDailyBonus", this ); }

                var canShowDaily = false;
                if (this.DailyLogin === 0) {
                    /* CGTeamBridge.instance.SetPropertyDayPlayed((DailyLogin + 1).ToString());
                    CGTeamBridge.instance.SetPropertyRetendDay("0");*/
                    UnityEngine.PlayerPrefs.SetInt("retent_type", 0);
                    return true;
                }

                var lastTimeOpen = System.DateTime.parse(UnityEngine.PlayerPrefs.GetString(GameplayVariables.lastTimeOpen, System.DateTime.format(System.DateTime.getNow())));
                UnityEngine.Debug.Log$1(UnityEngine.PlayerPrefs.GetString(GameplayVariables.lastTimeOpen, System.DateTime.format(System.DateTime.getNow())));
                var currentTimeDate = System.DateTime.getDate(System.DateTime.getNow());
                var dayOpen = (System.DateTime.subdd(currentTimeDate, lastTimeOpen)).getDays();
                if (dayOpen > 0) {
                    var retend_type = UnityEngine.PlayerPrefs.GetInt("retent_type");
                    retend_type = (retend_type + dayOpen) | 0;
                    UnityEngine.PlayerPrefs.SetInt("retent_type", retend_type);
                    /* CGTeamBridge.instance.SetPropertyRetendDay(retend_type.ToString());

                    CGTeamBridge.instance.SetPropertyDayPlayed((DailyLogin + 1).ToString());*/
                    canShowDaily = true;
                }
                return canShowDaily;
            },
            /*UserConfig.CanShowDailyBonus end.*/

            /*UserConfig.HasTurnOffInternet start.*/
            HasTurnOffInternet: function () {
if ( TRACE ) { TRACE( "UserConfig#HasTurnOffInternet", this ); }

                return UnityEngine.Application.internetReachability === UnityEngine.NetworkReachability.NotReachable;
            },
            /*UserConfig.HasTurnOffInternet end.*/


        }
    });
    /*UserConfig end.*/

    /*Vibration start.*/
    Bridge.define("Vibration", {
        statics: {
            fields: {
                unityPlayer: null,
                currentActivity: null,
                vibrator: null,
                timeVibrate: 0,
                currentStrengthVibrate: System.Int64(0)
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Vibration#init", this ); }

                    this.timeVibrate = 0;
                    this.currentStrengthVibrate = System.Int64(0);
                }
            },
            methods: {
                /*Vibration.Vibrate:static start.*/
                Vibrate: function () {
if ( TRACE ) { TRACE( "Vibration#Vibrate", this ); }

                    if (UnityEngine.Time.time >= Vibration.timeVibrate) {
                        Vibration.timeVibrate = UnityEngine.Time.time + 0.1;

                        //            if (isAndroid())
                        //                vibrator.Call("vibrate");
                        //            else
                        //            {
                        //#if UNITY_IPHONE || UNITY_IOS
                        //Handheld.Vibrate();
                        //#endif
                        //            }
                    }
                },
                /*Vibration.Vibrate:static end.*/

                /*Vibration.Vibrate$1:static start.*/
                Vibrate$1: function (milliseconds) {
if ( TRACE ) { TRACE( "Vibration#Vibrate$1", this ); }

                    if (!UserConfig.Instance.Vibrate) {
                        return;
                    }

                    try {
                        if (UnityEngine.Time.time >= Vibration.timeVibrate) {
                            Vibration.timeVibrate = UnityEngine.Time.time + 0.1;
                            Vibration.currentStrengthVibrate = milliseconds;

                            //                if (isAndroid())
                            //                    vibrator.Call("vibrate", milliseconds);
                            //                else
                            //                {
                            //#if UNITY_IPHONE || UNITY_IOS
                            //Handheld.Vibrate();
                            //#endif
                            //                }
                        } else if (milliseconds.gt(Vibration.currentStrengthVibrate)) {
                            Vibration.currentStrengthVibrate = milliseconds;
                            Vibration.Cancel();

                            //                if (isAndroid())
                            //                    vibrator.Call("vibrate", milliseconds);
                            //                else
                            //                {
                            //#if UNITY_IPHONE || UNITY_IOS
                            //            Handheld.Vibrate();
                            //#endif
                            //                }
                        }
                    } catch (e) {
                        e = System.Exception.create(e);

                    }
                },
                /*Vibration.Vibrate$1:static end.*/

                /*Vibration.Vibrate$2:static start.*/
                Vibrate$2: function (pattern, repeat) {
if ( TRACE ) { TRACE( "Vibration#Vibrate$2", this ); }

                    //        if (isAndroid())
                    //            vibrator.Call("vibrate", pattern, repeat);
                    //        else
                    //        {
                    //#if UNITY_IPHONE || UNITY_IOS
                    //Handheld.Vibrate();
                    //#endif
                    //        }
                },
                /*Vibration.Vibrate$2:static end.*/

                /*Vibration.HasVibrator:static start.*/
                HasVibrator: function () {
if ( TRACE ) { TRACE( "Vibration#HasVibrator", this ); }

                    return Vibration.isAndroid();
                },
                /*Vibration.HasVibrator:static end.*/

                /*Vibration.Cancel:static start.*/
                Cancel: function () {
if ( TRACE ) { TRACE( "Vibration#Cancel", this ); }

                    //if (isAndroid())
                    //    vibrator.Call("cancel");
                },
                /*Vibration.Cancel:static end.*/

                /*Vibration.isAndroid:static start.*/
                isAndroid: function () {
if ( TRACE ) { TRACE( "Vibration#isAndroid", this ); }

                    return true;
                    //#if UNITY_ANDROID && !UNITY_EDITOR
                    //	return true;
                    //#else
                    //        return false;
                    //#endif

                },
                /*Vibration.isAndroid:static end.*/


            }
        }
    });
    /*Vibration end.*/

    /*wall start.*/
    Bridge.define("wall", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            exploreParticle: null
        },
        methods: {
            /*wall.OnTriggerEnter2D start.*/
            OnTriggerEnter2D: function (other) {
if ( TRACE ) { TRACE( "wall#OnTriggerEnter2D", this ); }

                other.gameObject.SetActive(false);
                //LevelController.Instance.ScrewBar();

                if (UnityEngine.Component.op_Inequality(this.exploreParticle, null)) {
                    this.exploreParticle.transform.position = other.transform.position.$clone();
                    this.exploreParticle.gameObject.SetActive(true);
                    this.exploreParticle.Play();
                }
            },
            /*wall.OnTriggerEnter2D end.*/


        }
    });
    /*wall end.*/

    /*CameraResize start.*/
    Bridge.define("CameraResize", {
        inherits: function () {
if ( TRACE ) { TRACE( "CameraResize#inherits", this ); }
 return [Singleton$1(CameraResize)]; },
        methods: {
            /*CameraResize.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "CameraResize#Start", this ); }

                this.ResizeCamera(UnityEngine.Camera.main.orthographicSize);
            },
            /*CameraResize.Start end.*/

            /*CameraResize.ResizeCamera start.*/
            ResizeCamera: function (defaultSize) {
if ( TRACE ) { TRACE( "CameraResize#ResizeCamera", this ); }

                var height = UnityEngine.Screen.height;
                var width = UnityEngine.Screen.width;

                var ratio = width / height;
                var ratioDefault = 0.5625;
                if (ratio < ratioDefault) {
                    UnityEngine.Camera.main.orthographicSize = defaultSize / (ratio / ratioDefault);
                }
            },
            /*CameraResize.ResizeCamera end.*/


        }
    });
    /*CameraResize end.*/

    /*GameManager start.*/
    Bridge.define("GameManager", {
        inherits: function () {
if ( TRACE ) { TRACE( "GameManager#inherits", this ); }
 return [Singleton$1(GameManager)]; },
        statics: {
            fields: {
                RADIUS_CHECK_BAR: 0,
                MAX_LEVEL: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "GameManager#init", this ); }

                    this.RADIUS_CHECK_BAR = 0.34;
                    this.MAX_LEVEL = 25;
                }
            }
        },
        fields: {
            canControl: false,
            currentLevel: null,
            layerBolt: null,
            layerBar: null,
            layerBoardHole: null,
            layerBarHole: null,
            startTime: 0,
            count: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "GameManager#init", this ); }

                this.layerBolt = new UnityEngine.LayerMask();
                this.layerBar = new UnityEngine.LayerMask();
                this.layerBoardHole = new UnityEngine.LayerMask();
                this.layerBarHole = new UnityEngine.LayerMask();
                this.canControl = true;
                this.count = 0;
            }
        },
        methods: {
            /*GameManager.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "GameManager#Start", this ); }

                /* SoundManager.InitInstance(transform);*/
                this.canControl = true;
            },
            /*GameManager.Start end.*/

            /*GameManager.EndGame start.*/
            EndGame: function (win, delay) {
if ( TRACE ) { TRACE( "GameManager#EndGame", this ); }

                if (delay === void 0) { delay = 1.5; }

                if (win) {
                    AudioManager.instance.PlayContifieSound();
                    this.Invoke("OnWin", delay);
                } else {
                    //SoundManager.instance.PlaySound("Lose");
                }
            },
            /*GameManager.EndGame end.*/

            /*GameManager.OnWin start.*/
            OnWin: function () {
if ( TRACE ) { TRACE( "GameManager#OnWin", this ); }

                AudioManager.instance.PlayWinSound();
                Luna.Unity.LifeCycle.GameEnded();
                Luna.Unity.Playable.InstallFullGame();
                Luna.Unity.Analytics.LogEvent$1("Store", 0);
                LevelController.Instance.store.SetActive(true);
            },
            /*GameManager.OnWin end.*/

            /*GameManager.LoadAsset start.*/
            LoadAsset: function (assetName) {
if ( TRACE ) { TRACE( "GameManager#LoadAsset", this ); }

                var gameObject = null;
                gameObject = UnityEngine.Resources.Load(UnityEngine.GameObject, assetName);

                if (UnityEngine.GameObject.op_Inequality(gameObject, null)) {
                    return gameObject;
                }
                return null;
            },
            /*GameManager.LoadAsset end.*/

            /*GameManager.InstantiatePrefab start.*/
            InstantiatePrefab: function (assetName) {
if ( TRACE ) { TRACE( "GameManager#InstantiatePrefab", this ); }

                if (System.String.isNullOrEmpty(assetName)) {
                    return null;
                }
                var gameObject = this.LoadAsset(assetName);
                if (UnityEngine.GameObject.op_Inequality(gameObject, null)) {
                    var gameObject2 = ObjectPoolExtensions.Spawn$6(gameObject);
                    return gameObject2;
                }
                return gameObject;
            },
            /*GameManager.InstantiatePrefab end.*/


        }
    });
    /*GameManager end.*/

    /*Spine.CurveTimeline start.*/
    /**
     * The base class for timelines that interpolate between frame values using stepped, linear, or a Bezier curve.
     *
     * @abstract
     * @public
     * @class Spine.CurveTimeline
     * @augments Spine.Timeline
     */
    Bridge.define("Spine.CurveTimeline", {
        inherits: [Spine.Timeline],
        statics: {
            fields: {
                LINEAR: 0,
                STEPPED: 0,
                BEZIER: 0,
                BEZIER_SIZE: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.CurveTimeline#init", this ); }

                    this.LINEAR = 0;
                    this.STEPPED = 1;
                    this.BEZIER = 2;
                    this.BEZIER_SIZE = 18;
                }
            }
        },
        fields: {
            curves: null
        },
        ctors: {
            /**
             * The number of key frames for this timeline.
             *
             * @instance
             * @public
             * @this Spine.CurveTimeline
             * @memberof Spine.CurveTimeline
             * @param   {number}            frameCount     
             * @param   {number}            bezierCount    The maximum number of Bezier curves. See {@link }.
             * @param   {Array.<string>}    propertyIds    Unique identifiers for the properties the timeline modifies.
             * @return  {void}
             */
            ctor: function (frameCount, bezierCount, propertyIds) {
if ( TRACE ) { TRACE( "Spine.CurveTimeline#ctor", this ); }

                if (propertyIds === void 0) { propertyIds = []; }

                this.$initialize();
                Spine.Timeline.ctor.call(this, frameCount, propertyIds);
                this.curves = System.Array.init(((frameCount + Bridge.Int.mul(bezierCount, Spine.CurveTimeline.BEZIER_SIZE)) | 0), 0, System.Single);
                this.curves[((frameCount - 1) | 0)] = Spine.CurveTimeline.STEPPED;
            }
        },
        methods: {
            /*Spine.CurveTimeline.SetLinear start.*/
            /**
             * Sets the specified frame to linear interpolation.
             *
             * @instance
             * @public
             * @this Spine.CurveTimeline
             * @memberof Spine.CurveTimeline
             * @param   {number}    frame    Between 0 and <pre><code>frameCount - 1</code></pre>, inclusive.
             * @return  {void}
             */
            SetLinear: function (frame) {
if ( TRACE ) { TRACE( "Spine.CurveTimeline#SetLinear", this ); }

                this.curves[frame] = Spine.CurveTimeline.LINEAR;
            },
            /*Spine.CurveTimeline.SetLinear end.*/

            /*Spine.CurveTimeline.SetStepped start.*/
            /**
             * Sets the specified frame to stepped interpolation.
             *
             * @instance
             * @public
             * @this Spine.CurveTimeline
             * @memberof Spine.CurveTimeline
             * @param   {number}    frame    Between 0 and <pre><code>frameCount - 1</code></pre>, inclusive.
             * @return  {void}
             */
            SetStepped: function (frame) {
if ( TRACE ) { TRACE( "Spine.CurveTimeline#SetStepped", this ); }

                this.curves[frame] = Spine.CurveTimeline.STEPPED;
            },
            /*Spine.CurveTimeline.SetStepped end.*/

            /*Spine.CurveTimeline.GetCurveType start.*/
            /**
             * Returns the interpolation type for the specified frame.
             *
             * @instance
             * @public
             * @this Spine.CurveTimeline
             * @memberof Spine.CurveTimeline
             * @param   {number}    frame    Between 0 and <pre><code>frameCount - 1</code></pre>, inclusive.
             * @return  {number}             {@link }, {@link } or {@link } + the index of the Bezier segments.
             */
            GetCurveType: function (frame) {
if ( TRACE ) { TRACE( "Spine.CurveTimeline#GetCurveType", this ); }

                return Bridge.Int.clip32(this.curves[frame]);
            },
            /*Spine.CurveTimeline.GetCurveType end.*/

            /*Spine.CurveTimeline.Shrink start.*/
            /**
             * Shrinks the storage for Bezier curves, for use when <pre><code>bezierCount</code></pre> (specified in the constructor) was larger
             than the actual number of Bezier curves.
             *
             * @instance
             * @public
             * @this Spine.CurveTimeline
             * @memberof Spine.CurveTimeline
             * @param   {number}    bezierCount
             * @return  {void}
             */
            Shrink: function (bezierCount) {
if ( TRACE ) { TRACE( "Spine.CurveTimeline#Shrink", this ); }

                var size = (this.FrameCount + Bridge.Int.mul(bezierCount, Spine.CurveTimeline.BEZIER_SIZE)) | 0;
                if (this.curves.length > size) {
                    var newCurves = System.Array.init(size, 0, System.Single);
                    System.Array.copy(this.curves, 0, newCurves, 0, size);
                    this.curves = newCurves;
                }
            },
            /*Spine.CurveTimeline.Shrink end.*/

            /*Spine.CurveTimeline.SetBezier start.*/
            /**
             * Stores the segments for the specified Bezier curve. For timelines that modify multiple values, there may be more than
             one curve per frame.
             *
             * @instance
             * @public
             * @this Spine.CurveTimeline
             * @memberof Spine.CurveTimeline
             * @param   {number}    bezier    The ordinal of this Bezier curve for this timeline, between 0 and <pre><code>bezierCount - 1</code></pre> (specified
            					in the constructor), inclusive.
             * @param   {number}    frame     Between 0 and <pre><code>frameCount - 1</code></pre>, inclusive.
             * @param   {number}    value     The index of the value for the frame this curve is used for.
             * @param   {number}    time1     The time for the first key.
             * @param   {number}    value1    The value for the first key.
             * @param   {number}    cx1       The time for the first Bezier handle.
             * @param   {number}    cy1       The value for the first Bezier handle.
             * @param   {number}    cx2       The time of the second Bezier handle.
             * @param   {number}    cy2       The value for the second Bezier handle.
             * @param   {number}    time2     The time for the second key.
             * @param   {number}    value2    The value for the second key.
             * @return  {void}
             */
            SetBezier: function (bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2) {
if ( TRACE ) { TRACE( "Spine.CurveTimeline#SetBezier", this ); }


                var curves = this.curves;
                var i = (this.FrameCount + Bridge.Int.mul(bezier, Spine.CurveTimeline.BEZIER_SIZE)) | 0;
                if (value === 0) {
                    curves[frame] = (Spine.CurveTimeline.BEZIER + i) | 0;
                }
                var tmpx = (time1 - cx1 * 2 + cx2) * 0.03, tmpy = (value1 - cy1 * 2 + cy2) * 0.03;
                var dddx = ((cx1 - cx2) * 3 - time1 + time2) * 0.006, dddy = ((cy1 - cy2) * 3 - value1 + value2) * 0.006;
                var ddx = tmpx * 2 + dddx, ddy = tmpy * 2 + dddy;
                var dx = (cx1 - time1) * 0.3 + tmpx + dddx * 0.166666672, dy = (cy1 - value1) * 0.3 + tmpy + dddy * 0.166666672;
                var x = time1 + dx, y = value1 + dy;
                for (var n = (i + Spine.CurveTimeline.BEZIER_SIZE) | 0; i < n; i = (i + 2) | 0) {
                    curves[i] = x;
                    curves[((i + 1) | 0)] = y;
                    dx += ddx;
                    dy += ddy;
                    ddx += dddx;
                    ddy += dddy;
                    x += dx;
                    y += dy;
                }
            },
            /*Spine.CurveTimeline.SetBezier end.*/

            /*Spine.CurveTimeline.GetBezierValue start.*/
            /**
             * Returns the Bezier interpolated value for the specified time.
             *
             * @instance
             * @public
             * @this Spine.CurveTimeline
             * @memberof Spine.CurveTimeline
             * @param   {number}    time           
             * @param   {number}    frameIndex     The index into {@link } for the values of the frame before <pre><code>time</code></pre>.
             * @param   {number}    valueOffset    The offset from <pre><code>frameIndex</code></pre> to the value this curve is used for.
             * @param   {number}    i              The index of the Bezier segments. See {@link }.
             * @return  {number}
             */
            GetBezierValue: function (time, frameIndex, valueOffset, i) {
if ( TRACE ) { TRACE( "Spine.CurveTimeline#GetBezierValue", this ); }

                var curves = this.curves;
                if (curves[i] > time) {
                    var x = this.frames[frameIndex], y = this.frames[((frameIndex + valueOffset) | 0)];
                    return y + (time - x) / (curves[i] - x) * (curves[((i + 1) | 0)] - y);
                }
                var n = (i + Spine.CurveTimeline.BEZIER_SIZE) | 0;
                for (i = (i + 2) | 0; i < n; i = (i + 2) | 0) {
                    if (curves[i] >= time) {
                        var x1 = curves[((i - 2) | 0)], y1 = curves[((i - 1) | 0)];
                        return y1 + (time - x1) / (curves[i] - x1) * (curves[((i + 1) | 0)] - y1);
                    }
                }
                frameIndex = (frameIndex + this.FrameEntries) | 0;
                { // scope added to prevent compile error "float x and y declared in enclosing scope"
                    var x2 = curves[((n - 2) | 0)], y2 = curves[((n - 1) | 0)];
                    return y2 + (time - x2) / (this.frames[frameIndex] - x2) * (this.frames[((frameIndex + valueOffset) | 0)] - y2);
                }
            },
            /*Spine.CurveTimeline.GetBezierValue end.*/


        }
    });
    /*Spine.CurveTimeline end.*/

    /*Spine.AnimationStateData+AnimationPairComparer start.*/
    Bridge.define("Spine.AnimationStateData.AnimationPairComparer", {
        inherits: [System.Collections.Generic.IEqualityComparer$1(Spine.AnimationStateData.AnimationPair)],
        $kind: 1002,
        statics: {
            fields: {
                Instance: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.AnimationStateData.AnimationPairComparer#init", this ); }

                    this.Instance = new Spine.AnimationStateData.AnimationPairComparer();
                }
            }
        },
        alias: [
            "System$Collections$Generic$IEqualityComparer$1$Spine$AnimationStateData$AnimationPair$equals2", "System$Collections$Generic$IEqualityComparer$1$equals2",
            "System$Collections$Generic$IEqualityComparer$1$Spine$AnimationStateData$AnimationPair$getHashCode2", "System$Collections$Generic$IEqualityComparer$1$getHashCode2"
        ],
        methods: {
            /*Spine.AnimationStateData+AnimationPairComparer.System$Collections$Generic$IEqualityComparer$1$Spine$AnimationStateData$AnimationPair$equals2 start.*/
            System$Collections$Generic$IEqualityComparer$1$Spine$AnimationStateData$AnimationPair$equals2: function (x, y) {
if ( TRACE ) { TRACE( "Spine.AnimationStateData.AnimationPairComparer#System$Collections$Generic$IEqualityComparer$1$Spine$AnimationStateData$AnimationPair$equals2", this ); }

                return Bridge.referenceEquals(x.a1, y.a1) && Bridge.referenceEquals(x.a2, y.a2);
            },
            /*Spine.AnimationStateData+AnimationPairComparer.System$Collections$Generic$IEqualityComparer$1$Spine$AnimationStateData$AnimationPair$equals2 end.*/

            /*Spine.AnimationStateData+AnimationPairComparer.System$Collections$Generic$IEqualityComparer$1$Spine$AnimationStateData$AnimationPair$getHashCode2 start.*/
            System$Collections$Generic$IEqualityComparer$1$Spine$AnimationStateData$AnimationPair$getHashCode2: function (obj) {
if ( TRACE ) { TRACE( "Spine.AnimationStateData.AnimationPairComparer#System$Collections$Generic$IEqualityComparer$1$Spine$AnimationStateData$AnimationPair$getHashCode2", this ); }

                // from Tuple.CombineHashCodes // return (((h1 << 5) + h1) ^ h2);
                var h1 = Bridge.getHashCode(obj.a1);
                return (((((h1 << 5) + h1) | 0)) ^ Bridge.getHashCode(obj.a2));
            },
            /*Spine.AnimationStateData+AnimationPairComparer.System$Collections$Generic$IEqualityComparer$1$Spine$AnimationStateData$AnimationPair$getHashCode2 end.*/


        }
    });
    /*Spine.AnimationStateData+AnimationPairComparer end.*/

    /*Spine.AtlasRegion start.*/
    Bridge.define("Spine.AtlasRegion", {
        inherits: [Spine.TextureRegion],
        fields: {
            page: null,
            name: null,
            x: 0,
            y: 0,
            offsetX: 0,
            offsetY: 0,
            originalWidth: 0,
            originalHeight: 0,
            degrees: 0,
            rotate: false,
            index: 0,
            names: null,
            values: null
        },
        props: {
            packedWidth: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.AtlasRegion#packedWidth#get", this ); }

                    return this.width;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.AtlasRegion#packedWidth#set", this ); }

                    this.width = value;
                }
            },
            packedHeight: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.AtlasRegion#packedHeight#get", this ); }

                    return this.height;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.AtlasRegion#packedHeight#set", this ); }

                    this.height = value;
                }
            },
            OriginalWidth: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.AtlasRegion#OriginalWidth#get", this ); }

                    return this.originalWidth;
                }
            },
            OriginalHeight: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.AtlasRegion#OriginalHeight#get", this ); }

                    return this.originalHeight;
                }
            }
        },
        methods: {
            /*Spine.AtlasRegion.Clone start.*/
            Clone: function () {
if ( TRACE ) { TRACE( "Spine.AtlasRegion#Clone", this ); }

                return Bridge.as(Bridge.clone(this), Spine.AtlasRegion);
            },
            /*Spine.AtlasRegion.Clone end.*/


        }
    });
    /*Spine.AtlasRegion end.*/

    /*Spine.AtlasAttachmentLoader start.*/
    /**
     * An AttachmentLoader that configures attachments using texture regions from an Atlas.
     See <a href="http://esotericsoftware.com/spine-loading-skeleton-data#JSON-and-binary-data">Loading Skeleton Data</a> in the Spine Runtimes Guide.
     *
     * @public
     * @class Spine.AtlasAttachmentLoader
     * @implements  Spine.AttachmentLoader
     */
    Bridge.define("Spine.AtlasAttachmentLoader", {
        inherits: [Spine.AttachmentLoader],
        fields: {
            atlasArray: null
        },
        alias: [
            "NewRegionAttachment", "Spine$AttachmentLoader$NewRegionAttachment",
            "NewMeshAttachment", "Spine$AttachmentLoader$NewMeshAttachment",
            "NewBoundingBoxAttachment", "Spine$AttachmentLoader$NewBoundingBoxAttachment",
            "NewPathAttachment", "Spine$AttachmentLoader$NewPathAttachment",
            "NewPointAttachment", "Spine$AttachmentLoader$NewPointAttachment",
            "NewClippingAttachment", "Spine$AttachmentLoader$NewClippingAttachment"
        ],
        ctors: {
            ctor: function (atlasArray) {
if ( TRACE ) { TRACE( "Spine.AtlasAttachmentLoader#ctor", this ); }

                if (atlasArray === void 0) { atlasArray = []; }

                this.$initialize();
                if (atlasArray == null) {
                    throw new System.ArgumentNullException.$ctor3("atlas", "atlas array cannot be null.");
                }
                this.atlasArray = atlasArray;
            }
        },
        methods: {
            /*Spine.AtlasAttachmentLoader.LoadSequence start.*/
            LoadSequence: function (name, basePath, sequence) {
if ( TRACE ) { TRACE( "Spine.AtlasAttachmentLoader#LoadSequence", this ); }

                var regions = sequence.Regions;
                for (var i = 0, n = regions.length; i < n; i = (i + 1) | 0) {
                    var path = sequence.GetPath(basePath, i);
                    regions[i] = this.FindRegion(path);
                    if (regions[i] == null) {
                        throw new System.ArgumentException.$ctor1(System.String.format("Region not found in atlas: {0} (region attachment: {1})", path, name));
                    }
                }
            },
            /*Spine.AtlasAttachmentLoader.LoadSequence end.*/

            /*Spine.AtlasAttachmentLoader.NewRegionAttachment start.*/
            NewRegionAttachment: function (skin, name, path, sequence) {
if ( TRACE ) { TRACE( "Spine.AtlasAttachmentLoader#NewRegionAttachment", this ); }

                var attachment = new Spine.RegionAttachment.$ctor1(name);
                if (sequence != null) {
                    this.LoadSequence(name, path, sequence);
                } else {
                    var region = this.FindRegion(path);
                    if (region == null) {
                        throw new System.ArgumentException.$ctor1(System.String.format("Region not found in atlas: {0} (region attachment: {1})", path, name));
                    }
                    attachment.Region = region;
                }
                return attachment;
            },
            /*Spine.AtlasAttachmentLoader.NewRegionAttachment end.*/

            /*Spine.AtlasAttachmentLoader.NewMeshAttachment start.*/
            NewMeshAttachment: function (skin, name, path, sequence) {
if ( TRACE ) { TRACE( "Spine.AtlasAttachmentLoader#NewMeshAttachment", this ); }

                var attachment = new Spine.MeshAttachment.$ctor1(name);
                if (sequence != null) {
                    this.LoadSequence(name, path, sequence);
                } else {
                    var region = this.FindRegion(path);
                    if (region == null) {
                        throw new System.ArgumentException.$ctor1(System.String.format("Region not found in atlas: {0} (region attachment: {1})", path, name));
                    }
                    attachment.Region = region;
                }
                return attachment;
            },
            /*Spine.AtlasAttachmentLoader.NewMeshAttachment end.*/

            /*Spine.AtlasAttachmentLoader.NewBoundingBoxAttachment start.*/
            NewBoundingBoxAttachment: function (skin, name) {
if ( TRACE ) { TRACE( "Spine.AtlasAttachmentLoader#NewBoundingBoxAttachment", this ); }

                return new Spine.BoundingBoxAttachment.$ctor1(name);
            },
            /*Spine.AtlasAttachmentLoader.NewBoundingBoxAttachment end.*/

            /*Spine.AtlasAttachmentLoader.NewPathAttachment start.*/
            NewPathAttachment: function (skin, name) {
if ( TRACE ) { TRACE( "Spine.AtlasAttachmentLoader#NewPathAttachment", this ); }

                return new Spine.PathAttachment.$ctor1(name);
            },
            /*Spine.AtlasAttachmentLoader.NewPathAttachment end.*/

            /*Spine.AtlasAttachmentLoader.NewPointAttachment start.*/
            NewPointAttachment: function (skin, name) {
if ( TRACE ) { TRACE( "Spine.AtlasAttachmentLoader#NewPointAttachment", this ); }

                return new Spine.PointAttachment.$ctor1(name);
            },
            /*Spine.AtlasAttachmentLoader.NewPointAttachment end.*/

            /*Spine.AtlasAttachmentLoader.NewClippingAttachment start.*/
            NewClippingAttachment: function (skin, name) {
if ( TRACE ) { TRACE( "Spine.AtlasAttachmentLoader#NewClippingAttachment", this ); }

                return new Spine.ClippingAttachment.$ctor1(name);
            },
            /*Spine.AtlasAttachmentLoader.NewClippingAttachment end.*/

            /*Spine.AtlasAttachmentLoader.FindRegion start.*/
            FindRegion: function (name) {
if ( TRACE ) { TRACE( "Spine.AtlasAttachmentLoader#FindRegion", this ); }

                var region;

                for (var i = 0; i < this.atlasArray.length; i = (i + 1) | 0) {
                    region = this.atlasArray[i].FindRegion(name);
                    if (region != null) {
                        return region;
                    }
                }

                return null;
            },
            /*Spine.AtlasAttachmentLoader.FindRegion end.*/


        }
    });
    /*Spine.AtlasAttachmentLoader end.*/

    /*Spine.AttachmentTimeline start.*/
    /**
     * Changes a slot's {@link }.
     *
     * @public
     * @class Spine.AttachmentTimeline
     * @augments Spine.Timeline
     * @implements  Spine.ISlotTimeline
     */
    Bridge.define("Spine.AttachmentTimeline", {
        inherits: [Spine.Timeline,Spine.ISlotTimeline],
        fields: {
            slotIndex: 0,
            attachmentNames: null
        },
        props: {
            SlotIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.AttachmentTimeline#SlotIndex#get", this ); }

                    return this.slotIndex;
                }
            },
            /**
             * The attachment name for each frame. May contain null values to clear the attachment.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.AttachmentTimeline
             * @function AttachmentNames
             * @type Array.<string>
             */
            AttachmentNames: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.AttachmentTimeline#AttachmentNames#get", this ); }

                    return this.attachmentNames;
                }
            }
        },
        alias: ["SlotIndex", "Spine$ISlotTimeline$SlotIndex"],
        ctors: {
            ctor: function (frameCount, slotIndex) {
if ( TRACE ) { TRACE( "Spine.AttachmentTimeline#ctor", this ); }

                this.$initialize();
                Spine.Timeline.ctor.call(this, frameCount, [Spine.Property.Attachment + "|" + slotIndex]);
                this.slotIndex = slotIndex;
                this.attachmentNames = System.Array.init(frameCount, null, System.String);
            }
        },
        methods: {
            /*Spine.AttachmentTimeline.SetFrame start.*/
            /**
             * Sets the time and attachment name for the specified frame.
             *
             * @instance
             * @public
             * @this Spine.AttachmentTimeline
             * @memberof Spine.AttachmentTimeline
             * @param   {number}    frame             Between 0 and <pre><code>frameCount</code></pre>, inclusive.
             * @param   {number}    time              The frame time in seconds.
             * @param   {string}    attachmentName
             * @return  {void}
             */
            SetFrame: function (frame, time, attachmentName) {
if ( TRACE ) { TRACE( "Spine.AttachmentTimeline#SetFrame", this ); }

                this.frames[frame] = time;
                this.attachmentNames[frame] = attachmentName;
            },
            /*Spine.AttachmentTimeline.SetFrame end.*/

            /*Spine.AttachmentTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.AttachmentTimeline#Apply", this ); }

                var $t;
                var slot = ($t = skeleton.slots.Items)[this.slotIndex];
                if (!slot.bone.active) {
                    return;
                }

                if (direction === Spine.MixDirection.Out) {
                    if (blend === Spine.MixBlend.Setup) {
                        this.SetAttachment(skeleton, slot, slot.data.attachmentName);
                    }
                    return;
                }

                var frames = this.frames;
                if (time < frames[0]) {
                    if (blend === Spine.MixBlend.Setup || blend === Spine.MixBlend.First) {
                        this.SetAttachment(skeleton, slot, slot.data.attachmentName);
                    }
                    return;
                }

                this.SetAttachment(skeleton, slot, this.attachmentNames[Spine.Timeline.Search(frames, time)]);
            },
            /*Spine.AttachmentTimeline.Apply end.*/

            /*Spine.AttachmentTimeline.SetAttachment start.*/
            SetAttachment: function (skeleton, slot, attachmentName) {
if ( TRACE ) { TRACE( "Spine.AttachmentTimeline#SetAttachment", this ); }

                slot.Attachment = attachmentName == null ? null : skeleton.GetAttachment(this.slotIndex, attachmentName);
            },
            /*Spine.AttachmentTimeline.SetAttachment end.*/


        }
    });
    /*Spine.AttachmentTimeline end.*/

    /*Spine.Bone start.*/
    /**
     * Stores a bone's current pose.
     <p>A bone has a local transform which is used to compute its world transform. A bone also has an applied transform, which is a
     local transform that can be applied to compute the world transform. The local transform and applied transform may differ if a
     constraint or application code modifies the world transform after it was computed from the local transform.</p>
     *
     * @public
     * @class Spine.Bone
     * @implements  Spine.IUpdatable
     */
    Bridge.define("Spine.Bone", {
        inherits: [Spine.IUpdatable],
        statics: {
            fields: {
                yDown: false
            }
        },
        fields: {
            data: null,
            skeleton: null,
            parent: null,
            children: null,
            x: 0,
            y: 0,
            rotation: 0,
            scaleX: 0,
            scaleY: 0,
            shearX: 0,
            shearY: 0,
            ax: 0,
            ay: 0,
            arotation: 0,
            ascaleX: 0,
            ascaleY: 0,
            ashearX: 0,
            ashearY: 0,
            a: 0,
            b: 0,
            worldX: 0,
            c: 0,
            d: 0,
            worldY: 0,
            inherit: 0,
            sorted: false,
            active: false
        },
        props: {
            Data: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#Data#get", this ); }

                    return this.data;
                }
            },
            Skeleton: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#Skeleton#get", this ); }

                    return this.skeleton;
                }
            },
            Parent: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#Parent#get", this ); }

                    return this.parent;
                }
            },
            Children: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#Children#get", this ); }

                    return this.children;
                }
            },
            Active: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#Active#get", this ); }

                    return this.active;
                }
            },
            /**
             * The local X translation.
             *
             * @instance
             * @public
             * @memberof Spine.Bone
             * @function X
             * @type number
             */
            X: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#X#get", this ); }

                    return this.x;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#X#set", this ); }

                    this.x = value;
                }
            },
            /**
             * The local Y translation.
             *
             * @instance
             * @public
             * @memberof Spine.Bone
             * @function Y
             * @type number
             */
            Y: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#Y#get", this ); }

                    return this.y;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#Y#set", this ); }

                    this.y = value;
                }
            },
            /**
             * The local rotation.
             *
             * @instance
             * @public
             * @memberof Spine.Bone
             * @function Rotation
             * @type number
             */
            Rotation: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#Rotation#get", this ); }

                    return this.rotation;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#Rotation#set", this ); }

                    this.rotation = value;
                }
            },
            /**
             * The local scaleX.
             *
             * @instance
             * @public
             * @memberof Spine.Bone
             * @function ScaleX
             * @type number
             */
            ScaleX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#ScaleX#get", this ); }

                    return this.scaleX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#ScaleX#set", this ); }

                    this.scaleX = value;
                }
            },
            /**
             * The local scaleY.
             *
             * @instance
             * @public
             * @memberof Spine.Bone
             * @function ScaleY
             * @type number
             */
            ScaleY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#ScaleY#get", this ); }

                    return this.scaleY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#ScaleY#set", this ); }

                    this.scaleY = value;
                }
            },
            /**
             * The local shearX.
             *
             * @instance
             * @public
             * @memberof Spine.Bone
             * @function ShearX
             * @type number
             */
            ShearX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#ShearX#get", this ); }

                    return this.shearX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#ShearX#set", this ); }

                    this.shearX = value;
                }
            },
            /**
             * The local shearY.
             *
             * @instance
             * @public
             * @memberof Spine.Bone
             * @function ShearY
             * @type number
             */
            ShearY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#ShearY#get", this ); }

                    return this.shearY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#ShearY#set", this ); }

                    this.shearY = value;
                }
            },
            /**
             * Controls how parent world transforms affect this bone.
             *
             * @instance
             * @public
             * @memberof Spine.Bone
             * @function Inherit
             * @type Spine.Inherit
             */
            Inherit: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#Inherit#get", this ); }

                    return this.inherit;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#Inherit#set", this ); }

                    this.inherit = value;
                }
            },
            /**
             * The rotation, as calculated by any constraints.
             *
             * @instance
             * @public
             * @memberof Spine.Bone
             * @function AppliedRotation
             * @type number
             */
            AppliedRotation: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#AppliedRotation#get", this ); }

                    return this.arotation;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#AppliedRotation#set", this ); }

                    this.arotation = value;
                }
            },
            /**
             * The applied local x translation.
             *
             * @instance
             * @public
             * @memberof Spine.Bone
             * @function AX
             * @type number
             */
            AX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#AX#get", this ); }

                    return this.ax;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#AX#set", this ); }

                    this.ax = value;
                }
            },
            /**
             * The applied local y translation.
             *
             * @instance
             * @public
             * @memberof Spine.Bone
             * @function AY
             * @type number
             */
            AY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#AY#get", this ); }

                    return this.ay;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#AY#set", this ); }

                    this.ay = value;
                }
            },
            /**
             * The applied local scaleX.
             *
             * @instance
             * @public
             * @memberof Spine.Bone
             * @function AScaleX
             * @type number
             */
            AScaleX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#AScaleX#get", this ); }

                    return this.ascaleX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#AScaleX#set", this ); }

                    this.ascaleX = value;
                }
            },
            /**
             * The applied local scaleY.
             *
             * @instance
             * @public
             * @memberof Spine.Bone
             * @function AScaleY
             * @type number
             */
            AScaleY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#AScaleY#get", this ); }

                    return this.ascaleY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#AScaleY#set", this ); }

                    this.ascaleY = value;
                }
            },
            /**
             * The applied local shearX.
             *
             * @instance
             * @public
             * @memberof Spine.Bone
             * @function AShearX
             * @type number
             */
            AShearX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#AShearX#get", this ); }

                    return this.ashearX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#AShearX#set", this ); }

                    this.ashearX = value;
                }
            },
            /**
             * The applied local shearY.
             *
             * @instance
             * @public
             * @memberof Spine.Bone
             * @function AShearY
             * @type number
             */
            AShearY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#AShearY#get", this ); }

                    return this.ashearY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#AShearY#set", this ); }

                    this.ashearY = value;
                }
            },
            /**
             * Part of the world transform matrix for the X axis. If changed, {@link } should be called.
             *
             * @instance
             * @public
             * @memberof Spine.Bone
             * @function A
             * @type number
             */
            A: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#A#get", this ); }

                    return this.a;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#A#set", this ); }

                    this.a = value;
                }
            },
            /**
             * Part of the world transform matrix for the Y axis. If changed, {@link } should be called.
             *
             * @instance
             * @public
             * @memberof Spine.Bone
             * @function B
             * @type number
             */
            B: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#B#get", this ); }

                    return this.b;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#B#set", this ); }

                    this.b = value;
                }
            },
            /**
             * Part of the world transform matrix for the X axis. If changed, {@link } should be called.
             *
             * @instance
             * @public
             * @memberof Spine.Bone
             * @function C
             * @type number
             */
            C: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#C#get", this ); }

                    return this.c;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#C#set", this ); }

                    this.c = value;
                }
            },
            /**
             * Part of the world transform matrix for the Y axis. If changed, {@link } should be called.
             *
             * @instance
             * @public
             * @memberof Spine.Bone
             * @function D
             * @type number
             */
            D: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#D#get", this ); }

                    return this.d;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#D#set", this ); }

                    this.d = value;
                }
            },
            /**
             * The world X position. If changed, {@link } should be called.
             *
             * @instance
             * @public
             * @memberof Spine.Bone
             * @function WorldX
             * @type number
             */
            WorldX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#WorldX#get", this ); }

                    return this.worldX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#WorldX#set", this ); }

                    this.worldX = value;
                }
            },
            /**
             * The world Y position. If changed, {@link } should be called.
             *
             * @instance
             * @public
             * @memberof Spine.Bone
             * @function WorldY
             * @type number
             */
            WorldY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#WorldY#get", this ); }

                    return this.worldY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#WorldY#set", this ); }

                    this.worldY = value;
                }
            },
            /**
             * The world rotation for the X axis, calculated using {@link } and {@link }.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Bone
             * @function WorldRotationX
             * @type number
             */
            WorldRotationX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#WorldRotationX#get", this ); }

                    return Spine.MathUtils.Atan2Deg(this.c, this.a);
                }
            },
            /**
             * The world rotation for the Y axis, calculated using {@link } and {@link }.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Bone
             * @function WorldRotationY
             * @type number
             */
            WorldRotationY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#WorldRotationY#get", this ); }

                    return Spine.MathUtils.Atan2Deg(this.d, this.b);
                }
            },
            /**
             * Returns the magnitide (always positive) of the world scale X.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Bone
             * @function WorldScaleX
             * @type number
             */
            WorldScaleX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#WorldScaleX#get", this ); }

                    return Math.sqrt(this.a * this.a + this.c * this.c);
                }
            },
            /**
             * Returns the magnitide (always positive) of the world scale Y.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Bone
             * @function WorldScaleY
             * @type number
             */
            WorldScaleY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#WorldScaleY#get", this ); }

                    return Math.sqrt(this.b * this.b + this.d * this.d);
                }
            }
        },
        alias: [
            "Active", "Spine$IUpdatable$Active",
            "Update", "Spine$IUpdatable$Update"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Bone#init", this ); }

                this.children = new (Spine.ExposedList$1(Spine.Bone)).ctor();
            },
            $ctor1: function (data, skeleton, parent) {
if ( TRACE ) { TRACE( "Spine.Bone#$ctor1", this ); }

                this.$initialize();
                if (data == null) {
                    throw new System.ArgumentNullException.$ctor3("data", "data cannot be null.");
                }
                if (skeleton == null) {
                    throw new System.ArgumentNullException.$ctor3("skeleton", "skeleton cannot be null.");
                }
                this.data = data;
                this.skeleton = skeleton;
                this.parent = parent;
                this.SetToSetupPose();
            },
            /**
             * Copy constructor. Does not copy the {@link } bones.
             *
             * @instance
             * @public
             * @this Spine.Bone
             * @memberof Spine.Bone
             * @param   {Spine.Bone}        bone        
             * @param   {Spine.Skeleton}    skeleton    
             * @param   {Spine.Bone}        parent      May be null.
             * @return  {void}
             */
            ctor: function (bone, skeleton, parent) {
if ( TRACE ) { TRACE( "Spine.Bone#ctor", this ); }

                this.$initialize();
                if (bone == null) {
                    throw new System.ArgumentNullException.$ctor3("bone", "bone cannot be null.");
                }
                if (skeleton == null) {
                    throw new System.ArgumentNullException.$ctor3("skeleton", "skeleton cannot be null.");
                }
                this.skeleton = skeleton;
                this.parent = parent;
                this.data = bone.data;
                this.x = bone.x;
                this.y = bone.y;
                this.rotation = bone.rotation;
                this.scaleX = bone.scaleX;
                this.scaleY = bone.scaleY;
                this.shearX = bone.shearX;
                this.shearY = bone.shearY;
                this.inherit = bone.inherit;
            }
        },
        methods: {
            /*Spine.Bone.Update start.*/
            /**
             * Computes the world transform using the parent bone and this bone's local applied transform.
             *
             * @instance
             * @public
             * @this Spine.Bone
             * @memberof Spine.Bone
             * @param   {number}    physics
             * @return  {void}
             */
            Update: function (physics) {
if ( TRACE ) { TRACE( "Spine.Bone#Update", this ); }

                this.UpdateWorldTransform$1(this.ax, this.ay, this.arotation, this.ascaleX, this.ascaleY, this.ashearX, this.ashearY);
            },
            /*Spine.Bone.Update end.*/

            /*Spine.Bone.UpdateWorldTransform start.*/
            /**
             * Computes the world transform using the parent bone and this bone's local transform.
             *
             * @instance
             * @public
             * @this Spine.Bone
             * @memberof Spine.Bone
             * @return  {void}
             */
            UpdateWorldTransform: function () {
if ( TRACE ) { TRACE( "Spine.Bone#UpdateWorldTransform", this ); }

                this.UpdateWorldTransform$1(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
            },
            /*Spine.Bone.UpdateWorldTransform end.*/

            /*Spine.Bone.UpdateWorldTransform$1 start.*/
            /**
             * Computes the world transform using the parent bone and the specified local transform. The applied transform is set to the
             specified local transform. Child bones are not updated.
             <p>See <a href="http://esotericsoftware.com/spine-runtime-skeletons#World-transforms">World transforms</a> in the Spine
             Runtimes Guide.</p>
             *
             * @instance
             * @public
             * @this Spine.Bone
             * @memberof Spine.Bone
             * @param   {number}    x           
             * @param   {number}    y           
             * @param   {number}    rotation    
             * @param   {number}    scaleX      
             * @param   {number}    scaleY      
             * @param   {number}    shearX      
             * @param   {number}    shearY
             * @return  {void}
             */
            UpdateWorldTransform$1: function (x, y, rotation, scaleX, scaleY, shearX, shearY) {
if ( TRACE ) { TRACE( "Spine.Bone#UpdateWorldTransform$1", this ); }

                this.ax = x;
                this.ay = y;
                this.arotation = rotation;
                this.ascaleX = scaleX;
                this.ascaleY = scaleY;
                this.ashearX = shearX;
                this.ashearY = shearY;

                var parent = this.parent;
                if (parent == null) { // Root bone.
                    var skeleton = this.skeleton;
                    var sx = skeleton.scaleX, sy = skeleton.ScaleY;
                    var rx = (rotation + shearX) * Spine.MathUtils.DegRad;
                    var ry = (rotation + 90 + shearY) * Spine.MathUtils.DegRad;
                    this.a = Math.cos(rx) * scaleX * sx;
                    this.b = Math.cos(ry) * scaleY * sx;
                    this.c = Math.sin(rx) * scaleX * sy;
                    this.d = Math.sin(ry) * scaleY * sy;
                    this.worldX = x * sx + skeleton.x;
                    this.worldY = y * sy + skeleton.y;
                    return;
                }

                var pa = parent.a, pb = parent.b, pc = parent.c, pd = parent.d;
                this.worldX = pa * x + pb * y + parent.worldX;
                this.worldY = pc * x + pd * y + parent.worldY;

                switch (this.inherit) {
                    case Spine.Inherit.Normal: 
                        {
                            var rx1 = (rotation + shearX) * Spine.MathUtils.DegRad;
                            var ry1 = (rotation + 90 + shearY) * Spine.MathUtils.DegRad;
                            var la = Math.cos(rx1) * scaleX;
                            var lb = Math.cos(ry1) * scaleY;
                            var lc = Math.sin(rx1) * scaleX;
                            var ld = Math.sin(ry1) * scaleY;
                            this.a = pa * la + pb * lc;
                            this.b = pa * lb + pb * ld;
                            this.c = pc * la + pd * lc;
                            this.d = pc * lb + pd * ld;
                            return;
                        }
                    case Spine.Inherit.OnlyTranslation: 
                        {
                            var rx2 = (rotation + shearX) * Spine.MathUtils.DegRad;
                            var ry2 = (rotation + 90 + shearY) * Spine.MathUtils.DegRad;
                            this.a = Math.cos(rx2) * scaleX;
                            this.b = Math.cos(ry2) * scaleY;
                            this.c = Math.sin(rx2) * scaleX;
                            this.d = Math.sin(ry2) * scaleY;
                            break;
                        }
                    case Spine.Inherit.NoRotationOrReflection: 
                        {
                            var sx1 = 1 / this.skeleton.scaleX, sy1 = 1 / this.skeleton.ScaleY;
                            pa *= sx1;
                            pc *= sy1;
                            var s = pa * pa + pc * pc, prx;
                            if (s > 0.0001) {
                                s = Math.abs(pa * pd * sy1 - pb * sx1 * pc) / s;
                                pb = pc * s;
                                pd = pa * s;
                                prx = Spine.MathUtils.Atan2Deg(pc, pa);
                            } else {
                                pa = 0;
                                pc = 0;
                                prx = 90 - Spine.MathUtils.Atan2Deg(pd, pb);
                            }
                            var rx3 = (rotation + shearX - prx) * Spine.MathUtils.DegRad;
                            var ry3 = (rotation + shearY - prx + 90) * Spine.MathUtils.DegRad;
                            var la1 = Math.cos(rx3) * scaleX;
                            var lb1 = Math.cos(ry3) * scaleY;
                            var lc1 = Math.sin(rx3) * scaleX;
                            var ld1 = Math.sin(ry3) * scaleY;
                            this.a = pa * la1 - pb * lc1;
                            this.b = pa * lb1 - pb * ld1;
                            this.c = pc * la1 + pd * lc1;
                            this.d = pc * lb1 + pd * ld1;
                            break;
                        }
                    case Spine.Inherit.NoScale: 
                    case Spine.Inherit.NoScaleOrReflection: 
                        {
                            rotation *= Spine.MathUtils.DegRad;
                            var cos = Math.cos(rotation), sin = Math.sin(rotation);
                            var za = (pa * cos + pb * sin) / this.skeleton.scaleX;
                            var zc = (pc * cos + pd * sin) / this.skeleton.ScaleY;
                            var s1 = Math.sqrt(za * za + zc * zc);
                            if (s1 > 1E-05) {
                                s1 = 1 / s1;
                            }
                            za *= s1;
                            zc *= s1;
                            s1 = Math.sqrt(za * za + zc * zc);
                            if (this.inherit === Spine.Inherit.NoScale && (pa * pd - pb * pc < 0) !== (this.skeleton.scaleX < 0 !== this.skeleton.ScaleY < 0)) {
                                s1 = -s1;
                            }
                            rotation = 1.57079637 + Spine.MathUtils.Atan2(zc, za);
                            var zb = Math.cos(rotation) * s1;
                            var zd = Math.sin(rotation) * s1;
                            shearX *= Spine.MathUtils.DegRad;
                            shearY = (90 + shearY) * Spine.MathUtils.DegRad;
                            var la2 = Math.cos(shearX) * scaleX;
                            var lb2 = Math.cos(shearY) * scaleY;
                            var lc2 = Math.sin(shearX) * scaleX;
                            var ld2 = Math.sin(shearY) * scaleY;
                            this.a = za * la2 + zb * lc2;
                            this.b = za * lb2 + zb * ld2;
                            this.c = zc * la2 + zd * lc2;
                            this.d = zc * lb2 + zd * ld2;
                            break;
                        }
                }
                this.a *= this.skeleton.scaleX;
                this.b *= this.skeleton.scaleX;
                this.c *= this.skeleton.ScaleY;
                this.d *= this.skeleton.ScaleY;
            },
            /*Spine.Bone.UpdateWorldTransform$1 end.*/

            /*Spine.Bone.SetToSetupPose start.*/
            /**
             * Sets this bone's local transform to the setup pose.
             *
             * @instance
             * @public
             * @this Spine.Bone
             * @memberof Spine.Bone
             * @return  {void}
             */
            SetToSetupPose: function () {
if ( TRACE ) { TRACE( "Spine.Bone#SetToSetupPose", this ); }

                var data = this.data;
                this.x = data.x;
                this.y = data.y;
                this.rotation = data.rotation;
                this.scaleX = data.scaleX;
                this.scaleY = data.ScaleY;
                this.shearX = data.shearX;
                this.shearY = data.shearY;
                this.inherit = data.inherit;
            },
            /*Spine.Bone.SetToSetupPose end.*/

            /*Spine.Bone.UpdateAppliedTransform start.*/
            /**
             * Computes the applied transform values from the world transform.
             <p>If the world transform is modified (by a constraint, {@link }, etc) then this method should be called so
             the applied transform matches the world transform. The applied transform may be needed by other code (eg to apply another
             constraint).</p><p>Some information is ambiguous in the world transform, such as -1,-1 scale versus 180 rotation. The applied transform after
             calling this method is equivalent to the local transform used to compute the world transform, but may not be identical.</p>
             *
             * @instance
             * @public
             * @this Spine.Bone
             * @memberof Spine.Bone
             * @return  {void}
             */
            UpdateAppliedTransform: function () {
if ( TRACE ) { TRACE( "Spine.Bone#UpdateAppliedTransform", this ); }

                var parent = this.parent;
                if (parent == null) {
                    this.ax = this.worldX - this.skeleton.x;
                    this.ay = this.worldY - this.skeleton.y;
                    var a = this.a, b = this.b, c = this.c, d = this.d;
                    this.arotation = Spine.MathUtils.Atan2Deg(c, a);
                    this.ascaleX = Math.sqrt(a * a + c * c);
                    this.ascaleY = Math.sqrt(b * b + d * d);
                    this.ashearX = 0;
                    this.ashearY = Spine.MathUtils.Atan2Deg(a * b + c * d, a * d - b * c);
                    return;
                }

                var pa = parent.a, pb = parent.b, pc = parent.c, pd = parent.d;
                var pid = 1 / (pa * pd - pb * pc);
                var ia = pd * pid, ib = pb * pid, ic = pc * pid, id = pa * pid;
                var dx = this.worldX - parent.worldX, dy = this.worldY - parent.worldY;
                this.ax = (dx * ia - dy * ib);
                this.ay = (dy * id - dx * ic);

                var ra, rb, rc, rd;
                if (this.inherit === Spine.Inherit.OnlyTranslation) {
                    ra = this.a;
                    rb = this.b;
                    rc = this.c;
                    rd = this.d;
                } else {
                    switch (this.inherit) {
                        case Spine.Inherit.NoRotationOrReflection: 
                            {
                                var s = Math.abs(pa * pd - pb * pc) / (pa * pa + pc * pc);
                                var skeletonScaleY = this.skeleton.ScaleY;
                                pb = -pc * this.skeleton.scaleX * s / skeletonScaleY;
                                pd = pa * skeletonScaleY * s / this.skeleton.scaleX;
                                pid = 1 / (pa * pd - pb * pc);
                                ia = pd * pid;
                                ib = pb * pid;
                                break;
                            }
                        case Spine.Inherit.NoScale: 
                        case Spine.Inherit.NoScaleOrReflection: 
                            {
                                var r = this.rotation * Spine.MathUtils.DegRad, cos = Math.cos(r), sin = Math.sin(r);
                                pa = (pa * cos + pb * sin) / this.skeleton.scaleX;
                                pc = (pc * cos + pd * sin) / this.skeleton.ScaleY;
                                var s1 = Math.sqrt(pa * pa + pc * pc);
                                if (s1 > 1E-05) {
                                    s1 = 1 / s1;
                                }
                                pa *= s1;
                                pc *= s1;
                                s1 = Math.sqrt(pa * pa + pc * pc);
                                if (this.inherit === Spine.Inherit.NoScale && pid < 0 !== (this.skeleton.scaleX < 0 !== this.skeleton.ScaleY < 0)) {
                                    s1 = -s1;
                                }
                                r = 1.57079637 + Spine.MathUtils.Atan2(pc, pa);
                                pb = Math.cos(r) * s1;
                                pd = Math.sin(r) * s1;
                                pid = 1 / (pa * pd - pb * pc);
                                ia = pd * pid;
                                ib = pb * pid;
                                ic = pc * pid;
                                id = pa * pid;
                                break;
                            }
                    }
                    ra = ia * this.a - ib * this.c;
                    rb = ia * this.b - ib * this.d;
                    rc = id * this.c - ic * this.a;
                    rd = id * this.d - ic * this.b;
                }

                this.ashearX = 0;
                this.ascaleX = Math.sqrt(ra * ra + rc * rc);
                if (this.ascaleX > 0.0001) {
                    var det = ra * rd - rb * rc;
                    this.ascaleY = det / this.ascaleX;
                    this.ashearY = -Spine.MathUtils.Atan2Deg(ra * rb + rc * rd, det);
                    this.arotation = Spine.MathUtils.Atan2Deg(rc, ra);
                } else {
                    this.ascaleX = 0;
                    this.ascaleY = Math.sqrt(rb * rb + rd * rd);
                    this.ashearY = 0;
                    this.arotation = 90 - Spine.MathUtils.Atan2Deg(rd, rb);
                }
            },
            /*Spine.Bone.UpdateAppliedTransform end.*/

            /*Spine.Bone.WorldToLocal start.*/
            /**
             * Transforms a point from world coordinates to the bone's local coordinates.
             *
             * @instance
             * @public
             * @this Spine.Bone
             * @memberof Spine.Bone
             * @param   {number}           worldX    
             * @param   {number}           worldY    
             * @param   {System.Single}    localX    
             * @param   {System.Single}    localY
             * @return  {void}
             */
            WorldToLocal: function (worldX, worldY, localX, localY) {
if ( TRACE ) { TRACE( "Spine.Bone#WorldToLocal", this ); }

                var a = this.a, b = this.b, c = this.c, d = this.d;
                var det = a * d - b * c;
                var x = worldX - this.worldX, y = worldY - this.worldY;
                localX.v = (x * d - y * b) / det;
                localY.v = (y * a - x * c) / det;
            },
            /*Spine.Bone.WorldToLocal end.*/

            /*Spine.Bone.LocalToWorld start.*/
            /**
             * Transforms a point from the bone's local coordinates to world coordinates.
             *
             * @instance
             * @public
             * @this Spine.Bone
             * @memberof Spine.Bone
             * @param   {number}           localX    
             * @param   {number}           localY    
             * @param   {System.Single}    worldX    
             * @param   {System.Single}    worldY
             * @return  {void}
             */
            LocalToWorld: function (localX, localY, worldX, worldY) {
if ( TRACE ) { TRACE( "Spine.Bone#LocalToWorld", this ); }

                worldX.v = localX * this.a + localY * this.b + this.worldX;
                worldY.v = localX * this.c + localY * this.d + this.worldY;
            },
            /*Spine.Bone.LocalToWorld end.*/

            /*Spine.Bone.WorldToParent start.*/
            /**
             * Transforms a point from world coordinates to the parent bone's local coordinates.
             *
             * @instance
             * @public
             * @this Spine.Bone
             * @memberof Spine.Bone
             * @param   {number}           worldX     
             * @param   {number}           worldY     
             * @param   {System.Single}    parentX    
             * @param   {System.Single}    parentY
             * @return  {void}
             */
            WorldToParent: function (worldX, worldY, parentX, parentY) {
if ( TRACE ) { TRACE( "Spine.Bone#WorldToParent", this ); }

                if (this.parent == null) {
                    parentX.v = worldX;
                    parentY.v = worldY;
                } else {
                    this.parent.WorldToLocal(worldX, worldY, parentX, parentY);
                }
            },
            /*Spine.Bone.WorldToParent end.*/

            /*Spine.Bone.ParentToWorld start.*/
            /**
             * Transforms a point from the parent bone's coordinates to world coordinates.
             *
             * @instance
             * @public
             * @this Spine.Bone
             * @memberof Spine.Bone
             * @param   {number}           parentX    
             * @param   {number}           parentY    
             * @param   {System.Single}    worldX     
             * @param   {System.Single}    worldY
             * @return  {void}
             */
            ParentToWorld: function (parentX, parentY, worldX, worldY) {
if ( TRACE ) { TRACE( "Spine.Bone#ParentToWorld", this ); }

                if (this.parent == null) {
                    worldX.v = parentX;
                    worldY.v = parentY;
                } else {
                    this.parent.LocalToWorld(parentX, parentY, worldX, worldY);
                }
            },
            /*Spine.Bone.ParentToWorld end.*/

            /*Spine.Bone.WorldToLocalRotation start.*/
            /**
             * Transforms a world rotation to a local rotation.
             *
             * @instance
             * @public
             * @this Spine.Bone
             * @memberof Spine.Bone
             * @param   {number}    worldRotation
             * @return  {number}
             */
            WorldToLocalRotation: function (worldRotation) {
if ( TRACE ) { TRACE( "Spine.Bone#WorldToLocalRotation", this ); }

                worldRotation *= Spine.MathUtils.DegRad;
                var sin = Math.sin(worldRotation), cos = Math.cos(worldRotation);
                return Spine.MathUtils.Atan2Deg(this.a * sin - this.c * cos, this.d * cos - this.b * sin) + this.rotation - this.shearX;
            },
            /*Spine.Bone.WorldToLocalRotation end.*/

            /*Spine.Bone.LocalToWorldRotation start.*/
            /**
             * Transforms a local rotation to a world rotation.
             *
             * @instance
             * @public
             * @this Spine.Bone
             * @memberof Spine.Bone
             * @param   {number}    localRotation
             * @return  {number}
             */
            LocalToWorldRotation: function (localRotation) {
if ( TRACE ) { TRACE( "Spine.Bone#LocalToWorldRotation", this ); }

                localRotation = (localRotation - this.rotation - this.shearX) * Spine.MathUtils.DegRad;
                var sin = Math.sin(localRotation), cos = Math.cos(localRotation);
                return Spine.MathUtils.Atan2Deg(cos * this.c + sin * this.d, cos * this.a + sin * this.b);
            },
            /*Spine.Bone.LocalToWorldRotation end.*/

            /*Spine.Bone.RotateWorld start.*/
            /**
             * Rotates the world transform the specified amount.
             <p>After changes are made to the world transform, {@link } should be called and
             {@link } will need to be called on any child bones, recursively.</p>
             *
             * @instance
             * @public
             * @this Spine.Bone
             * @memberof Spine.Bone
             * @param   {number}    degrees
             * @return  {void}
             */
            RotateWorld: function (degrees) {
if ( TRACE ) { TRACE( "Spine.Bone#RotateWorld", this ); }

                degrees *= Spine.MathUtils.DegRad;
                var sin = Math.sin(degrees), cos = Math.cos(degrees);
                var ra = this.a, rb = this.b;
                this.a = cos * ra - sin * this.c;
                this.b = cos * rb - sin * this.d;
                this.c = sin * ra + cos * this.c;
                this.d = sin * rb + cos * this.d;
            },
            /*Spine.Bone.RotateWorld end.*/

            /*Spine.Bone.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.Bone#toString", this ); }

                return this.data.name;
            },
            /*Spine.Bone.toString end.*/


        },
        overloads: {
            "UpdateWorldTransform(float, float, float, float, float, float, float)": "UpdateWorldTransform$1",
            "ToString()": "toString"
        }
    });
    /*Spine.Bone end.*/

    /*Spine.VertexAttachment start.*/
    /**
     * &gt;An attachment with vertices that are transformed by one or more bones and can be deformed by a slot's
     {@link }.
     *
     * @abstract
     * @public
     * @class Spine.VertexAttachment
     * @augments Spine.Attachment
     */
    Bridge.define("Spine.VertexAttachment", {
        inherits: [Spine.Attachment],
        statics: {
            fields: {
                nextID: 0,
                nextIdLock: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.VertexAttachment#init", this ); }

                    this.nextID = 0;
                    this.nextIdLock = { };
                }
            }
        },
        fields: {
            id: 0,
            timelineAttachment: null,
            bones: null,
            vertices: null,
            worldVerticesLength: 0
        },
        props: {
            /**
             * Gets a unique ID for this attachment.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.VertexAttachment
             * @function Id
             * @type number
             */
            Id: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.VertexAttachment#Id#get", this ); }

                    return this.id;
                }
            },
            Bones: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.VertexAttachment#Bones#get", this ); }

                    return this.bones;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.VertexAttachment#Bones#set", this ); }

                    this.bones = value;
                }
            },
            Vertices: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.VertexAttachment#Vertices#get", this ); }

                    return this.vertices;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.VertexAttachment#Vertices#set", this ); }

                    this.vertices = value;
                }
            },
            WorldVerticesLength: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.VertexAttachment#WorldVerticesLength#get", this ); }

                    return this.worldVerticesLength;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.VertexAttachment#WorldVerticesLength#set", this ); }

                    this.worldVerticesLength = value;
                }
            },
            /**
             * Timelines for the timeline attachment are also applied to this attachment.
             May be null if no attachment-specific timelines should be applied.
             *
             * @instance
             * @public
             * @memberof Spine.VertexAttachment
             * @function TimelineAttachment
             * @type Spine.VertexAttachment
             */
            TimelineAttachment: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.VertexAttachment#TimelineAttachment#get", this ); }

                    return this.timelineAttachment;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.VertexAttachment#TimelineAttachment#set", this ); }

                    this.timelineAttachment = value;
                }
            }
        },
        ctors: {
            $ctor1: function (name) {
if ( TRACE ) { TRACE( "Spine.VertexAttachment#$ctor1", this ); }

                var $t;
                this.$initialize();
                Spine.Attachment.$ctor1.call(this, name);

                Spine.VertexAttachment.nextIdLock;
                {
                    this.id = Bridge.identity(Spine.VertexAttachment.nextID, (($t = (Spine.VertexAttachment.nextID + 1) | 0, Spine.VertexAttachment.nextID = $t, $t)));
                }
                this.timelineAttachment = this;
            },
            /**
             * Copy constructor.
             *
             * @instance
             * @public
             * @this Spine.VertexAttachment
             * @memberof Spine.VertexAttachment
             * @param   {Spine.VertexAttachment}    other
             * @return  {void}
             */
            ctor: function (other) {
if ( TRACE ) { TRACE( "Spine.VertexAttachment#ctor", this ); }

                var $t;
                this.$initialize();
                Spine.Attachment.ctor.call(this, other);

                Spine.VertexAttachment.nextIdLock;
                {
                    this.id = Bridge.identity(Spine.VertexAttachment.nextID, (($t = (Spine.VertexAttachment.nextID + 1) | 0, Spine.VertexAttachment.nextID = $t, $t)));
                }
                this.timelineAttachment = other.timelineAttachment;
                if (other.bones != null) {
                    this.bones = System.Array.init(other.bones.length, 0, System.Int32);
                    System.Array.copy(other.bones, 0, this.bones, 0, this.bones.length);
                } else {
                    this.bones = null;
                }

                if (other.vertices != null) {
                    this.vertices = System.Array.init(other.vertices.length, 0, System.Single);
                    System.Array.copy(other.vertices, 0, this.vertices, 0, this.vertices.length);
                } else {
                    this.vertices = null;
                }

                this.worldVerticesLength = other.worldVerticesLength;
            }
        },
        methods: {
            /*Spine.VertexAttachment.ComputeWorldVertices$1 start.*/
            ComputeWorldVertices$1: function (slot, worldVertices) {
if ( TRACE ) { TRACE( "Spine.VertexAttachment#ComputeWorldVertices$1", this ); }

                this.ComputeWorldVertices(slot, 0, this.worldVerticesLength, worldVertices, 0);
            },
            /*Spine.VertexAttachment.ComputeWorldVertices$1 end.*/

            /*Spine.VertexAttachment.ComputeWorldVertices start.*/
            /**
             * Transforms the attachment's local {@link } to world coordinates. If the slot's {@link } is
             not empty, it is used to deform the vertices.
             <p />
             See <a href="http://esotericsoftware.com/spine-runtime-skeletons#World-transforms">World transforms</a> in the Spine
             Runtimes Guide.
             *
             * @instance
             * @public
             * @this Spine.VertexAttachment
             * @memberof Spine.VertexAttachment
             * @param   {Spine.Slot}        slot             
             * @param   {number}            start            The index of the first {@link } value to transform. Each vertex has 2 values, x and y.
             * @param   {number}            count            The number of world vertex values to output. Must be less than or equal to {@link } - start.
             * @param   {Array.<number>}    worldVertices    The output world vertices. Must have a length greater than or equal to <b>worldVertices</b> + <b>worldVertices</b>.
             * @param   {number}            offset           The <b>offset</b> index to begin writing values.
             * @param   {number}            stride           The number of <b>stride</b> entries between the value pairs written.
             * @return  {void}
             */
            ComputeWorldVertices: function (slot, start, count, worldVertices, offset, stride) {
if ( TRACE ) { TRACE( "Spine.VertexAttachment#ComputeWorldVertices", this ); }

                if (stride === void 0) { stride = 2; }
                count = (offset + Bridge.Int.mul((count >> 1), stride)) | 0;
                var deformArray = slot.deform;
                var vertices = this.vertices;
                var bones = this.bones;
                if (bones == null) {
                    if (deformArray.Count > 0) {
                        vertices = deformArray.Items;
                    }
                    var bone = slot.bone;
                    var x = bone.worldX, y = bone.worldY;
                    var a = bone.a, b = bone.b, c = bone.c, d = bone.d;
                    for (var vv = start, w = offset; w < count; vv = (vv + 2) | 0, w = (w + stride) | 0) {
                        var vx = vertices[vv], vy = vertices[((vv + 1) | 0)];
                        worldVertices[w] = vx * a + vy * b + x;
                        worldVertices[((w + 1) | 0)] = vx * c + vy * d + y;
                    }
                    return;
                }
                var v = 0, skip = 0;
                for (var i = 0; i < start; i = (i + 2) | 0) {
                    var n = bones[v];
                    v = (v + (((n + 1) | 0))) | 0;
                    skip = (skip + n) | 0;
                }
                var skeletonBones = slot.bone.skeleton.bones.Items;
                if (deformArray.Count === 0) {
                    for (var w1 = offset, b1 = Bridge.Int.mul(skip, 3); w1 < count; w1 = (w1 + stride) | 0) {
                        var wx = 0, wy = 0;
                        var n1 = bones[Bridge.identity(v, ((v = (v + 1) | 0)))];
                        n1 = (n1 + v) | 0;
                        for (; v < n1; v = (v + 1) | 0, b1 = (b1 + 3) | 0) {
                            var bone1 = skeletonBones[bones[v]];
                            var vx1 = vertices[b1], vy1 = vertices[((b1 + 1) | 0)], weight = vertices[((b1 + 2) | 0)];
                            wx += (vx1 * bone1.a + vy1 * bone1.b + bone1.worldX) * weight;
                            wy += (vx1 * bone1.c + vy1 * bone1.d + bone1.worldY) * weight;
                        }
                        worldVertices[w1] = wx;
                        worldVertices[((w1 + 1) | 0)] = wy;
                    }
                } else {
                    var deform = deformArray.Items;
                    for (var w2 = offset, b2 = Bridge.Int.mul(skip, 3), f = skip << 1; w2 < count; w2 = (w2 + stride) | 0) {
                        var wx1 = 0, wy1 = 0;
                        var n2 = bones[Bridge.identity(v, ((v = (v + 1) | 0)))];
                        n2 = (n2 + v) | 0;
                        for (; v < n2; v = (v + 1) | 0, b2 = (b2 + 3) | 0, f = (f + 2) | 0) {
                            var bone2 = skeletonBones[bones[v]];
                            var vx2 = vertices[b2] + deform[f], vy2 = vertices[((b2 + 1) | 0)] + deform[((f + 1) | 0)], weight1 = vertices[((b2 + 2) | 0)];
                            wx1 += (vx2 * bone2.a + vy2 * bone2.b + bone2.worldX) * weight1;
                            wy1 += (vx2 * bone2.c + vy2 * bone2.d + bone2.worldY) * weight1;
                        }
                        worldVertices[w2] = wx1;
                        worldVertices[((w2 + 1) | 0)] = wy1;
                    }
                }
            },
            /*Spine.VertexAttachment.ComputeWorldVertices end.*/


        },
        overloads: {
            "ComputeWorldVertices(Slot, float[])": "ComputeWorldVertices$1"
        }
    });
    /*Spine.VertexAttachment end.*/

    /*Spine.DrawOrderTimeline start.*/
    /**
     * Changes a skeleton's {@link }.
     *
     * @public
     * @class Spine.DrawOrderTimeline
     * @augments Spine.Timeline
     */
    Bridge.define("Spine.DrawOrderTimeline", {
        inherits: [Spine.Timeline],
        statics: {
            fields: {
                propertyIds: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.DrawOrderTimeline#init", this ); }

                    this.propertyIds = System.Array.init([Bridge.toString((Spine.Property.DrawOrder))], System.String);
                }
            }
        },
        fields: {
            drawOrders: null
        },
        props: {
            /**
             * The draw order for each frame.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.DrawOrderTimeline
             * @function DrawOrders
             * @type Array.<Array.<number>>
             * @see {@link Timeline.SetFrame(int, float, int[])}
             */
            DrawOrders: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.DrawOrderTimeline#DrawOrders#get", this ); }

                    return this.drawOrders;
                }
            }
        },
        ctors: {
            ctor: function (frameCount) {
if ( TRACE ) { TRACE( "Spine.DrawOrderTimeline#ctor", this ); }

                this.$initialize();
                Spine.Timeline.ctor.call(this, frameCount, Spine.DrawOrderTimeline.propertyIds);
                this.drawOrders = System.Array.init(frameCount, null, System.Array.type(System.Int32));
            }
        },
        methods: {
            /*Spine.DrawOrderTimeline.SetFrame start.*/
            /**
             * Sets the time and draw order for the specified frame.
             *
             * @instance
             * @public
             * @this Spine.DrawOrderTimeline
             * @memberof Spine.DrawOrderTimeline
             * @param   {number}            frame        Between 0 and <pre><code>frameCount</code></pre>, inclusive.
             * @param   {number}            time         The frame time in seconds.
             * @param   {Array.<number>}    drawOrder    For each slot in {@link }, the index of the slot in the new draw order. May be null to use
            					 setup pose draw order.
             * @return  {void}
             */
            SetFrame: function (frame, time, drawOrder) {
if ( TRACE ) { TRACE( "Spine.DrawOrderTimeline#SetFrame", this ); }

                this.frames[frame] = time;
                this.drawOrders[frame] = drawOrder;
            },
            /*Spine.DrawOrderTimeline.SetFrame end.*/

            /*Spine.DrawOrderTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.DrawOrderTimeline#Apply", this ); }


                if (direction === Spine.MixDirection.Out) {
                    if (blend === Spine.MixBlend.Setup) {
                        System.Array.copy(skeleton.slots.Items, 0, skeleton.drawOrder.Items, 0, skeleton.slots.Count);
                    }
                    return;
                }

                var frames = this.frames;
                if (time < frames[0]) {
                    if (blend === Spine.MixBlend.Setup || blend === Spine.MixBlend.First) {
                        System.Array.copy(skeleton.slots.Items, 0, skeleton.drawOrder.Items, 0, skeleton.slots.Count);
                    }
                    return;
                }

                var drawOrderToSetupIndex = this.drawOrders[Spine.Timeline.Search(frames, time)];
                if (drawOrderToSetupIndex == null) {
                    System.Array.copy(skeleton.slots.Items, 0, skeleton.drawOrder.Items, 0, skeleton.slots.Count);
                } else {
                    var slots = skeleton.slots.Items;
                    var drawOrder = skeleton.drawOrder.Items;
                    for (var i = 0, n = drawOrderToSetupIndex.length; i < n; i = (i + 1) | 0) {
                        drawOrder[i] = slots[drawOrderToSetupIndex[i]];
                    }
                }
            },
            /*Spine.DrawOrderTimeline.Apply end.*/


        }
    });
    /*Spine.DrawOrderTimeline end.*/

    /*Spine.EventTimeline start.*/
    /**
     * Fires an {@link } when specific animation times are reached.
     *
     * @public
     * @class Spine.EventTimeline
     * @augments Spine.Timeline
     */
    Bridge.define("Spine.EventTimeline", {
        inherits: [Spine.Timeline],
        statics: {
            fields: {
                propertyIds: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.EventTimeline#init", this ); }

                    this.propertyIds = System.Array.init([Bridge.toString((Spine.Property.Event))], System.String);
                }
            }
        },
        fields: {
            events: null
        },
        props: {
            /**
             * The event for each frame.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.EventTimeline
             * @function Events
             * @type Array.<Spine.Event>
             */
            Events: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.EventTimeline#Events#get", this ); }

                    return this.events;
                }
            }
        },
        ctors: {
            ctor: function (frameCount) {
if ( TRACE ) { TRACE( "Spine.EventTimeline#ctor", this ); }

                this.$initialize();
                Spine.Timeline.ctor.call(this, frameCount, Spine.EventTimeline.propertyIds);
                this.events = System.Array.init(frameCount, null, Spine.Event);
            }
        },
        methods: {
            /*Spine.EventTimeline.SetFrame start.*/
            /**
             * Sets the time and event for the specified frame.
             *
             * @instance
             * @public
             * @this Spine.EventTimeline
             * @memberof Spine.EventTimeline
             * @param   {number}         frame    Between 0 and <pre><code>frameCount</code></pre>, inclusive.
             * @param   {Spine.Event}    e
             * @return  {void}
             */
            SetFrame: function (frame, e) {
if ( TRACE ) { TRACE( "Spine.EventTimeline#SetFrame", this ); }

                this.frames[frame] = e.time;
                this.events[frame] = e;
            },
            /*Spine.EventTimeline.SetFrame end.*/

            /*Spine.EventTimeline.Apply start.*/
            /**
             * Fires events for frames &gt; <pre><code>lastTime</code></pre> and &lt;= <pre><code>time</code></pre>.
             *
             * @instance
             * @public
             * @override
             * @this Spine.EventTimeline
             * @memberof Spine.EventTimeline
             * @param   {Spine.Skeleton}         skeleton       
             * @param   {number}                 lastTime       
             * @param   {number}                 time           
             * @param   {Spine.ExposedList$1}    firedEvents    
             * @param   {number}                 alpha          
             * @param   {Spine.MixBlend}         blend          
             * @param   {Spine.MixDirection}     direction
             * @return  {void}
             */
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.EventTimeline#Apply", this ); }


                if (firedEvents == null) {
                    return;
                }

                var frames = this.frames;
                var frameCount = frames.length;

                if (lastTime > time) { // Apply after lastTime for looped animations.
                    this.Apply(skeleton, lastTime, 2147483647, firedEvents, alpha, blend, direction);
                    lastTime = -1.0;
                } else if (lastTime >= frames[((frameCount - 1) | 0)]) {
                    return;
                }
                if (time < frames[0]) {
                    return;
                }

                var i;
                if (lastTime < frames[0]) {
                    i = 0;
                } else {
                    i = (Spine.Timeline.Search(frames, lastTime) + 1) | 0;
                    var frameTime = frames[i];
                    while (i > 0) { // Fire multiple events with the same frame.
                        if (frames[((i - 1) | 0)] !== frameTime) {
                            break;
                        }
                        i = (i - 1) | 0;
                    }
                }
                for (; i < frameCount && time >= frames[i]; i = (i + 1) | 0) {
                    firedEvents.Add(this.events[i]);
                }
            },
            /*Spine.EventTimeline.Apply end.*/


        }
    });
    /*Spine.EventTimeline end.*/

    /*Spine.IkConstraint start.*/
    /**
     * <p>Stores the current pose for an IK constraint. An IK constraint adjusts the rotation of 1 or 2 constrained bones so the tip of
     the last bone is as close to the target bone as possible.</p><p>See <a href="http://esotericsoftware.com/spine-ik-constraints">IK constraints</a> in the Spine User Guide.</p>
     *
     * @public
     * @class Spine.IkConstraint
     * @implements  Spine.IUpdatable
     */
    Bridge.define("Spine.IkConstraint", {
        inherits: [Spine.IUpdatable],
        statics: {
            methods: {
                /*Spine.IkConstraint.Apply$1:static start.*/
                /**
                 * Applies 1 bone IK. The target is specified in the world coordinate system.
                 *
                 * @static
                 * @public
                 * @this Spine.IkConstraint
                 * @memberof Spine.IkConstraint
                 * @param   {Spine.Bone}    bone        
                 * @param   {number}        targetX     
                 * @param   {number}        targetY     
                 * @param   {boolean}       compress    
                 * @param   {boolean}       stretch     
                 * @param   {boolean}       uniform     
                 * @param   {number}        alpha
                 * @return  {void}
                 */
                Apply$1: function (bone, targetX, targetY, compress, stretch, uniform, alpha) {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Apply$1", this ); }

                    var $step = 0,
                        $jumpFromFinally, 
                        p, 
                        pa, 
                        pb, 
                        pc, 
                        pd, 
                        rotationIK, 
                        tx, 
                        ty, 
                        $t, 
                        s, 
                        sa, 
                        sc, 
                        x, 
                        y, 
                        d, 
                        sx, 
                        sy, 
                        b, 
                        dd, 
                        s1, 
                        $asyncBody = Bridge.fn.bind(this, function () {
                            for (;;) {
                                $step = System.Array.min([0,1,2,3,4], $step);
                                switch ($step) {
                                    case 0: {
                                        if (bone == null) {
                                            throw new System.ArgumentNullException.$ctor3("bone", "bone cannot be null.");
                                        }
                                        p = bone.parent;

                                        pa = p.a;
                                        pb = p.b;
                                        pc = p.c;
                                        pd = p.d;
                                        rotationIK = -bone.ashearX - bone.arotation;
                                        tx = 0;
                                        ty = 0;

                                        $t = bone.inherit;
                                        if ($t === Spine.Inherit.OnlyTranslation) {
                                            $step = 1;
                                            continue;
                                        }
                                        else if ($t === Spine.Inherit.NoRotationOrReflection) {
                                            $step = 2;
                                            continue;
                                        }
                                        else  {
                                            $step = 3;
                                            continue;
                                        }
                                        $step = 4;
                                        continue;
                                    }
                                    case 1: {
                                        tx = (targetX - bone.worldX) * Bridge.Int.sign(bone.skeleton.ScaleX);
                                        ty = (targetY - bone.worldY) * Bridge.Int.sign(bone.skeleton.ScaleY);
                                        $step = 4;
                                        continue;
                                    }
                                    case 2: {
                                        s = Math.abs(pa * pd - pb * pc) / Math.max(0.0001, pa * pa + pc * pc);
                                        sa = pa / bone.skeleton.scaleX;
                                        sc = pc / bone.skeleton.ScaleY;
                                        pb = -sc * s * bone.skeleton.scaleX;
                                        pd = sa * s * bone.skeleton.ScaleY;
                                        rotationIK += Spine.MathUtils.Atan2Deg(sc, sa);
                                        $step = 3;
                                        continue;// Fall through.
                                    }
                                    case 3: {
                                        x = targetX - p.worldX;
                                        y = targetY - p.worldY;
                                        d = pa * pd - pb * pc;
                                        if (Math.abs(d) <= 0.0001) {
                                            tx = 0;
                                            ty = 0;
                                        } else {
                                            tx = (x * pd - y * pb) / d - bone.ax;
                                            ty = (y * pa - x * pc) / d - bone.ay;
                                        }
                                        $step = 4;
                                        continue;
                                    }
                                    case 4: {
                                        rotationIK += Spine.MathUtils.Atan2Deg(ty, tx);
                                        if (bone.ascaleX < 0) {
                                            rotationIK += 180;
                                        }
                                        if (rotationIK > 180) {
                                            rotationIK -= 360;
                                        } else {
                                            if (rotationIK < -180) {
                                                rotationIK += 360;
                                            }
                                        }

                                        sx = bone.ascaleX;
                                        sy = bone.ascaleY;
                                        if (compress || stretch) {
                                            switch (bone.inherit) {
                                                case Spine.Inherit.NoScale: 
                                                case Spine.Inherit.NoScaleOrReflection: 
                                                    tx = targetX - bone.worldX;
                                                    ty = targetY - bone.worldY;
                                                    break;
                                            }
                                            b = bone.data.length * sx;
                                            if (b > 0.0001) {
                                                dd = tx * tx + ty * ty;
                                                if ((compress && dd < b * b) || (stretch && dd > b * b)) {
                                                    s1 = (Math.sqrt(dd) / b - 1) * alpha + 1;
                                                    sx *= s1;
                                                    if (uniform) {
                                                        sy *= s1;
                                                    }
                                                }
                                            }
                                        }
                                        bone.UpdateWorldTransform$1(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, sx, sy, bone.ashearX, bone.ashearY);
                                        return;
                                    }
                                    default: {
                                        return;
                                    }
                                }
                            }
                        }, arguments);

                    return $asyncBody();
                },
                /*Spine.IkConstraint.Apply$1:static end.*/

                /*Spine.IkConstraint.Apply:static start.*/
                /**
                 * Applies 2 bone IK. The target is specified in the world coordinate system.
                 *
                 * @static
                 * @public
                 * @this Spine.IkConstraint
                 * @memberof Spine.IkConstraint
                 * @param   {Spine.Bone}    parent      
                 * @param   {Spine.Bone}    child       A direct descendant of the parent bone.
                 * @param   {number}        targetX     
                 * @param   {number}        targetY     
                 * @param   {number}        bendDir     
                 * @param   {boolean}       stretch     
                 * @param   {boolean}       uniform     
                 * @param   {number}        softness    
                 * @param   {number}        alpha
                 * @return  {void}
                 */
                Apply: function (parent, child, targetX, targetY, bendDir, stretch, uniform, softness, alpha) {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Apply", this ); }

                    var $step = 0,
                        $jumpFromFinally, 
                        px, 
                        py, 
                        psx, 
                        psy, 
                        sx, 
                        sy, 
                        csx, 
                        os1, 
                        os2, 
                        s2, 
                        cx, 
                        cy, 
                        cwx, 
                        cwy, 
                        a, 
                        b, 
                        c, 
                        d, 
                        u, 
                        pp, 
                        id, 
                        x, 
                        y, 
                        dx, 
                        dy, 
                        l1, 
                        l2, 
                        a1, 
                        a2, 
                        tx, 
                        ty, 
                        dd, 
                        td, 
                        sd, 
                        p, 
                        cos, 
                        aa, 
                        bb, 
                        ta, 
                        c1, 
                        c2, 
                        q, 
                        r0, 
                        r1, 
                        r, 
                        minAngle, 
                        minX, 
                        minDist, 
                        minY, 
                        maxAngle, 
                        maxX, 
                        maxDist, 
                        maxY, 
                        os, 
                        rotation, 
                        $asyncBody = Bridge.fn.bind(this, function () {
                            for (;;) {
                                $step = System.Array.min([0,1,2,3,4,6,7,8], $step);
                                switch ($step) {
                                    case 0: {
                                        if (parent == null) {
                                            throw new System.ArgumentNullException.$ctor3("parent", "parent cannot be null.");
                                        }
                                        if (child == null) {
                                            throw new System.ArgumentNullException.$ctor3("child", "child cannot be null.");
                                        }
                                        if (parent.inherit !== Spine.Inherit.Normal || child.inherit !== Spine.Inherit.Normal) {
                                            return;
                                        }
                                        px = parent.ax;
                                        py = parent.ay;
                                        psx = parent.ascaleX;
                                        psy = parent.ascaleY;
                                        sx = psx;
                                        sy = psy;
                                        csx = child.ascaleX;
                                        if (psx < 0) {
                                            psx = -psx;
                                            os1 = 180;
                                            s2 = -1;
                                        } else {
                                            os1 = 0;
                                            s2 = 1;
                                        }
                                        if (psy < 0) {
                                            psy = -psy;
                                            s2 = (-s2) | 0;
                                        }
                                        if (csx < 0) {
                                            csx = -csx;
                                            os2 = 180;
                                        } else {
                                            os2 = 0;
                                        }
                                        cx = child.ax;
                                        a = parent.a;
                                        b = parent.b;
                                        c = parent.c;
                                        d = parent.d;
                                        u = Math.abs(psx - psy) <= 0.0001;
                                        if (!u || stretch) {
                                            cy = 0;
                                            cwx = a * cx + parent.worldX;
                                            cwy = c * cx + parent.worldY;
                                        } else {
                                            cy = child.ay;
                                            cwx = a * cx + b * cy + parent.worldX;
                                            cwy = c * cx + d * cy + parent.worldY;
                                        }
                                        pp = parent.parent;
                                        a = pp.a;
                                        b = pp.b;
                                        c = pp.c;
                                        d = pp.d;
                                        id = a * d - b * c;
                                        x = cwx - pp.worldX;
                                        y = cwy - pp.worldY;
                                        id = Math.abs(id) <= 0.0001 ? 0 : 1 / id;
                                        dx = (x * d - y * b) * id - px;
                                        dy = (y * a - x * c) * id - py;
                                        l1 = Math.sqrt(dx * dx + dy * dy);
                                        l2 = child.data.length * csx;
                                        if (l1 < 0.0001) {
                                            Spine.IkConstraint.Apply$1(parent, targetX, targetY, false, stretch, false, alpha);
                                            child.UpdateWorldTransform$1(cx, cy, 0, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);
                                            return;
                                        }
                                        x = targetX - pp.worldX;
                                        y = targetY - pp.worldY;
                                        tx = (x * d - y * b) * id - px;
                                        ty = (y * a - x * c) * id - py;
                                        dd = tx * tx + ty * ty;
                                        if (softness !== 0) {
                                            softness *= psx * (csx + 1) * 0.5;
                                            td = Math.sqrt(dd);
                                            sd = td - l1 - l2 * psx + softness;
                                            if (sd > 0) {
                                                p = Math.min(1, sd / (softness * 2)) - 1;
                                                p = (sd - softness * (1 - p * p)) / td;
                                                tx -= p * tx;
                                                ty -= p * ty;
                                                dd = tx * tx + ty * ty;
                                            }
                                        }
                                        if (u) {
                                            $step = 1;
                                            continue;
                                        } else  {
                                            $step = 2;
                                            continue;
                                        }
                                    }
                                    case 1: {
                                        l2 *= psx;
                                        cos = (dd - l1 * l1 - l2 * l2) / (2 * l1 * l2);
                                        if (cos < -1) {
                                            cos = -1;
                                            a2 = Spine.MathUtils.PI * bendDir;
                                        } else if (cos > 1) {
                                            cos = 1;
                                            a2 = 0;
                                            if (stretch) {
                                                a = (Math.sqrt(dd) / (l1 + l2) - 1) * alpha + 1;
                                                sx *= a;
                                                if (uniform) {
                                                    sy *= a;
                                                }
                                            }
                                        } else {
                                            a2 = Math.acos(cos) * bendDir;
                                        }
                                        a = l1 + l2 * cos;
                                        b = l2 * Math.sin(a2);
                                        a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);
                                        $step = 7;
                                        continue;
                                    }
                                    case 2: {
                                        a = psx * l2;
                                        b = psy * l2;
                                        aa = a * a;
                                        bb = b * b;
                                        ta = Math.atan2(ty, tx);
                                        c = bb * l1 * l1 + aa * dd - aa * bb;
                                        c1 = -2 * bb * l1;
                                        c2 = bb - aa;
                                        d = c1 * c1 - 4 * c2 * c;
                                        if (d >= 0) {
                                            $step = 3;
                                            continue;
                                        } 
                                        $step = 6;
                                        continue;
                                    }
                                    case 3: {
                                        q = Math.sqrt(d);
                                        if (c1 < 0) {
                                            q = -q;
                                        }
                                        q = -(c1 + q) * 0.5;
                                        r0 = q / c2;
                                        r1 = c / q;
                                        r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;
                                        r0 = dd - r * r;
                                        if (r0 >= 0) {
                                            $step = 4;
                                            continue;
                                        } 
                                        $step = 5;
                                        continue;
                                    }
                                    case 4: {
                                        y = Math.sqrt(r0) * bendDir;
                                        a1 = ta - Math.atan2(y, r);
                                        a2 = Math.atan2(y / psy, (r - l1) / psx);
                                        $step = 8;
                                        continue;// break outer;
                                        $step = 5;
                                        continue;
                                    }

                                    case 6: {
                                        minAngle = Spine.MathUtils.PI;
                                        minX = l1 - a;
                                        minDist = minX * minX;
                                        minY = 0;
                                        maxAngle = 0;
                                        maxX = l1 + a;
                                        maxDist = maxX * maxX;
                                        maxY = 0;
                                        c = -a * l1 / (aa - bb);
                                        if (c >= -1 && c <= 1) {
                                            c = Math.acos(c);
                                            x = a * Math.cos(c) + l1;
                                            y = b * Math.sin(c);
                                            d = x * x + y * y;
                                            if (d < minDist) {
                                                minAngle = c;
                                                minDist = d;
                                                minX = x;
                                                minY = y;
                                            }
                                            if (d > maxDist) {
                                                maxAngle = c;
                                                maxDist = d;
                                                maxX = x;
                                                maxY = y;
                                            }
                                        }
                                        if (dd <= (minDist + maxDist) * 0.5) {
                                            a1 = ta - Math.atan2(minY * bendDir, minX);
                                            a2 = minAngle * bendDir;
                                        } else {
                                            a1 = ta - Math.atan2(maxY * bendDir, maxX);
                                            a2 = maxAngle * bendDir;
                                        }
                                        $step = 7;
                                        continue;
                                    }
                                    case 7: {

                                    }
                                    case 8: {
                                        os = Math.atan2(cy, cx) * s2;
                                        rotation = parent.arotation;
                                        a1 = (a1 - os) * Spine.MathUtils.RadDeg + os1 - rotation;
                                        if (a1 > 180) {
                                            a1 -= 360;
                                        } else {
                                            if (a1 < -180) {
                                                a1 += 360;
                                            }
                                        }
                                        parent.UpdateWorldTransform$1(px, py, rotation + a1 * alpha, sx, sy, 0, 0);
                                        rotation = child.arotation;
                                        a2 = ((a2 + os) * Spine.MathUtils.RadDeg - child.ashearX) * s2 + os2 - rotation;
                                        if (a2 > 180) {
                                            a2 -= 360;
                                        } else {
                                            if (a2 < -180) {
                                                a2 += 360;
                                            }
                                        }
                                        child.UpdateWorldTransform$1(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);
                                        return;
                                    }
                                    default: {
                                        return;
                                    }
                                }
                            }
                        }, arguments);

                    return $asyncBody();
                },
                /*Spine.IkConstraint.Apply:static end.*/


            }
        },
        fields: {
            data: null,
            bones: null,
            target: null,
            bendDirection: 0,
            compress: false,
            stretch: false,
            mix: 0,
            softness: 0,
            active: false
        },
        props: {
            /**
             * The bones that will be modified by this IK constraint.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.IkConstraint
             * @function Bones
             * @type Spine.ExposedList$1
             */
            Bones: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Bones#get", this ); }

                    return this.bones;
                }
            },
            /**
             * The bone that is the IK target.
             *
             * @instance
             * @public
             * @memberof Spine.IkConstraint
             * @function Target
             * @type Spine.Bone
             */
            Target: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Target#get", this ); }

                    return this.target;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Target#set", this ); }

                    this.target = value;
                }
            },
            /**
             * A percentage (0-1) that controls the mix between the constrained and unconstrained rotation.
             <p>For two bone IK: if the parent bone has local nonuniform scale, the child bone's local Y translation is set to 0.</p>
             *
             * @instance
             * @public
             * @memberof Spine.IkConstraint
             * @function Mix
             * @type number
             */
            Mix: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Mix#get", this ); }

                    return this.mix;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Mix#set", this ); }

                    this.mix = value;
                }
            },
            /**
             * For two bone IK, the target bone's distance from the maximum reach of the bones where rotation begins to slow. The bones
             will not straighten completely until the target is this far out of range.
             *
             * @instance
             * @public
             * @memberof Spine.IkConstraint
             * @function Softness
             * @type number
             */
            Softness: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Softness#get", this ); }

                    return this.softness;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Softness#set", this ); }

                    this.softness = value;
                }
            },
            /**
             * For two bone IK, controls the bend direction of the IK bones, either 1 or -1.
             *
             * @instance
             * @public
             * @memberof Spine.IkConstraint
             * @function BendDirection
             * @type number
             */
            BendDirection: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraint#BendDirection#get", this ); }

                    return this.bendDirection;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.IkConstraint#BendDirection#set", this ); }

                    this.bendDirection = value;
                }
            },
            /**
             * For one bone IK, when true and the target is too close, the bone is scaled to reach it.
             *
             * @instance
             * @public
             * @memberof Spine.IkConstraint
             * @function Compress
             * @type boolean
             */
            Compress: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Compress#get", this ); }

                    return this.compress;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Compress#set", this ); }

                    this.compress = value;
                }
            },
            /**
             * When true and the target is out of range, the parent bone is scaled to reach it.
             <p>For two bone IK: 1) the child bone's local Y translation is set to 0,
             2) stretch is not applied if {@link } is &gt; 0,
             and 3) if the parent bone has local nonuniform scale, stretch is not applied.</p>
             *
             * @instance
             * @public
             * @memberof Spine.IkConstraint
             * @function Stretch
             * @type boolean
             */
            Stretch: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Stretch#get", this ); }

                    return this.stretch;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Stretch#set", this ); }

                    this.stretch = value;
                }
            },
            Active: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Active#get", this ); }

                    return this.active;
                }
            },
            /**
             * The IK constraint's setup pose data.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.IkConstraint
             * @function Data
             * @type Spine.IkConstraintData
             */
            Data: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Data#get", this ); }

                    return this.data;
                }
            }
        },
        alias: [
            "Update", "Spine$IUpdatable$Update",
            "Active", "Spine$IUpdatable$Active"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraint#init", this ); }

                this.bones = new (Spine.ExposedList$1(Spine.Bone)).ctor();
                this.mix = 1;
            },
            $ctor1: function (data, skeleton) {
if ( TRACE ) { TRACE( "Spine.IkConstraint#$ctor1", this ); }

                var $t, $t1, $t2;
                this.$initialize();
                if (data == null) {
                    throw new System.ArgumentNullException.$ctor3("data", "data cannot be null.");
                }
                this.data = data;

                this.bones = new (Spine.ExposedList$1(Spine.Bone)).$ctor3(data.bones.Count);
                $t = Bridge.getEnumerator(data.bones);
                try {
                    while ($t.moveNext()) {
                        var boneData = $t.Current;
                        this.bones.Add(($t1 = skeleton.bones.Items)[boneData.index]);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                this.target = ($t2 = skeleton.bones.Items)[data.target.index];

                this.mix = data.mix;
                this.softness = data.softness;
                this.bendDirection = data.bendDirection;
                this.compress = data.compress;
                this.stretch = data.stretch;
            },
            /**
             * Copy constructor.
             *
             * @instance
             * @public
             * @this Spine.IkConstraint
             * @memberof Spine.IkConstraint
             * @param   {Spine.IkConstraint}    constraint    
             * @param   {Spine.Skeleton}        skeleton
             * @return  {void}
             */
            ctor: function (constraint, skeleton) {
if ( TRACE ) { TRACE( "Spine.IkConstraint#ctor", this ); }

                Spine.IkConstraint.$ctor1.call(this, constraint.data, skeleton);

                this.mix = constraint.mix;
                this.softness = constraint.softness;
                this.bendDirection = constraint.bendDirection;
                this.compress = constraint.compress;
                this.stretch = constraint.stretch;
            }
        },
        methods: {
            /*Spine.IkConstraint.SetToSetupPose start.*/
            SetToSetupPose: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraint#SetToSetupPose", this ); }

                var data = this.data;
                this.mix = data.mix;
                this.softness = data.softness;
                this.bendDirection = data.bendDirection;
                this.compress = data.compress;
                this.stretch = data.stretch;
            },
            /*Spine.IkConstraint.SetToSetupPose end.*/

            /*Spine.IkConstraint.Update start.*/
            Update: function (physics) {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Update", this ); }

                if (this.mix === 0) {
                    return;
                }
                var target = this.target;
                var bones = this.bones.Items;
                switch (this.bones.Count) {
                    case 1: 
                        Spine.IkConstraint.Apply$1(bones[0], target.worldX, target.worldY, this.compress, this.stretch, this.data.uniform, this.mix);
                        break;
                    case 2: 
                        Spine.IkConstraint.Apply(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.stretch, this.data.uniform, this.softness, this.mix);
                        break;
                }
            },
            /*Spine.IkConstraint.Update end.*/

            /*Spine.IkConstraint.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraint#toString", this ); }

                return this.data.name;
            },
            /*Spine.IkConstraint.toString end.*/


        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.IkConstraint end.*/

    /*Spine.IkConstraintData start.*/
    /**
     * Stores the setup pose for an IkConstraint.
     *
     * @public
     * @class Spine.IkConstraintData
     * @augments Spine.ConstraintData
     */
    Bridge.define("Spine.IkConstraintData", {
        inherits: [Spine.ConstraintData],
        fields: {
            bones: null,
            target: null,
            bendDirection: 0,
            compress: false,
            stretch: false,
            uniform: false,
            mix: 0,
            softness: 0
        },
        props: {
            /**
             * The bones that are constrained by this IK Constraint.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.IkConstraintData
             * @function Bones
             * @type Spine.ExposedList$1
             */
            Bones: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#Bones#get", this ); }

                    return this.bones;
                }
            },
            /**
             * The bone that is the IK target.
             *
             * @instance
             * @public
             * @memberof Spine.IkConstraintData
             * @function Target
             * @type Spine.BoneData
             */
            Target: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#Target#get", this ); }

                    return this.target;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#Target#set", this ); }

                    this.target = value;
                }
            },
            /**
             * A percentage (0-1) that controls the mix between the constrained and unconstrained rotation.
             <p>For two bone IK: if the parent bone has local nonuniform scale, the child bone's local Y translation is set to 0.</p>
             *
             * @instance
             * @public
             * @memberof Spine.IkConstraintData
             * @function Mix
             * @type number
             */
            Mix: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#Mix#get", this ); }

                    return this.mix;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#Mix#set", this ); }

                    this.mix = value;
                }
            },
            /**
             * For two bone IK, the target bone's distance from the maximum reach of the bones where rotation begins to slow. The bones
             will not straighten completely until the target is this far out of range.
             *
             * @instance
             * @public
             * @memberof Spine.IkConstraintData
             * @function Softness
             * @type number
             */
            Softness: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#Softness#get", this ); }

                    return this.softness;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#Softness#set", this ); }

                    this.softness = value;
                }
            },
            /**
             * For two bone IK, controls the bend direction of the IK bones, either 1 or -1.
             *
             * @instance
             * @public
             * @memberof Spine.IkConstraintData
             * @function BendDirection
             * @type number
             */
            BendDirection: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#BendDirection#get", this ); }

                    return this.bendDirection;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#BendDirection#set", this ); }

                    this.bendDirection = value;
                }
            },
            /**
             * For one bone IK, when true and the target is too close, the bone is scaled to reach it.
             *
             * @instance
             * @public
             * @memberof Spine.IkConstraintData
             * @function Compress
             * @type boolean
             */
            Compress: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#Compress#get", this ); }

                    return this.compress;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#Compress#set", this ); }

                    this.compress = value;
                }
            },
            /**
             * When true and the target is out of range, the parent bone is scaled to reach it.
             <p>For two bone IK: 1) the child bone's local Y translation is set to 0,
             2) stretch is not applied if {@link } is &gt; 0,
             and 3) if the parent bone has local nonuniform scale, stretch is not applied.</p>
             *
             * @instance
             * @public
             * @memberof Spine.IkConstraintData
             * @function Stretch
             * @type boolean
             */
            Stretch: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#Stretch#get", this ); }

                    return this.stretch;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#Stretch#set", this ); }

                    this.stretch = value;
                }
            },
            /**
             * When true and {@link } or {@link } is used, the bone is scaled on both the X and Y axes.
             *
             * @instance
             * @public
             * @memberof Spine.IkConstraintData
             * @function Uniform
             * @type boolean
             */
            Uniform: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#Uniform#get", this ); }

                    return this.uniform;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#Uniform#set", this ); }

                    this.uniform = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#init", this ); }

                this.bones = new (Spine.ExposedList$1(Spine.BoneData)).ctor();
            },
            ctor: function (name) {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#ctor", this ); }

                this.$initialize();
                Spine.ConstraintData.ctor.call(this, name);
            }
        }
    });
    /*Spine.IkConstraintData end.*/

    /*Spine.InheritTimeline start.*/
    /**
     * Changes a bone's {@link }.
     *
     * @public
     * @class Spine.InheritTimeline
     * @augments Spine.Timeline
     * @implements  Spine.IBoneTimeline
     */
    Bridge.define("Spine.InheritTimeline", {
        inherits: [Spine.Timeline,Spine.IBoneTimeline],
        statics: {
            fields: {
                ENTRIES: 0,
                INHERIT: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.InheritTimeline#init", this ); }

                    this.ENTRIES = 2;
                    this.INHERIT = 1;
                }
            }
        },
        fields: {
            boneIndex: 0
        },
        props: {
            BoneIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.InheritTimeline#BoneIndex#get", this ); }

                    return this.boneIndex;
                }
            },
            FrameEntries: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.InheritTimeline#FrameEntries#get", this ); }

                    return Spine.InheritTimeline.ENTRIES;
                }
            }
        },
        alias: ["BoneIndex", "Spine$IBoneTimeline$BoneIndex"],
        ctors: {
            ctor: function (frameCount, boneIndex) {
if ( TRACE ) { TRACE( "Spine.InheritTimeline#ctor", this ); }

                this.$initialize();
                Spine.Timeline.ctor.call(this, frameCount, [Spine.Property.Inherit + "|" + boneIndex]);
                this.boneIndex = boneIndex;
            }
        },
        methods: {
            /*Spine.InheritTimeline.SetFrame start.*/
            /**
             * Sets the transform mode for the specified frame.
             *
             * @instance
             * @public
             * @this Spine.InheritTimeline
             * @memberof Spine.InheritTimeline
             * @param   {number}           frame      Between 0 and <pre><code>frameCount</code></pre>, inclusive.
             * @param   {number}           time       The frame time in seconds.
             * @param   {Spine.Inherit}    inherit
             * @return  {void}
             */
            SetFrame: function (frame, time, inherit) {
if ( TRACE ) { TRACE( "Spine.InheritTimeline#SetFrame", this ); }

                frame = Bridge.Int.mul(frame, Spine.InheritTimeline.ENTRIES);
                this.frames[frame] = time;
                this.frames[((frame + Spine.InheritTimeline.INHERIT) | 0)] = inherit;
            },
            /*Spine.InheritTimeline.SetFrame end.*/

            /*Spine.InheritTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.InheritTimeline#Apply", this ); }

                var $t;

                var bone = ($t = skeleton.bones.Items)[this.boneIndex];
                if (!bone.active) {
                    return;
                }

                if (direction === Spine.MixDirection.Out) {
                    if (blend === Spine.MixBlend.Setup) {
                        bone.inherit = bone.data.inherit;
                    }
                    return;
                }

                var frames = this.frames;
                if (time < frames[0]) {
                    if (blend === Spine.MixBlend.Setup || blend === Spine.MixBlend.First) {
                        bone.inherit = bone.data.inherit;
                    }
                    return;
                }
                bone.inherit = Spine.InheritEnum.Values[Bridge.Int.clip32(frames[((Spine.Timeline.Search$1(frames, time, Spine.InheritTimeline.ENTRIES) + Spine.InheritTimeline.INHERIT) | 0)])];
            },
            /*Spine.InheritTimeline.Apply end.*/


        }
    });
    /*Spine.InheritTimeline end.*/

    /*Spine.PathConstraint start.*/
    /**
     * <p>Stores the current pose for a path constraint. A path constraint adjusts the rotation, translation, and scale of the
     constrained bones so they follow a {@link }.</p><p>See <a href="http://esotericsoftware.com/spine-path-constraints">Path constraints</a> in the Spine User Guide.</p>
     *
     * @public
     * @class Spine.PathConstraint
     * @implements  Spine.IUpdatable
     */
    Bridge.define("Spine.PathConstraint", {
        inherits: [Spine.IUpdatable],
        statics: {
            fields: {
                NONE: 0,
                BEFORE: 0,
                AFTER: 0,
                Epsilon: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraint#init", this ); }

                    this.NONE = -1;
                    this.BEFORE = -2;
                    this.AFTER = -3;
                    this.Epsilon = 1E-05;
                }
            },
            methods: {
                /*Spine.PathConstraint.ArraysFill:static start.*/
                ArraysFill: function (a, fromIndex, toIndex, val) {
if ( TRACE ) { TRACE( "Spine.PathConstraint#ArraysFill", this ); }

                    for (var i = fromIndex; i < toIndex; i = (i + 1) | 0) {
                        a[i] = val;
                    }
                },
                /*Spine.PathConstraint.ArraysFill:static end.*/

                /*Spine.PathConstraint.AddBeforePosition:static start.*/
                AddBeforePosition: function (p, temp, i, output, o) {
if ( TRACE ) { TRACE( "Spine.PathConstraint#AddBeforePosition", this ); }

                    var x1 = temp[i], y1 = temp[((i + 1) | 0)], dx = temp[((i + 2) | 0)] - x1, dy = temp[((i + 3) | 0)] - y1, r = Spine.MathUtils.Atan2(dy, dx);
                    output[o] = x1 + p * Spine.MathUtils.Cos(r);
                    output[((o + 1) | 0)] = y1 + p * Spine.MathUtils.Sin(r);
                    output[((o + 2) | 0)] = r;
                },
                /*Spine.PathConstraint.AddBeforePosition:static end.*/

                /*Spine.PathConstraint.AddAfterPosition:static start.*/
                AddAfterPosition: function (p, temp, i, output, o) {
if ( TRACE ) { TRACE( "Spine.PathConstraint#AddAfterPosition", this ); }

                    var x1 = temp[((i + 2) | 0)], y1 = temp[((i + 3) | 0)], dx = x1 - temp[i], dy = y1 - temp[((i + 1) | 0)], r = Spine.MathUtils.Atan2(dy, dx);
                    output[o] = x1 + p * Spine.MathUtils.Cos(r);
                    output[((o + 1) | 0)] = y1 + p * Spine.MathUtils.Sin(r);
                    output[((o + 2) | 0)] = r;
                },
                /*Spine.PathConstraint.AddAfterPosition:static end.*/

                /*Spine.PathConstraint.AddCurvePosition:static start.*/
                AddCurvePosition: function (p, x1, y1, cx1, cy1, cx2, cy2, x2, y2, output, o, tangents) {
if ( TRACE ) { TRACE( "Spine.PathConstraint#AddCurvePosition", this ); }

                    if (p < Spine.PathConstraint.Epsilon || isNaN(p)) {
                        output[o] = x1;
                        output[((o + 1) | 0)] = y1;
                        output[((o + 2) | 0)] = Math.atan2(cy1 - y1, cx1 - x1);
                        return;
                    }
                    var tt = p * p, ttt = tt * p, u = 1 - p, uu = u * u, uuu = uu * u;
                    var ut = u * p, ut3 = ut * 3, uut3 = u * ut3, utt3 = ut3 * p;
                    var x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt, y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;
                    output[o] = x;
                    output[((o + 1) | 0)] = y;
                    if (tangents) {
                        if (p < 0.001) {
                            output[((o + 2) | 0)] = Math.atan2(cy1 - y1, cx1 - x1);
                        } else {
                            output[((o + 2) | 0)] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));
                        }
                    }
                },
                /*Spine.PathConstraint.AddCurvePosition:static end.*/


            }
        },
        fields: {
            data: null,
            bones: null,
            target: null,
            position: 0,
            spacing: 0,
            mixRotate: 0,
            mixX: 0,
            mixY: 0,
            active: false,
            spaces: null,
            positions: null,
            world: null,
            curves: null,
            lengths: null,
            segments: null
        },
        props: {
            /**
             * The position along the path.
             *
             * @instance
             * @public
             * @memberof Spine.PathConstraint
             * @function Position
             * @type number
             */
            Position: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraint#Position#get", this ); }

                    return this.position;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraint#Position#set", this ); }

                    this.position = value;
                }
            },
            /**
             * The spacing between bones.
             *
             * @instance
             * @public
             * @memberof Spine.PathConstraint
             * @function Spacing
             * @type number
             */
            Spacing: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraint#Spacing#get", this ); }

                    return this.spacing;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraint#Spacing#set", this ); }

                    this.spacing = value;
                }
            },
            /**
             * A percentage (0-1) that controls the mix between the constrained and unconstrained rotations.
             *
             * @instance
             * @public
             * @memberof Spine.PathConstraint
             * @function MixRotate
             * @type number
             */
            MixRotate: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraint#MixRotate#get", this ); }

                    return this.mixRotate;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraint#MixRotate#set", this ); }

                    this.mixRotate = value;
                }
            },
            /**
             * A percentage (0-1) that controls the mix between the constrained and unconstrained translation X.
             *
             * @instance
             * @public
             * @memberof Spine.PathConstraint
             * @function MixX
             * @type number
             */
            MixX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraint#MixX#get", this ); }

                    return this.mixX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraint#MixX#set", this ); }

                    this.mixX = value;
                }
            },
            /**
             * A percentage (0-1) that controls the mix between the constrained and unconstrained translation Y.
             *
             * @instance
             * @public
             * @memberof Spine.PathConstraint
             * @function MixY
             * @type number
             */
            MixY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraint#MixY#get", this ); }

                    return this.mixY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraint#MixY#set", this ); }

                    this.mixY = value;
                }
            },
            /**
             * The bones that will be modified by this path constraint.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.PathConstraint
             * @function Bones
             * @type Spine.ExposedList$1
             */
            Bones: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraint#Bones#get", this ); }

                    return this.bones;
                }
            },
            /**
             * The slot whose path attachment will be used to constrained the bones.
             *
             * @instance
             * @public
             * @memberof Spine.PathConstraint
             * @function Target
             * @type Spine.Slot
             */
            Target: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraint#Target#get", this ); }

                    return this.target;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraint#Target#set", this ); }

                    this.target = value;
                }
            },
            Active: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraint#Active#get", this ); }

                    return this.active;
                }
            },
            /**
             * The path constraint's setup pose data.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.PathConstraint
             * @function Data
             * @type Spine.PathConstraintData
             */
            Data: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraint#Data#get", this ); }

                    return this.data;
                }
            }
        },
        alias: [
            "Update", "Spine$IUpdatable$Update",
            "Active", "Spine$IUpdatable$Active"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraint#init", this ); }

                this.spaces = new (Spine.ExposedList$1(System.Single)).ctor();
                this.positions = new (Spine.ExposedList$1(System.Single)).ctor();
                this.world = new (Spine.ExposedList$1(System.Single)).ctor();
                this.curves = new (Spine.ExposedList$1(System.Single)).ctor();
                this.lengths = new (Spine.ExposedList$1(System.Single)).ctor();
                this.segments = System.Array.init(10, 0, System.Single);
            },
            $ctor1: function (data, skeleton) {
if ( TRACE ) { TRACE( "Spine.PathConstraint#$ctor1", this ); }

                var $t, $t1, $t2;
                this.$initialize();
                if (data == null) {
                    throw new System.ArgumentNullException.$ctor3("data", "data cannot be null.");
                }
                if (skeleton == null) {
                    throw new System.ArgumentNullException.$ctor3("skeleton", "skeleton cannot be null.");
                }
                this.data = data;

                this.bones = new (Spine.ExposedList$1(Spine.Bone)).$ctor3(data.Bones.Count);
                $t = Bridge.getEnumerator(data.bones);
                try {
                    while ($t.moveNext()) {
                        var boneData = $t.Current;
                        this.bones.Add(($t1 = skeleton.bones.Items)[boneData.index]);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                this.target = ($t2 = skeleton.slots.Items)[data.target.index];

                this.position = data.position;
                this.spacing = data.spacing;
                this.mixRotate = data.mixRotate;
                this.mixX = data.mixX;
                this.mixY = data.mixY;
            },
            /**
             * Copy constructor.
             *
             * @instance
             * @public
             * @this Spine.PathConstraint
             * @memberof Spine.PathConstraint
             * @param   {Spine.PathConstraint}    constraint    
             * @param   {Spine.Skeleton}          skeleton
             * @return  {void}
             */
            ctor: function (constraint, skeleton) {
if ( TRACE ) { TRACE( "Spine.PathConstraint#ctor", this ); }

                Spine.PathConstraint.$ctor1.call(this, constraint.data, skeleton);

                this.position = constraint.position;
                this.spacing = constraint.spacing;
                this.mixRotate = constraint.mixRotate;
                this.mixX = constraint.mixX;
                this.mixY = constraint.mixY;
            }
        },
        methods: {
            /*Spine.PathConstraint.SetToSetupPose start.*/
            SetToSetupPose: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraint#SetToSetupPose", this ); }

                var data = this.data;
                this.position = data.position;
                this.spacing = data.spacing;
                this.mixRotate = data.mixRotate;
                this.mixX = data.mixX;
                this.mixY = data.mixY;
            },
            /*Spine.PathConstraint.SetToSetupPose end.*/

            /*Spine.PathConstraint.Update start.*/
            Update: function (physics) {
if ( TRACE ) { TRACE( "Spine.PathConstraint#Update", this ); }

                var attachment = Bridge.as(this.target.Attachment, Spine.PathAttachment);
                if (attachment == null) {
                    return;
                }

                var mixRotate = this.mixRotate, mixX = this.mixX, mixY = this.mixY;
                if (mixRotate === 0 && mixX === 0 && mixY === 0) {
                    return;
                }

                var data = this.data;
                var tangents = data.rotateMode === Spine.RotateMode.Tangent, scale = data.rotateMode === Spine.RotateMode.ChainScale;
                var boneCount = this.bones.Count, spacesCount = tangents ? boneCount : ((boneCount + 1) | 0);
                var bonesItems = this.bones.Items;
                var spaces = this.spaces.Resize(spacesCount).Items, lengths = scale ? this.lengths.Resize(boneCount).Items : null;
                var spacing = this.spacing;
                switch (data.spacingMode) {
                    case Spine.SpacingMode.Percent: 
                        if (scale) {
                            for (var i = 0, n = (spacesCount - 1) | 0; i < n; i = (i + 1) | 0) {
                                var bone = bonesItems[i];
                                var setupLength = bone.data.length;
                                var x = setupLength * bone.a, y = setupLength * bone.c;
                                lengths[i] = Math.sqrt(x * x + y * y);
                            }
                        }
                        Spine.PathConstraint.ArraysFill(spaces, 1, spacesCount, spacing);
                        break;
                    case Spine.SpacingMode.Proportional: 
                        {
                            var sum = 0;
                            for (var i1 = 0, n1 = (spacesCount - 1) | 0; i1 < n1; ) {
                                var bone1 = bonesItems[i1];
                                var setupLength1 = bone1.data.length;
                                if (setupLength1 < Spine.PathConstraint.Epsilon) {
                                    if (scale) {
                                        lengths[i1] = 0;
                                    }
                                    spaces[((i1 = (i1 + 1) | 0))] = spacing;
                                } else {
                                    var x1 = setupLength1 * bone1.a, y1 = setupLength1 * bone1.c;
                                    var length = Math.sqrt(x1 * x1 + y1 * y1);
                                    if (scale) {
                                        lengths[i1] = length;
                                    }
                                    spaces[((i1 = (i1 + 1) | 0))] = length;
                                    sum += length;
                                }
                            }
                            if (sum > 0) {
                                sum = spacesCount / sum * spacing;
                                for (var i2 = 1; i2 < spacesCount; i2 = (i2 + 1) | 0) {
                                    spaces[i2] *= sum;
                                }
                            }
                            break;
                        }
                    default: 
                        {
                            var lengthSpacing = data.spacingMode === Spine.SpacingMode.Length;
                            for (var i3 = 0, n2 = (spacesCount - 1) | 0; i3 < n2; ) {
                                var bone2 = bonesItems[i3];
                                var setupLength2 = bone2.data.length;
                                if (setupLength2 < Spine.PathConstraint.Epsilon) {
                                    if (scale) {
                                        lengths[i3] = 0;
                                    }
                                    spaces[((i3 = (i3 + 1) | 0))] = spacing;
                                } else {
                                    var x2 = setupLength2 * bone2.a, y2 = setupLength2 * bone2.c;
                                    var length1 = Math.sqrt(x2 * x2 + y2 * y2);
                                    if (scale) {
                                        lengths[i3] = length1;
                                    }
                                    spaces[((i3 = (i3 + 1) | 0))] = (lengthSpacing ? setupLength2 + spacing : spacing) * length1 / setupLength2;
                                }
                            }
                            break;
                        }
                }

                var positions = this.ComputeWorldPositions(attachment, spacesCount, tangents);
                var boneX = positions[0], boneY = positions[1], offsetRotation = data.offsetRotation;
                var tip;
                if (offsetRotation === 0) {
                    tip = data.rotateMode === Spine.RotateMode.Chain;
                } else {
                    tip = false;
                    var p = this.target.bone;
                    offsetRotation *= p.a * p.d - p.b * p.c > 0 ? Spine.MathUtils.DegRad : -0.0174532924;
                }
                for (var i4 = 0, p1 = 3; i4 < boneCount; i4 = (i4 + 1) | 0, p1 = (p1 + 3) | 0) {
                    var bone3 = bonesItems[i4];
                    bone3.worldX += (boneX - bone3.worldX) * mixX;
                    bone3.worldY += (boneY - bone3.worldY) * mixY;
                    var x3 = positions[p1], y3 = positions[((p1 + 1) | 0)], dx = x3 - boneX, dy = y3 - boneY;
                    if (scale) {
                        var length2 = lengths[i4];
                        if (length2 >= Spine.PathConstraint.Epsilon) {
                            var s = (Math.sqrt(dx * dx + dy * dy) / length2 - 1) * mixRotate + 1;
                            bone3.a *= s;
                            bone3.c *= s;
                        }
                    }
                    boneX = x3;
                    boneY = y3;
                    if (mixRotate > 0) {
                        var a = bone3.a, b = bone3.b, c = bone3.c, d = bone3.d, r, cos, sin;
                        if (tangents) {
                            r = positions[((p1 - 1) | 0)];
                        } else {
                            if (spaces[((i4 + 1) | 0)] < Spine.PathConstraint.Epsilon) {
                                r = positions[((p1 + 2) | 0)];
                            } else {
                                r = Spine.MathUtils.Atan2(dy, dx);
                            }
                        }
                        r -= Spine.MathUtils.Atan2(c, a);
                        if (tip) {
                            cos = Spine.MathUtils.Cos(r);
                            sin = Spine.MathUtils.Sin(r);
                            var length3 = bone3.data.length;
                            boneX += (length3 * (cos * a - sin * c) - dx) * mixRotate;
                            boneY += (length3 * (sin * a + cos * c) - dy) * mixRotate;
                        } else {
                            r += offsetRotation;
                        }
                        if (r > Spine.MathUtils.PI) {
                            r -= Spine.MathUtils.PI2;
                        } else {
                            if (r < -3.14159274) {
                                r += Spine.MathUtils.PI2;
                            }
                        }
                        r *= mixRotate;
                        cos = Spine.MathUtils.Cos(r);
                        sin = Spine.MathUtils.Sin(r);
                        bone3.a = cos * a - sin * c;
                        bone3.b = cos * b - sin * d;
                        bone3.c = sin * a + cos * c;
                        bone3.d = sin * b + cos * d;
                    }
                    bone3.UpdateAppliedTransform();
                }
            },
            /*Spine.PathConstraint.Update end.*/

            /*Spine.PathConstraint.ComputeWorldPositions start.*/
            ComputeWorldPositions: function (path, spacesCount, tangents) {
if ( TRACE ) { TRACE( "Spine.PathConstraint#ComputeWorldPositions", this ); }

                var target = this.target;
                var position = this.position;
                var spaces = this.spaces.Items, output = this.positions.Resize(((Bridge.Int.mul(spacesCount, 3) + 2) | 0)).Items, world;
                var closed = path.Closed;
                var verticesLength = path.WorldVerticesLength, curveCount = (Bridge.Int.div(verticesLength, 6)) | 0, prevCurve = Spine.PathConstraint.NONE;

                var pathLength, multiplier;
                if (!path.ConstantSpeed) {
                    var lengths = path.Lengths;
                    curveCount = (curveCount - (closed ? 1 : 2)) | 0;
                    pathLength = lengths[curveCount];

                    if (this.data.positionMode === Spine.PositionMode.Percent) {
                        position *= pathLength;
                    }

                    switch (this.data.spacingMode) {
                        case Spine.SpacingMode.Percent: 
                            multiplier = pathLength;
                            break;
                        case Spine.SpacingMode.Proportional: 
                            multiplier = pathLength / spacesCount;
                            break;
                        default: 
                            multiplier = 1;
                            break;
                    }

                    world = this.world.Resize(8).Items;
                    for (var i = 0, o = 0, curve = 0; i < spacesCount; i = (i + 1) | 0, o = (o + 3) | 0) {
                        var space = spaces[i] * multiplier;
                        position += space;
                        var p = position;

                        if (closed) {
                            p %= pathLength;
                            if (p < 0) {
                                p += pathLength;
                            }
                            curve = 0;
                        } else if (p < 0) {
                            if (prevCurve !== Spine.PathConstraint.BEFORE) {
                                prevCurve = Spine.PathConstraint.BEFORE;
                                path.ComputeWorldVertices(target, 2, 4, world, 0, 2);
                            }
                            Spine.PathConstraint.AddBeforePosition(p, world, 0, output, o);
                            continue;
                        } else if (p > pathLength) {
                            if (prevCurve !== Spine.PathConstraint.AFTER) {
                                prevCurve = Spine.PathConstraint.AFTER;
                                path.ComputeWorldVertices(target, ((verticesLength - 6) | 0), 4, world, 0, 2);
                            }
                            Spine.PathConstraint.AddAfterPosition(p - pathLength, world, 0, output, o);
                            continue;
                        }

                        // Determine curve containing position.
                        for (; ; curve = (curve + 1) | 0) {
                            var length = lengths[curve];
                            if (p > length) {
                                continue;
                            }
                            if (curve === 0) {
                                p /= length;
                            } else {
                                var prev = lengths[((curve - 1) | 0)];
                                p = (p - prev) / (length - prev);
                            }
                            break;
                        }
                        if (curve !== prevCurve) {
                            prevCurve = curve;
                            if (closed && curve === curveCount) {
                                path.ComputeWorldVertices(target, ((verticesLength - 4) | 0), 4, world, 0, 2);
                                path.ComputeWorldVertices(target, 0, 4, world, 4, 2);
                            } else {
                                path.ComputeWorldVertices(target, ((Bridge.Int.mul(curve, 6) + 2) | 0), 8, world, 0, 2);
                            }
                        }
                        Spine.PathConstraint.AddCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], output, o, tangents || (i > 0 && space < Spine.PathConstraint.Epsilon));
                    }
                    return output;
                }

                // World vertices.
                if (closed) {
                    verticesLength = (verticesLength + 2) | 0;
                    world = this.world.Resize(verticesLength).Items;
                    path.ComputeWorldVertices(target, 2, ((verticesLength - 4) | 0), world, 0, 2);
                    path.ComputeWorldVertices(target, 0, 2, world, ((verticesLength - 4) | 0), 2);
                    world[((verticesLength - 2) | 0)] = world[0];
                    world[((verticesLength - 1) | 0)] = world[1];
                } else {
                    curveCount = (curveCount - 1) | 0;
                    verticesLength = (verticesLength - 4) | 0;
                    world = this.world.Resize(verticesLength).Items;
                    path.ComputeWorldVertices(target, 2, verticesLength, world, 0, 2);
                }

                // Curve lengths.
                var curves = this.curves.Resize(curveCount).Items;
                pathLength = 0;
                var x1 = world[0], y1 = world[1], cx1 = 0, cy1 = 0, cx2 = 0, cy2 = 0, x2 = 0, y2 = 0;
                var tmpx, tmpy, dddfx, dddfy, ddfx, ddfy, dfx, dfy;
                for (var i1 = 0, w = 2; i1 < curveCount; i1 = (i1 + 1) | 0, w = (w + 6) | 0) {
                    cx1 = world[w];
                    cy1 = world[((w + 1) | 0)];
                    cx2 = world[((w + 2) | 0)];
                    cy2 = world[((w + 3) | 0)];
                    x2 = world[((w + 4) | 0)];
                    y2 = world[((w + 5) | 0)];
                    tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;
                    tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;
                    dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;
                    dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;
                    ddfx = tmpx * 2 + dddfx;
                    ddfy = tmpy * 2 + dddfy;
                    dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.166666672;
                    dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.166666672;
                    pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
                    dfx += ddfx;
                    dfy += ddfy;
                    ddfx += dddfx;
                    ddfy += dddfy;
                    pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
                    dfx += ddfx;
                    dfy += ddfy;
                    pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
                    dfx += ddfx + dddfx;
                    dfy += ddfy + dddfy;
                    pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
                    curves[i1] = pathLength;
                    x1 = x2;
                    y1 = y2;
                }

                if (this.data.positionMode === Spine.PositionMode.Percent) {
                    position *= pathLength;
                }

                switch (this.data.spacingMode) {
                    case Spine.SpacingMode.Percent: 
                        multiplier = pathLength;
                        break;
                    case Spine.SpacingMode.Proportional: 
                        multiplier = pathLength / spacesCount;
                        break;
                    default: 
                        multiplier = 1;
                        break;
                }

                var segments = this.segments;
                var curveLength = 0;
                for (var i2 = 0, o1 = 0, curve1 = 0, segment = 0; i2 < spacesCount; i2 = (i2 + 1) | 0, o1 = (o1 + 3) | 0) {
                    var space1 = spaces[i2] * multiplier;
                    position += space1;
                    var p1 = position;

                    if (closed) {
                        p1 %= pathLength;
                        if (p1 < 0) {
                            p1 += pathLength;
                        }
                        curve1 = 0;
                    } else if (p1 < 0) {
                        Spine.PathConstraint.AddBeforePosition(p1, world, 0, output, o1);
                        continue;
                    } else if (p1 > pathLength) {
                        Spine.PathConstraint.AddAfterPosition(p1 - pathLength, world, ((verticesLength - 4) | 0), output, o1);
                        continue;
                    }

                    // Determine curve containing position.
                    for (; ; curve1 = (curve1 + 1) | 0) {
                        var length1 = curves[curve1];
                        if (p1 > length1) {
                            continue;
                        }
                        if (curve1 === 0) {
                            p1 /= length1;
                        } else {
                            var prev1 = curves[((curve1 - 1) | 0)];
                            p1 = (p1 - prev1) / (length1 - prev1);
                        }
                        break;
                    }

                    // Curve segment lengths.
                    if (curve1 !== prevCurve) {
                        prevCurve = curve1;
                        var ii = Bridge.Int.mul(curve1, 6);
                        x1 = world[ii];
                        y1 = world[((ii + 1) | 0)];
                        cx1 = world[((ii + 2) | 0)];
                        cy1 = world[((ii + 3) | 0)];
                        cx2 = world[((ii + 4) | 0)];
                        cy2 = world[((ii + 5) | 0)];
                        x2 = world[((ii + 6) | 0)];
                        y2 = world[((ii + 7) | 0)];
                        tmpx = (x1 - cx1 * 2 + cx2) * 0.03;
                        tmpy = (y1 - cy1 * 2 + cy2) * 0.03;
                        dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.006;
                        dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.006;
                        ddfx = tmpx * 2 + dddfx;
                        ddfy = tmpy * 2 + dddfy;
                        dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.166666672;
                        dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.166666672;
                        curveLength = Math.sqrt(dfx * dfx + dfy * dfy);
                        segments[0] = curveLength;
                        for (ii = 1; ii < 8; ii = (ii + 1) | 0) {
                            dfx += ddfx;
                            dfy += ddfy;
                            ddfx += dddfx;
                            ddfy += dddfy;
                            curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
                            segments[ii] = curveLength;
                        }
                        dfx += ddfx;
                        dfy += ddfy;
                        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
                        segments[8] = curveLength;
                        dfx += ddfx + dddfx;
                        dfy += ddfy + dddfy;
                        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
                        segments[9] = curveLength;
                        segment = 0;
                    }

                    // Weight by segment length.
                    p1 *= curveLength;
                    for (; ; segment = (segment + 1) | 0) {
                        var length2 = segments[segment];
                        if (p1 > length2) {
                            continue;
                        }
                        if (segment === 0) {
                            p1 /= length2;
                        } else {
                            var prev2 = segments[((segment - 1) | 0)];
                            p1 = segment + (p1 - prev2) / (length2 - prev2);
                        }
                        break;
                    }
                    Spine.PathConstraint.AddCurvePosition(p1 * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, output, o1, tangents || (i2 > 0 && space1 < Spine.PathConstraint.Epsilon));
                }
                return output;
            },
            /*Spine.PathConstraint.ComputeWorldPositions end.*/

            /*Spine.PathConstraint.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraint#toString", this ); }

                return this.data.name;
            },
            /*Spine.PathConstraint.toString end.*/


        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.PathConstraint end.*/

    /*Spine.PathConstraintData start.*/
    Bridge.define("Spine.PathConstraintData", {
        inherits: [Spine.ConstraintData],
        fields: {
            bones: null,
            target: null,
            positionMode: 0,
            spacingMode: 0,
            rotateMode: 0,
            offsetRotation: 0,
            position: 0,
            spacing: 0,
            mixRotate: 0,
            mixX: 0,
            mixY: 0
        },
        props: {
            Bones: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#Bones#get", this ); }

                    return this.bones;
                }
            },
            Target: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#Target#get", this ); }

                    return this.target;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#Target#set", this ); }

                    this.target = value;
                }
            },
            PositionMode: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#PositionMode#get", this ); }

                    return this.positionMode;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#PositionMode#set", this ); }

                    this.positionMode = value;
                }
            },
            SpacingMode: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#SpacingMode#get", this ); }

                    return this.spacingMode;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#SpacingMode#set", this ); }

                    this.spacingMode = value;
                }
            },
            RotateMode: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#RotateMode#get", this ); }

                    return this.rotateMode;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#RotateMode#set", this ); }

                    this.rotateMode = value;
                }
            },
            OffsetRotation: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#OffsetRotation#get", this ); }

                    return this.offsetRotation;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#OffsetRotation#set", this ); }

                    this.offsetRotation = value;
                }
            },
            Position: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#Position#get", this ); }

                    return this.position;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#Position#set", this ); }

                    this.position = value;
                }
            },
            Spacing: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#Spacing#get", this ); }

                    return this.spacing;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#Spacing#set", this ); }

                    this.spacing = value;
                }
            },
            /**
             * A percentage (0-1) that controls the mix between the constrained and unconstrained rotation.
             *
             * @instance
             * @public
             * @memberof Spine.PathConstraintData
             * @function RotateMix
             * @type number
             */
            RotateMix: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#RotateMix#get", this ); }

                    return this.mixRotate;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#RotateMix#set", this ); }

                    this.mixRotate = value;
                }
            },
            /**
             * A percentage (0-1) that controls the mix between the constrained and unconstrained translation X.
             *
             * @instance
             * @public
             * @memberof Spine.PathConstraintData
             * @function MixX
             * @type number
             */
            MixX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#MixX#get", this ); }

                    return this.mixX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#MixX#set", this ); }

                    this.mixX = value;
                }
            },
            /**
             * A percentage (0-1) that controls the mix between the constrained and unconstrained translation Y.
             *
             * @instance
             * @public
             * @memberof Spine.PathConstraintData
             * @function MixY
             * @type number
             */
            MixY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#MixY#get", this ); }

                    return this.mixY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#MixY#set", this ); }

                    this.mixY = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#init", this ); }

                this.bones = new (Spine.ExposedList$1(Spine.BoneData)).ctor();
            },
            ctor: function (name) {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#ctor", this ); }

                this.$initialize();
                Spine.ConstraintData.ctor.call(this, name);
            }
        }
    });
    /*Spine.PathConstraintData end.*/

    /*Spine.PhysicsConstraint start.*/
    /**
     * Stores the current pose for a physics constraint. A physics constraint applies physics to bones.
     <p>See <a href="http://esotericsoftware.com/spine-physics-constraints">Physics constraints</a> in the Spine User Guide.</p>
     *
     * @public
     * @class Spine.PhysicsConstraint
     * @implements  Spine.IUpdatable
     */
    Bridge.define("Spine.PhysicsConstraint", {
        inherits: [Spine.IUpdatable],
        fields: {
            data: null,
            bone: null,
            inertia: 0,
            strength: 0,
            damping: 0,
            massInverse: 0,
            wind: 0,
            gravity: 0,
            mix: 0,
            reset: false,
            ux: 0,
            uy: 0,
            cx: 0,
            cy: 0,
            tx: 0,
            ty: 0,
            xOffset: 0,
            xVelocity: 0,
            yOffset: 0,
            yVelocity: 0,
            rotateOffset: 0,
            rotateVelocity: 0,
            scaleOffset: 0,
            scaleVelocity: 0,
            active: false,
            skeleton: null,
            remaining: 0,
            lastTime: 0
        },
        props: {
            /**
             * The bone constrained by this physics constraint.
             *
             * @instance
             * @public
             * @memberof Spine.PhysicsConstraint
             * @function Bone
             * @type Spine.Bone
             */
            Bone: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraint#Bone#get", this ); }

                    return this.bone;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraint#Bone#set", this ); }

                    this.bone = value;
                }
            },
            Inertia: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraint#Inertia#get", this ); }

                    return this.inertia;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraint#Inertia#set", this ); }

                    this.inertia = value;
                }
            },
            Strength: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraint#Strength#get", this ); }

                    return this.strength;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraint#Strength#set", this ); }

                    this.strength = value;
                }
            },
            Damping: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraint#Damping#get", this ); }

                    return this.damping;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraint#Damping#set", this ); }

                    this.damping = value;
                }
            },
            MassInverse: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraint#MassInverse#get", this ); }

                    return this.massInverse;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraint#MassInverse#set", this ); }

                    this.massInverse = value;
                }
            },
            Wind: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraint#Wind#get", this ); }

                    return this.wind;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraint#Wind#set", this ); }

                    this.wind = value;
                }
            },
            Gravity: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraint#Gravity#get", this ); }

                    return this.gravity;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraint#Gravity#set", this ); }

                    this.gravity = value;
                }
            },
            /**
             * A percentage (0-1) that controls the mix between the constrained and unconstrained poses.
             *
             * @instance
             * @public
             * @memberof Spine.PhysicsConstraint
             * @function Mix
             * @type number
             */
            Mix: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraint#Mix#get", this ); }

                    return this.mix;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraint#Mix#set", this ); }

                    this.mix = value;
                }
            },
            Active: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraint#Active#get", this ); }

                    return this.active;
                }
            },
            /**
             * The physics constraint's setup pose data.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.PhysicsConstraint
             * @function Data
             * @type Spine.PhysicsConstraintData
             */
            Data: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraint#Data#get", this ); }

                    return this.data;
                }
            }
        },
        alias: [
            "Update", "Spine$IUpdatable$Update",
            "Active", "Spine$IUpdatable$Active"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraint#init", this ); }

                this.reset = true;
            },
            $ctor1: function (data, skeleton) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraint#$ctor1", this ); }

                var $t;
                this.$initialize();
                if (data == null) {
                    throw new System.ArgumentNullException.$ctor3("data", "data cannot be null.");
                }
                if (skeleton == null) {
                    throw new System.ArgumentNullException.$ctor3("skeleton", "skeleton cannot be null.");
                }
                this.data = data;
                this.skeleton = skeleton;

                this.bone = ($t = skeleton.bones.Items)[data.bone.index];

                this.inertia = data.inertia;
                this.strength = data.strength;
                this.damping = data.damping;
                this.massInverse = data.massInverse;
                this.wind = data.wind;
                this.gravity = data.gravity;
                this.mix = data.mix;
            },
            /**
             * Copy constructor.
             *
             * @instance
             * @public
             * @this Spine.PhysicsConstraint
             * @memberof Spine.PhysicsConstraint
             * @param   {Spine.PhysicsConstraint}    constraint    
             * @param   {Spine.Skeleton}             skeleton
             * @return  {void}
             */
            ctor: function (constraint, skeleton) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraint#ctor", this ); }

                Spine.PhysicsConstraint.$ctor1.call(this, constraint.data, skeleton);

                this.inertia = constraint.inertia;
                this.strength = constraint.strength;
                this.damping = constraint.damping;
                this.massInverse = constraint.massInverse;
                this.wind = constraint.wind;
                this.gravity = constraint.gravity;
                this.mix = constraint.mix;
            }
        },
        methods: {
            /*Spine.PhysicsConstraint.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraint#Reset", this ); }

                this.remaining = 0;
                this.lastTime = this.skeleton.time;
                this.reset = true;
                this.xOffset = 0;
                this.xVelocity = 0;
                this.yOffset = 0;
                this.yVelocity = 0;
                this.rotateOffset = 0;
                this.rotateVelocity = 0;
                this.scaleOffset = 0;
                this.scaleVelocity = 0;
            },
            /*Spine.PhysicsConstraint.Reset end.*/

            /*Spine.PhysicsConstraint.SetToSetupPose start.*/
            SetToSetupPose: function () {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraint#SetToSetupPose", this ); }

                var data = this.data;
                this.inertia = data.inertia;
                this.strength = data.strength;
                this.damping = data.damping;
                this.massInverse = data.massInverse;
                this.wind = data.wind;
                this.gravity = data.gravity;
                this.mix = data.mix;
            },
            /*Spine.PhysicsConstraint.SetToSetupPose end.*/

            /*Spine.PhysicsConstraint.Translate start.*/
            /**
             * Translates the physics constraint so next {@link } forces are applied as if the bone moved an additional
             amount in world space.
             *
             * @instance
             * @public
             * @this Spine.PhysicsConstraint
             * @memberof Spine.PhysicsConstraint
             * @param   {number}    x    
             * @param   {number}    y
             * @return  {void}
             */
            Translate: function (x, y) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraint#Translate", this ); }

                this.ux -= x;
                this.uy -= y;
                this.cx -= x;
                this.cy -= y;
            },
            /*Spine.PhysicsConstraint.Translate end.*/

            /*Spine.PhysicsConstraint.Rotate start.*/
            /**
             * Rotates the physics constraint so next {@link } forces are applied as if the bone rotated around the
             specified point in world space.
             *
             * @instance
             * @public
             * @this Spine.PhysicsConstraint
             * @memberof Spine.PhysicsConstraint
             * @param   {number}    x          
             * @param   {number}    y          
             * @param   {number}    degrees
             * @return  {void}
             */
            Rotate: function (x, y, degrees) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraint#Rotate", this ); }

                var r = degrees * Spine.MathUtils.DegRad, cos = Math.cos(r), sin = Math.sin(r);
                var dx = this.cx - x, dy = this.cy - y;
                this.Translate(dx * cos - dy * sin - dx, dx * sin + dy * cos - dy);
            },
            /*Spine.PhysicsConstraint.Rotate end.*/

            /*Spine.PhysicsConstraint.Update start.*/
            /**
             * Applies the constraint to the constrained bones.
             *
             * @instance
             * @public
             * @this Spine.PhysicsConstraint
             * @memberof Spine.PhysicsConstraint
             * @param   {number}    physics
             * @return  {void}
             */
            Update: function (physics) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraint#Update", this ); }

                var $step = 0,
                    $jumpFromFinally, 
                    mix, 
                    x, 
                    y, 
                    rotateOrShearX, 
                    scaleX, 
                    bone, 
                    l, 
                    skeleton, 
                    delta, 
                    bx, 
                    by, 
                    a, 
                    i, 
                    t, 
                    f, 
                    d, 
                    qx, 
                    qy, 
                    u, 
                    u1, 
                    m, 
                    e, 
                    w, 
                    g, 
                    ca, 
                    c, 
                    s, 
                    mr, 
                    dx, 
                    dy, 
                    r, 
                    r1, 
                    m1, 
                    e1, 
                    w1, 
                    g1, 
                    h, 
                    r2, 
                    o, 
                    s1, 
                    c1, 
                    a1, 
                    r3, 
                    s2, 
                    $asyncBody = Bridge.fn.bind(this, function () {
                        for (;;) {
                            $step = System.Array.min([0,1,2,3,4,5], $step);
                            switch ($step) {
                                case 0: {
                                    mix = this.mix;
                                    if (mix === 0) {
                                        return;
                                    }

                                    x = this.data.x > 0;
                                    y = this.data.y > 0;
                                    rotateOrShearX = this.data.rotate > 0 || this.data.shearX > 0;
                                    scaleX = this.data.scaleX > 0;
                                    bone = this.bone;
                                    l = bone.data.length;

                                    if (physics === Spine.Skeleton.Physics.None) {
                                        $step = 1;
                                        continue;
                                    }
                                    else if (physics === Spine.Skeleton.Physics.Reset) {
                                        $step = 2;
                                        continue;
                                    }
                                    else if (physics === Spine.Skeleton.Physics.Update) {
                                        $step = 3;
                                        continue;
                                    }
                                    else if (physics === Spine.Skeleton.Physics.Pose) {
                                        $step = 4;
                                        continue;
                                    }
                                    $step = 5;
                                    continue;
                                }
                                case 1: {
                                    return;
                                }
                                case 2: {
                                    this.Reset();
                                    $step = 3;
                                    continue;
                                }
                                case 3: {
                                    skeleton = this.skeleton;
                                    delta = Math.max(skeleton.time - this.lastTime, 0);
                                    this.remaining += delta;
                                    this.lastTime = skeleton.time;
                                    bx = bone.worldX;
                                    by = bone.worldY;
                                    if (this.reset) {
                                        this.reset = false;
                                        this.ux = bx;
                                        this.uy = by;
                                    } else {
                                        a = this.remaining;
                                        i = this.inertia;
                                        t = this.data.step;
                                        f = skeleton.data.referenceScale;
                                        d = -1;
                                        qx = this.data.limit * delta;
                                        qy = qx * Math.abs(skeleton.ScaleY);
                                        qx *= Math.abs(skeleton.ScaleX);

                                        if (x || y) {
                                            if (x) {
                                                u = (this.ux - bx) * i;
                                                this.xOffset += u > qx ? qx : u < -qx ? -qx : u;
                                                this.ux = bx;
                                            }
                                            if (y) {
                                                u1 = (this.uy - by) * i;
                                                this.yOffset += u1 > qy ? qy : u1 < -qy ? -qy : u1;
                                                this.uy = by;
                                            }
                                            if (a >= t) {
                                                d = Math.pow(this.damping, 60 * t);
                                                m = this.massInverse * t;
                                                e = this.strength;
                                                w = this.wind * f;
                                                g = (Spine.Bone.yDown ? -this.gravity : this.gravity) * f;
                                                do {
                                                    if (x) {
                                                        this.xVelocity += (w - this.xOffset * e) * m;
                                                        this.xOffset += this.xVelocity * t;
                                                        this.xVelocity *= d;
                                                    }
                                                    if (y) {
                                                        this.yVelocity -= (g + this.yOffset * e) * m;
                                                        this.yOffset += this.yVelocity * t;
                                                        this.yVelocity *= d;
                                                    }
                                                    a -= t;
                                                } while (a >= t);
                                            }
                                            if (x) {
                                                bone.worldX += this.xOffset * mix * this.data.x;
                                            }
                                            if (y) {
                                                bone.worldY += this.yOffset * mix * this.data.y;
                                            }
                                        }
                                        if (rotateOrShearX || scaleX) {
                                            ca = Math.atan2(bone.c, bone.a);
                                            mr = 0;
                                            dx = this.cx - bone.worldX;
                                            dy = this.cy - bone.worldY;
                                            if (dx > qx) {
                                                dx = qx;
                                            } else {
                                                if (dx < -qx) {
                                                    dx = -qx;
                                                }
                                            }
                                            if (dy > qy) {
                                                dy = qy;
                                            } else {
                                                if (dy < -qy) {
                                                    dy = -qy;
                                                }
                                            }
                                            if (rotateOrShearX) {
                                                mr = (this.data.rotate + this.data.shearX) * mix;
                                                r = Math.atan2(dy + this.ty, dx + this.tx) - ca - this.rotateOffset * mr;
                                                this.rotateOffset += (r - Math.ceil(r * Spine.MathUtils.InvPI2 - 0.5) * Spine.MathUtils.PI2) * i;
                                                r = this.rotateOffset * mr + ca;
                                                c = Math.cos(r);
                                                s = Math.sin(r);
                                                if (scaleX) {
                                                    r = l * bone.WorldScaleX;
                                                    if (r > 0) {
                                                        this.scaleOffset += (dx * c + dy * s) * i / r;
                                                    }
                                                }
                                            } else {
                                                c = Math.cos(ca);
                                                s = Math.sin(ca);
                                                r1 = l * bone.WorldScaleX;
                                                if (r1 > 0) {
                                                    this.scaleOffset += (dx * c + dy * s) * i / r1;
                                                }
                                            }
                                            a = this.remaining;
                                            if (a >= t) {
                                                if (d === -1) {
                                                    d = Math.pow(this.damping, 60 * t);
                                                }
                                                m1 = this.massInverse * t;
                                                e1 = this.strength;
                                                w1 = this.wind;
                                                g1 = (Spine.Bone.yDown ? -this.gravity : this.gravity);
                                                h = l / f;
                                                while (true) {
                                                    a -= t;
                                                    if (scaleX) {
                                                        this.scaleVelocity += (w1 * c - g1 * s - this.scaleOffset * e1) * m1;
                                                        this.scaleOffset += this.scaleVelocity * t;
                                                        this.scaleVelocity *= d;
                                                    }
                                                    if (rotateOrShearX) {
                                                        this.rotateVelocity -= ((w1 * s + g1 * c) * h + this.rotateOffset * e1) * m1;
                                                        this.rotateOffset += this.rotateVelocity * t;
                                                        this.rotateVelocity *= d;
                                                        if (a < t) {
                                                            break;
                                                        }
                                                        r2 = this.rotateOffset * mr + ca;
                                                        c = Math.cos(r2);
                                                        s = Math.sin(r2);
                                                    } else if (a < t) {
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                        this.remaining = a;
                                    }
                                    this.cx = bone.worldX;
                                    this.cy = bone.worldY;
                                    $step = 5;
                                    continue;
                                }
                                case 4: {
                                    if (x) {
                                        bone.worldX += this.xOffset * mix * this.data.x;
                                    }
                                    if (y) {
                                        bone.worldY += this.yOffset * mix * this.data.y;
                                    }
                                    $step = 5;
                                    continue;
                                }
                                case 5: {
                                    if (rotateOrShearX) {
                                        o = this.rotateOffset * mix;
                                        if (this.data.shearX > 0) {
                                            r3 = 0;
                                            if (this.data.rotate > 0) {
                                                r3 = o * this.data.rotate;
                                                s1 = Math.sin(r3);
                                                c1 = Math.cos(r3);
                                                a1 = bone.b;
                                                bone.b = c1 * a1 - s1 * bone.d;
                                                bone.d = s1 * a1 + c1 * bone.d;
                                            }
                                            r3 += o * this.data.shearX;
                                            s1 = Math.sin(r3);
                                            c1 = Math.cos(r3);
                                            a1 = bone.a;
                                            bone.a = c1 * a1 - s1 * bone.c;
                                            bone.c = s1 * a1 + c1 * bone.c;
                                        } else {
                                            o *= this.data.rotate;
                                            s1 = Math.sin(o);
                                            c1 = Math.cos(o);
                                            a1 = bone.a;
                                            bone.a = c1 * a1 - s1 * bone.c;
                                            bone.c = s1 * a1 + c1 * bone.c;
                                            a1 = bone.b;
                                            bone.b = c1 * a1 - s1 * bone.d;
                                            bone.d = s1 * a1 + c1 * bone.d;
                                        }
                                    }
                                    if (scaleX) {
                                        s2 = 1 + this.scaleOffset * mix * this.data.scaleX;
                                        bone.a *= s2;
                                        bone.c *= s2;
                                    }
                                    if (physics !== Spine.Skeleton.Physics.Pose) {
                                        this.tx = l * bone.a;
                                        this.ty = l * bone.c;
                                    }
                                    bone.UpdateAppliedTransform();
                                    return;
                                }
                                default: {
                                    return;
                                }
                            }
                        }
                    }, arguments);

                return $asyncBody();
            },
            /*Spine.PhysicsConstraint.Update end.*/

            /*Spine.PhysicsConstraint.getData start.*/
            /**
             * The physics constraint's setup pose data.
             *
             * @instance
             * @public
             * @this Spine.PhysicsConstraint
             * @memberof Spine.PhysicsConstraint
             * @return  {Spine.PhysicsConstraintData}
             */
            getData: function () {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraint#getData", this ); }

                return this.data;
            },
            /*Spine.PhysicsConstraint.getData end.*/

            /*Spine.PhysicsConstraint.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraint#toString", this ); }

                return this.data.name;
            },
            /*Spine.PhysicsConstraint.toString end.*/


        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.PhysicsConstraint end.*/

    /*Spine.PhysicsConstraintData start.*/
    /**
     * Stores the setup pose for a {@link }.
     <p>See <a href="http://esotericsoftware.com/spine-physics-constraints">Physics constraints</a> in the Spine User Guide.</p>
     *
     * @public
     * @class Spine.PhysicsConstraintData
     * @augments Spine.ConstraintData
     */
    Bridge.define("Spine.PhysicsConstraintData", {
        inherits: [Spine.ConstraintData],
        fields: {
            bone: null,
            x: 0,
            y: 0,
            rotate: 0,
            scaleX: 0,
            shearX: 0,
            limit: 0,
            step: 0,
            inertia: 0,
            strength: 0,
            damping: 0,
            massInverse: 0,
            wind: 0,
            gravity: 0,
            mix: 0,
            inertiaGlobal: false,
            strengthGlobal: false,
            dampingGlobal: false,
            massGlobal: false,
            windGlobal: false,
            gravityGlobal: false,
            mixGlobal: false
        },
        props: {
            /**
             * The bone constrained by this physics constraint.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.PhysicsConstraintData
             * @function Bone
             * @type Spine.BoneData
             */
            Bone: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintData#Bone#get", this ); }

                    return this.bone;
                }
            },
            Step: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintData#Step#get", this ); }

                    return this.step;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintData#Step#set", this ); }

                    this.step = value;
                }
            },
            X: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintData#X#get", this ); }

                    return this.x;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintData#X#set", this ); }

                    this.x = value;
                }
            },
            Y: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintData#Y#get", this ); }

                    return this.y;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintData#Y#set", this ); }

                    this.y = value;
                }
            },
            Rotate: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintData#Rotate#get", this ); }

                    return this.rotate;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintData#Rotate#set", this ); }

                    this.rotate = value;
                }
            },
            ScaleX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintData#ScaleX#get", this ); }

                    return this.scaleX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintData#ScaleX#set", this ); }

                    this.scaleX = value;
                }
            },
            ShearX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintData#ShearX#get", this ); }

                    return this.shearX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintData#ShearX#set", this ); }

                    this.shearX = value;
                }
            },
            Limit: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintData#Limit#get", this ); }

                    return this.limit;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintData#Limit#set", this ); }

                    this.limit = value;
                }
            },
            Inertia: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintData#Inertia#get", this ); }

                    return this.inertia;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintData#Inertia#set", this ); }

                    this.inertia = value;
                }
            },
            Strength: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintData#Strength#get", this ); }

                    return this.strength;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintData#Strength#set", this ); }

                    this.strength = value;
                }
            },
            Damping: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintData#Damping#get", this ); }

                    return this.damping;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintData#Damping#set", this ); }

                    this.damping = value;
                }
            },
            MassInverse: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintData#MassInverse#get", this ); }

                    return this.massInverse;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintData#MassInverse#set", this ); }

                    this.massInverse = value;
                }
            },
            Wind: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintData#Wind#get", this ); }

                    return this.wind;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintData#Wind#set", this ); }

                    this.wind = value;
                }
            },
            Gravity: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintData#Gravity#get", this ); }

                    return this.gravity;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintData#Gravity#set", this ); }

                    this.gravity = value;
                }
            },
            /**
             * A percentage (0-1) that controls the mix between the constrained and unconstrained poses.
             *
             * @instance
             * @public
             * @memberof Spine.PhysicsConstraintData
             * @function Mix
             * @type number
             */
            Mix: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintData#Mix#get", this ); }

                    return this.mix;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintData#Mix#set", this ); }

                    this.mix = value;
                }
            },
            InertiaGlobal: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintData#InertiaGlobal#get", this ); }

                    return this.inertiaGlobal;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintData#InertiaGlobal#set", this ); }

                    this.inertiaGlobal = value;
                }
            },
            StrengthGlobal: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintData#StrengthGlobal#get", this ); }

                    return this.strengthGlobal;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintData#StrengthGlobal#set", this ); }

                    this.strengthGlobal = value;
                }
            },
            DampingGlobal: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintData#DampingGlobal#get", this ); }

                    return this.dampingGlobal;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintData#DampingGlobal#set", this ); }

                    this.dampingGlobal = value;
                }
            },
            MassGlobal: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintData#MassGlobal#get", this ); }

                    return this.massGlobal;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintData#MassGlobal#set", this ); }

                    this.massGlobal = value;
                }
            },
            WindGlobal: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintData#WindGlobal#get", this ); }

                    return this.windGlobal;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintData#WindGlobal#set", this ); }

                    this.windGlobal = value;
                }
            },
            GravityGlobal: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintData#GravityGlobal#get", this ); }

                    return this.gravityGlobal;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintData#GravityGlobal#set", this ); }

                    this.gravityGlobal = value;
                }
            },
            MixGlobal: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintData#MixGlobal#get", this ); }

                    return this.mixGlobal;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintData#MixGlobal#set", this ); }

                    this.mixGlobal = value;
                }
            }
        },
        ctors: {
            ctor: function (name) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintData#ctor", this ); }

                this.$initialize();
                Spine.ConstraintData.ctor.call(this, name);
            }
        }
    });
    /*Spine.PhysicsConstraintData end.*/

    /*Spine.PhysicsConstraintResetTimeline start.*/
    /**
     * Resets a physics constraint when specific animation times are reached.
     *
     * @public
     * @class Spine.PhysicsConstraintResetTimeline
     * @augments Spine.Timeline
     */
    Bridge.define("Spine.PhysicsConstraintResetTimeline", {
        inherits: [Spine.Timeline],
        statics: {
            fields: {
                propertyIds: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintResetTimeline#init", this ); }

                    this.propertyIds = System.Array.init([Bridge.toString((Spine.Property.PhysicsConstraintReset))], System.String);
                }
            }
        },
        fields: {
            constraintIndex: 0
        },
        props: {
            /**
             * The index of the physics constraint in {@link } that will be reset when this timeline is
             applied, or -1 if all physics constraints in the skeleton will be reset.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.PhysicsConstraintResetTimeline
             * @function PhysicsConstraintIndex
             * @type number
             */
            PhysicsConstraintIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintResetTimeline#PhysicsConstraintIndex#get", this ); }

                    return this.constraintIndex;
                }
            },
            FrameCount: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintResetTimeline#FrameCount#get", this ); }

                    return this.frames.length;
                }
            }
        },
        ctors: {
            /**
             * @instance
             * @public
             * @this Spine.PhysicsConstraintResetTimeline
             * @memberof Spine.PhysicsConstraintResetTimeline
             * @param   {number}    frameCount                
             * @param   {number}    physicsConstraintIndex    -1 for all physics constraints in the skeleton.
             * @return  {void}
             */
            ctor: function (frameCount, physicsConstraintIndex) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintResetTimeline#ctor", this ); }

                this.$initialize();
                Spine.Timeline.ctor.call(this, frameCount, Spine.PhysicsConstraintResetTimeline.propertyIds);
                this.constraintIndex = physicsConstraintIndex;
            }
        },
        methods: {
            /*Spine.PhysicsConstraintResetTimeline.SetFrame start.*/
            
            SetFrame: function (frame, time) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintResetTimeline#SetFrame", this ); }

                this.frames[frame] = time;
            },
            /*Spine.PhysicsConstraintResetTimeline.SetFrame end.*/

            /*Spine.PhysicsConstraintResetTimeline.Apply start.*/
            
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintResetTimeline#Apply", this ); }

                var $t;

                var constraint = null;
                if (this.constraintIndex !== -1) {
                    constraint = ($t = skeleton.physicsConstraints.Items)[this.constraintIndex];
                    if (!constraint.active) {
                        return;
                    }
                }

                var frames = this.frames;

                if (lastTime > time) { // Apply after lastTime for looped animations.
                    this.Apply(skeleton, lastTime, 2147483647, null, alpha, blend, direction);
                    lastTime = -1.0;
                } else if (lastTime >= frames[((frames.length - 1) | 0)]) {
                    return;
                }
                if (time < frames[0]) {
                    return;
                }

                if (lastTime < frames[0] || time >= frames[((Spine.Timeline.Search(frames, lastTime) + 1) | 0)]) {
                    if (constraint != null) {
                        constraint.Reset();
                    } else {
                        var constraints = skeleton.physicsConstraints.Items;
                        for (var i = 0, n = skeleton.physicsConstraints.Count; i < n; i = (i + 1) | 0) {
                            constraint = constraints[i];
                            if (constraint.active) {
                                constraint.Reset();
                            }
                        }
                    }
                }
            },
            /*Spine.PhysicsConstraintResetTimeline.Apply end.*/


        }
    });
    /*Spine.PhysicsConstraintResetTimeline end.*/

    /*Spine.PointAttachment start.*/
    
    Bridge.define("Spine.PointAttachment", {
        inherits: [Spine.Attachment],
        fields: {
            x: 0,
            y: 0,
            rotation: 0
        },
        props: {
            X: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PointAttachment#X#get", this ); }

                    return this.x;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PointAttachment#X#set", this ); }

                    this.x = value;
                }
            },
            Y: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PointAttachment#Y#get", this ); }

                    return this.y;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PointAttachment#Y#set", this ); }

                    this.y = value;
                }
            },
            Rotation: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PointAttachment#Rotation#get", this ); }

                    return this.rotation;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PointAttachment#Rotation#set", this ); }

                    this.rotation = value;
                }
            }
        },
        ctors: {
            $ctor1: function (name) {
if ( TRACE ) { TRACE( "Spine.PointAttachment#$ctor1", this ); }

                this.$initialize();
                Spine.Attachment.$ctor1.call(this, name);
            },
            /**
             * Copy constructor.
             *
             * @instance
             * @protected
             * @this Spine.PointAttachment
             * @memberof Spine.PointAttachment
             * @param   {Spine.PointAttachment}    other
             * @return  {void}
             */
            ctor: function (other) {
if ( TRACE ) { TRACE( "Spine.PointAttachment#ctor", this ); }

                this.$initialize();
                Spine.Attachment.ctor.call(this, other);
                this.x = other.x;
                this.y = other.y;
                this.rotation = other.rotation;
            }
        },
        methods: {
            /*Spine.PointAttachment.ComputeWorldPosition start.*/
            ComputeWorldPosition: function (bone, ox, oy) {
if ( TRACE ) { TRACE( "Spine.PointAttachment#ComputeWorldPosition", this ); }

                bone.LocalToWorld(this.x, this.y, ox, oy);
            },
            /*Spine.PointAttachment.ComputeWorldPosition end.*/

            /*Spine.PointAttachment.ComputeWorldRotation start.*/
            ComputeWorldRotation: function (bone) {
if ( TRACE ) { TRACE( "Spine.PointAttachment#ComputeWorldRotation", this ); }

                var r = this.rotation * Spine.MathUtils.DegRad, cos = Math.cos(r), sin = Math.sin(r);
                var x = cos * bone.a + sin * bone.b;
                var y = cos * bone.c + sin * bone.d;
                return Spine.MathUtils.Atan2Deg(y, x);
            },
            /*Spine.PointAttachment.ComputeWorldRotation end.*/

            /*Spine.PointAttachment.Copy start.*/
            Copy: function () {
if ( TRACE ) { TRACE( "Spine.PointAttachment#Copy", this ); }

                return new Spine.PointAttachment.ctor(this);
            },
            /*Spine.PointAttachment.Copy end.*/


        }
    });
    /*Spine.PointAttachment end.*/

    /*Spine.Pow start.*/
    Bridge.define("Spine.Pow", {
        inherits: [Spine.IInterpolation],
        fields: {
            Power: 0
        },
        ctors: {
            ctor: function (power) {
if ( TRACE ) { TRACE( "Spine.Pow#ctor", this ); }

                this.$initialize();
                Spine.IInterpolation.ctor.call(this);
                this.Power = power;
            }
        },
        methods: {
            /*Spine.Pow.Apply$1 start.*/
            Apply$1: function (a) {
if ( TRACE ) { TRACE( "Spine.Pow#Apply$1", this ); }

                if (a <= 0.5) {
                    return Math.pow(a * 2, this.Power) / 2;
                }
                return Math.pow((a - 1) * 2, this.Power) / (this.Power % 2 === 0 ? -2 : 2) + 1;
            },
            /*Spine.Pow.Apply$1 end.*/


        },
        overloads: {
            "Apply(float)": "Apply$1"
        }
    });
    /*Spine.Pow end.*/

    /*Spine.RegionAttachment start.*/
    /**
     * Attachment that displays a texture region.
     *
     * @public
     * @class Spine.RegionAttachment
     * @augments Spine.Attachment
     * @implements  Spine.IHasTextureRegion
     */
    Bridge.define("Spine.RegionAttachment", {
        inherits: [Spine.Attachment,Spine.IHasTextureRegion],
        statics: {
            fields: {
                BLX: 0,
                BLY: 0,
                ULX: 0,
                ULY: 0,
                URX: 0,
                URY: 0,
                BRX: 0,
                BRY: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#init", this ); }

                    this.BLX = 0;
                    this.BLY = 1;
                    this.ULX = 2;
                    this.ULY = 3;
                    this.URX = 4;
                    this.URY = 5;
                    this.BRX = 6;
                    this.BRY = 7;
                }
            }
        },
        fields: {
            region: null,
            x: 0,
            y: 0,
            rotation: 0,
            scaleX: 0,
            scaleY: 0,
            width: 0,
            height: 0,
            offset: null,
            uvs: null,
            r: 0,
            g: 0,
            b: 0,
            a: 0,
            sequence: null,
            Path: null
        },
        props: {
            X: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#X#get", this ); }

                    return this.x;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#X#set", this ); }

                    this.x = value;
                }
            },
            Y: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#Y#get", this ); }

                    return this.y;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#Y#set", this ); }

                    this.y = value;
                }
            },
            Rotation: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#Rotation#get", this ); }

                    return this.rotation;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#Rotation#set", this ); }

                    this.rotation = value;
                }
            },
            ScaleX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#ScaleX#get", this ); }

                    return this.scaleX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#ScaleX#set", this ); }

                    this.scaleX = value;
                }
            },
            ScaleY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#ScaleY#get", this ); }

                    return this.scaleY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#ScaleY#set", this ); }

                    this.scaleY = value;
                }
            },
            Width: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#Width#get", this ); }

                    return this.width;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#Width#set", this ); }

                    this.width = value;
                }
            },
            Height: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#Height#get", this ); }

                    return this.height;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#Height#set", this ); }

                    this.height = value;
                }
            },
            R: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#R#get", this ); }

                    return this.r;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#R#set", this ); }

                    this.r = value;
                }
            },
            G: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#G#get", this ); }

                    return this.g;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#G#set", this ); }

                    this.g = value;
                }
            },
            B: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#B#get", this ); }

                    return this.b;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#B#set", this ); }

                    this.b = value;
                }
            },
            A: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#A#get", this ); }

                    return this.a;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#A#set", this ); }

                    this.a = value;
                }
            },
            Region: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#Region#get", this ); }

                    return this.region;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#Region#set", this ); }

                    this.region = value;
                }
            },
            /**
             * For each of the 4 vertices, a pair of <pre><code>x,y</code></pre> values that is the local position of the vertex.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.RegionAttachment
             * @function Offset
             * @type Array.<number>
             * @see {@link UpdateRegion}
             */
            Offset: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#Offset#get", this ); }

                    return this.offset;
                }
            },
            UVs: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#UVs#get", this ); }

                    return this.uvs;
                }
            },
            Sequence: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#Sequence#get", this ); }

                    return this.sequence;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#Sequence#set", this ); }

                    this.sequence = value;
                }
            }
        },
        alias: [
            "R", "Spine$IHasTextureRegion$R",
            "G", "Spine$IHasTextureRegion$G",
            "B", "Spine$IHasTextureRegion$B",
            "A", "Spine$IHasTextureRegion$A",
            "Path", "Spine$IHasTextureRegion$Path",
            "Region", "Spine$IHasTextureRegion$Region",
            "Sequence", "Spine$IHasTextureRegion$Sequence",
            "UpdateRegion", "Spine$IHasTextureRegion$UpdateRegion"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#init", this ); }

                this.scaleX = 1;
                this.scaleY = 1;
                this.offset = System.Array.init(8, 0, System.Single);
                this.uvs = System.Array.init(8, 0, System.Single);
                this.r = 1;
                this.g = 1;
                this.b = 1;
                this.a = 1;
            },
            $ctor1: function (name) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#$ctor1", this ); }

                this.$initialize();
                Spine.Attachment.$ctor1.call(this, name);
            },
            /**
             * Copy constructor.
             *
             * @instance
             * @public
             * @this Spine.RegionAttachment
             * @memberof Spine.RegionAttachment
             * @param   {Spine.RegionAttachment}    other
             * @return  {void}
             */
            ctor: function (other) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#ctor", this ); }

                this.$initialize();
                Spine.Attachment.ctor.call(this, other);
                this.region = other.region;
                this.Path = other.Path;
                this.x = other.x;
                this.y = other.y;
                this.scaleX = other.scaleX;
                this.scaleY = other.scaleY;
                this.rotation = other.rotation;
                this.width = other.width;
                this.height = other.height;
                System.Array.copy(other.uvs, 0, this.uvs, 0, 8);
                System.Array.copy(other.offset, 0, this.offset, 0, 8);
                this.r = other.r;
                this.g = other.g;
                this.b = other.b;
                this.a = other.a;
                this.sequence = other.sequence == null ? null : new Spine.Sequence.ctor(other.sequence);
            }
        },
        methods: {
            /*Spine.RegionAttachment.UpdateRegion start.*/
            /**
             * Calculates the {@link } and {@link } using the region and the attachment's transform. Must be called if the
             region, the region's properties, or the transform are changed.
             *
             * @instance
             * @public
             * @this Spine.RegionAttachment
             * @memberof Spine.RegionAttachment
             * @return  {void}
             */
            UpdateRegion: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#UpdateRegion", this ); }

                var uvs = this.uvs;
                if (this.region == null) {
                    uvs[Spine.RegionAttachment.BLX] = 0;
                    uvs[Spine.RegionAttachment.BLY] = 0;
                    uvs[Spine.RegionAttachment.ULX] = 0;
                    uvs[Spine.RegionAttachment.ULY] = 1;
                    uvs[Spine.RegionAttachment.URX] = 1;
                    uvs[Spine.RegionAttachment.URY] = 1;
                    uvs[Spine.RegionAttachment.BRX] = 1;
                    uvs[Spine.RegionAttachment.BRY] = 0;
                    return;
                }

                var width = this.Width, height = this.Height;
                var localX2 = width / 2;
                var localY2 = height / 2;
                var localX = -localX2;
                var localY = -localY2;
                var rotated = false;
                if (Bridge.is(this.region, Spine.AtlasRegion)) {
                    var region = Bridge.cast(this.region, Spine.AtlasRegion);
                    localX += region.offsetX / region.originalWidth * width;
                    localY += region.offsetY / region.originalHeight * height;
                    if (region.degrees === 90) {
                        rotated = true;
                        localX2 -= (region.originalWidth - region.offsetX - region.packedHeight) / region.originalWidth * width;
                        localY2 -= (region.originalHeight - region.offsetY - region.packedWidth) / region.originalHeight * height;
                    } else {
                        localX2 -= (region.originalWidth - region.offsetX - region.packedWidth) / region.originalWidth * width;
                        localY2 -= (region.originalHeight - region.offsetY - region.packedHeight) / region.originalHeight * height;
                    }
                }
                var scaleX = this.ScaleX, scaleY = this.ScaleY;
                localX *= scaleX;
                localY *= scaleY;
                localX2 *= scaleX;
                localY2 *= scaleY;
                var r = this.Rotation * Spine.MathUtils.DegRad, cos = Math.cos(r), sin = Math.sin(r);
                var x = this.X, y = this.Y;
                var localXCos = localX * cos + x;
                var localXSin = localX * sin;
                var localYCos = localY * cos + y;
                var localYSin = localY * sin;
                var localX2Cos = localX2 * cos + x;
                var localX2Sin = localX2 * sin;
                var localY2Cos = localY2 * cos + y;
                var localY2Sin = localY2 * sin;
                var offset = this.offset;
                offset[Spine.RegionAttachment.BLX] = localXCos - localYSin;
                offset[Spine.RegionAttachment.BLY] = localYCos + localXSin;
                offset[Spine.RegionAttachment.ULX] = localXCos - localY2Sin;
                offset[Spine.RegionAttachment.ULY] = localY2Cos + localXSin;
                offset[Spine.RegionAttachment.URX] = localX2Cos - localY2Sin;
                offset[Spine.RegionAttachment.URY] = localY2Cos + localX2Sin;
                offset[Spine.RegionAttachment.BRX] = localX2Cos - localYSin;
                offset[Spine.RegionAttachment.BRY] = localYCos + localX2Sin;

                if (rotated) {
                    uvs[Spine.RegionAttachment.BLX] = this.region.u2;
                    uvs[Spine.RegionAttachment.BLY] = this.region.v;
                    uvs[Spine.RegionAttachment.ULX] = this.region.u2;
                    uvs[Spine.RegionAttachment.ULY] = this.region.v2;
                    uvs[Spine.RegionAttachment.URX] = this.region.u;
                    uvs[Spine.RegionAttachment.URY] = this.region.v2;
                    uvs[Spine.RegionAttachment.BRX] = this.region.u;
                    uvs[Spine.RegionAttachment.BRY] = this.region.v;
                } else {
                    uvs[Spine.RegionAttachment.BLX] = this.region.u2;
                    uvs[Spine.RegionAttachment.BLY] = this.region.v2;
                    uvs[Spine.RegionAttachment.ULX] = this.region.u;
                    uvs[Spine.RegionAttachment.ULY] = this.region.v2;
                    uvs[Spine.RegionAttachment.URX] = this.region.u;
                    uvs[Spine.RegionAttachment.URY] = this.region.v;
                    uvs[Spine.RegionAttachment.BRX] = this.region.u2;
                    uvs[Spine.RegionAttachment.BRY] = this.region.v;
                }
            },
            /*Spine.RegionAttachment.UpdateRegion end.*/

            /*Spine.RegionAttachment.ComputeWorldVertices start.*/
            /**
             * Transforms the attachment's four vertices to world coordinates. If the attachment has a {@link } the region may
             be changed.
             *
             * @instance
             * @public
             * @this Spine.RegionAttachment
             * @memberof Spine.RegionAttachment
             * @param   {Spine.Slot}        slot             
             * @param   {Array.<number>}    worldVertices    The output world vertices. Must have a length greater than or equal to offset + 8.
             * @param   {number}            offset           The worldVertices index to begin writing values.
             * @param   {number}            stride           The number of worldVertices entries between the value pairs written.
             * @return  {void}
             */
            ComputeWorldVertices: function (slot, worldVertices, offset, stride) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#ComputeWorldVertices", this ); }

                if (stride === void 0) { stride = 2; }
                if (this.sequence != null) {
                    this.sequence.Apply(slot, this);
                }

                var vertexOffset = this.offset;
                var bone = slot.Bone;
                var bwx = bone.worldX, bwy = bone.worldY;
                var a = bone.a, b = bone.b, c = bone.c, d = bone.d;
                var offsetX, offsetY;

                // Vertex order is different from RegionAttachment.java
                offsetX = vertexOffset[Spine.RegionAttachment.BRX]; // 0
                offsetY = vertexOffset[Spine.RegionAttachment.BRY]; // 1
                worldVertices[offset] = offsetX * a + offsetY * b + bwx; // bl
                worldVertices[((offset + 1) | 0)] = offsetX * c + offsetY * d + bwy;
                offset = (offset + stride) | 0;

                offsetX = vertexOffset[Spine.RegionAttachment.BLX]; // 2
                offsetY = vertexOffset[Spine.RegionAttachment.BLY]; // 3
                worldVertices[offset] = offsetX * a + offsetY * b + bwx; // ul
                worldVertices[((offset + 1) | 0)] = offsetX * c + offsetY * d + bwy;
                offset = (offset + stride) | 0;

                offsetX = vertexOffset[Spine.RegionAttachment.ULX]; // 4
                offsetY = vertexOffset[Spine.RegionAttachment.ULY]; // 5
                worldVertices[offset] = offsetX * a + offsetY * b + bwx; // ur
                worldVertices[((offset + 1) | 0)] = offsetX * c + offsetY * d + bwy;
                offset = (offset + stride) | 0;

                offsetX = vertexOffset[Spine.RegionAttachment.URX]; // 6
                offsetY = vertexOffset[Spine.RegionAttachment.URY]; // 7
                worldVertices[offset] = offsetX * a + offsetY * b + bwx; // br
                worldVertices[((offset + 1) | 0)] = offsetX * c + offsetY * d + bwy;
                //offset += stride;
            },
            /*Spine.RegionAttachment.ComputeWorldVertices end.*/

            /*Spine.RegionAttachment.Copy start.*/
            Copy: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#Copy", this ); }

                return new Spine.RegionAttachment.ctor(this);
            },
            /*Spine.RegionAttachment.Copy end.*/


        }
    });
    /*Spine.RegionAttachment end.*/

    /*Spine.SequenceTimeline start.*/
    /**
     * Changes a slot's {@link } for an attachment's {@link }.
     *
     * @public
     * @class Spine.SequenceTimeline
     * @augments Spine.Timeline
     * @implements  Spine.ISlotTimeline
     */
    Bridge.define("Spine.SequenceTimeline", {
        inherits: [Spine.Timeline,Spine.ISlotTimeline],
        statics: {
            fields: {
                ENTRIES: 0,
                MODE: 0,
                DELAY: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.SequenceTimeline#init", this ); }

                    this.ENTRIES = 3;
                    this.MODE = 1;
                    this.DELAY = 2;
                }
            }
        },
        fields: {
            slotIndex: 0,
            attachment: null
        },
        props: {
            FrameEntries: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SequenceTimeline#FrameEntries#get", this ); }

                    return Spine.SequenceTimeline.ENTRIES;
                }
            },
            SlotIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SequenceTimeline#SlotIndex#get", this ); }

                    return this.slotIndex;
                }
            },
            Attachment: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SequenceTimeline#Attachment#get", this ); }

                    return Bridge.cast(this.attachment, Spine.Attachment);
                }
            }
        },
        alias: ["SlotIndex", "Spine$ISlotTimeline$SlotIndex"],
        ctors: {
            ctor: function (frameCount, slotIndex, attachment) {
if ( TRACE ) { TRACE( "Spine.SequenceTimeline#ctor", this ); }

                this.$initialize();
                Spine.Timeline.ctor.call(this, frameCount, [Spine.Property.Sequence + "|" + slotIndex + "|" + Bridge.cast(attachment, Spine.IHasTextureRegion).Spine$IHasTextureRegion$Sequence.Id]);
                this.slotIndex = slotIndex;
                this.attachment = Bridge.cast(attachment, Spine.IHasTextureRegion);
            }
        },
        methods: {
            /*Spine.SequenceTimeline.SetFrame start.*/
            /**
             * Sets the time, mode, index, and frame time for the specified frame.
             *
             * @instance
             * @public
             * @this Spine.SequenceTimeline
             * @memberof Spine.SequenceTimeline
             * @param   {number}                frame    Between 0 and <pre><code>frameCount</code></pre>, inclusive.
             * @param   {number}                time     Seconds between frames.
             * @param   {Spine.SequenceMode}    mode     
             * @param   {number}                index    
             * @param   {number}                delay
             * @return  {void}
             */
            SetFrame: function (frame, time, mode, index, delay) {
if ( TRACE ) { TRACE( "Spine.SequenceTimeline#SetFrame", this ); }

                frame = Bridge.Int.mul(frame, Spine.SequenceTimeline.ENTRIES);
                this.frames[frame] = time;
                this.frames[((frame + Spine.SequenceTimeline.MODE) | 0)] = mode | (index << 4);
                this.frames[((frame + Spine.SequenceTimeline.DELAY) | 0)] = delay;
            },
            /*Spine.SequenceTimeline.SetFrame end.*/

            /*Spine.SequenceTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.SequenceTimeline#Apply", this ); }

                var $t;

                var slot = ($t = skeleton.slots.Items)[this.slotIndex];
                if (!slot.bone.active) {
                    return;
                }
                var slotAttachment = slot.attachment;
                if (!Bridge.referenceEquals(slotAttachment, this.attachment)) {
                    var vertexAttachment = Bridge.as(slotAttachment, Spine.VertexAttachment);
                    if ((vertexAttachment == null) || !Bridge.referenceEquals(vertexAttachment.TimelineAttachment, this.attachment)) {
                        return;
                    }
                }
                var sequence = Bridge.cast(slotAttachment, Spine.IHasTextureRegion).Spine$IHasTextureRegion$Sequence;
                if (sequence == null) {
                    return;
                }

                var frames = this.frames;
                if (time < frames[0]) {
                    if (blend === Spine.MixBlend.Setup || blend === Spine.MixBlend.First) {
                        slot.SequenceIndex = -1;
                    }
                    return;
                }

                var i = Spine.Timeline.Search$1(frames, time, Spine.SequenceTimeline.ENTRIES);
                var before = frames[i];
                var modeAndIndex = Bridge.Int.clip32(frames[((i + Spine.SequenceTimeline.MODE) | 0)]);
                var delay = frames[((i + Spine.SequenceTimeline.DELAY) | 0)];

                var index = modeAndIndex >> 4, count = sequence.Regions.length;
                var mode = modeAndIndex & 15;
                if (mode !== Spine.SequenceMode.Hold) {
                    index = (index + (Bridge.Int.clip32((time - before) / delay + 0.0001))) | 0;
                    switch (mode) {
                        case Spine.SequenceMode.Once: 
                            index = Math.min(((count - 1) | 0), index);
                            break;
                        case Spine.SequenceMode.Loop: 
                            index = index % count;
                            break;
                        case Spine.SequenceMode.Pingpong: 
                            {
                                var n = ((count << 1) - 2) | 0;
                                index = n === 0 ? 0 : index % n;
                                if (index >= count) {
                                    index = (n - index) | 0;
                                }
                                break;
                            }
                        case Spine.SequenceMode.OnceReverse: 
                            index = Math.max(((((count - 1) | 0) - index) | 0), 0);
                            break;
                        case Spine.SequenceMode.LoopReverse: 
                            index = (((count - 1) | 0) - (index % count)) | 0;
                            break;
                        case Spine.SequenceMode.PingpongReverse: 
                            {
                                var n1 = ((count << 1) - 2) | 0;
                                index = n1 === 0 ? 0 : (((((index + count) | 0) - 1) | 0)) % n1;
                                if (index >= count) {
                                    index = (n1 - index) | 0;
                                }
                                break;
                            }
                    }
                }
                slot.SequenceIndex = index;
            },
            /*Spine.SequenceTimeline.Apply end.*/


        }
    });
    /*Spine.SequenceTimeline end.*/

    /*Spine.SkeletonBinary start.*/
    Bridge.define("Spine.SkeletonBinary", {
        inherits: [Spine.SkeletonLoader],
        statics: {
            fields: {
                BONE_ROTATE: 0,
                BONE_TRANSLATE: 0,
                BONE_TRANSLATEX: 0,
                BONE_TRANSLATEY: 0,
                BONE_SCALE: 0,
                BONE_SCALEX: 0,
                BONE_SCALEY: 0,
                BONE_SHEAR: 0,
                BONE_SHEARX: 0,
                BONE_SHEARY: 0,
                BONE_INHERIT: 0,
                SLOT_ATTACHMENT: 0,
                SLOT_RGBA: 0,
                SLOT_RGB: 0,
                SLOT_RGBA2: 0,
                SLOT_RGB2: 0,
                SLOT_ALPHA: 0,
                ATTACHMENT_DEFORM: 0,
                ATTACHMENT_SEQUENCE: 0,
                PATH_POSITION: 0,
                PATH_SPACING: 0,
                PATH_MIX: 0,
                PHYSICS_INERTIA: 0,
                PHYSICS_STRENGTH: 0,
                PHYSICS_DAMPING: 0,
                PHYSICS_MASS: 0,
                PHYSICS_WIND: 0,
                PHYSICS_GRAVITY: 0,
                PHYSICS_MIX: 0,
                PHYSICS_RESET: 0,
                CURVE_LINEAR: 0,
                CURVE_STEPPED: 0,
                CURVE_BEZIER: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#init", this ); }

                    this.BONE_ROTATE = 0;
                    this.BONE_TRANSLATE = 1;
                    this.BONE_TRANSLATEX = 2;
                    this.BONE_TRANSLATEY = 3;
                    this.BONE_SCALE = 4;
                    this.BONE_SCALEX = 5;
                    this.BONE_SCALEY = 6;
                    this.BONE_SHEAR = 7;
                    this.BONE_SHEARX = 8;
                    this.BONE_SHEARY = 9;
                    this.BONE_INHERIT = 10;
                    this.SLOT_ATTACHMENT = 0;
                    this.SLOT_RGBA = 1;
                    this.SLOT_RGB = 2;
                    this.SLOT_RGBA2 = 3;
                    this.SLOT_RGB2 = 4;
                    this.SLOT_ALPHA = 5;
                    this.ATTACHMENT_DEFORM = 0;
                    this.ATTACHMENT_SEQUENCE = 1;
                    this.PATH_POSITION = 0;
                    this.PATH_SPACING = 1;
                    this.PATH_MIX = 2;
                    this.PHYSICS_INERTIA = 0;
                    this.PHYSICS_STRENGTH = 1;
                    this.PHYSICS_DAMPING = 2;
                    this.PHYSICS_MASS = 4;
                    this.PHYSICS_WIND = 5;
                    this.PHYSICS_GRAVITY = 6;
                    this.PHYSICS_MIX = 7;
                    this.PHYSICS_RESET = 8;
                    this.CURVE_LINEAR = 0;
                    this.CURVE_STEPPED = 1;
                    this.CURVE_BEZIER = 2;
                }
            },
            methods: {
                /*Spine.SkeletonBinary.GetVersionString:static start.*/
                /**
                 * Returns the version string of binary skeleton data.
                 *
                 * @static
                 * @public
                 * @this Spine.SkeletonBinary
                 * @memberof Spine.SkeletonBinary
                 * @param   {System.IO.Stream}    file
                 * @return  {string}
                 */
                GetVersionString: function (file) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#GetVersionString", this ); }

                    if (file == null) {
                        throw new System.ArgumentNullException.$ctor1("file");
                    }

                    var input = new Spine.SkeletonBinary.SkeletonInput(file);
                    return input.GetVersionString();
                },
                /*Spine.SkeletonBinary.GetVersionString:static end.*/


            }
        },
        fields: {
            linkedMeshes: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#init", this ); }

                this.linkedMeshes = new (System.Collections.Generic.List$1(Spine.SkeletonBinary.LinkedMesh)).ctor();
            },
            $ctor1: function (attachmentLoader) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#$ctor1", this ); }

                this.$initialize();
                Spine.SkeletonLoader.$ctor1.call(this, attachmentLoader);
            },
            ctor: function (atlasArray) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#ctor", this ); }

                if (atlasArray === void 0) { atlasArray = []; }

                this.$initialize();
                Spine.SkeletonLoader.ctor.call(this, atlasArray);
            }
        },
        methods: {
            /*Spine.SkeletonBinary.ReadSkeletonData start.*/
            ReadSkeletonData: function (path) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#ReadSkeletonData", this ); }

                var input = new System.IO.FileStream.$ctor2(path, 3, System.IO.FileAccess.Read, 1);
                try {
                    var skeletonData = this.ReadSkeletonData$1(input);
                    skeletonData.name = System.IO.Path.GetFileNameWithoutExtension(path);
                    return skeletonData;
                }
                finally {
                    if (Bridge.hasValue(input)) {
                        input.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.SkeletonBinary.ReadSkeletonData end.*/

            /*Spine.SkeletonBinary.ReadSkeletonData$1 start.*/
            ReadSkeletonData$1: function (file) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#ReadSkeletonData$1", this ); }

                var $t;
                if (file == null) {
                    throw new System.ArgumentNullException.$ctor1("file");
                }
                var scale = this.scale;

                var skeletonData = new Spine.SkeletonData();
                var input = new Spine.SkeletonBinary.SkeletonInput(file);

                var hash = input.ReadLong();
                skeletonData.hash = hash.equals(System.Int64(0)) ? null : Bridge.toString(hash);
                skeletonData.version = input.ReadString();
                if (skeletonData.version.length === 0) {
                    skeletonData.version = null;
                }
                // early return for old 3.8 format instead of reading past the end
                if (skeletonData.version.length > 13) {
                    return null;
                }
                skeletonData.x = input.ReadFloat();
                skeletonData.y = input.ReadFloat();
                skeletonData.width = input.ReadFloat();
                skeletonData.height = input.ReadFloat();
                skeletonData.referenceScale = input.ReadFloat() * scale;

                var nonessential = input.ReadBoolean();

                if (nonessential) {
                    skeletonData.fps = input.ReadFloat();

                    skeletonData.imagesPath = input.ReadString();
                    if (System.String.isNullOrEmpty(skeletonData.imagesPath)) {
                        skeletonData.imagesPath = null;
                    }

                    skeletonData.audioPath = input.ReadString();
                    if (System.String.isNullOrEmpty(skeletonData.audioPath)) {
                        skeletonData.audioPath = null;
                    }
                }

                var n;
                var o;

                // Strings.
                o = (input.strings = System.Array.init((n = input.ReadInt$1(true)), null, System.String));
                for (var i = 0; i < n; i = (i + 1) | 0) {
                    o[i] = input.ReadString();
                }

                // Bones.
                var bones = skeletonData.bones.Resize((n = input.ReadInt$1(true))).Items;
                for (var i1 = 0; i1 < n; i1 = (i1 + 1) | 0) {
                    var name = input.ReadString();
                    var parent = i1 === 0 ? null : bones[input.ReadInt$1(true)];
                    var data = new Spine.BoneData(i1, name, parent);
                    data.rotation = input.ReadFloat();
                    data.x = input.ReadFloat() * scale;
                    data.y = input.ReadFloat() * scale;
                    data.scaleX = input.ReadFloat();
                    data.scaleY = input.ReadFloat();
                    data.shearX = input.ReadFloat();
                    data.shearY = input.ReadFloat();
                    data.Length = input.ReadFloat() * scale;
                    data.inherit = Spine.InheritEnum.Values[input.ReadInt$1(true)];
                    data.skinRequired = input.ReadBoolean();
                    if (nonessential) { // discard non-essential data
                        input.ReadInt(); // Color.rgba8888ToColor(data.color, input.readInt());
                        input.ReadString(); // data.icon = input.readString();
                        input.ReadBoolean(); // data.visible = input.readBoolean();
                    }
                    bones[i1] = data;
                }

                // Slots.
                var slots = skeletonData.slots.Resize((n = input.ReadInt$1(true))).Items;
                for (var i2 = 0; i2 < n; i2 = (i2 + 1) | 0) {
                    var slotName = input.ReadString();

                    var boneData = bones[input.ReadInt$1(true)];
                    var slotData = new Spine.SlotData(i2, slotName, boneData);
                    var color = input.ReadInt();
                    slotData.r = ((System.Int64(color).and(System.Int64(4278190080))).shr(24)) / 255.0;
                    slotData.g = ((color & 16711680) >> 16) / 255.0;
                    slotData.b = ((color & 65280) >> 8) / 255.0;
                    slotData.a = ((color & 255)) / 255.0;

                    var darkColor = input.ReadInt(); // 0x00rrggbb
                    if (darkColor !== -1) {
                        slotData.hasSecondColor = true;
                        slotData.r2 = ((darkColor & 16711680) >> 16) / 255.0;
                        slotData.g2 = ((darkColor & 65280) >> 8) / 255.0;
                        slotData.b2 = ((darkColor & 255)) / 255.0;
                    }

                    slotData.attachmentName = input.ReadStringRef();
                    slotData.blendMode = input.ReadInt$1(true);
                    if (nonessential) {
                        input.ReadBoolean(); // data.visible = input.readBoolean(); data.path = path;
                    }
                    slots[i2] = slotData;
                }

                // IK constraints.
                o = skeletonData.ikConstraints.Resize((n = input.ReadInt$1(true))).Items;
                for (var i3 = 0, nn; i3 < n; i3 = (i3 + 1) | 0) {
                    var data1 = new Spine.IkConstraintData(input.ReadString());
                    data1.order = input.ReadInt$1(true);
                    var constraintBones = data1.bones.Resize((nn = input.ReadInt$1(true))).Items;
                    for (var ii = 0; ii < nn; ii = (ii + 1) | 0) {
                        constraintBones[ii] = bones[input.ReadInt$1(true)];
                    }
                    data1.target = bones[input.ReadInt$1(true)];
                    var flags = input.Read();
                    data1.skinRequired = (flags & 1) !== 0;
                    data1.bendDirection = (flags & 2) !== 0 ? 1 : -1;
                    data1.compress = (flags & 4) !== 0;
                    data1.stretch = (flags & 8) !== 0;
                    data1.uniform = (flags & 16) !== 0;
                    if ((flags & 32) !== 0) {
                        data1.mix = (flags & 64) !== 0 ? input.ReadFloat() : 1;
                    }
                    if ((flags & 128) !== 0) {
                        data1.softness = input.ReadFloat() * scale;
                    }
                    o[i3] = data1;
                }

                // Transform constraints.
                o = skeletonData.transformConstraints.Resize((n = input.ReadInt$1(true))).Items;
                for (var i4 = 0, nn1; i4 < n; i4 = (i4 + 1) | 0) {
                    var data2 = new Spine.TransformConstraintData(input.ReadString());
                    data2.order = input.ReadInt$1(true);
                    var constraintBones1 = data2.bones.Resize((nn1 = input.ReadInt$1(true))).Items;
                    for (var ii1 = 0; ii1 < nn1; ii1 = (ii1 + 1) | 0) {
                        constraintBones1[ii1] = bones[input.ReadInt$1(true)];
                    }
                    data2.target = bones[input.ReadInt$1(true)];
                    var flags1 = input.Read();
                    data2.skinRequired = (flags1 & 1) !== 0;
                    data2.local = (flags1 & 2) !== 0;
                    data2.relative = (flags1 & 4) !== 0;
                    if ((flags1 & 8) !== 0) {
                        data2.offsetRotation = input.ReadFloat();
                    }
                    if ((flags1 & 16) !== 0) {
                        data2.offsetX = input.ReadFloat() * scale;
                    }
                    if ((flags1 & 32) !== 0) {
                        data2.offsetY = input.ReadFloat() * scale;
                    }
                    if ((flags1 & 64) !== 0) {
                        data2.offsetScaleX = input.ReadFloat();
                    }
                    if ((flags1 & 128) !== 0) {
                        data2.offsetScaleY = input.ReadFloat();
                    }
                    flags1 = input.Read();
                    if ((flags1 & 1) !== 0) {
                        data2.offsetShearY = input.ReadFloat();
                    }
                    if ((flags1 & 2) !== 0) {
                        data2.mixRotate = input.ReadFloat();
                    }
                    if ((flags1 & 4) !== 0) {
                        data2.mixX = input.ReadFloat();
                    }
                    if ((flags1 & 8) !== 0) {
                        data2.mixY = input.ReadFloat();
                    }
                    if ((flags1 & 16) !== 0) {
                        data2.mixScaleX = input.ReadFloat();
                    }
                    if ((flags1 & 32) !== 0) {
                        data2.mixScaleY = input.ReadFloat();
                    }
                    if ((flags1 & 64) !== 0) {
                        data2.mixShearY = input.ReadFloat();
                    }
                    o[i4] = data2;
                }

                // Path constraints
                o = skeletonData.pathConstraints.Resize((n = input.ReadInt$1(true))).Items;
                for (var i5 = 0, nn2; i5 < n; i5 = (i5 + 1) | 0) {
                    var data3 = new Spine.PathConstraintData(input.ReadString());
                    data3.order = input.ReadInt$1(true);
                    data3.skinRequired = input.ReadBoolean();
                    var constraintBones2 = data3.bones.Resize((nn2 = input.ReadInt$1(true))).Items;
                    for (var ii2 = 0; ii2 < nn2; ii2 = (ii2 + 1) | 0) {
                        constraintBones2[ii2] = bones[input.ReadInt$1(true)];
                    }
                    data3.target = slots[input.ReadInt$1(true)];
                    var flags2 = input.Read();
                    data3.positionMode = System.Nullable.getValue(Bridge.cast(Bridge.unbox(System.Array.get(System.Enum.getValues(Spine.PositionMode), flags2 & 1), Spine.PositionMode), System.Int32));
                    data3.spacingMode = System.Nullable.getValue(Bridge.cast(Bridge.unbox(System.Array.get(System.Enum.getValues(Spine.SpacingMode), (flags2 >> 1) & 3), Spine.SpacingMode), System.Int32));
                    data3.rotateMode = System.Nullable.getValue(Bridge.cast(Bridge.unbox(System.Array.get(System.Enum.getValues(Spine.RotateMode), (flags2 >> 3) & 3), Spine.RotateMode), System.Int32));
                    if ((flags2 & 128) !== 0) {
                        data3.offsetRotation = input.ReadFloat();
                    }

                    data3.position = input.ReadFloat();
                    if (data3.positionMode === Spine.PositionMode.Fixed) {
                        data3.position *= scale;
                    }
                    data3.spacing = input.ReadFloat();
                    if (data3.spacingMode === Spine.SpacingMode.Length || data3.spacingMode === Spine.SpacingMode.Fixed) {
                        data3.spacing *= scale;
                    }
                    data3.mixRotate = input.ReadFloat();
                    data3.mixX = input.ReadFloat();
                    data3.mixY = input.ReadFloat();
                    o[i5] = data3;
                }

                // Physics constraints.
                o = skeletonData.physicsConstraints.Resize((n = input.ReadInt$1(true))).Items;
                for (var i6 = 0; i6 < n; i6 = (i6 + 1) | 0) {
                    var data4 = new Spine.PhysicsConstraintData(input.ReadString());
                    data4.order = input.ReadInt$1(true);
                    data4.bone = bones[input.ReadInt$1(true)];
                    var flags3 = input.Read();
                    data4.skinRequired = (flags3 & 1) !== 0;
                    if ((flags3 & 2) !== 0) {
                        data4.x = input.ReadFloat();
                    }
                    if ((flags3 & 4) !== 0) {
                        data4.y = input.ReadFloat();
                    }
                    if ((flags3 & 8) !== 0) {
                        data4.rotate = input.ReadFloat();
                    }
                    if ((flags3 & 16) !== 0) {
                        data4.scaleX = input.ReadFloat();
                    }
                    if ((flags3 & 32) !== 0) {
                        data4.shearX = input.ReadFloat();
                    }
                    data4.limit = ((flags3 & 64) !== 0 ? input.ReadFloat() : 5000) * scale;
                    data4.step = 1.0 / input.ReadUByte();
                    data4.inertia = input.ReadFloat();
                    data4.strength = input.ReadFloat();
                    data4.damping = input.ReadFloat();
                    data4.massInverse = (flags3 & 128) !== 0 ? input.ReadFloat() : 1;
                    data4.wind = input.ReadFloat();
                    data4.gravity = input.ReadFloat();
                    flags3 = input.Read();
                    if ((flags3 & 1) !== 0) {
                        data4.inertiaGlobal = true;
                    }
                    if ((flags3 & 2) !== 0) {
                        data4.strengthGlobal = true;
                    }
                    if ((flags3 & 4) !== 0) {
                        data4.dampingGlobal = true;
                    }
                    if ((flags3 & 8) !== 0) {
                        data4.massGlobal = true;
                    }
                    if ((flags3 & 16) !== 0) {
                        data4.windGlobal = true;
                    }
                    if ((flags3 & 32) !== 0) {
                        data4.gravityGlobal = true;
                    }
                    if ((flags3 & 64) !== 0) {
                        data4.mixGlobal = true;
                    }
                    data4.mix = (flags3 & 128) !== 0 ? input.ReadFloat() : 1;
                    o[i6] = data4;
                }

                // Default skin.
                var defaultSkin = this.ReadSkin(input, skeletonData, true, nonessential);
                if (defaultSkin != null) {
                    skeletonData.defaultSkin = defaultSkin;
                    skeletonData.skins.Add(defaultSkin);
                }

                // Skins.
                {
                    var i7 = skeletonData.skins.Count;
                    o = skeletonData.skins.Resize((n = (i7 + input.ReadInt$1(true)) | 0)).Items;
                    for (; i7 < n; i7 = (i7 + 1) | 0) {
                        o[i7] = this.ReadSkin(input, skeletonData, false, nonessential);
                    }
                }

                // Linked meshes.
                n = this.linkedMeshes.Count;
                for (var i8 = 0; i8 < n; i8 = (i8 + 1) | 0) {
                    var linkedMesh = this.linkedMeshes.getItem(i8);
                    var skin = ($t = skeletonData.skins.Items)[linkedMesh.skinIndex];
                    var parent1 = skin.GetAttachment(linkedMesh.slotIndex, linkedMesh.parent);
                    if (parent1 == null) {
                        throw new System.Exception("Parent mesh not found: " + (linkedMesh.parent || ""));
                    }
                    linkedMesh.mesh.TimelineAttachment = linkedMesh.inheritTimelines ? Bridge.cast(parent1, Spine.VertexAttachment) : linkedMesh.mesh;
                    linkedMesh.mesh.ParentMesh = Bridge.cast(parent1, Spine.MeshAttachment);
                    if (linkedMesh.mesh.Sequence == null) {
                        linkedMesh.mesh.UpdateRegion();
                    }
                }
                this.linkedMeshes.clear();

                // Events.
                o = skeletonData.events.Resize((n = input.ReadInt$1(true))).Items;
                for (var i9 = 0; i9 < n; i9 = (i9 + 1) | 0) {
                    var data5 = new Spine.EventData(input.ReadString());
                    data5.Int = input.ReadInt$1(false);
                    data5.Float = input.ReadFloat();
                    data5.String = input.ReadString();
                    data5.AudioPath = input.ReadString();
                    if (data5.AudioPath != null) {
                        data5.Volume = input.ReadFloat();
                        data5.Balance = input.ReadFloat();
                    }
                    o[i9] = data5;
                }

                // Animations.
                o = skeletonData.animations.Resize((n = input.ReadInt$1(true))).Items;
                for (var i10 = 0; i10 < n; i10 = (i10 + 1) | 0) {
                    o[i10] = this.ReadAnimation(input.ReadString(), input, skeletonData);
                }

                return skeletonData;
            },
            /*Spine.SkeletonBinary.ReadSkeletonData$1 end.*/

            /*Spine.SkeletonBinary.ReadSkin start.*/
            /**
             * @instance
             * @private
             * @this Spine.SkeletonBinary
             * @memberof Spine.SkeletonBinary
             * @param   {Spine.SkeletonBinary.SkeletonInput}    input           
             * @param   {Spine.SkeletonData}                    skeletonData    
             * @param   {boolean}                               defaultSkin     
             * @param   {boolean}                               nonessential
             * @return  {Spine.Skin}                                            May be null.
             */
            ReadSkin: function (input, skeletonData, defaultSkin, nonessential) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#ReadSkin", this ); }


                var skin;
                var slotCount;

                if (defaultSkin) {
                    slotCount = input.ReadInt$1(true);
                    if (slotCount === 0) {
                        return null;
                    }
                    skin = new Spine.Skin("default");
                } else {
                    skin = new Spine.Skin(input.ReadString());

                    if (nonessential) {
                        input.ReadInt();
                    } // discard, Color.rgba8888ToColor(skin.color, input.readInt());

                    var bones = skin.bones.Resize(input.ReadInt$1(true)).Items;
                    var bonesItems = skeletonData.bones.Items;
                    for (var i = 0, n = skin.bones.Count; i < n; i = (i + 1) | 0) {
                        bones[i] = bonesItems[input.ReadInt$1(true)];
                    }

                    var ikConstraintsItems = skeletonData.ikConstraints.Items;
                    for (var i1 = 0, n1 = input.ReadInt$1(true); i1 < n1; i1 = (i1 + 1) | 0) {
                        skin.constraints.Add(ikConstraintsItems[input.ReadInt$1(true)]);
                    }
                    var transformConstraintsItems = skeletonData.transformConstraints.Items;
                    for (var i2 = 0, n2 = input.ReadInt$1(true); i2 < n2; i2 = (i2 + 1) | 0) {
                        skin.constraints.Add(transformConstraintsItems[input.ReadInt$1(true)]);
                    }
                    var pathConstraintsItems = skeletonData.pathConstraints.Items;
                    for (var i3 = 0, n3 = input.ReadInt$1(true); i3 < n3; i3 = (i3 + 1) | 0) {
                        skin.constraints.Add(pathConstraintsItems[input.ReadInt$1(true)]);
                    }
                    var physicsConstraintsItems = skeletonData.physicsConstraints.Items;
                    for (var i4 = 0, n4 = input.ReadInt$1(true); i4 < n4; i4 = (i4 + 1) | 0) {
                        skin.constraints.Add(physicsConstraintsItems[input.ReadInt$1(true)]);
                    }
                    skin.constraints.TrimExcess();

                    slotCount = input.ReadInt$1(true);
                }
                for (var i5 = 0; i5 < slotCount; i5 = (i5 + 1) | 0) {
                    var slotIndex = input.ReadInt$1(true);
                    for (var ii = 0, nn = input.ReadInt$1(true); ii < nn; ii = (ii + 1) | 0) {
                        var name = input.ReadStringRef();
                        var attachment = this.ReadAttachment(input, skeletonData, skin, slotIndex, name, nonessential);
                        if (attachment != null) {
                            skin.SetAttachment(slotIndex, name, attachment);
                        }
                    }
                }
                return skin;
            },
            /*Spine.SkeletonBinary.ReadSkin end.*/

            /*Spine.SkeletonBinary.ReadAttachment start.*/
            ReadAttachment: function (input, skeletonData, skin, slotIndex, attachmentName, nonessential) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#ReadAttachment", this ); }

                var $t;
                var scale = this.scale;

                var flags = input.ReadUByte();
                var name = (flags & 8) !== 0 ? input.ReadStringRef() : attachmentName;

                switch (flags & 7) {
                    case Spine.AttachmentType.Region: 
                        {
                            var path = (flags & 16) !== 0 ? input.ReadStringRef() : null;
                            var color = (flags & 32) !== 0 ? ((input.ReadInt()) >>> 0) : 4294967295;
                            var sequence = (flags & 64) !== 0 ? this.ReadSequence(input) : null;
                            var rotation = (flags & 128) !== 0 ? input.ReadFloat() : 0;
                            var x = input.ReadFloat();
                            var y = input.ReadFloat();
                            var scaleX = input.ReadFloat();
                            var scaleY = input.ReadFloat();
                            var width = input.ReadFloat();
                            var height = input.ReadFloat();

                            if (path == null) {
                                path = name;
                            }
                            var region = this.attachmentLoader.Spine$AttachmentLoader$NewRegionAttachment(skin, name, path, sequence);
                            if (region == null) {
                                return null;
                            }
                            region.Path = path;
                            region.x = x * scale;
                            region.y = y * scale;
                            region.scaleX = scaleX;
                            region.scaleY = scaleY;
                            region.rotation = rotation;
                            region.width = width * scale;
                            region.height = height * scale;
                            region.r = ((((color & 4278190080) >>> 0)) >>> 24) / 255.0;
                            region.g = ((((color & 16711680) >>> 0)) >>> 16) / 255.0;
                            region.b = ((((color & 65280) >>> 0)) >>> 8) / 255.0;
                            region.a = ((((color & 255) >>> 0))) / 255.0;
                            region.sequence = sequence;
                            if (sequence == null) {
                                region.UpdateRegion();
                            }
                            return region;
                        }
                    case Spine.AttachmentType.Boundingbox: 
                        {
                            var vertices = this.ReadVertices(input, (flags & 16) !== 0);
                            if (nonessential) {
                                input.ReadInt();
                            } // discard, int color = nonessential ? input.readInt() : 0;

                            var box = this.attachmentLoader.Spine$AttachmentLoader$NewBoundingBoxAttachment(skin, name);
                            if (box == null) {
                                return null;
                            }
                            box.worldVerticesLength = vertices.length;
                            box.vertices = vertices.vertices;
                            box.bones = vertices.bones;
                            // skipped porting: if (nonessential) Color.rgba8888ToColor(box.getColor(), color);
                            return box;
                        }
                    case Spine.AttachmentType.Mesh: 
                        {
                            var path1 = (flags & 16) !== 0 ? input.ReadStringRef() : name;
                            var color1 = (flags & 32) !== 0 ? ((input.ReadInt()) >>> 0) : 4294967295;
                            var sequence1 = (flags & 64) !== 0 ? this.ReadSequence(input) : null;
                            var hullLength = input.ReadInt$1(true);
                            var vertices1 = this.ReadVertices(input, (flags & 128) !== 0);
                            var uvs = this.ReadFloatArray(input, vertices1.length, 1);
                            var triangles = this.ReadShortArray(input, Bridge.Int.mul((((((vertices1.length - hullLength) | 0) - 2) | 0)), 3));

                            var edges = null;
                            var width1 = 0, height1 = 0;
                            if (nonessential) {
                                edges = this.ReadShortArray(input, input.ReadInt$1(true));
                                width1 = input.ReadFloat();
                                height1 = input.ReadFloat();
                            }

                            var mesh = this.attachmentLoader.Spine$AttachmentLoader$NewMeshAttachment(skin, name, path1, sequence1);
                            if (mesh == null) {
                                return null;
                            }
                            mesh.Path = path1;
                            mesh.r = ((((color1 & 4278190080) >>> 0)) >>> 24) / 255.0;
                            mesh.g = ((((color1 & 16711680) >>> 0)) >>> 16) / 255.0;
                            mesh.b = ((((color1 & 65280) >>> 0)) >>> 8) / 255.0;
                            mesh.a = ((((color1 & 255) >>> 0))) / 255.0;
                            mesh.bones = vertices1.bones;
                            mesh.vertices = vertices1.vertices;
                            mesh.WorldVerticesLength = vertices1.length;
                            mesh.triangles = triangles;
                            mesh.regionUVs = uvs;
                            if (sequence1 == null) {
                                mesh.UpdateRegion();
                            }
                            mesh.HullLength = hullLength << 1;
                            mesh.Sequence = sequence1;
                            if (nonessential) {
                                mesh.Edges = edges;
                                mesh.Width = width1 * scale;
                                mesh.Height = height1 * scale;
                            }
                            return mesh;
                        }
                    case Spine.AttachmentType.Linkedmesh: 
                        {
                            var path2 = (flags & 16) !== 0 ? input.ReadStringRef() : name;
                            var color2 = (flags & 32) !== 0 ? ((input.ReadInt()) >>> 0) : 4294967295;
                            var sequence2 = (flags & 64) !== 0 ? this.ReadSequence(input) : null;
                            var inheritTimelines = (flags & 128) !== 0;
                            var skinIndex = input.ReadInt$1(true);
                            var parent = input.ReadStringRef();
                            var width2 = 0, height2 = 0;
                            if (nonessential) {
                                width2 = input.ReadFloat();
                                height2 = input.ReadFloat();
                            }

                            var mesh1 = this.attachmentLoader.Spine$AttachmentLoader$NewMeshAttachment(skin, name, path2, sequence2);
                            if (mesh1 == null) {
                                return null;
                            }
                            mesh1.Path = path2;
                            mesh1.r = ((((color2 & 4278190080) >>> 0)) >>> 24) / 255.0;
                            mesh1.g = ((((color2 & 16711680) >>> 0)) >>> 16) / 255.0;
                            mesh1.b = ((((color2 & 65280) >>> 0)) >>> 8) / 255.0;
                            mesh1.a = ((((color2 & 255) >>> 0))) / 255.0;
                            mesh1.Sequence = sequence2;
                            if (nonessential) {
                                mesh1.Width = width2 * scale;
                                mesh1.Height = height2 * scale;
                            }
                            this.linkedMeshes.add(new Spine.SkeletonBinary.LinkedMesh(mesh1, skinIndex, slotIndex, parent, inheritTimelines));
                            return mesh1;
                        }
                    case Spine.AttachmentType.Path: 
                        {
                            var closed = (flags & 16) !== 0;
                            var constantSpeed = (flags & 32) !== 0;
                            var vertices2 = this.ReadVertices(input, (flags & 64) !== 0);
                            var lengths = System.Array.init(((Bridge.Int.div(vertices2.length, 6)) | 0), 0, System.Single);
                            for (var i = 0, n = lengths.length; i < n; i = (i + 1) | 0) {
                                lengths[i] = input.ReadFloat() * scale;
                            }
                            if (nonessential) {
                                input.ReadInt();
                            } //int color = nonessential ? input.ReadInt() : 0;

                            var path3 = this.attachmentLoader.Spine$AttachmentLoader$NewPathAttachment(skin, name);
                            if (path3 == null) {
                                return null;
                            }
                            path3.closed = closed;
                            path3.constantSpeed = constantSpeed;
                            path3.worldVerticesLength = vertices2.length;
                            path3.vertices = vertices2.vertices;
                            path3.bones = vertices2.bones;
                            path3.lengths = lengths;
                            // skipped porting: if (nonessential) Color.rgba8888ToColor(path.getColor(), color);
                            return path3;
                        }
                    case Spine.AttachmentType.Point: 
                        {
                            var rotation1 = input.ReadFloat();
                            var x1 = input.ReadFloat();
                            var y1 = input.ReadFloat();
                            if (nonessential) {
                                input.ReadInt();
                            } //int color = nonessential ? input.ReadInt() : 0;

                            var point = this.attachmentLoader.Spine$AttachmentLoader$NewPointAttachment(skin, name);
                            if (point == null) {
                                return null;
                            }
                            point.x = x1 * scale;
                            point.y = y1 * scale;
                            point.rotation = rotation1;
                            // skipped porting: if (nonessential) point.color = color;
                            return point;
                        }
                    case Spine.AttachmentType.Clipping: 
                        {
                            var endSlotIndex = input.ReadInt$1(true);
                            var vertices3 = this.ReadVertices(input, (flags & 16) !== 0);
                            if (nonessential) {
                                input.ReadInt();
                            }

                            var clip = this.attachmentLoader.Spine$AttachmentLoader$NewClippingAttachment(skin, name);
                            if (clip == null) {
                                return null;
                            }
                            clip.EndSlot = ($t = skeletonData.slots.Items)[endSlotIndex];
                            clip.worldVerticesLength = vertices3.length;
                            clip.vertices = vertices3.vertices;
                            clip.bones = vertices3.bones;
                            // skipped porting: if (nonessential) Color.rgba8888ToColor(clip.getColor(), color);
                            return clip;
                        }
                }
                return null;
            },
            /*Spine.SkeletonBinary.ReadAttachment end.*/

            /*Spine.SkeletonBinary.ReadSequence start.*/
            ReadSequence: function (input) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#ReadSequence", this ); }

                var sequence = new Spine.Sequence.$ctor1(input.ReadInt$1(true));
                sequence.Start = input.ReadInt$1(true);
                sequence.Digits = input.ReadInt$1(true);
                sequence.SetupIndex = input.ReadInt$1(true);
                return sequence;
            },
            /*Spine.SkeletonBinary.ReadSequence end.*/

            /*Spine.SkeletonBinary.ReadVertices start.*/
            ReadVertices: function (input, weighted) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#ReadVertices", this ); }

                var scale = this.scale;
                var vertexCount = input.ReadInt$1(true);
                var vertices = new Spine.SkeletonBinary.Vertices();
                vertices.length = vertexCount << 1;
                if (!weighted) {
                    vertices.vertices = this.ReadFloatArray(input, vertices.length, scale);
                    return vertices;
                }
                var weights = new (Spine.ExposedList$1(System.Single)).$ctor3(Bridge.Int.mul(Bridge.Int.mul(vertices.length, 3), 3));
                var bonesArray = new (Spine.ExposedList$1(System.Int32)).$ctor3(Bridge.Int.mul(vertices.length, 3));
                for (var i = 0; i < vertexCount; i = (i + 1) | 0) {
                    var boneCount = input.ReadInt$1(true);
                    bonesArray.Add(boneCount);
                    for (var ii = 0; ii < boneCount; ii = (ii + 1) | 0) {
                        bonesArray.Add(input.ReadInt$1(true));
                        weights.Add(input.ReadFloat() * scale);
                        weights.Add(input.ReadFloat() * scale);
                        weights.Add(input.ReadFloat());
                    }
                }

                vertices.vertices = weights.ToArray();
                vertices.bones = bonesArray.ToArray();
                return vertices;
            },
            /*Spine.SkeletonBinary.ReadVertices end.*/

            /*Spine.SkeletonBinary.ReadFloatArray start.*/
            ReadFloatArray: function (input, n, scale) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#ReadFloatArray", this ); }

                var array = System.Array.init(n, 0, System.Single);
                if (scale === 1) {
                    for (var i = 0; i < n; i = (i + 1) | 0) {
                        array[i] = input.ReadFloat();
                    }
                } else {
                    for (var i1 = 0; i1 < n; i1 = (i1 + 1) | 0) {
                        array[i1] = input.ReadFloat() * scale;
                    }
                }
                return array;
            },
            /*Spine.SkeletonBinary.ReadFloatArray end.*/

            /*Spine.SkeletonBinary.ReadShortArray start.*/
            ReadShortArray: function (input, n) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#ReadShortArray", this ); }

                var array = System.Array.init(n, 0, System.Int32);
                for (var i = 0; i < n; i = (i + 1) | 0) {
                    array[i] = input.ReadInt$1(true);
                }
                return array;
            },
            /*Spine.SkeletonBinary.ReadShortArray end.*/

            /*Spine.SkeletonBinary.ReadAnimation start.*/
            /**
             * @instance
             * @private
             * @this Spine.SkeletonBinary
             * @memberof Spine.SkeletonBinary
             * @throws SerializationException will be thrown when a Vertex attachment is not found.
             * @throws Throws IOException when a read operation fails.
             * @param   {string}                                name            
             * @param   {Spine.SkeletonBinary.SkeletonInput}    input           
             * @param   {Spine.SkeletonData}                    skeletonData
             * @return  {Spine.Animation}
             */
            ReadAnimation: function (name, input, skeletonData) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#ReadAnimation", this ); }

                var $t, $t1, $t2;
                var timelines = new (Spine.ExposedList$1(Spine.Timeline)).$ctor3(input.ReadInt$1(true));
                var scale = this.scale;

                // Slot timelines.
                for (var i = 0, n = input.ReadInt$1(true); i < n; i = (i + 1) | 0) {
                    var slotIndex = input.ReadInt$1(true);
                    for (var ii = 0, nn = input.ReadInt$1(true); ii < nn; ii = (ii + 1) | 0) {
                        var timelineType = input.ReadUByte(), frameCount = input.ReadInt$1(true), frameLast = (frameCount - 1) | 0;
                        switch (timelineType) {
                            case Spine.SkeletonBinary.SLOT_ATTACHMENT: 
                                {
                                    var timeline = new Spine.AttachmentTimeline(frameCount, slotIndex);
                                    for (var frame = 0; frame < frameCount; frame = (frame + 1) | 0) {
                                        timeline.SetFrame(frame, input.ReadFloat(), input.ReadStringRef());
                                    }
                                    timelines.Add(timeline);
                                    break;
                                }
                            case Spine.SkeletonBinary.SLOT_RGBA: 
                                {
                                    var timeline1 = new Spine.RGBATimeline(frameCount, input.ReadInt$1(true), slotIndex);
                                    var time = input.ReadFloat();
                                    var r = input.Read() / 255.0, g = input.Read() / 255.0;
                                    var b = input.Read() / 255.0, a = input.Read() / 255.0;
                                    for (var frame1 = 0, bezier = 0; ; frame1 = (frame1 + 1) | 0) {
                                        timeline1.SetFrame(frame1, time, r, g, b, a);
                                        if (frame1 === frameLast) {
                                            break;
                                        }
                                        var time2 = input.ReadFloat();
                                        var r2 = input.Read() / 255.0, g2 = input.Read() / 255.0;
                                        var b2 = input.Read() / 255.0, a2 = input.Read() / 255.0;
                                        switch (input.ReadUByte()) {
                                            case Spine.SkeletonBinary.CURVE_STEPPED: 
                                                timeline1.SetStepped(frame1);
                                                break;
                                            case Spine.SkeletonBinary.CURVE_BEZIER: 
                                                this.SetBezier(input, timeline1, Bridge.identity(bezier, ((bezier = (bezier + 1) | 0))), frame1, 0, time, time2, r, r2, 1);
                                                this.SetBezier(input, timeline1, Bridge.identity(bezier, ((bezier = (bezier + 1) | 0))), frame1, 1, time, time2, g, g2, 1);
                                                this.SetBezier(input, timeline1, Bridge.identity(bezier, ((bezier = (bezier + 1) | 0))), frame1, 2, time, time2, b, b2, 1);
                                                this.SetBezier(input, timeline1, Bridge.identity(bezier, ((bezier = (bezier + 1) | 0))), frame1, 3, time, time2, a, a2, 1);
                                                break;
                                        }
                                        time = time2;
                                        r = r2;
                                        g = g2;
                                        b = b2;
                                        a = a2;
                                    }
                                    timelines.Add(timeline1);
                                    break;
                                }
                            case Spine.SkeletonBinary.SLOT_RGB: 
                                {
                                    var timeline2 = new Spine.RGBTimeline(frameCount, input.ReadInt$1(true), slotIndex);
                                    var time1 = input.ReadFloat();
                                    var r1 = input.Read() / 255.0, g1 = input.Read() / 255.0, b1 = input.Read() / 255.0;
                                    for (var frame2 = 0, bezier1 = 0; ; frame2 = (frame2 + 1) | 0) {
                                        timeline2.SetFrame(frame2, time1, r1, g1, b1);
                                        if (frame2 === frameLast) {
                                            break;
                                        }
                                        var time21 = input.ReadFloat();
                                        var r21 = input.Read() / 255.0, g21 = input.Read() / 255.0, b21 = input.Read() / 255.0;
                                        switch (input.ReadUByte()) {
                                            case Spine.SkeletonBinary.CURVE_STEPPED: 
                                                timeline2.SetStepped(frame2);
                                                break;
                                            case Spine.SkeletonBinary.CURVE_BEZIER: 
                                                this.SetBezier(input, timeline2, Bridge.identity(bezier1, ((bezier1 = (bezier1 + 1) | 0))), frame2, 0, time1, time21, r1, r21, 1);
                                                this.SetBezier(input, timeline2, Bridge.identity(bezier1, ((bezier1 = (bezier1 + 1) | 0))), frame2, 1, time1, time21, g1, g21, 1);
                                                this.SetBezier(input, timeline2, Bridge.identity(bezier1, ((bezier1 = (bezier1 + 1) | 0))), frame2, 2, time1, time21, b1, b21, 1);
                                                break;
                                        }
                                        time1 = time21;
                                        r1 = r21;
                                        g1 = g21;
                                        b1 = b21;
                                    }
                                    timelines.Add(timeline2);
                                    break;
                                }
                            case Spine.SkeletonBinary.SLOT_RGBA2: 
                                {
                                    var timeline3 = new Spine.RGBA2Timeline(frameCount, input.ReadInt$1(true), slotIndex);
                                    var time2 = input.ReadFloat();
                                    var r2 = input.Read() / 255.0, g2 = input.Read() / 255.0;
                                    var b2 = input.Read() / 255.0, a1 = input.Read() / 255.0;
                                    var r22 = input.Read() / 255.0, g22 = input.Read() / 255.0, b22 = input.Read() / 255.0;
                                    for (var frame3 = 0, bezier2 = 0; ; frame3 = (frame3 + 1) | 0) {
                                        timeline3.SetFrame(frame3, time2, r2, g2, b2, a1, r22, g22, b22);
                                        if (frame3 === frameLast) {
                                            break;
                                        }
                                        var time22 = input.ReadFloat();
                                        var nr = input.Read() / 255.0, ng = input.Read() / 255.0;
                                        var nb = input.Read() / 255.0, na = input.Read() / 255.0;
                                        var nr2 = input.Read() / 255.0, ng2 = input.Read() / 255.0, nb2 = input.Read() / 255.0;
                                        switch (input.ReadUByte()) {
                                            case Spine.SkeletonBinary.CURVE_STEPPED: 
                                                timeline3.SetStepped(frame3);
                                                break;
                                            case Spine.SkeletonBinary.CURVE_BEZIER: 
                                                this.SetBezier(input, timeline3, Bridge.identity(bezier2, ((bezier2 = (bezier2 + 1) | 0))), frame3, 0, time2, time22, r2, nr, 1);
                                                this.SetBezier(input, timeline3, Bridge.identity(bezier2, ((bezier2 = (bezier2 + 1) | 0))), frame3, 1, time2, time22, g2, ng, 1);
                                                this.SetBezier(input, timeline3, Bridge.identity(bezier2, ((bezier2 = (bezier2 + 1) | 0))), frame3, 2, time2, time22, b2, nb, 1);
                                                this.SetBezier(input, timeline3, Bridge.identity(bezier2, ((bezier2 = (bezier2 + 1) | 0))), frame3, 3, time2, time22, a1, na, 1);
                                                this.SetBezier(input, timeline3, Bridge.identity(bezier2, ((bezier2 = (bezier2 + 1) | 0))), frame3, 4, time2, time22, r22, nr2, 1);
                                                this.SetBezier(input, timeline3, Bridge.identity(bezier2, ((bezier2 = (bezier2 + 1) | 0))), frame3, 5, time2, time22, g22, ng2, 1);
                                                this.SetBezier(input, timeline3, Bridge.identity(bezier2, ((bezier2 = (bezier2 + 1) | 0))), frame3, 6, time2, time22, b22, nb2, 1);
                                                break;
                                        }
                                        time2 = time22;
                                        r2 = nr;
                                        g2 = ng;
                                        b2 = nb;
                                        a1 = na;
                                        r22 = nr2;
                                        g22 = ng2;
                                        b22 = nb2;
                                    }
                                    timelines.Add(timeline3);
                                    break;
                                }
                            case Spine.SkeletonBinary.SLOT_RGB2: 
                                {
                                    var timeline4 = new Spine.RGB2Timeline(frameCount, input.ReadInt$1(true), slotIndex);
                                    var time3 = input.ReadFloat();
                                    var r3 = input.Read() / 255.0, g3 = input.Read() / 255.0, b3 = input.Read() / 255.0;
                                    var r23 = input.Read() / 255.0, g23 = input.Read() / 255.0, b23 = input.Read() / 255.0;
                                    for (var frame4 = 0, bezier3 = 0; ; frame4 = (frame4 + 1) | 0) {
                                        timeline4.SetFrame(frame4, time3, r3, g3, b3, r23, g23, b23);
                                        if (frame4 === frameLast) {
                                            break;
                                        }
                                        var time23 = input.ReadFloat();
                                        var nr1 = input.Read() / 255.0, ng1 = input.Read() / 255.0, nb1 = input.Read() / 255.0;
                                        var nr21 = input.Read() / 255.0, ng21 = input.Read() / 255.0, nb21 = input.Read() / 255.0;
                                        switch (input.ReadUByte()) {
                                            case Spine.SkeletonBinary.CURVE_STEPPED: 
                                                timeline4.SetStepped(frame4);
                                                break;
                                            case Spine.SkeletonBinary.CURVE_BEZIER: 
                                                this.SetBezier(input, timeline4, Bridge.identity(bezier3, ((bezier3 = (bezier3 + 1) | 0))), frame4, 0, time3, time23, r3, nr1, 1);
                                                this.SetBezier(input, timeline4, Bridge.identity(bezier3, ((bezier3 = (bezier3 + 1) | 0))), frame4, 1, time3, time23, g3, ng1, 1);
                                                this.SetBezier(input, timeline4, Bridge.identity(bezier3, ((bezier3 = (bezier3 + 1) | 0))), frame4, 2, time3, time23, b3, nb1, 1);
                                                this.SetBezier(input, timeline4, Bridge.identity(bezier3, ((bezier3 = (bezier3 + 1) | 0))), frame4, 3, time3, time23, r23, nr21, 1);
                                                this.SetBezier(input, timeline4, Bridge.identity(bezier3, ((bezier3 = (bezier3 + 1) | 0))), frame4, 4, time3, time23, g23, ng21, 1);
                                                this.SetBezier(input, timeline4, Bridge.identity(bezier3, ((bezier3 = (bezier3 + 1) | 0))), frame4, 5, time3, time23, b23, nb21, 1);
                                                break;
                                        }
                                        time3 = time23;
                                        r3 = nr1;
                                        g3 = ng1;
                                        b3 = nb1;
                                        r23 = nr21;
                                        g23 = ng21;
                                        b23 = nb21;
                                    }
                                    timelines.Add(timeline4);
                                    break;
                                }
                            case Spine.SkeletonBinary.SLOT_ALPHA: 
                                {
                                    var timeline5 = new Spine.AlphaTimeline(frameCount, input.ReadInt$1(true), slotIndex);
                                    var time4 = input.ReadFloat(), a3 = input.Read() / 255.0;
                                    for (var frame5 = 0, bezier4 = 0; ; frame5 = (frame5 + 1) | 0) {
                                        timeline5.SetFrame(frame5, time4, a3);
                                        if (frame5 === frameLast) {
                                            break;
                                        }
                                        var time24 = input.ReadFloat();
                                        var a21 = input.Read() / 255.0;
                                        switch (input.ReadUByte()) {
                                            case Spine.SkeletonBinary.CURVE_STEPPED: 
                                                timeline5.SetStepped(frame5);
                                                break;
                                            case Spine.SkeletonBinary.CURVE_BEZIER: 
                                                this.SetBezier(input, timeline5, Bridge.identity(bezier4, ((bezier4 = (bezier4 + 1) | 0))), frame5, 0, time4, time24, a3, a21, 1);
                                                break;
                                        }
                                        time4 = time24;
                                        a3 = a21;
                                    }
                                    timelines.Add(timeline5);
                                    break;
                                }
                        }
                    }
                }

                // Bone timelines.
                for (var i1 = 0, n1 = input.ReadInt$1(true); i1 < n1; i1 = (i1 + 1) | 0) {
                    var boneIndex = input.ReadInt$1(true);
                    for (var ii1 = 0, nn1 = input.ReadInt$1(true); ii1 < nn1; ii1 = (ii1 + 1) | 0) {
                        var type = input.ReadUByte(), frameCount1 = input.ReadInt$1(true);
                        if (type === Spine.SkeletonBinary.BONE_INHERIT) {
                            var timeline6 = new Spine.InheritTimeline(frameCount1, boneIndex);
                            for (var frame6 = 0; frame6 < frameCount1; frame6 = (frame6 + 1) | 0) {
                                timeline6.SetFrame(frame6, input.ReadFloat(), Spine.InheritEnum.Values[input.ReadUByte()]);
                            }
                            timelines.Add(timeline6);
                            continue;
                        }
                        var bezierCount = input.ReadInt$1(true);
                        switch (type) {
                            case Spine.SkeletonBinary.BONE_ROTATE: 
                                this.ReadTimeline(input, timelines, new Spine.RotateTimeline(frameCount1, bezierCount, boneIndex), 1);
                                break;
                            case Spine.SkeletonBinary.BONE_TRANSLATE: 
                                this.ReadTimeline$1(input, timelines, new Spine.TranslateTimeline(frameCount1, bezierCount, boneIndex), scale);
                                break;
                            case Spine.SkeletonBinary.BONE_TRANSLATEX: 
                                this.ReadTimeline(input, timelines, new Spine.TranslateXTimeline(frameCount1, bezierCount, boneIndex), scale);
                                break;
                            case Spine.SkeletonBinary.BONE_TRANSLATEY: 
                                this.ReadTimeline(input, timelines, new Spine.TranslateYTimeline(frameCount1, bezierCount, boneIndex), scale);
                                break;
                            case Spine.SkeletonBinary.BONE_SCALE: 
                                this.ReadTimeline$1(input, timelines, new Spine.ScaleTimeline(frameCount1, bezierCount, boneIndex), 1);
                                break;
                            case Spine.SkeletonBinary.BONE_SCALEX: 
                                this.ReadTimeline(input, timelines, new Spine.ScaleXTimeline(frameCount1, bezierCount, boneIndex), 1);
                                break;
                            case Spine.SkeletonBinary.BONE_SCALEY: 
                                this.ReadTimeline(input, timelines, new Spine.ScaleYTimeline(frameCount1, bezierCount, boneIndex), 1);
                                break;
                            case Spine.SkeletonBinary.BONE_SHEAR: 
                                this.ReadTimeline$1(input, timelines, new Spine.ShearTimeline(frameCount1, bezierCount, boneIndex), 1);
                                break;
                            case Spine.SkeletonBinary.BONE_SHEARX: 
                                this.ReadTimeline(input, timelines, new Spine.ShearXTimeline(frameCount1, bezierCount, boneIndex), 1);
                                break;
                            case Spine.SkeletonBinary.BONE_SHEARY: 
                                this.ReadTimeline(input, timelines, new Spine.ShearYTimeline(frameCount1, bezierCount, boneIndex), 1);
                                break;
                        }
                    }
                }

                // IK constraint timelines.
                for (var i2 = 0, n2 = input.ReadInt$1(true); i2 < n2; i2 = (i2 + 1) | 0) {
                    var index = input.ReadInt$1(true), frameCount2 = input.ReadInt$1(true), frameLast1 = (frameCount2 - 1) | 0;
                    var timeline7 = new Spine.IkConstraintTimeline(frameCount2, input.ReadInt$1(true), index);
                    var flags = input.Read();
                    var time5 = input.ReadFloat(), mix = (flags & 1) !== 0 ? ((flags & 2) !== 0 ? input.ReadFloat() : 1) : 0;
                    var softness = (flags & 4) !== 0 ? input.ReadFloat() * scale : 0;
                    for (var frame7 = 0, bezier5 = 0; ; frame7 = (frame7 + 1) | 0) {
                        timeline7.SetFrame(frame7, time5, mix, softness, (flags & 8) !== 0 ? 1 : -1, (flags & 16) !== 0, (flags & 32) !== 0);

                        if (frame7 === frameLast1) {
                            break;
                        }
                        flags = input.Read();
                        var time25 = input.ReadFloat(), mix2 = (flags & 1) !== 0 ? ((flags & 2) !== 0 ? input.ReadFloat() : 1) : 0;
                        var softness2 = (flags & 4) !== 0 ? input.ReadFloat() * scale : 0;
                        if ((flags & 64) !== 0) {
                            timeline7.SetStepped(frame7);
                        } else {
                            if ((flags & 128) !== 0) {
                                this.SetBezier(input, timeline7, Bridge.identity(bezier5, ((bezier5 = (bezier5 + 1) | 0))), frame7, 0, time5, time25, mix, mix2, 1);
                                this.SetBezier(input, timeline7, Bridge.identity(bezier5, ((bezier5 = (bezier5 + 1) | 0))), frame7, 1, time5, time25, softness, softness2, scale);
                            }
                        }
                        time5 = time25;
                        mix = mix2;
                        softness = softness2;
                    }
                    timelines.Add(timeline7);
                }

                // Transform constraint timelines.
                for (var i3 = 0, n3 = input.ReadInt$1(true); i3 < n3; i3 = (i3 + 1) | 0) {
                    var index1 = input.ReadInt$1(true), frameCount3 = input.ReadInt$1(true), frameLast2 = (frameCount3 - 1) | 0;
                    var timeline8 = new Spine.TransformConstraintTimeline(frameCount3, input.ReadInt$1(true), index1);
                    var time6 = input.ReadFloat(), mixRotate = input.ReadFloat(), mixX = input.ReadFloat(), mixY = input.ReadFloat(), mixScaleX = input.ReadFloat(), mixScaleY = input.ReadFloat(), mixShearY = input.ReadFloat();
                    for (var frame8 = 0, bezier6 = 0; ; frame8 = (frame8 + 1) | 0) {
                        timeline8.SetFrame(frame8, time6, mixRotate, mixX, mixY, mixScaleX, mixScaleY, mixShearY);
                        if (frame8 === frameLast2) {
                            break;
                        }
                        var time26 = input.ReadFloat(), mixRotate2 = input.ReadFloat(), mixX2 = input.ReadFloat(), mixY2 = input.ReadFloat(), mixScaleX2 = input.ReadFloat(), mixScaleY2 = input.ReadFloat(), mixShearY2 = input.ReadFloat();
                        switch (input.ReadUByte()) {
                            case Spine.SkeletonBinary.CURVE_STEPPED: 
                                timeline8.SetStepped(frame8);
                                break;
                            case Spine.SkeletonBinary.CURVE_BEZIER: 
                                this.SetBezier(input, timeline8, Bridge.identity(bezier6, ((bezier6 = (bezier6 + 1) | 0))), frame8, 0, time6, time26, mixRotate, mixRotate2, 1);
                                this.SetBezier(input, timeline8, Bridge.identity(bezier6, ((bezier6 = (bezier6 + 1) | 0))), frame8, 1, time6, time26, mixX, mixX2, 1);
                                this.SetBezier(input, timeline8, Bridge.identity(bezier6, ((bezier6 = (bezier6 + 1) | 0))), frame8, 2, time6, time26, mixY, mixY2, 1);
                                this.SetBezier(input, timeline8, Bridge.identity(bezier6, ((bezier6 = (bezier6 + 1) | 0))), frame8, 3, time6, time26, mixScaleX, mixScaleX2, 1);
                                this.SetBezier(input, timeline8, Bridge.identity(bezier6, ((bezier6 = (bezier6 + 1) | 0))), frame8, 4, time6, time26, mixScaleY, mixScaleY2, 1);
                                this.SetBezier(input, timeline8, Bridge.identity(bezier6, ((bezier6 = (bezier6 + 1) | 0))), frame8, 5, time6, time26, mixShearY, mixShearY2, 1);
                                break;
                        }
                        time6 = time26;
                        mixRotate = mixRotate2;
                        mixX = mixX2;
                        mixY = mixY2;
                        mixScaleX = mixScaleX2;
                        mixScaleY = mixScaleY2;
                        mixShearY = mixShearY2;
                    }
                    timelines.Add(timeline8);
                }

                // Path constraint timelines.
                for (var i4 = 0, n4 = input.ReadInt$1(true); i4 < n4; i4 = (i4 + 1) | 0) {
                    var index2 = input.ReadInt$1(true);
                    var data = ($t = skeletonData.pathConstraints.Items)[index2];
                    for (var ii2 = 0, nn2 = input.ReadInt$1(true); ii2 < nn2; ii2 = (ii2 + 1) | 0) {
                        var type1 = input.ReadUByte(), frameCount4 = input.ReadInt$1(true), bezierCount1 = input.ReadInt$1(true);
                        switch (type1) {
                            case Spine.SkeletonBinary.PATH_POSITION: 
                                this.ReadTimeline(input, timelines, new Spine.PathConstraintPositionTimeline(frameCount4, bezierCount1, index2), data.positionMode === Spine.PositionMode.Fixed ? scale : 1);
                                break;
                            case Spine.SkeletonBinary.PATH_SPACING: 
                                this.ReadTimeline(input, timelines, new Spine.PathConstraintSpacingTimeline(frameCount4, bezierCount1, index2), data.spacingMode === Spine.SpacingMode.Length || data.spacingMode === Spine.SpacingMode.Fixed ? scale : 1);
                                break;
                            case Spine.SkeletonBinary.PATH_MIX: 
                                var timeline9 = new Spine.PathConstraintMixTimeline(frameCount4, bezierCount1, index2);
                                var time7 = input.ReadFloat(), mixRotate1 = input.ReadFloat(), mixX1 = input.ReadFloat(), mixY1 = input.ReadFloat();
                                for (var frame9 = 0, bezier7 = 0, frameLast3 = (timeline9.FrameCount - 1) | 0; ; frame9 = (frame9 + 1) | 0) {
                                    timeline9.SetFrame(frame9, time7, mixRotate1, mixX1, mixY1);
                                    if (frame9 === frameLast3) {
                                        break;
                                    }
                                    var time27 = input.ReadFloat(), mixRotate21 = input.ReadFloat(), mixX21 = input.ReadFloat(), mixY21 = input.ReadFloat();
                                    switch (input.ReadUByte()) {
                                        case Spine.SkeletonBinary.CURVE_STEPPED: 
                                            timeline9.SetStepped(frame9);
                                            break;
                                        case Spine.SkeletonBinary.CURVE_BEZIER: 
                                            this.SetBezier(input, timeline9, Bridge.identity(bezier7, ((bezier7 = (bezier7 + 1) | 0))), frame9, 0, time7, time27, mixRotate1, mixRotate21, 1);
                                            this.SetBezier(input, timeline9, Bridge.identity(bezier7, ((bezier7 = (bezier7 + 1) | 0))), frame9, 1, time7, time27, mixX1, mixX21, 1);
                                            this.SetBezier(input, timeline9, Bridge.identity(bezier7, ((bezier7 = (bezier7 + 1) | 0))), frame9, 2, time7, time27, mixY1, mixY21, 1);
                                            break;
                                    }
                                    time7 = time27;
                                    mixRotate1 = mixRotate21;
                                    mixX1 = mixX21;
                                    mixY1 = mixY21;
                                }
                                timelines.Add(timeline9);
                                break;
                        }
                    }
                }

                // Physics timelines.
                for (var i5 = 0, n5 = input.ReadInt$1(true); i5 < n5; i5 = (i5 + 1) | 0) {
                    var index3 = (input.ReadInt$1(true) - 1) | 0;
                    for (var ii3 = 0, nn3 = input.ReadInt$1(true); ii3 < nn3; ii3 = (ii3 + 1) | 0) {
                        var type2 = input.ReadUByte(), frameCount5 = input.ReadInt$1(true);
                        if (type2 === Spine.SkeletonBinary.PHYSICS_RESET) {
                            var timeline10 = new Spine.PhysicsConstraintResetTimeline(frameCount5, index3);
                            for (var frame10 = 0; frame10 < frameCount5; frame10 = (frame10 + 1) | 0) {
                                timeline10.SetFrame(frame10, input.ReadFloat());
                            }
                            timelines.Add(timeline10);
                            continue;
                        }
                        var bezierCount2 = input.ReadInt$1(true);
                        switch (type2) {
                            case Spine.SkeletonBinary.PHYSICS_INERTIA: 
                                this.ReadTimeline(input, timelines, new Spine.PhysicsConstraintInertiaTimeline(frameCount5, bezierCount2, index3), 1);
                                break;
                            case Spine.SkeletonBinary.PHYSICS_STRENGTH: 
                                this.ReadTimeline(input, timelines, new Spine.PhysicsConstraintStrengthTimeline(frameCount5, bezierCount2, index3), 1);
                                break;
                            case Spine.SkeletonBinary.PHYSICS_DAMPING: 
                                this.ReadTimeline(input, timelines, new Spine.PhysicsConstraintDampingTimeline(frameCount5, bezierCount2, index3), 1);
                                break;
                            case Spine.SkeletonBinary.PHYSICS_MASS: 
                                this.ReadTimeline(input, timelines, new Spine.PhysicsConstraintMassTimeline(frameCount5, bezierCount2, index3), 1);
                                break;
                            case Spine.SkeletonBinary.PHYSICS_WIND: 
                                this.ReadTimeline(input, timelines, new Spine.PhysicsConstraintWindTimeline(frameCount5, bezierCount2, index3), 1);
                                break;
                            case Spine.SkeletonBinary.PHYSICS_GRAVITY: 
                                this.ReadTimeline(input, timelines, new Spine.PhysicsConstraintGravityTimeline(frameCount5, bezierCount2, index3), 1);
                                break;
                            case Spine.SkeletonBinary.PHYSICS_MIX: 
                                this.ReadTimeline(input, timelines, new Spine.PhysicsConstraintMixTimeline(frameCount5, bezierCount2, index3), 1);
                                break;
                        }
                    }
                }

                // Attachment timelines.
                for (var i6 = 0, n6 = input.ReadInt$1(true); i6 < n6; i6 = (i6 + 1) | 0) {
                    var skin = ($t1 = skeletonData.skins.Items)[input.ReadInt$1(true)];
                    for (var ii4 = 0, nn4 = input.ReadInt$1(true); ii4 < nn4; ii4 = (ii4 + 1) | 0) {
                        var slotIndex1 = input.ReadInt$1(true);
                        for (var iii = 0, nnn = input.ReadInt$1(true); iii < nnn; iii = (iii + 1) | 0) {
                            var attachmentName = input.ReadStringRef();
                            var attachment = skin.GetAttachment(slotIndex1, attachmentName);
                            if (attachment == null) {
                                throw new System.Runtime.Serialization.SerializationException.$ctor1("Timeline attachment not found: " + (attachmentName || ""));
                            }

                            var timelineType1 = input.ReadUByte(), frameCount6 = input.ReadInt$1(true), frameLast4 = (frameCount6 - 1) | 0;
                            switch (timelineType1) {
                                case Spine.SkeletonBinary.ATTACHMENT_DEFORM: 
                                    {
                                        var vertexAttachment = Bridge.cast(attachment, Spine.VertexAttachment);
                                        var weighted = vertexAttachment.Bones != null;
                                        var vertices = vertexAttachment.Vertices;
                                        var deformLength = weighted ? (((Bridge.Int.div(vertices.length, 3)) | 0)) << 1 : vertices.length;

                                        var timeline11 = new Spine.DeformTimeline(frameCount6, input.ReadInt$1(true), slotIndex1, vertexAttachment);

                                        var time8 = input.ReadFloat();
                                        for (var frame11 = 0, bezier8 = 0; ; frame11 = (frame11 + 1) | 0) {
                                            var deform;
                                            var end = input.ReadInt$1(true);
                                            if (end === 0) {
                                                deform = weighted ? System.Array.init(deformLength, 0, System.Single) : vertices;
                                            } else {
                                                deform = System.Array.init(deformLength, 0, System.Single);
                                                var start = input.ReadInt$1(true);
                                                end = (end + start) | 0;
                                                if (scale === 1) {
                                                    for (var v = start; v < end; v = (v + 1) | 0) {
                                                        deform[v] = input.ReadFloat();
                                                    }
                                                } else {
                                                    for (var v1 = start; v1 < end; v1 = (v1 + 1) | 0) {
                                                        deform[v1] = input.ReadFloat() * scale;
                                                    }
                                                }
                                                if (!weighted) {
                                                    for (var v2 = 0, vn = deform.length; v2 < vn; v2 = (v2 + 1) | 0) {
                                                        deform[v2] += vertices[v2];
                                                    }
                                                }
                                            }
                                            timeline11.SetFrame(frame11, time8, deform);
                                            if (frame11 === frameLast4) {
                                                break;
                                            }
                                            var time28 = input.ReadFloat();
                                            switch (input.ReadUByte()) {
                                                case Spine.SkeletonBinary.CURVE_STEPPED: 
                                                    timeline11.SetStepped(frame11);
                                                    break;
                                                case Spine.SkeletonBinary.CURVE_BEZIER: 
                                                    this.SetBezier(input, timeline11, Bridge.identity(bezier8, ((bezier8 = (bezier8 + 1) | 0))), frame11, 0, time8, time28, 0, 1, 1);
                                                    break;
                                            }
                                            time8 = time28;
                                        }
                                        timelines.Add(timeline11);
                                        break;
                                    }
                                case Spine.SkeletonBinary.ATTACHMENT_SEQUENCE: 
                                    {
                                        var timeline12 = new Spine.SequenceTimeline(frameCount6, slotIndex1, attachment);
                                        for (var frame12 = 0; frame12 < frameCount6; frame12 = (frame12 + 1) | 0) {
                                            var time9 = input.ReadFloat();
                                            var modeAndIndex = input.ReadInt();
                                            timeline12.SetFrame(frame12, time9, modeAndIndex & 15, modeAndIndex >> 4, input.ReadFloat());
                                        }
                                        timelines.Add(timeline12);
                                        break;
                                    }
                            } // end switch
                        }
                    }
                }

                // Draw order timeline.
                var drawOrderCount = input.ReadInt$1(true);
                if (drawOrderCount > 0) {
                    var timeline13 = new Spine.DrawOrderTimeline(drawOrderCount);
                    var slotCount = skeletonData.slots.Count;
                    for (var i7 = 0; i7 < drawOrderCount; i7 = (i7 + 1) | 0) {
                        var time10 = input.ReadFloat();
                        var offsetCount = input.ReadInt$1(true);
                        var drawOrder = System.Array.init(slotCount, 0, System.Int32);
                        for (var ii5 = (slotCount - 1) | 0; ii5 >= 0; ii5 = (ii5 - 1) | 0) {
                            drawOrder[ii5] = -1;
                        }
                        var unchanged = System.Array.init(((slotCount - offsetCount) | 0), 0, System.Int32);
                        var originalIndex = 0, unchangedIndex = 0;
                        for (var ii6 = 0; ii6 < offsetCount; ii6 = (ii6 + 1) | 0) {
                            var slotIndex2 = input.ReadInt$1(true);
                            // Collect unchanged items.
                            while (originalIndex !== slotIndex2) {
                                unchanged[Bridge.identity(unchangedIndex, ((unchangedIndex = (unchangedIndex + 1) | 0)))] = Bridge.identity(originalIndex, ((originalIndex = (originalIndex + 1) | 0)));
                            }
                            // Set changed items.
                            drawOrder[((originalIndex + input.ReadInt$1(true)) | 0)] = Bridge.identity(originalIndex, ((originalIndex = (originalIndex + 1) | 0)));
                        }
                        // Collect remaining unchanged items.
                        while (originalIndex < slotCount) {
                            unchanged[Bridge.identity(unchangedIndex, ((unchangedIndex = (unchangedIndex + 1) | 0)))] = Bridge.identity(originalIndex, ((originalIndex = (originalIndex + 1) | 0)));
                        }
                        // Fill in unchanged items.
                        for (var ii7 = (slotCount - 1) | 0; ii7 >= 0; ii7 = (ii7 - 1) | 0) {
                            if (drawOrder[ii7] === -1) {
                                drawOrder[ii7] = unchanged[((unchangedIndex = (unchangedIndex - 1) | 0))];
                            }
                        }
                        timeline13.SetFrame(i7, time10, drawOrder);
                    }
                    timelines.Add(timeline13);
                }

                // Event timeline.
                var eventCount = input.ReadInt$1(true);
                if (eventCount > 0) {
                    var timeline14 = new Spine.EventTimeline(eventCount);
                    for (var i8 = 0; i8 < eventCount; i8 = (i8 + 1) | 0) {
                        var time11 = input.ReadFloat();
                        var eventData = ($t2 = skeletonData.events.Items)[input.ReadInt$1(true)];
                        var e = new Spine.Event(time11, eventData);
                        e.intValue = input.ReadInt$1(false);
                        e.floatValue = input.ReadFloat();
                        e.stringValue = input.ReadString();
                        if (e.stringValue == null) {
                            e.stringValue = eventData.String;
                        }
                        if (e.Data.AudioPath != null) {
                            e.volume = input.ReadFloat();
                            e.balance = input.ReadFloat();
                        }
                        timeline14.SetFrame(i8, e);
                    }
                    timelines.Add(timeline14);
                }

                var duration = 0;
                var items = timelines.Items;
                for (var i9 = 0, n7 = timelines.Count; i9 < n7; i9 = (i9 + 1) | 0) {
                    duration = Math.max(duration, items[i9].Duration);
                }
                return new Spine.Animation(name, timelines, duration);
            },
            /*Spine.SkeletonBinary.ReadAnimation end.*/

            /*Spine.SkeletonBinary.ReadTimeline start.*/
            /**
             * @instance
             * @private
             * @this Spine.SkeletonBinary
             * @memberof Spine.SkeletonBinary
             * @throws Throws IOException when a read operation fails.
             * @param   {Spine.SkeletonBinary.SkeletonInput}    input        
             * @param   {Spine.ExposedList$1}                   timelines    
             * @param   {Spine.CurveTimeline1}                  timeline     
             * @param   {number}                                scale
             * @return  {void}
             */
            ReadTimeline: function (input, timelines, timeline, scale) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#ReadTimeline", this ); }

                var time = input.ReadFloat(), value = input.ReadFloat() * scale;
                for (var frame = 0, bezier = 0, frameLast = (timeline.FrameCount - 1) | 0; ; frame = (frame + 1) | 0) {
                    timeline.SetFrame(frame, time, value);
                    if (frame === frameLast) {
                        break;
                    }
                    var time2 = input.ReadFloat(), value2 = input.ReadFloat() * scale;
                    switch (input.ReadUByte()) {
                        case Spine.SkeletonBinary.CURVE_STEPPED: 
                            timeline.SetStepped(frame);
                            break;
                        case Spine.SkeletonBinary.CURVE_BEZIER: 
                            this.SetBezier(input, timeline, Bridge.identity(bezier, ((bezier = (bezier + 1) | 0))), frame, 0, time, time2, value, value2, scale);
                            break;
                    }
                    time = time2;
                    value = value2;
                }
                timelines.Add(timeline);
            },
            /*Spine.SkeletonBinary.ReadTimeline end.*/

            /*Spine.SkeletonBinary.ReadTimeline$1 start.*/
            /**
             * @instance
             * @private
             * @this Spine.SkeletonBinary
             * @memberof Spine.SkeletonBinary
             * @throws Throws IOException when a read operation fails.
             * @param   {Spine.SkeletonBinary.SkeletonInput}    input        
             * @param   {Spine.ExposedList$1}                   timelines    
             * @param   {Spine.CurveTimeline2}                  timeline     
             * @param   {number}                                scale
             * @return  {void}
             */
            ReadTimeline$1: function (input, timelines, timeline, scale) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#ReadTimeline$1", this ); }

                var time = input.ReadFloat(), value1 = input.ReadFloat() * scale, value2 = input.ReadFloat() * scale;
                for (var frame = 0, bezier = 0, frameLast = (timeline.FrameCount - 1) | 0; ; frame = (frame + 1) | 0) {
                    timeline.SetFrame(frame, time, value1, value2);
                    if (frame === frameLast) {
                        break;
                    }
                    var time2 = input.ReadFloat(), nvalue1 = input.ReadFloat() * scale, nvalue2 = input.ReadFloat() * scale;
                    switch (input.ReadUByte()) {
                        case Spine.SkeletonBinary.CURVE_STEPPED: 
                            timeline.SetStepped(frame);
                            break;
                        case Spine.SkeletonBinary.CURVE_BEZIER: 
                            this.SetBezier(input, timeline, Bridge.identity(bezier, ((bezier = (bezier + 1) | 0))), frame, 0, time, time2, value1, nvalue1, scale);
                            this.SetBezier(input, timeline, Bridge.identity(bezier, ((bezier = (bezier + 1) | 0))), frame, 1, time, time2, value2, nvalue2, scale);
                            break;
                    }
                    time = time2;
                    value1 = nvalue1;
                    value2 = nvalue2;
                }
                timelines.Add(timeline);
            },
            /*Spine.SkeletonBinary.ReadTimeline$1 end.*/

            /*Spine.SkeletonBinary.SetBezier start.*/
            /**
             * @instance
             * @private
             * @this Spine.SkeletonBinary
             * @memberof Spine.SkeletonBinary
             * @throws Throws IOException when a read operation fails.
             * @param   {Spine.SkeletonBinary.SkeletonInput}    input       
             * @param   {Spine.CurveTimeline}                   timeline    
             * @param   {number}                                bezier      
             * @param   {number}                                frame       
             * @param   {number}                                value       
             * @param   {number}                                time1       
             * @param   {number}                                time2       
             * @param   {number}                                value1      
             * @param   {number}                                value2      
             * @param   {number}                                scale
             * @return  {void}
             */
            SetBezier: function (input, timeline, bezier, frame, value, time1, time2, value1, value2, scale) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#SetBezier", this ); }

                timeline.SetBezier(bezier, frame, value, time1, value1, input.ReadFloat(), input.ReadFloat() * scale, input.ReadFloat(), input.ReadFloat() * scale, time2, value2);
            },
            /*Spine.SkeletonBinary.SetBezier end.*/


        },
        overloads: {
            "ReadSkeletonData(Stream)": "ReadSkeletonData$1",
            "ReadTimeline(SkeletonInput, ExposedList<Timeline>, CurveTimeline2, float)": "ReadTimeline$1"
        }
    });
    /*Spine.SkeletonBinary end.*/

    /*Spine.SkeletonJson start.*/
    /**
     * Loads skeleton data in the Spine JSON format.
     <p>JSON is human readable but the binary format is much smaller on disk and faster to load. See {@link }.</p><p>See <a href="http://esotericsoftware.com/spine-json-format">Spine JSON format</a> and
     <a href="http://esotericsoftware.com/spine-loading-skeleton-data#JSON-and-binary-data"> JSON and binary data</a> in the Spine
     Runtimes Guide.</p>
     *
     * @public
     * @class Spine.SkeletonJson
     * @augments Spine.SkeletonLoader
     */
    Bridge.define("Spine.SkeletonJson", {
        inherits: [Spine.SkeletonLoader],
        statics: {
            methods: {
                /*Spine.SkeletonJson.ReadSequence:static start.*/
                ReadSequence: function (sequenceJson) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#ReadSequence", this ); }

                    var map = Bridge.as(sequenceJson, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                    if (map == null) {
                        return null;
                    }
                    var sequence = new Spine.Sequence.$ctor1(Spine.SkeletonJson.GetInt(map, "count"));
                    sequence.start = Spine.SkeletonJson.GetInt$1(map, "start", 1);
                    sequence.digits = Spine.SkeletonJson.GetInt$1(map, "digits", 0);
                    sequence.setupIndex = Spine.SkeletonJson.GetInt$1(map, "setup", 0);
                    return sequence;
                },
                /*Spine.SkeletonJson.ReadSequence:static end.*/

                /*Spine.SkeletonJson.ReadTimeline:static start.*/
                ReadTimeline: function (keyMapEnumerator, timeline, defaultValue, scale) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#ReadTimeline", this ); }

                    var keyMap = Bridge.cast(keyMapEnumerator.v.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                    var time = Spine.SkeletonJson.GetFloat(keyMap, "time", 0);
                    var value = Spine.SkeletonJson.GetFloat(keyMap, "value", defaultValue) * scale;
                    for (var frame = 0, bezier = 0; ; frame = (frame + 1) | 0) {
                        timeline.SetFrame(frame, time, value);
                        if (!keyMapEnumerator.v.moveNext()) {
                            timeline.Shrink(bezier);
                            return timeline;
                        }
                        var nextMap = Bridge.cast(keyMapEnumerator.v.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                        var time2 = Spine.SkeletonJson.GetFloat(nextMap, "time", 0);
                        var value2 = Spine.SkeletonJson.GetFloat(nextMap, "value", defaultValue) * scale;
                        if (keyMap.containsKey("curve")) {
                            var curve = keyMap.getItem("curve");
                            bezier = Spine.SkeletonJson.ReadCurve(curve, timeline, bezier, frame, 0, time, time2, value, value2, scale);
                        }
                        time = time2;
                        value = value2;
                        keyMap = nextMap;
                    }
                },
                /*Spine.SkeletonJson.ReadTimeline:static end.*/

                /*Spine.SkeletonJson.ReadTimeline$1:static start.*/
                ReadTimeline$1: function (keyMapEnumerator, timeline, name1, name2, defaultValue, scale) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#ReadTimeline$1", this ); }


                    var keyMap = Bridge.cast(keyMapEnumerator.v.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                    var time = Spine.SkeletonJson.GetFloat(keyMap, "time", 0);
                    var value1 = Spine.SkeletonJson.GetFloat(keyMap, name1, defaultValue) * scale, value2 = Spine.SkeletonJson.GetFloat(keyMap, name2, defaultValue) * scale;
                    for (var frame = 0, bezier = 0; ; frame = (frame + 1) | 0) {
                        timeline.SetFrame(frame, time, value1, value2);
                        if (!keyMapEnumerator.v.moveNext()) {
                            timeline.Shrink(bezier);
                            return timeline;
                        }
                        var nextMap = Bridge.cast(keyMapEnumerator.v.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                        var time2 = Spine.SkeletonJson.GetFloat(nextMap, "time", 0);
                        var nvalue1 = Spine.SkeletonJson.GetFloat(nextMap, name1, defaultValue) * scale, nvalue2 = Spine.SkeletonJson.GetFloat(nextMap, name2, defaultValue) * scale;
                        if (keyMap.containsKey("curve")) {
                            var curve = keyMap.getItem("curve");
                            bezier = Spine.SkeletonJson.ReadCurve(curve, timeline, bezier, frame, 0, time, time2, value1, nvalue1, scale);
                            bezier = Spine.SkeletonJson.ReadCurve(curve, timeline, bezier, frame, 1, time, time2, value2, nvalue2, scale);
                        }
                        time = time2;
                        value1 = nvalue1;
                        value2 = nvalue2;
                        keyMap = nextMap;
                    }
                },
                /*Spine.SkeletonJson.ReadTimeline$1:static end.*/

                /*Spine.SkeletonJson.ReadCurve:static start.*/
                ReadCurve: function (curve, timeline, bezier, frame, value, time1, time2, value1, value2, scale) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#ReadCurve", this ); }


                    var curveString = Bridge.as(curve, System.String);
                    if (curveString != null) {
                        if (Bridge.referenceEquals(curveString, "stepped")) {
                            timeline.SetStepped(frame);
                        }
                        return bezier;
                    }
                    var curveValues = Bridge.cast(curve, System.Collections.Generic.List$1(System.Object));
                    var i = value << 2;
                    var cx1 = System.Nullable.getValue(Bridge.cast(Bridge.unbox(curveValues.getItem(i), System.Single), System.Single));
                    var cy1 = System.Nullable.getValue(Bridge.cast(Bridge.unbox(curveValues.getItem(((i + 1) | 0)), System.Single), System.Single)) * scale;
                    var cx2 = System.Nullable.getValue(Bridge.cast(Bridge.unbox(curveValues.getItem(((i + 2) | 0)), System.Single), System.Single));
                    var cy2 = System.Nullable.getValue(Bridge.cast(Bridge.unbox(curveValues.getItem(((i + 3) | 0)), System.Single), System.Single)) * scale;
                    Spine.SkeletonJson.SetBezier(timeline, frame, value, bezier, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
                    return ((bezier + 1) | 0);
                },
                /*Spine.SkeletonJson.ReadCurve:static end.*/

                /*Spine.SkeletonJson.SetBezier:static start.*/
                SetBezier: function (timeline, frame, value, bezier, time1, value1, cx1, cy1, cx2, cy2, time2, value2) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#SetBezier", this ); }

                    timeline.SetBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
                },
                /*Spine.SkeletonJson.SetBezier:static end.*/

                /*Spine.SkeletonJson.GetFloatArray:static start.*/
                GetFloatArray: function (map, name, scale) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#GetFloatArray", this ); }

                    var list = Bridge.cast(map.getItem(name), System.Collections.Generic.List$1(System.Object));
                    var values = System.Array.init(list.Count, 0, System.Single);
                    if (scale === 1) {
                        for (var i = 0, n = list.Count; i < n; i = (i + 1) | 0) {
                            values[i] = System.Nullable.getValue(Bridge.cast(Bridge.unbox(list.getItem(i), System.Single), System.Single));
                        }
                    } else {
                        for (var i1 = 0, n1 = list.Count; i1 < n1; i1 = (i1 + 1) | 0) {
                            values[i1] = System.Nullable.getValue(Bridge.cast(Bridge.unbox(list.getItem(i1), System.Single), System.Single)) * scale;
                        }
                    }
                    return values;
                },
                /*Spine.SkeletonJson.GetFloatArray:static end.*/

                /*Spine.SkeletonJson.GetIntArray:static start.*/
                GetIntArray: function (map, name) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#GetIntArray", this ); }

                    var list = Bridge.cast(map.getItem(name), System.Collections.Generic.List$1(System.Object));
                    var values = System.Array.init(list.Count, 0, System.Int32);
                    for (var i = 0, n = list.Count; i < n; i = (i + 1) | 0) {
                        values[i] = Bridge.Int.clip32(System.Nullable.getValue(Bridge.cast(Bridge.unbox(list.getItem(i), System.Single), System.Single)));
                    }
                    return values;
                },
                /*Spine.SkeletonJson.GetIntArray:static end.*/

                /*Spine.SkeletonJson.GetFloat:static start.*/
                GetFloat: function (map, name, defaultValue) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#GetFloat", this ); }

                    if (!map.containsKey(name)) {
                        return defaultValue;
                    }
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(map.getItem(name), System.Single), System.Single));
                },
                /*Spine.SkeletonJson.GetFloat:static end.*/

                /*Spine.SkeletonJson.GetInt$1:static start.*/
                GetInt$1: function (map, name, defaultValue) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#GetInt$1", this ); }

                    if (!map.containsKey(name)) {
                        return defaultValue;
                    }
                    return Bridge.Int.clip32(System.Nullable.getValue(Bridge.cast(Bridge.unbox(map.getItem(name), System.Single), System.Single)));
                },
                /*Spine.SkeletonJson.GetInt$1:static end.*/

                /*Spine.SkeletonJson.GetInt:static start.*/
                GetInt: function (map, name) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#GetInt", this ); }

                    if (!map.containsKey(name)) {
                        throw new System.ArgumentException.$ctor1("Named value not found: " + (name || ""));
                    }
                    return Bridge.Int.clip32(System.Nullable.getValue(Bridge.cast(Bridge.unbox(map.getItem(name), System.Single), System.Single)));
                },
                /*Spine.SkeletonJson.GetInt:static end.*/

                /*Spine.SkeletonJson.GetBoolean:static start.*/
                GetBoolean: function (map, name, defaultValue) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#GetBoolean", this ); }

                    if (!map.containsKey(name)) {
                        return defaultValue;
                    }
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(map.getItem(name), System.Boolean), System.Boolean));
                },
                /*Spine.SkeletonJson.GetBoolean:static end.*/

                /*Spine.SkeletonJson.GetString:static start.*/
                GetString: function (map, name, defaultValue) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#GetString", this ); }

                    if (!map.containsKey(name)) {
                        return defaultValue;
                    }
                    return Bridge.cast(map.getItem(name), System.String);
                },
                /*Spine.SkeletonJson.GetString:static end.*/

                /*Spine.SkeletonJson.ToColor:static start.*/
                ToColor: function (hexString, colorIndex, expectedLength) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#ToColor", this ); }

                    if (expectedLength === void 0) { expectedLength = 8; }
                    if (hexString.length < expectedLength) {
                        throw new System.ArgumentException.$ctor3("Color hexadecimal length must be " + expectedLength + ", received: " + (hexString || ""), "hexString");
                    }
                    return System.Convert.toNumberInBase(hexString.substr(Bridge.Int.mul(colorIndex, 2), 2), 16, 9) / 255.0;
                },
                /*Spine.SkeletonJson.ToColor:static end.*/


            }
        },
        fields: {
            linkedMeshes: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#init", this ); }

                this.linkedMeshes = new (System.Collections.Generic.List$1(Spine.SkeletonJson.LinkedMesh)).ctor();
            },
            $ctor1: function (attachmentLoader) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#$ctor1", this ); }

                this.$initialize();
                Spine.SkeletonLoader.$ctor1.call(this, attachmentLoader);
            },
            ctor: function (atlasArray) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#ctor", this ); }

                if (atlasArray === void 0) { atlasArray = []; }

                this.$initialize();
                Spine.SkeletonLoader.ctor.call(this, atlasArray);
            }
        },
        methods: {
            /*Spine.SkeletonJson.ReadSkeletonData start.*/
            ReadSkeletonData: function (path) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#ReadSkeletonData", this ); }

                var reader = new System.IO.StreamReader.$ctor1(new System.IO.FileStream.$ctor2(path, 3, System.IO.FileAccess.Read, 1));
                try {
                    var skeletonData = this.ReadSkeletonData$1(reader);
                    skeletonData.name = System.IO.Path.GetFileNameWithoutExtension(path);
                    return skeletonData;
                }
                finally {
                    if (Bridge.hasValue(reader)) {
                        reader.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.SkeletonJson.ReadSkeletonData end.*/

            /*Spine.SkeletonJson.ReadSkeletonData$1 start.*/
            ReadSkeletonData$1: function (reader) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#ReadSkeletonData$1", this ); }

                var $t, $t1, $t2, $t3, $t4, $t5, $t6, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14, $t15, $t16, $t17, $t18;
                if (reader == null) {
                    throw new System.ArgumentNullException.$ctor3("reader", "reader cannot be null.");
                }

                var scale = this.scale;
                var skeletonData = new Spine.SkeletonData();

                var root = Bridge.as(Spine.Json.Deserialize(reader), System.Collections.Generic.Dictionary$2(System.String,System.Object));
                if (root == null) {
                    throw new System.Exception("Invalid JSON.");
                }

                // Skeleton.
                if (root.containsKey("skeleton")) {
                    var skeletonMap = Bridge.cast(root.getItem("skeleton"), System.Collections.Generic.Dictionary$2(System.String,System.Object));
                    skeletonData.hash = Bridge.cast(skeletonMap.getItem("hash"), System.String);
                    skeletonData.version = Bridge.cast(skeletonMap.getItem("spine"), System.String);
                    skeletonData.x = Spine.SkeletonJson.GetFloat(skeletonMap, "x", 0);
                    skeletonData.y = Spine.SkeletonJson.GetFloat(skeletonMap, "y", 0);
                    skeletonData.width = Spine.SkeletonJson.GetFloat(skeletonMap, "width", 0);
                    skeletonData.height = Spine.SkeletonJson.GetFloat(skeletonMap, "height", 0);
                    skeletonData.referenceScale = Spine.SkeletonJson.GetFloat(skeletonMap, "referenceScale", 100) * scale;
                    skeletonData.fps = Spine.SkeletonJson.GetFloat(skeletonMap, "fps", 30);
                    skeletonData.imagesPath = Spine.SkeletonJson.GetString(skeletonMap, "images", null);
                    skeletonData.audioPath = Spine.SkeletonJson.GetString(skeletonMap, "audio", null);
                }

                // Bones.
                if (root.containsKey("bones")) {
                    $t = Bridge.getEnumerator(Bridge.cast(root.getItem("bones"), System.Collections.Generic.List$1(System.Object)));
                    try {
                        while ($t.moveNext()) {
                            var boneMap = Bridge.cast($t.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                            var parent = null;
                            if (boneMap.containsKey("parent")) {
                                parent = skeletonData.FindBone(Bridge.cast(boneMap.getItem("parent"), System.String));
                                if (parent == null) {
                                    throw new System.Exception(System.String.concat("Parent bone not found: ", boneMap.getItem("parent")));
                                }
                            }
                            var data = new Spine.BoneData(skeletonData.Bones.Count, Bridge.cast(boneMap.getItem("name"), System.String), parent);
                            data.length = Spine.SkeletonJson.GetFloat(boneMap, "length", 0) * scale;
                            data.x = Spine.SkeletonJson.GetFloat(boneMap, "x", 0) * scale;
                            data.y = Spine.SkeletonJson.GetFloat(boneMap, "y", 0) * scale;
                            data.rotation = Spine.SkeletonJson.GetFloat(boneMap, "rotation", 0);
                            data.scaleX = Spine.SkeletonJson.GetFloat(boneMap, "scaleX", 1);
                            data.scaleY = Spine.SkeletonJson.GetFloat(boneMap, "scaleY", 1);
                            data.shearX = Spine.SkeletonJson.GetFloat(boneMap, "shearX", 0);
                            data.shearY = Spine.SkeletonJson.GetFloat(boneMap, "shearY", 0);

                            var inheritString = Spine.SkeletonJson.GetString(boneMap, "inherit", System.Enum.toString(Spine.Inherit, Spine.Inherit.Normal));
                            data.inherit = System.Nullable.getValue(Bridge.cast(Bridge.unbox(System.Enum.parse(Spine.Inherit, inheritString, true), Spine.Inherit), System.Int32));
                            data.skinRequired = Spine.SkeletonJson.GetBoolean(boneMap, "skin", false);

                            skeletonData.bones.Add(data);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }

                // Slots.
                if (root.containsKey("slots")) {
                    $t1 = Bridge.getEnumerator(Bridge.cast(root.getItem("slots"), System.Collections.Generic.List$1(System.Object)));
                    try {
                        while ($t1.moveNext()) {
                            var slotMap = Bridge.cast($t1.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                            var slotName = Bridge.cast(slotMap.getItem("name"), System.String);
                            var boneName = Bridge.cast(slotMap.getItem("bone"), System.String);
                            var boneData = skeletonData.FindBone(boneName);
                            if (boneData == null) {
                                throw new System.Exception("Slot bone not found: " + (boneName || ""));
                            }
                            var data1 = new Spine.SlotData(skeletonData.Slots.Count, slotName, boneData);

                            if (slotMap.containsKey("color")) {
                                var color = Bridge.cast(slotMap.getItem("color"), System.String);
                                data1.r = Spine.SkeletonJson.ToColor(color, 0);
                                data1.g = Spine.SkeletonJson.ToColor(color, 1);
                                data1.b = Spine.SkeletonJson.ToColor(color, 2);
                                data1.a = Spine.SkeletonJson.ToColor(color, 3);
                            }

                            if (slotMap.containsKey("dark")) {
                                var color2 = Bridge.cast(slotMap.getItem("dark"), System.String);
                                data1.r2 = Spine.SkeletonJson.ToColor(color2, 0, 6); // expectedLength = 6. ie. "RRGGBB"
                                data1.g2 = Spine.SkeletonJson.ToColor(color2, 1, 6);
                                data1.b2 = Spine.SkeletonJson.ToColor(color2, 2, 6);
                                data1.hasSecondColor = true;
                            }

                            data1.attachmentName = Spine.SkeletonJson.GetString(slotMap, "attachment", null);
                            if (slotMap.containsKey("blend")) {
                                data1.blendMode = System.Nullable.getValue(Bridge.cast(Bridge.unbox(System.Enum.parse(Spine.BlendMode, Bridge.cast(slotMap.getItem("blend"), System.String), true), Spine.BlendMode), System.Int32));
                            } else {
                                data1.blendMode = Spine.BlendMode.Normal;
                            }
                            //data.visible = slotMap.getBoolean("visible", true);
                            skeletonData.slots.Add(data1);
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                }

                // IK constraints.
                if (root.containsKey("ik")) {
                    $t2 = Bridge.getEnumerator(Bridge.cast(root.getItem("ik"), System.Collections.Generic.List$1(System.Object)));
                    try {
                        while ($t2.moveNext()) {
                            var constraintMap = Bridge.cast($t2.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                            var data2 = new Spine.IkConstraintData(Bridge.cast(constraintMap.getItem("name"), System.String));
                            data2.order = Spine.SkeletonJson.GetInt$1(constraintMap, "order", 0);
                            data2.skinRequired = Spine.SkeletonJson.GetBoolean(constraintMap, "skin", false);

                            if (constraintMap.containsKey("bones")) {
                                $t3 = Bridge.getEnumerator(Bridge.cast(constraintMap.getItem("bones"), System.Collections.Generic.List$1(System.Object)));
                                try {
                                    while ($t3.moveNext()) {
                                        var boneName1 = Bridge.cast($t3.Current, System.String);
                                        var bone = skeletonData.FindBone(boneName1);
                                        if (bone == null) {
                                            throw new System.Exception("IK bone not found: " + (boneName1 || ""));
                                        }
                                        data2.bones.Add(bone);
                                    }
                                } finally {
                                    if (Bridge.is($t3, System.IDisposable)) {
                                        $t3.System$IDisposable$Dispose();
                                    }
                                }
                            }

                            var targetName = Bridge.cast(constraintMap.getItem("target"), System.String);
                            data2.target = skeletonData.FindBone(targetName);
                            if (data2.target == null) {
                                throw new System.Exception("IK target bone not found: " + (targetName || ""));
                            }
                            data2.mix = Spine.SkeletonJson.GetFloat(constraintMap, "mix", 1);
                            data2.softness = Spine.SkeletonJson.GetFloat(constraintMap, "softness", 0) * scale;
                            data2.bendDirection = Spine.SkeletonJson.GetBoolean(constraintMap, "bendPositive", true) ? 1 : -1;
                            data2.compress = Spine.SkeletonJson.GetBoolean(constraintMap, "compress", false);
                            data2.stretch = Spine.SkeletonJson.GetBoolean(constraintMap, "stretch", false);
                            data2.uniform = Spine.SkeletonJson.GetBoolean(constraintMap, "uniform", false);

                            skeletonData.ikConstraints.Add(data2);
                        }
                    } finally {
                        if (Bridge.is($t2, System.IDisposable)) {
                            $t2.System$IDisposable$Dispose();
                        }
                    }
                }

                // Transform constraints.
                if (root.containsKey("transform")) {
                    $t4 = Bridge.getEnumerator(Bridge.cast(root.getItem("transform"), System.Collections.Generic.List$1(System.Object)));
                    try {
                        while ($t4.moveNext()) {
                            var constraintMap1 = Bridge.cast($t4.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                            var data3 = new Spine.TransformConstraintData(Bridge.cast(constraintMap1.getItem("name"), System.String));
                            data3.order = Spine.SkeletonJson.GetInt$1(constraintMap1, "order", 0);
                            data3.skinRequired = Spine.SkeletonJson.GetBoolean(constraintMap1, "skin", false);

                            if (constraintMap1.containsKey("bones")) {
                                $t5 = Bridge.getEnumerator(Bridge.cast(constraintMap1.getItem("bones"), System.Collections.Generic.List$1(System.Object)));
                                try {
                                    while ($t5.moveNext()) {
                                        var boneName2 = Bridge.cast($t5.Current, System.String);
                                        var bone1 = skeletonData.FindBone(boneName2);
                                        if (bone1 == null) {
                                            throw new System.Exception("Transform constraint bone not found: " + (boneName2 || ""));
                                        }
                                        data3.bones.Add(bone1);
                                    }
                                } finally {
                                    if (Bridge.is($t5, System.IDisposable)) {
                                        $t5.System$IDisposable$Dispose();
                                    }
                                }
                            }

                            var targetName1 = Bridge.cast(constraintMap1.getItem("target"), System.String);
                            data3.target = skeletonData.FindBone(targetName1);
                            if (data3.target == null) {
                                throw new System.Exception("Transform constraint target bone not found: " + (targetName1 || ""));
                            }

                            data3.local = Spine.SkeletonJson.GetBoolean(constraintMap1, "local", false);
                            data3.relative = Spine.SkeletonJson.GetBoolean(constraintMap1, "relative", false);

                            data3.offsetRotation = Spine.SkeletonJson.GetFloat(constraintMap1, "rotation", 0);
                            data3.offsetX = Spine.SkeletonJson.GetFloat(constraintMap1, "x", 0) * scale;
                            data3.offsetY = Spine.SkeletonJson.GetFloat(constraintMap1, "y", 0) * scale;
                            data3.offsetScaleX = Spine.SkeletonJson.GetFloat(constraintMap1, "scaleX", 0);
                            data3.offsetScaleY = Spine.SkeletonJson.GetFloat(constraintMap1, "scaleY", 0);
                            data3.offsetShearY = Spine.SkeletonJson.GetFloat(constraintMap1, "shearY", 0);

                            data3.mixRotate = Spine.SkeletonJson.GetFloat(constraintMap1, "mixRotate", 1);
                            data3.mixX = Spine.SkeletonJson.GetFloat(constraintMap1, "mixX", 1);
                            data3.mixY = Spine.SkeletonJson.GetFloat(constraintMap1, "mixY", data3.mixX);
                            data3.mixScaleX = Spine.SkeletonJson.GetFloat(constraintMap1, "mixScaleX", 1);
                            data3.mixScaleY = Spine.SkeletonJson.GetFloat(constraintMap1, "mixScaleY", data3.mixScaleX);
                            data3.mixShearY = Spine.SkeletonJson.GetFloat(constraintMap1, "mixShearY", 1);

                            skeletonData.transformConstraints.Add(data3);
                        }
                    } finally {
                        if (Bridge.is($t4, System.IDisposable)) {
                            $t4.System$IDisposable$Dispose();
                        }
                    }
                }

                // Path constraints.
                if (root.containsKey("path")) {
                    $t6 = Bridge.getEnumerator(Bridge.cast(root.getItem("path"), System.Collections.Generic.List$1(System.Object)));
                    try {
                        while ($t6.moveNext()) {
                            var constraintMap2 = Bridge.cast($t6.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                            var data4 = new Spine.PathConstraintData(Bridge.cast(constraintMap2.getItem("name"), System.String));
                            data4.order = Spine.SkeletonJson.GetInt$1(constraintMap2, "order", 0);
                            data4.skinRequired = Spine.SkeletonJson.GetBoolean(constraintMap2, "skin", false);

                            if (constraintMap2.containsKey("bones")) {
                                $t7 = Bridge.getEnumerator(Bridge.cast(constraintMap2.getItem("bones"), System.Collections.Generic.List$1(System.Object)));
                                try {
                                    while ($t7.moveNext()) {
                                        var boneName3 = Bridge.cast($t7.Current, System.String);
                                        var bone2 = skeletonData.FindBone(boneName3);
                                        if (bone2 == null) {
                                            throw new System.Exception("Path bone not found: " + (boneName3 || ""));
                                        }
                                        data4.bones.Add(bone2);
                                    }
                                } finally {
                                    if (Bridge.is($t7, System.IDisposable)) {
                                        $t7.System$IDisposable$Dispose();
                                    }
                                }
                            }

                            var targetName2 = Bridge.cast(constraintMap2.getItem("target"), System.String);
                            data4.target = skeletonData.FindSlot(targetName2);
                            if (data4.target == null) {
                                throw new System.Exception("Path target slot not found: " + (targetName2 || ""));
                            }

                            data4.positionMode = System.Nullable.getValue(Bridge.cast(Bridge.unbox(System.Enum.parse(Spine.PositionMode, Spine.SkeletonJson.GetString(constraintMap2, "positionMode", "percent"), true), Spine.PositionMode), System.Int32));
                            data4.spacingMode = System.Nullable.getValue(Bridge.cast(Bridge.unbox(System.Enum.parse(Spine.SpacingMode, Spine.SkeletonJson.GetString(constraintMap2, "spacingMode", "length"), true), Spine.SpacingMode), System.Int32));
                            data4.rotateMode = System.Nullable.getValue(Bridge.cast(Bridge.unbox(System.Enum.parse(Spine.RotateMode, Spine.SkeletonJson.GetString(constraintMap2, "rotateMode", "tangent"), true), Spine.RotateMode), System.Int32));
                            data4.offsetRotation = Spine.SkeletonJson.GetFloat(constraintMap2, "rotation", 0);
                            data4.position = Spine.SkeletonJson.GetFloat(constraintMap2, "position", 0);
                            if (data4.positionMode === Spine.PositionMode.Fixed) {
                                data4.position *= scale;
                            }
                            data4.spacing = Spine.SkeletonJson.GetFloat(constraintMap2, "spacing", 0);
                            if (data4.spacingMode === Spine.SpacingMode.Length || data4.spacingMode === Spine.SpacingMode.Fixed) {
                                data4.spacing *= scale;
                            }
                            data4.mixRotate = Spine.SkeletonJson.GetFloat(constraintMap2, "mixRotate", 1);
                            data4.mixX = Spine.SkeletonJson.GetFloat(constraintMap2, "mixX", 1);
                            data4.mixY = Spine.SkeletonJson.GetFloat(constraintMap2, "mixY", data4.mixX);

                            skeletonData.pathConstraints.Add(data4);
                        }
                    } finally {
                        if (Bridge.is($t6, System.IDisposable)) {
                            $t6.System$IDisposable$Dispose();
                        }
                    }
                }

                // Physics constraints.
                if (root.containsKey("physics")) {
                    $t8 = Bridge.getEnumerator(Bridge.cast(root.getItem("physics"), System.Collections.Generic.List$1(System.Object)));
                    try {
                        while ($t8.moveNext()) {
                            var constraintMap3 = Bridge.cast($t8.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                            var data5 = new Spine.PhysicsConstraintData(Bridge.cast(constraintMap3.getItem("name"), System.String));
                            data5.order = Spine.SkeletonJson.GetInt$1(constraintMap3, "order", 0);
                            data5.skinRequired = Spine.SkeletonJson.GetBoolean(constraintMap3, "skin", false);

                            var boneName4 = Bridge.cast(constraintMap3.getItem("bone"), System.String);
                            data5.bone = skeletonData.FindBone(boneName4);
                            if (data5.bone == null) {
                                throw new System.Exception("Physics bone not found: " + (boneName4 || ""));
                            }

                            data5.x = Spine.SkeletonJson.GetFloat(constraintMap3, "x", 0);
                            data5.y = Spine.SkeletonJson.GetFloat(constraintMap3, "y", 0);
                            data5.rotate = Spine.SkeletonJson.GetFloat(constraintMap3, "rotate", 0);
                            data5.scaleX = Spine.SkeletonJson.GetFloat(constraintMap3, "scaleX", 0);
                            data5.shearX = Spine.SkeletonJson.GetFloat(constraintMap3, "shearX", 0);
                            data5.limit = Spine.SkeletonJson.GetFloat(constraintMap3, "limit", 5000) * scale;
                            data5.step = 1.0 / Spine.SkeletonJson.GetInt$1(constraintMap3, "fps", 60);
                            data5.inertia = Spine.SkeletonJson.GetFloat(constraintMap3, "inertia", 1);
                            data5.strength = Spine.SkeletonJson.GetFloat(constraintMap3, "strength", 100);
                            data5.damping = Spine.SkeletonJson.GetFloat(constraintMap3, "damping", 1);
                            data5.massInverse = 1.0 / Spine.SkeletonJson.GetFloat(constraintMap3, "mass", 1);
                            data5.wind = Spine.SkeletonJson.GetFloat(constraintMap3, "wind", 0);
                            data5.gravity = Spine.SkeletonJson.GetFloat(constraintMap3, "gravity", 0);
                            data5.mix = Spine.SkeletonJson.GetFloat(constraintMap3, "mix", 1);
                            data5.inertiaGlobal = Spine.SkeletonJson.GetBoolean(constraintMap3, "inertiaGlobal", false);
                            data5.strengthGlobal = Spine.SkeletonJson.GetBoolean(constraintMap3, "strengthGlobal", false);
                            data5.dampingGlobal = Spine.SkeletonJson.GetBoolean(constraintMap3, "dampingGlobal", false);
                            data5.massGlobal = Spine.SkeletonJson.GetBoolean(constraintMap3, "massGlobal", false);
                            data5.windGlobal = Spine.SkeletonJson.GetBoolean(constraintMap3, "windGlobal", false);
                            data5.gravityGlobal = Spine.SkeletonJson.GetBoolean(constraintMap3, "gravityGlobal", false);
                            data5.mixGlobal = Spine.SkeletonJson.GetBoolean(constraintMap3, "mixGlobal", false);

                            skeletonData.physicsConstraints.Add(data5);
                        }
                    } finally {
                        if (Bridge.is($t8, System.IDisposable)) {
                            $t8.System$IDisposable$Dispose();
                        }
                    }
                }

                // Skins.
                if (root.containsKey("skins")) {
                    $t9 = Bridge.getEnumerator(Bridge.cast(root.getItem("skins"), System.Collections.Generic.List$1(System.Object)));
                    try {
                        while ($t9.moveNext()) {
                            var skinMap = Bridge.cast($t9.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                            var skin = new Spine.Skin(Bridge.cast(skinMap.getItem("name"), System.String));
                            if (skinMap.containsKey("bones")) {
                                $t10 = Bridge.getEnumerator(Bridge.cast(skinMap.getItem("bones"), System.Collections.Generic.List$1(System.Object)));
                                try {
                                    while ($t10.moveNext()) {
                                        var entryName = Bridge.cast($t10.Current, System.String);
                                        var bone3 = skeletonData.FindBone(entryName);
                                        if (bone3 == null) {
                                            throw new System.Exception("Skin bone not found: " + (entryName || ""));
                                        }
                                        skin.bones.Add(bone3);
                                    }
                                } finally {
                                    if (Bridge.is($t10, System.IDisposable)) {
                                        $t10.System$IDisposable$Dispose();
                                    }
                                }
                            }
                            skin.bones.TrimExcess();
                            if (skinMap.containsKey("ik")) {
                                $t11 = Bridge.getEnumerator(Bridge.cast(skinMap.getItem("ik"), System.Collections.Generic.List$1(System.Object)));
                                try {
                                    while ($t11.moveNext()) {
                                        var entryName1 = Bridge.cast($t11.Current, System.String);
                                        var constraint = skeletonData.FindIkConstraint(entryName1);
                                        if (constraint == null) {
                                            throw new System.Exception("Skin IK constraint not found: " + (entryName1 || ""));
                                        }
                                        skin.constraints.Add(constraint);
                                    }
                                } finally {
                                    if (Bridge.is($t11, System.IDisposable)) {
                                        $t11.System$IDisposable$Dispose();
                                    }
                                }
                            }
                            if (skinMap.containsKey("transform")) {
                                $t12 = Bridge.getEnumerator(Bridge.cast(skinMap.getItem("transform"), System.Collections.Generic.List$1(System.Object)));
                                try {
                                    while ($t12.moveNext()) {
                                        var entryName2 = Bridge.cast($t12.Current, System.String);
                                        var constraint1 = skeletonData.FindTransformConstraint(entryName2);
                                        if (constraint1 == null) {
                                            throw new System.Exception("Skin transform constraint not found: " + (entryName2 || ""));
                                        }
                                        skin.constraints.Add(constraint1);
                                    }
                                } finally {
                                    if (Bridge.is($t12, System.IDisposable)) {
                                        $t12.System$IDisposable$Dispose();
                                    }
                                }
                            }
                            if (skinMap.containsKey("path")) {
                                $t13 = Bridge.getEnumerator(Bridge.cast(skinMap.getItem("path"), System.Collections.Generic.List$1(System.Object)));
                                try {
                                    while ($t13.moveNext()) {
                                        var entryName3 = Bridge.cast($t13.Current, System.String);
                                        var constraint2 = skeletonData.FindPathConstraint(entryName3);
                                        if (constraint2 == null) {
                                            throw new System.Exception("Skin path constraint not found: " + (entryName3 || ""));
                                        }
                                        skin.constraints.Add(constraint2);
                                    }
                                } finally {
                                    if (Bridge.is($t13, System.IDisposable)) {
                                        $t13.System$IDisposable$Dispose();
                                    }
                                }
                            }
                            if (skinMap.containsKey("physics")) {
                                $t14 = Bridge.getEnumerator(Bridge.cast(skinMap.getItem("physics"), System.Collections.Generic.List$1(System.Object)));
                                try {
                                    while ($t14.moveNext()) {
                                        var entryName4 = Bridge.cast($t14.Current, System.String);
                                        var constraint3 = skeletonData.FindPhysicsConstraint(entryName4);
                                        if (constraint3 == null) {
                                            throw new System.Exception("Skin physics constraint not found: " + (entryName4 || ""));
                                        }
                                        skin.constraints.Add(constraint3);
                                    }
                                } finally {
                                    if (Bridge.is($t14, System.IDisposable)) {
                                        $t14.System$IDisposable$Dispose();
                                    }
                                }
                            }
                            skin.constraints.TrimExcess();
                            if (skinMap.containsKey("attachments")) {
                                $t15 = Bridge.getEnumerator(Bridge.cast(skinMap.getItem("attachments"), System.Collections.Generic.Dictionary$2(System.String,System.Object)));
                                try {
                                    while ($t15.moveNext()) {
                                        var slotEntry = $t15.Current;
                                        var slotIndex = this.FindSlotIndex(skeletonData, slotEntry.key);
                                        $t16 = Bridge.getEnumerator(Bridge.cast(slotEntry.value, System.Collections.Generic.Dictionary$2(System.String,System.Object)));
                                        try {
                                            while ($t16.moveNext()) {
                                                var entry = $t16.Current;
                                                try {
                                                    var attachment = this.ReadAttachment(Bridge.cast(entry.value, System.Collections.Generic.Dictionary$2(System.String,System.Object)), skin, slotIndex, entry.key, skeletonData);
                                                    if (attachment != null) {
                                                        skin.SetAttachment(slotIndex, entry.key, attachment);
                                                    }
                                                } catch (e) {
                                                    e = System.Exception.create(e);
                                                    throw new System.Exception(System.String.concat("Error reading attachment: " + (entry.key || "") + ", skin: ", skin), e);
                                                }
                                            }
                                        } finally {
                                            if (Bridge.is($t16, System.IDisposable)) {
                                                $t16.System$IDisposable$Dispose();
                                            }
                                        }
                                    }
                                } finally {
                                    if (Bridge.is($t15, System.IDisposable)) {
                                        $t15.System$IDisposable$Dispose();
                                    }
                                }
                            }
                            skeletonData.skins.Add(skin);
                            if (Bridge.referenceEquals(skin.name, "default")) {
                                skeletonData.defaultSkin = skin;
                            }
                        }
                    } finally {
                        if (Bridge.is($t9, System.IDisposable)) {
                            $t9.System$IDisposable$Dispose();
                        }
                    }
                }

                // Linked meshes.
                for (var i = 0, n = this.linkedMeshes.Count; i < n; i = (i + 1) | 0) {
                    var linkedMesh = this.linkedMeshes.getItem(i);
                    var skin1 = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.FindSkin(linkedMesh.skin);
                    if (skin1 == null) {
                        throw new System.Exception("Slot not found: " + (linkedMesh.skin || ""));
                    }
                    var parent1 = skin1.GetAttachment(linkedMesh.slotIndex, linkedMesh.parent);
                    if (parent1 == null) {
                        throw new System.Exception("Parent mesh not found: " + (linkedMesh.parent || ""));
                    }
                    linkedMesh.mesh.TimelineAttachment = linkedMesh.inheritTimelines ? Bridge.cast(parent1, Spine.VertexAttachment) : linkedMesh.mesh;
                    linkedMesh.mesh.ParentMesh = Bridge.cast(parent1, Spine.MeshAttachment);
                    if (linkedMesh.mesh.Region != null) {
                        linkedMesh.mesh.UpdateRegion();
                    }
                }
                this.linkedMeshes.clear();

                // Events.
                if (root.containsKey("events")) {
                    $t17 = Bridge.getEnumerator(Bridge.cast(root.getItem("events"), System.Collections.Generic.Dictionary$2(System.String,System.Object)));
                    try {
                        while ($t17.moveNext()) {
                            var entry1 = $t17.Current;
                            var entryMap = Bridge.cast(entry1.value, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                            var data6 = new Spine.EventData(entry1.key);
                            data6.Int = Spine.SkeletonJson.GetInt$1(entryMap, "int", 0);
                            data6.Float = Spine.SkeletonJson.GetFloat(entryMap, "float", 0);
                            data6.String = Spine.SkeletonJson.GetString(entryMap, "string", "");
                            data6.AudioPath = Spine.SkeletonJson.GetString(entryMap, "audio", null);
                            if (data6.AudioPath != null) {
                                data6.Volume = Spine.SkeletonJson.GetFloat(entryMap, "volume", 1);
                                data6.Balance = Spine.SkeletonJson.GetFloat(entryMap, "balance", 0);
                            }
                            skeletonData.events.Add(data6);
                        }
                    } finally {
                        if (Bridge.is($t17, System.IDisposable)) {
                            $t17.System$IDisposable$Dispose();
                        }
                    }
                }

                // Animations.
                if (root.containsKey("animations")) {
                    $t18 = Bridge.getEnumerator(Bridge.cast(root.getItem("animations"), System.Collections.Generic.Dictionary$2(System.String,System.Object)));
                    try {
                        while ($t18.moveNext()) {
                            var entry2 = $t18.Current;
                            try {
                                this.ReadAnimation(Bridge.cast(entry2.value, System.Collections.Generic.Dictionary$2(System.String,System.Object)), entry2.key, skeletonData);
                            } catch (e1) {
                                e1 = System.Exception.create(e1);
                                throw new System.Exception("Error reading animation: " + (entry2.key || "") + "\n" + (e1.Message || ""), e1);
                            }
                        }
                    } finally {
                        if (Bridge.is($t18, System.IDisposable)) {
                            $t18.System$IDisposable$Dispose();
                        }
                    }
                }

                skeletonData.bones.TrimExcess();
                skeletonData.slots.TrimExcess();
                skeletonData.skins.TrimExcess();
                skeletonData.events.TrimExcess();
                skeletonData.animations.TrimExcess();
                skeletonData.ikConstraints.TrimExcess();
                return skeletonData;
            },
            /*Spine.SkeletonJson.ReadSkeletonData$1 end.*/

            /*Spine.SkeletonJson.ReadAttachment start.*/
            ReadAttachment: function (map, skin, slotIndex, name, skeletonData) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#ReadAttachment", this ); }

                var scale = this.scale;
                name = Spine.SkeletonJson.GetString(map, "name", name);

                var typeName = Spine.SkeletonJson.GetString(map, "type", "region");
                var type = System.Nullable.getValue(Bridge.cast(Bridge.unbox(System.Enum.parse(Spine.AttachmentType, typeName, true), Spine.AttachmentType), System.Int32));

                switch (type) {
                    case Spine.AttachmentType.Region: 
                        {
                            var path = Spine.SkeletonJson.GetString(map, "path", name);
                            var sequenceJson = { };
                            map.tryGetValue("sequence", sequenceJson);
                            var sequence = Spine.SkeletonJson.ReadSequence(sequenceJson.v);
                            var region = this.attachmentLoader.Spine$AttachmentLoader$NewRegionAttachment(skin, name, path, sequence);
                            if (region == null) {
                                return null;
                            }
                            region.Path = path;
                            region.x = Spine.SkeletonJson.GetFloat(map, "x", 0) * scale;
                            region.y = Spine.SkeletonJson.GetFloat(map, "y", 0) * scale;
                            region.scaleX = Spine.SkeletonJson.GetFloat(map, "scaleX", 1);
                            region.scaleY = Spine.SkeletonJson.GetFloat(map, "scaleY", 1);
                            region.rotation = Spine.SkeletonJson.GetFloat(map, "rotation", 0);
                            region.width = Spine.SkeletonJson.GetFloat(map, "width", 32) * scale;
                            region.height = Spine.SkeletonJson.GetFloat(map, "height", 32) * scale;
                            region.sequence = sequence;

                            if (map.containsKey("color")) {
                                var color = Bridge.cast(map.getItem("color"), System.String);
                                region.r = Spine.SkeletonJson.ToColor(color, 0);
                                region.g = Spine.SkeletonJson.ToColor(color, 1);
                                region.b = Spine.SkeletonJson.ToColor(color, 2);
                                region.a = Spine.SkeletonJson.ToColor(color, 3);
                            }

                            if (region.Region != null) {
                                region.UpdateRegion();
                            }
                            return region;
                        }
                    case Spine.AttachmentType.Boundingbox: 
                        var box = this.attachmentLoader.Spine$AttachmentLoader$NewBoundingBoxAttachment(skin, name);
                        if (box == null) {
                            return null;
                        }
                        this.ReadVertices(map, box, Spine.SkeletonJson.GetInt$1(map, "vertexCount", 0) << 1);
                        return box;
                    case Spine.AttachmentType.Mesh: 
                    case Spine.AttachmentType.Linkedmesh: 
                        {
                            var path1 = Spine.SkeletonJson.GetString(map, "path", name);
                            var sequenceJson1 = { };
                            map.tryGetValue("sequence", sequenceJson1);
                            var sequence1 = Spine.SkeletonJson.ReadSequence(sequenceJson1.v);
                            var mesh = this.attachmentLoader.Spine$AttachmentLoader$NewMeshAttachment(skin, name, path1, sequence1);
                            if (mesh == null) {
                                return null;
                            }
                            mesh.Path = path1;

                            if (map.containsKey("color")) {
                                var color1 = Bridge.cast(map.getItem("color"), System.String);
                                mesh.r = Spine.SkeletonJson.ToColor(color1, 0);
                                mesh.g = Spine.SkeletonJson.ToColor(color1, 1);
                                mesh.b = Spine.SkeletonJson.ToColor(color1, 2);
                                mesh.a = Spine.SkeletonJson.ToColor(color1, 3);
                            }

                            mesh.Width = Spine.SkeletonJson.GetFloat(map, "width", 0) * scale;
                            mesh.Height = Spine.SkeletonJson.GetFloat(map, "height", 0) * scale;
                            mesh.Sequence = sequence1;

                            var parent = Spine.SkeletonJson.GetString(map, "parent", null);
                            if (parent != null) {
                                this.linkedMeshes.add(new Spine.SkeletonJson.LinkedMesh(mesh, Spine.SkeletonJson.GetString(map, "skin", null), slotIndex, parent, Spine.SkeletonJson.GetBoolean(map, "timelines", true)));
                                return mesh;
                            }

                            var uvs = Spine.SkeletonJson.GetFloatArray(map, "uvs", 1);
                            this.ReadVertices(map, mesh, uvs.length);
                            mesh.triangles = Spine.SkeletonJson.GetIntArray(map, "triangles");
                            mesh.regionUVs = uvs;
                            if (mesh.Region != null) {
                                mesh.UpdateRegion();
                            }

                            if (map.containsKey("hull")) {
                                mesh.HullLength = Spine.SkeletonJson.GetInt$1(map, "hull", 0) << 1;
                            }
                            if (map.containsKey("edges")) {
                                mesh.Edges = Spine.SkeletonJson.GetIntArray(map, "edges");
                            }
                            return mesh;
                        }
                    case Spine.AttachmentType.Path: 
                        {
                            var pathAttachment = this.attachmentLoader.Spine$AttachmentLoader$NewPathAttachment(skin, name);
                            if (pathAttachment == null) {
                                return null;
                            }
                            pathAttachment.closed = Spine.SkeletonJson.GetBoolean(map, "closed", false);
                            pathAttachment.constantSpeed = Spine.SkeletonJson.GetBoolean(map, "constantSpeed", true);

                            var vertexCount = Spine.SkeletonJson.GetInt$1(map, "vertexCount", 0);
                            this.ReadVertices(map, pathAttachment, vertexCount << 1);

                            // potential BOZO see Java impl
                            pathAttachment.lengths = Spine.SkeletonJson.GetFloatArray(map, "lengths", scale);
                            return pathAttachment;
                        }
                    case Spine.AttachmentType.Point: 
                        {
                            var point = this.attachmentLoader.Spine$AttachmentLoader$NewPointAttachment(skin, name);
                            if (point == null) {
                                return null;
                            }
                            point.x = Spine.SkeletonJson.GetFloat(map, "x", 0) * scale;
                            point.y = Spine.SkeletonJson.GetFloat(map, "y", 0) * scale;
                            point.rotation = Spine.SkeletonJson.GetFloat(map, "rotation", 0);

                            //string color = GetString(map, "color", null);
                            //if (color != null) point.color = color;
                            return point;
                        }
                    case Spine.AttachmentType.Clipping: 
                        {
                            var clip = this.attachmentLoader.Spine$AttachmentLoader$NewClippingAttachment(skin, name);
                            if (clip == null) {
                                return null;
                            }

                            var end = Spine.SkeletonJson.GetString(map, "end", null);
                            if (end != null) {
                                var slot = skeletonData.FindSlot(end);
                                if (slot == null) {
                                    throw new System.Exception("Clipping end slot not found: " + (end || ""));
                                }
                                clip.EndSlot = slot;
                            }

                            this.ReadVertices(map, clip, Spine.SkeletonJson.GetInt$1(map, "vertexCount", 0) << 1);

                            //string color = GetString(map, "color", null);
                            // if (color != null) clip.color = color;
                            return clip;
                        }
                }
                return null;
            },
            /*Spine.SkeletonJson.ReadAttachment end.*/

            /*Spine.SkeletonJson.ReadVertices start.*/
            ReadVertices: function (map, attachment, verticesLength) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#ReadVertices", this ); }

                attachment.WorldVerticesLength = verticesLength;
                var vertices = Spine.SkeletonJson.GetFloatArray(map, "vertices", 1);
                var scale = this.Scale;
                if (verticesLength === vertices.length) {
                    if (scale !== 1) {
                        for (var i = 0; i < vertices.length; i = (i + 1) | 0) {
                            vertices[i] *= scale;
                        }
                    }
                    attachment.vertices = vertices;
                    return;
                }
                var weights = new (Spine.ExposedList$1(System.Single)).$ctor3(Bridge.Int.mul(Bridge.Int.mul(verticesLength, 3), 3));
                var bones = new (Spine.ExposedList$1(System.Int32)).$ctor3(Bridge.Int.mul(verticesLength, 3));
                for (var i1 = 0, n = vertices.length; i1 < n; ) {
                    var boneCount = Bridge.Int.clip32(vertices[Bridge.identity(i1, ((i1 = (i1 + 1) | 0)))]);
                    bones.Add(boneCount);
                    for (var nn = (i1 + (boneCount << 2)) | 0; i1 < nn; i1 = (i1 + 4) | 0) {
                        bones.Add(Bridge.Int.clip32(vertices[i1]));
                        weights.Add(vertices[((i1 + 1) | 0)] * this.Scale);
                        weights.Add(vertices[((i1 + 2) | 0)] * this.Scale);
                        weights.Add(vertices[((i1 + 3) | 0)]);
                    }
                }
                attachment.bones = bones.ToArray();
                attachment.vertices = weights.ToArray();
            },
            /*Spine.SkeletonJson.ReadVertices end.*/

            /*Spine.SkeletonJson.FindSlotIndex start.*/
            FindSlotIndex: function (skeletonData, slotName) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#FindSlotIndex", this ); }

                var slots = skeletonData.slots.Items;
                for (var i = 0, n = skeletonData.slots.Count; i < n; i = (i + 1) | 0) {
                    if (Bridge.referenceEquals(slots[i].name, slotName)) {
                        return i;
                    }
                }
                throw new System.Exception("Slot not found: " + (slotName || ""));
            },
            /*Spine.SkeletonJson.FindSlotIndex end.*/

            /*Spine.SkeletonJson.ReadAnimation start.*/
            ReadAnimation: function (map, name, skeletonData) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#ReadAnimation", this ); }

                var $t, $t1, $t2, $t3, $t4, $t5, $t6, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14, $t15, $t16, $t17, $t18, $t19;
                var scale = this.scale;
                var timelines = new (Spine.ExposedList$1(Spine.Timeline)).ctor();

                // Slot timelines.
                if (map.containsKey("slots")) {
                    $t = Bridge.getEnumerator(Bridge.cast(map.getItem("slots"), System.Collections.Generic.Dictionary$2(System.String,System.Object)));
                    try {
                        while ($t.moveNext()) {
                            var entry = $t.Current;
                            var slotName = entry.key;
                            var slotIndex = this.FindSlotIndex(skeletonData, slotName);
                            var timelineMap = Bridge.cast(entry.value, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                            $t1 = Bridge.getEnumerator(timelineMap);
                            try {
                                while ($t1.moveNext()) {
                                    var timelineEntry = $t1.Current;
                                    var values = Bridge.cast(timelineEntry.value, System.Collections.Generic.List$1(System.Object));
                                    var frames = values.Count;
                                    if (frames === 0) {
                                        continue;
                                    }
                                    var timelineName = timelineEntry.key;
                                    if (Bridge.referenceEquals(timelineName, "attachment")) {
                                        var timeline = new Spine.AttachmentTimeline(frames, slotIndex);
                                        var frame = 0;
                                        $t2 = Bridge.getEnumerator(values);
                                        try {
                                            while ($t2.moveNext()) {
                                                var keyMap = Bridge.cast($t2.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                                                timeline.SetFrame(Bridge.identity(frame, ((frame = (frame + 1) | 0))), Spine.SkeletonJson.GetFloat(keyMap, "time", 0), Spine.SkeletonJson.GetString(keyMap, "name", null));
                                            }
                                        } finally {
                                            if (Bridge.is($t2, System.IDisposable)) {
                                                $t2.System$IDisposable$Dispose();
                                            }
                                        }
                                        timelines.Add(timeline);

                                    } else if (Bridge.referenceEquals(timelineName, "rgba")) {
                                        var timeline1 = new Spine.RGBATimeline(frames, frames << 2, slotIndex);

                                        var keyMapEnumerator = values.GetEnumerator();
                                        keyMapEnumerator.moveNext();
                                        var keyMap1 = Bridge.cast(keyMapEnumerator.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                                        var time = Spine.SkeletonJson.GetFloat(keyMap1, "time", 0);
                                        var color = Bridge.cast(keyMap1.getItem("color"), System.String);
                                        var r = Spine.SkeletonJson.ToColor(color, 0);
                                        var g = Spine.SkeletonJson.ToColor(color, 1);
                                        var b = Spine.SkeletonJson.ToColor(color, 2);
                                        var a = Spine.SkeletonJson.ToColor(color, 3);
                                        for (var frame1 = 0, bezier = 0; ; frame1 = (frame1 + 1) | 0) {
                                            timeline1.SetFrame(frame1, time, r, g, b, a);
                                            if (!keyMapEnumerator.moveNext()) {
                                                timeline1.Shrink(bezier);
                                                break;
                                            }
                                            var nextMap = Bridge.cast(keyMapEnumerator.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));

                                            var time2 = Spine.SkeletonJson.GetFloat(nextMap, "time", 0);
                                            color = Bridge.cast(nextMap.getItem("color"), System.String);
                                            var nr = Spine.SkeletonJson.ToColor(color, 0);
                                            var ng = Spine.SkeletonJson.ToColor(color, 1);
                                            var nb = Spine.SkeletonJson.ToColor(color, 2);
                                            var na = Spine.SkeletonJson.ToColor(color, 3);

                                            if (keyMap1.containsKey("curve")) {
                                                var curve = keyMap1.getItem("curve");
                                                bezier = Spine.SkeletonJson.ReadCurve(curve, timeline1, bezier, frame1, 0, time, time2, r, nr, 1);
                                                bezier = Spine.SkeletonJson.ReadCurve(curve, timeline1, bezier, frame1, 1, time, time2, g, ng, 1);
                                                bezier = Spine.SkeletonJson.ReadCurve(curve, timeline1, bezier, frame1, 2, time, time2, b, nb, 1);
                                                bezier = Spine.SkeletonJson.ReadCurve(curve, timeline1, bezier, frame1, 3, time, time2, a, na, 1);
                                            }
                                            time = time2;
                                            r = nr;
                                            g = ng;
                                            b = nb;
                                            a = na;
                                            keyMap1 = nextMap;
                                        }
                                        timelines.Add(timeline1);

                                    } else if (Bridge.referenceEquals(timelineName, "rgb")) {
                                        var timeline2 = new Spine.RGBTimeline(frames, Bridge.Int.mul(frames, 3), slotIndex);

                                        var keyMapEnumerator1 = values.GetEnumerator();
                                        keyMapEnumerator1.moveNext();
                                        var keyMap2 = Bridge.cast(keyMapEnumerator1.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                                        var time1 = Spine.SkeletonJson.GetFloat(keyMap2, "time", 0);
                                        var color1 = Bridge.cast(keyMap2.getItem("color"), System.String);
                                        var r1 = Spine.SkeletonJson.ToColor(color1, 0, 6);
                                        var g1 = Spine.SkeletonJson.ToColor(color1, 1, 6);
                                        var b1 = Spine.SkeletonJson.ToColor(color1, 2, 6);
                                        for (var frame2 = 0, bezier1 = 0; ; frame2 = (frame2 + 1) | 0) {
                                            timeline2.SetFrame(frame2, time1, r1, g1, b1);
                                            if (!keyMapEnumerator1.moveNext()) {
                                                timeline2.Shrink(bezier1);
                                                break;
                                            }
                                            var nextMap1 = Bridge.cast(keyMapEnumerator1.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));

                                            var time21 = Spine.SkeletonJson.GetFloat(nextMap1, "time", 0);
                                            color1 = Bridge.cast(nextMap1.getItem("color"), System.String);
                                            var nr1 = Spine.SkeletonJson.ToColor(color1, 0, 6);
                                            var ng1 = Spine.SkeletonJson.ToColor(color1, 1, 6);
                                            var nb1 = Spine.SkeletonJson.ToColor(color1, 2, 6);

                                            if (keyMap2.containsKey("curve")) {
                                                var curve1 = keyMap2.getItem("curve");
                                                bezier1 = Spine.SkeletonJson.ReadCurve(curve1, timeline2, bezier1, frame2, 0, time1, time21, r1, nr1, 1);
                                                bezier1 = Spine.SkeletonJson.ReadCurve(curve1, timeline2, bezier1, frame2, 1, time1, time21, g1, ng1, 1);
                                                bezier1 = Spine.SkeletonJson.ReadCurve(curve1, timeline2, bezier1, frame2, 2, time1, time21, b1, nb1, 1);
                                            }
                                            time1 = time21;
                                            r1 = nr1;
                                            g1 = ng1;
                                            b1 = nb1;
                                            keyMap2 = nextMap1;
                                        }
                                        timelines.Add(timeline2);

                                    } else if (Bridge.referenceEquals(timelineName, "alpha")) {
                                        var keyMapEnumerator2 = { v : values.GetEnumerator() };
                                        keyMapEnumerator2.v.moveNext();
                                        timelines.Add(Spine.SkeletonJson.ReadTimeline(keyMapEnumerator2, new Spine.AlphaTimeline(frames, frames, slotIndex), 0, 1));

                                    } else if (Bridge.referenceEquals(timelineName, "rgba2")) {
                                        var timeline3 = new Spine.RGBA2Timeline(frames, Bridge.Int.mul(frames, 7), slotIndex);

                                        var keyMapEnumerator3 = values.GetEnumerator();
                                        keyMapEnumerator3.moveNext();
                                        var keyMap3 = Bridge.cast(keyMapEnumerator3.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                                        var time2 = Spine.SkeletonJson.GetFloat(keyMap3, "time", 0);
                                        var color2 = Bridge.cast(keyMap3.getItem("light"), System.String);
                                        var r2 = Spine.SkeletonJson.ToColor(color2, 0);
                                        var g2 = Spine.SkeletonJson.ToColor(color2, 1);
                                        var b2 = Spine.SkeletonJson.ToColor(color2, 2);
                                        var a1 = Spine.SkeletonJson.ToColor(color2, 3);
                                        color2 = Bridge.cast(keyMap3.getItem("dark"), System.String);
                                        var r21 = Spine.SkeletonJson.ToColor(color2, 0, 6);
                                        var g21 = Spine.SkeletonJson.ToColor(color2, 1, 6);
                                        var b21 = Spine.SkeletonJson.ToColor(color2, 2, 6);
                                        for (var frame3 = 0, bezier2 = 0; ; frame3 = (frame3 + 1) | 0) {
                                            timeline3.SetFrame(frame3, time2, r2, g2, b2, a1, r21, g21, b21);
                                            if (!keyMapEnumerator3.moveNext()) {
                                                timeline3.Shrink(bezier2);
                                                break;
                                            }
                                            var nextMap2 = Bridge.cast(keyMapEnumerator3.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));

                                            var time22 = Spine.SkeletonJson.GetFloat(nextMap2, "time", 0);
                                            color2 = Bridge.cast(nextMap2.getItem("light"), System.String);
                                            var nr2 = Spine.SkeletonJson.ToColor(color2, 0);
                                            var ng2 = Spine.SkeletonJson.ToColor(color2, 1);
                                            var nb2 = Spine.SkeletonJson.ToColor(color2, 2);
                                            var na1 = Spine.SkeletonJson.ToColor(color2, 3);
                                            color2 = Bridge.cast(nextMap2.getItem("dark"), System.String);
                                            var nr21 = Spine.SkeletonJson.ToColor(color2, 0, 6);
                                            var ng21 = Spine.SkeletonJson.ToColor(color2, 1, 6);
                                            var nb21 = Spine.SkeletonJson.ToColor(color2, 2, 6);

                                            if (keyMap3.containsKey("curve")) {
                                                var curve2 = keyMap3.getItem("curve");
                                                bezier2 = Spine.SkeletonJson.ReadCurve(curve2, timeline3, bezier2, frame3, 0, time2, time22, r2, nr2, 1);
                                                bezier2 = Spine.SkeletonJson.ReadCurve(curve2, timeline3, bezier2, frame3, 1, time2, time22, g2, ng2, 1);
                                                bezier2 = Spine.SkeletonJson.ReadCurve(curve2, timeline3, bezier2, frame3, 2, time2, time22, b2, nb2, 1);
                                                bezier2 = Spine.SkeletonJson.ReadCurve(curve2, timeline3, bezier2, frame3, 3, time2, time22, a1, na1, 1);
                                                bezier2 = Spine.SkeletonJson.ReadCurve(curve2, timeline3, bezier2, frame3, 4, time2, time22, r21, nr21, 1);
                                                bezier2 = Spine.SkeletonJson.ReadCurve(curve2, timeline3, bezier2, frame3, 5, time2, time22, g21, ng21, 1);
                                                bezier2 = Spine.SkeletonJson.ReadCurve(curve2, timeline3, bezier2, frame3, 6, time2, time22, b21, nb21, 1);
                                            }
                                            time2 = time22;
                                            r2 = nr2;
                                            g2 = ng2;
                                            b2 = nb2;
                                            a1 = na1;
                                            r21 = nr21;
                                            g21 = ng21;
                                            b21 = nb21;
                                            keyMap3 = nextMap2;
                                        }
                                        timelines.Add(timeline3);

                                    } else if (Bridge.referenceEquals(timelineName, "rgb2")) {
                                        var timeline4 = new Spine.RGB2Timeline(frames, Bridge.Int.mul(frames, 6), slotIndex);

                                        var keyMapEnumerator4 = values.GetEnumerator();
                                        keyMapEnumerator4.moveNext();
                                        var keyMap4 = Bridge.cast(keyMapEnumerator4.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                                        var time3 = Spine.SkeletonJson.GetFloat(keyMap4, "time", 0);
                                        var color3 = Bridge.cast(keyMap4.getItem("light"), System.String);
                                        var r3 = Spine.SkeletonJson.ToColor(color3, 0, 6);
                                        var g3 = Spine.SkeletonJson.ToColor(color3, 1, 6);
                                        var b3 = Spine.SkeletonJson.ToColor(color3, 2, 6);
                                        color3 = Bridge.cast(keyMap4.getItem("dark"), System.String);
                                        var r22 = Spine.SkeletonJson.ToColor(color3, 0, 6);
                                        var g22 = Spine.SkeletonJson.ToColor(color3, 1, 6);
                                        var b22 = Spine.SkeletonJson.ToColor(color3, 2, 6);
                                        for (var frame4 = 0, bezier3 = 0; ; frame4 = (frame4 + 1) | 0) {
                                            timeline4.SetFrame(frame4, time3, r3, g3, b3, r22, g22, b22);
                                            if (!keyMapEnumerator4.moveNext()) {
                                                timeline4.Shrink(bezier3);
                                                break;
                                            }
                                            var nextMap3 = Bridge.cast(keyMapEnumerator4.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));

                                            var time23 = Spine.SkeletonJson.GetFloat(nextMap3, "time", 0);
                                            color3 = Bridge.cast(nextMap3.getItem("light"), System.String);
                                            var nr3 = Spine.SkeletonJson.ToColor(color3, 0, 6);
                                            var ng3 = Spine.SkeletonJson.ToColor(color3, 1, 6);
                                            var nb3 = Spine.SkeletonJson.ToColor(color3, 2, 6);
                                            color3 = Bridge.cast(nextMap3.getItem("dark"), System.String);
                                            var nr22 = Spine.SkeletonJson.ToColor(color3, 0, 6);
                                            var ng22 = Spine.SkeletonJson.ToColor(color3, 1, 6);
                                            var nb22 = Spine.SkeletonJson.ToColor(color3, 2, 6);

                                            if (keyMap4.containsKey("curve")) {
                                                var curve3 = keyMap4.getItem("curve");
                                                bezier3 = Spine.SkeletonJson.ReadCurve(curve3, timeline4, bezier3, frame4, 0, time3, time23, r3, nr3, 1);
                                                bezier3 = Spine.SkeletonJson.ReadCurve(curve3, timeline4, bezier3, frame4, 1, time3, time23, g3, ng3, 1);
                                                bezier3 = Spine.SkeletonJson.ReadCurve(curve3, timeline4, bezier3, frame4, 2, time3, time23, b3, nb3, 1);
                                                bezier3 = Spine.SkeletonJson.ReadCurve(curve3, timeline4, bezier3, frame4, 3, time3, time23, r22, nr22, 1);
                                                bezier3 = Spine.SkeletonJson.ReadCurve(curve3, timeline4, bezier3, frame4, 4, time3, time23, g22, ng22, 1);
                                                bezier3 = Spine.SkeletonJson.ReadCurve(curve3, timeline4, bezier3, frame4, 5, time3, time23, b22, nb22, 1);
                                            }
                                            time3 = time23;
                                            r3 = nr3;
                                            g3 = ng3;
                                            b3 = nb3;
                                            r22 = nr22;
                                            g22 = ng22;
                                            b22 = nb22;
                                            keyMap4 = nextMap3;
                                        }
                                        timelines.Add(timeline4);

                                    } else {
                                        throw new System.Exception("Invalid timeline type for a slot: " + (timelineName || "") + " (" + (slotName || "") + ")");
                                    }
                                }
                            } finally {
                                if (Bridge.is($t1, System.IDisposable)) {
                                    $t1.System$IDisposable$Dispose();
                                }
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }

                // Bone timelines.
                if (map.containsKey("bones")) {
                    $t3 = Bridge.getEnumerator(Bridge.cast(map.getItem("bones"), System.Collections.Generic.Dictionary$2(System.String,System.Object)));
                    try {
                        while ($t3.moveNext()) {
                            var entry1 = $t3.Current;
                            var boneName = entry1.key;
                            var boneIndex = -1;
                            var bones = skeletonData.bones.Items;
                            for (var i = 0, n = skeletonData.bones.Count; i < n; i = (i + 1) | 0) {
                                if (Bridge.referenceEquals(bones[i].name, boneName)) {
                                    boneIndex = i;
                                    break;
                                }
                            }
                            if (boneIndex === -1) {
                                throw new System.Exception("Bone not found: " + (boneName || ""));
                            }
                            var timelineMap1 = Bridge.cast(entry1.value, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                            $t4 = Bridge.getEnumerator(timelineMap1);
                            try {
                                while ($t4.moveNext()) {
                                    var timelineEntry1 = $t4.Current;
                                    var values1 = Bridge.cast(timelineEntry1.value, System.Collections.Generic.List$1(System.Object));
                                    var keyMapEnumerator5 = { v : values1.GetEnumerator() };
                                    if (!keyMapEnumerator5.v.moveNext()) {
                                        continue;
                                    }
                                    var frames1 = values1.Count;
                                    var timelineName1 = timelineEntry1.key;
                                    if (Bridge.referenceEquals(timelineName1, "rotate")) {
                                        timelines.Add(Spine.SkeletonJson.ReadTimeline(keyMapEnumerator5, new Spine.RotateTimeline(frames1, frames1, boneIndex), 0, 1));
                                    } else {
                                        if (Bridge.referenceEquals(timelineName1, "translate")) {
                                            var timeline5 = new Spine.TranslateTimeline(frames1, frames1 << 1, boneIndex);
                                            timelines.Add(Spine.SkeletonJson.ReadTimeline$1(keyMapEnumerator5, timeline5, "x", "y", 0, scale));
                                        } else if (Bridge.referenceEquals(timelineName1, "translatex")) {
                                            timelines.Add(Spine.SkeletonJson.ReadTimeline(keyMapEnumerator5, new Spine.TranslateXTimeline(frames1, frames1, boneIndex), 0, scale));
                                        } else if (Bridge.referenceEquals(timelineName1, "translatey")) {
                                            timelines.Add(Spine.SkeletonJson.ReadTimeline(keyMapEnumerator5, new Spine.TranslateYTimeline(frames1, frames1, boneIndex), 0, scale));
                                        } else if (Bridge.referenceEquals(timelineName1, "scale")) {
                                            var timeline6 = new Spine.ScaleTimeline(frames1, frames1 << 1, boneIndex);
                                            timelines.Add(Spine.SkeletonJson.ReadTimeline$1(keyMapEnumerator5, timeline6, "x", "y", 1, 1));
                                        } else if (Bridge.referenceEquals(timelineName1, "scalex")) {
                                            timelines.Add(Spine.SkeletonJson.ReadTimeline(keyMapEnumerator5, new Spine.ScaleXTimeline(frames1, frames1, boneIndex), 1, 1));
                                        } else {
                                            if (Bridge.referenceEquals(timelineName1, "scaley")) {
                                                timelines.Add(Spine.SkeletonJson.ReadTimeline(keyMapEnumerator5, new Spine.ScaleYTimeline(frames1, frames1, boneIndex), 1, 1));
                                            } else {
                                                if (Bridge.referenceEquals(timelineName1, "shear")) {
                                                    var timeline7 = new Spine.ShearTimeline(frames1, frames1 << 1, boneIndex);
                                                    timelines.Add(Spine.SkeletonJson.ReadTimeline$1(keyMapEnumerator5, timeline7, "x", "y", 0, 1));
                                                } else if (Bridge.referenceEquals(timelineName1, "shearx")) {
                                                    timelines.Add(Spine.SkeletonJson.ReadTimeline(keyMapEnumerator5, new Spine.ShearXTimeline(frames1, frames1, boneIndex), 0, 1));
                                                } else {
                                                    if (Bridge.referenceEquals(timelineName1, "sheary")) {
                                                        timelines.Add(Spine.SkeletonJson.ReadTimeline(keyMapEnumerator5, new Spine.ShearYTimeline(frames1, frames1, boneIndex), 0, 1));
                                                    } else {
                                                        if (Bridge.referenceEquals(timelineName1, "inherit")) {
                                                            var timeline8 = new Spine.InheritTimeline(frames1, boneIndex);
                                                            for (var frame5 = 0; ; frame5 = (frame5 + 1) | 0) {
                                                                var keyMap5 = Bridge.cast(keyMapEnumerator5.v.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                                                                var time4 = Spine.SkeletonJson.GetFloat(keyMap5, "time", 0);
                                                                var inherit = System.Nullable.getValue(Bridge.cast(Bridge.unbox(System.Enum.parse(Spine.Inherit, Spine.SkeletonJson.GetString(keyMap5, "inherit", System.Enum.toString(Spine.Inherit, Spine.Inherit.Normal)), true), Spine.Inherit), System.Int32));
                                                                timeline8.SetFrame(frame5, time4, inherit);
                                                                if (!keyMapEnumerator5.v.moveNext()) {
                                                                    break;
                                                                }
                                                            }
                                                            timelines.Add(timeline8);
                                                        } else {
                                                            throw new System.Exception("Invalid timeline type for a bone: " + (timelineName1 || "") + " (" + (boneName || "") + ")");
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } finally {
                                if (Bridge.is($t4, System.IDisposable)) {
                                    $t4.System$IDisposable$Dispose();
                                }
                            }
                        }
                    } finally {
                        if (Bridge.is($t3, System.IDisposable)) {
                            $t3.System$IDisposable$Dispose();
                        }
                    }
                }

                // IK constraint timelines.
                if (map.containsKey("ik")) {
                    $t5 = Bridge.getEnumerator(Bridge.cast(map.getItem("ik"), System.Collections.Generic.Dictionary$2(System.String,System.Object)));
                    try {
                        while ($t5.moveNext()) {
                            var timelineMap2 = $t5.Current;
                            var values2 = Bridge.cast(timelineMap2.value, System.Collections.Generic.List$1(System.Object));
                            var keyMapEnumerator6 = values2.GetEnumerator();
                            if (!keyMapEnumerator6.moveNext()) {
                                continue;
                            }
                            var keyMap6 = Bridge.cast(keyMapEnumerator6.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                            var constraint = skeletonData.FindIkConstraint(timelineMap2.key);
                            var timeline9 = new Spine.IkConstraintTimeline(values2.Count, values2.Count << 1, skeletonData.IkConstraints.IndexOf(constraint));
                            var time5 = Spine.SkeletonJson.GetFloat(keyMap6, "time", 0);
                            var mix = Spine.SkeletonJson.GetFloat(keyMap6, "mix", 1), softness = Spine.SkeletonJson.GetFloat(keyMap6, "softness", 0) * scale;
                            for (var frame6 = 0, bezier4 = 0; ; frame6 = (frame6 + 1) | 0) {
                                timeline9.SetFrame(frame6, time5, mix, softness, Spine.SkeletonJson.GetBoolean(keyMap6, "bendPositive", true) ? 1 : -1, Spine.SkeletonJson.GetBoolean(keyMap6, "compress", false), Spine.SkeletonJson.GetBoolean(keyMap6, "stretch", false));
                                if (!keyMapEnumerator6.moveNext()) {
                                    timeline9.Shrink(bezier4);
                                    break;
                                }
                                var nextMap4 = Bridge.cast(keyMapEnumerator6.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                                var time24 = Spine.SkeletonJson.GetFloat(nextMap4, "time", 0);
                                var mix2 = Spine.SkeletonJson.GetFloat(nextMap4, "mix", 1), softness2 = Spine.SkeletonJson.GetFloat(nextMap4, "softness", 0) * scale;
                                if (keyMap6.containsKey("curve")) {
                                    var curve4 = keyMap6.getItem("curve");
                                    bezier4 = Spine.SkeletonJson.ReadCurve(curve4, timeline9, bezier4, frame6, 0, time5, time24, mix, mix2, 1);
                                    bezier4 = Spine.SkeletonJson.ReadCurve(curve4, timeline9, bezier4, frame6, 1, time5, time24, softness, softness2, scale);
                                }
                                time5 = time24;
                                mix = mix2;
                                softness = softness2;
                                keyMap6 = nextMap4;
                            }
                            timelines.Add(timeline9);
                        }
                    } finally {
                        if (Bridge.is($t5, System.IDisposable)) {
                            $t5.System$IDisposable$Dispose();
                        }
                    }
                }

                // Transform constraint timelines.
                if (map.containsKey("transform")) {
                    $t6 = Bridge.getEnumerator(Bridge.cast(map.getItem("transform"), System.Collections.Generic.Dictionary$2(System.String,System.Object)));
                    try {
                        while ($t6.moveNext()) {
                            var timelineMap3 = $t6.Current;
                            var values3 = Bridge.cast(timelineMap3.value, System.Collections.Generic.List$1(System.Object));
                            var keyMapEnumerator7 = values3.GetEnumerator();
                            if (!keyMapEnumerator7.moveNext()) {
                                continue;
                            }
                            var keyMap7 = Bridge.cast(keyMapEnumerator7.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                            var constraint1 = skeletonData.FindTransformConstraint(timelineMap3.key);
                            var timeline10 = new Spine.TransformConstraintTimeline(values3.Count, Bridge.Int.mul(values3.Count, 6), skeletonData.TransformConstraints.IndexOf(constraint1));
                            var time6 = Spine.SkeletonJson.GetFloat(keyMap7, "time", 0);
                            var mixRotate = Spine.SkeletonJson.GetFloat(keyMap7, "mixRotate", 1), mixShearY = Spine.SkeletonJson.GetFloat(keyMap7, "mixShearY", 1);
                            var mixX = Spine.SkeletonJson.GetFloat(keyMap7, "mixX", 1), mixY = Spine.SkeletonJson.GetFloat(keyMap7, "mixY", mixX);
                            var mixScaleX = Spine.SkeletonJson.GetFloat(keyMap7, "mixScaleX", 1), mixScaleY = Spine.SkeletonJson.GetFloat(keyMap7, "mixScaleY", mixScaleX);
                            for (var frame7 = 0, bezier5 = 0; ; frame7 = (frame7 + 1) | 0) {
                                timeline10.SetFrame(frame7, time6, mixRotate, mixX, mixY, mixScaleX, mixScaleY, mixShearY);
                                if (!keyMapEnumerator7.moveNext()) {
                                    timeline10.Shrink(bezier5);
                                    break;
                                }
                                var nextMap5 = Bridge.cast(keyMapEnumerator7.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                                var time25 = Spine.SkeletonJson.GetFloat(nextMap5, "time", 0);
                                var mixRotate2 = Spine.SkeletonJson.GetFloat(nextMap5, "mixRotate", 1), mixShearY2 = Spine.SkeletonJson.GetFloat(nextMap5, "mixShearY", 1);
                                var mixX2 = Spine.SkeletonJson.GetFloat(nextMap5, "mixX", 1), mixY2 = Spine.SkeletonJson.GetFloat(nextMap5, "mixY", mixX2);
                                var mixScaleX2 = Spine.SkeletonJson.GetFloat(nextMap5, "mixScaleX", 1), mixScaleY2 = Spine.SkeletonJson.GetFloat(nextMap5, "mixScaleY", mixScaleX2);
                                if (keyMap7.containsKey("curve")) {
                                    var curve5 = keyMap7.getItem("curve");
                                    bezier5 = Spine.SkeletonJson.ReadCurve(curve5, timeline10, bezier5, frame7, 0, time6, time25, mixRotate, mixRotate2, 1);
                                    bezier5 = Spine.SkeletonJson.ReadCurve(curve5, timeline10, bezier5, frame7, 1, time6, time25, mixX, mixX2, 1);
                                    bezier5 = Spine.SkeletonJson.ReadCurve(curve5, timeline10, bezier5, frame7, 2, time6, time25, mixY, mixY2, 1);
                                    bezier5 = Spine.SkeletonJson.ReadCurve(curve5, timeline10, bezier5, frame7, 3, time6, time25, mixScaleX, mixScaleX2, 1);
                                    bezier5 = Spine.SkeletonJson.ReadCurve(curve5, timeline10, bezier5, frame7, 4, time6, time25, mixScaleY, mixScaleY2, 1);
                                    bezier5 = Spine.SkeletonJson.ReadCurve(curve5, timeline10, bezier5, frame7, 5, time6, time25, mixShearY, mixShearY2, 1);
                                }
                                time6 = time25;
                                mixRotate = mixRotate2;
                                mixX = mixX2;
                                mixY = mixY2;
                                mixScaleX = mixScaleX2;
                                mixScaleY = mixScaleY2;
                                mixShearY = mixShearY2;
                                keyMap7 = nextMap5;
                            }
                            timelines.Add(timeline10);
                        }
                    } finally {
                        if (Bridge.is($t6, System.IDisposable)) {
                            $t6.System$IDisposable$Dispose();
                        }
                    }
                }

                // Path constraint timelines.
                if (map.containsKey("path")) {
                    $t7 = Bridge.getEnumerator(Bridge.cast(map.getItem("path"), System.Collections.Generic.Dictionary$2(System.String,System.Object)));
                    try {
                        while ($t7.moveNext()) {
                            var constraintMap = $t7.Current;
                            var constraint2 = skeletonData.FindPathConstraint(constraintMap.key);
                            if (constraint2 == null) {
                                throw new System.Exception("Path constraint not found: " + (constraintMap.key || ""));
                            }
                            var constraintIndex = skeletonData.pathConstraints.IndexOf(constraint2);
                            var timelineMap4 = Bridge.cast(constraintMap.value, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                            $t8 = Bridge.getEnumerator(timelineMap4);
                            try {
                                while ($t8.moveNext()) {
                                    var timelineEntry2 = $t8.Current;
                                    var values4 = Bridge.cast(timelineEntry2.value, System.Collections.Generic.List$1(System.Object));
                                    var keyMapEnumerator8 = { v : values4.GetEnumerator() };
                                    if (!keyMapEnumerator8.v.moveNext()) {
                                        continue;
                                    }

                                    var frames2 = values4.Count;
                                    var timelineName2 = timelineEntry2.key;
                                    if (Bridge.referenceEquals(timelineName2, "position")) {
                                        var timeline11 = new Spine.PathConstraintPositionTimeline(frames2, frames2, constraintIndex);
                                        timelines.Add(Spine.SkeletonJson.ReadTimeline(keyMapEnumerator8, timeline11, 0, constraint2.positionMode === Spine.PositionMode.Fixed ? scale : 1));
                                    } else if (Bridge.referenceEquals(timelineName2, "spacing")) {
                                        var timeline12 = new Spine.PathConstraintSpacingTimeline(frames2, frames2, constraintIndex);
                                        timelines.Add(Spine.SkeletonJson.ReadTimeline(keyMapEnumerator8, timeline12, 0, constraint2.spacingMode === Spine.SpacingMode.Length || constraint2.spacingMode === Spine.SpacingMode.Fixed ? scale : 1));
                                    } else if (Bridge.referenceEquals(timelineName2, "mix")) {
                                        var timeline13 = new Spine.PathConstraintMixTimeline(frames2, Bridge.Int.mul(frames2, 3), constraintIndex);
                                        var keyMap8 = Bridge.cast(keyMapEnumerator8.v.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                                        var time7 = Spine.SkeletonJson.GetFloat(keyMap8, "time", 0);
                                        var mixRotate1 = Spine.SkeletonJson.GetFloat(keyMap8, "mixRotate", 1);
                                        var mixX1 = Spine.SkeletonJson.GetFloat(keyMap8, "mixX", 1), mixY1 = Spine.SkeletonJson.GetFloat(keyMap8, "mixY", mixX1);
                                        for (var frame8 = 0, bezier6 = 0; ; frame8 = (frame8 + 1) | 0) {
                                            timeline13.SetFrame(frame8, time7, mixRotate1, mixX1, mixY1);
                                            if (!keyMapEnumerator8.v.moveNext()) {
                                                timeline13.Shrink(bezier6);
                                                break;
                                            }
                                            var nextMap6 = Bridge.cast(keyMapEnumerator8.v.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                                            var time26 = Spine.SkeletonJson.GetFloat(nextMap6, "time", 0);
                                            var mixRotate21 = Spine.SkeletonJson.GetFloat(nextMap6, "mixRotate", 1);
                                            var mixX21 = Spine.SkeletonJson.GetFloat(nextMap6, "mixX", 1), mixY21 = Spine.SkeletonJson.GetFloat(nextMap6, "mixY", mixX21);
                                            if (keyMap8.containsKey("curve")) {
                                                var curve6 = keyMap8.getItem("curve");
                                                bezier6 = Spine.SkeletonJson.ReadCurve(curve6, timeline13, bezier6, frame8, 0, time7, time26, mixRotate1, mixRotate21, 1);
                                                bezier6 = Spine.SkeletonJson.ReadCurve(curve6, timeline13, bezier6, frame8, 1, time7, time26, mixX1, mixX21, 1);
                                                bezier6 = Spine.SkeletonJson.ReadCurve(curve6, timeline13, bezier6, frame8, 2, time7, time26, mixY1, mixY21, 1);
                                            }
                                            time7 = time26;
                                            mixRotate1 = mixRotate21;
                                            mixX1 = mixX21;
                                            mixY1 = mixY21;
                                            keyMap8 = nextMap6;
                                        }
                                        timelines.Add(timeline13);
                                    }
                                }
                            } finally {
                                if (Bridge.is($t8, System.IDisposable)) {
                                    $t8.System$IDisposable$Dispose();
                                }
                            }
                        }
                    } finally {
                        if (Bridge.is($t7, System.IDisposable)) {
                            $t7.System$IDisposable$Dispose();
                        }
                    }
                }

                // Physics constraint timelines.
                if (map.containsKey("physics")) {
                    $t9 = Bridge.getEnumerator(Bridge.cast(map.getItem("physics"), System.Collections.Generic.Dictionary$2(System.String,System.Object)));
                    try {
                        while ($t9.moveNext()) {
                            var constraintMap1 = $t9.Current;
                            var index = -1;
                            if (!System.String.isNullOrEmpty(constraintMap1.key)) {
                                var constraint3 = skeletonData.FindPhysicsConstraint(constraintMap1.key);
                                if (constraint3 == null) {
                                    throw new System.Exception("Physics constraint not found: " + (constraintMap1.key || ""));
                                }
                                index = skeletonData.physicsConstraints.IndexOf(constraint3);
                            }
                            var timelineMap5 = Bridge.cast(constraintMap1.value, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                            $t10 = Bridge.getEnumerator(timelineMap5);
                            try {
                                while ($t10.moveNext()) {
                                    var timelineEntry3 = $t10.Current;
                                    var values5 = Bridge.cast(timelineEntry3.value, System.Collections.Generic.List$1(System.Object));
                                    var keyMapEnumerator9 = { v : values5.GetEnumerator() };
                                    if (!keyMapEnumerator9.v.moveNext()) {
                                        continue;
                                    }

                                    var frames3 = values5.Count;
                                    var timelineName3 = timelineEntry3.key;
                                    if (Bridge.referenceEquals(timelineName3, "reset")) {
                                        var timeline1 = new Spine.PhysicsConstraintResetTimeline(frames3, index);
                                        var frame9 = 0;
                                        $t11 = Bridge.getEnumerator(values5);
                                        try {
                                            while ($t11.moveNext()) {
                                                var keyMap9 = Bridge.cast($t11.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                                                timeline1.SetFrame(Bridge.identity(frame9, ((frame9 = (frame9 + 1) | 0))), Spine.SkeletonJson.GetFloat(keyMap9, "time", 0));
                                            }
                                        } finally {
                                            if (Bridge.is($t11, System.IDisposable)) {
                                                $t11.System$IDisposable$Dispose();
                                            }
                                        }
                                        timelines.Add(timeline1);
                                        continue;
                                    }

                                    var timeline14;
                                    if (Bridge.referenceEquals(timelineName3, "inertia")) {
                                        timeline14 = new Spine.PhysicsConstraintInertiaTimeline(frames3, frames3, index);
                                    } else {
                                        if (Bridge.referenceEquals(timelineName3, "strength")) {
                                            timeline14 = new Spine.PhysicsConstraintStrengthTimeline(frames3, frames3, index);
                                        } else {
                                            if (Bridge.referenceEquals(timelineName3, "damping")) {
                                                timeline14 = new Spine.PhysicsConstraintDampingTimeline(frames3, frames3, index);
                                            } else {
                                                if (Bridge.referenceEquals(timelineName3, "mass")) {
                                                    timeline14 = new Spine.PhysicsConstraintMassTimeline(frames3, frames3, index);
                                                } else {
                                                    if (Bridge.referenceEquals(timelineName3, "wind")) {
                                                        timeline14 = new Spine.PhysicsConstraintWindTimeline(frames3, frames3, index);
                                                    } else {
                                                        if (Bridge.referenceEquals(timelineName3, "gravity")) {
                                                            timeline14 = new Spine.PhysicsConstraintGravityTimeline(frames3, frames3, index);
                                                        } else {
                                                            if (Bridge.referenceEquals(timelineName3, "mix")) {
                                                                timeline14 = new Spine.PhysicsConstraintMixTimeline(frames3, frames3, index);
                                                            } else {
                                                                continue;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    timelines.Add(Spine.SkeletonJson.ReadTimeline(keyMapEnumerator9, timeline14, 0, 1));
                                }
                            } finally {
                                if (Bridge.is($t10, System.IDisposable)) {
                                    $t10.System$IDisposable$Dispose();
                                }
                            }
                        }
                    } finally {
                        if (Bridge.is($t9, System.IDisposable)) {
                            $t9.System$IDisposable$Dispose();
                        }
                    }
                }

                // Attachment timelines.
                if (map.containsKey("attachments")) {
                    $t12 = Bridge.getEnumerator(Bridge.cast(map.getItem("attachments"), System.Collections.Generic.Dictionary$2(System.String,System.Object)));
                    try {
                        while ($t12.moveNext()) {
                            var attachmentsMap = $t12.Current;
                            var skin = skeletonData.FindSkin(attachmentsMap.key);
                            $t13 = Bridge.getEnumerator(Bridge.cast(attachmentsMap.value, System.Collections.Generic.Dictionary$2(System.String,System.Object)));
                            try {
                                while ($t13.moveNext()) {
                                    var slotMap = $t13.Current;
                                    var slot = skeletonData.FindSlot(slotMap.key);
                                    if (slot == null) {
                                        throw new System.Exception("Slot not found: " + (slotMap.key || ""));
                                    }
                                    $t14 = Bridge.getEnumerator(Bridge.cast(slotMap.value, System.Collections.Generic.Dictionary$2(System.String,System.Object)));
                                    try {
                                        while ($t14.moveNext()) {
                                            var attachmentMap = $t14.Current;
                                            var attachment = skin.GetAttachment(slot.index, attachmentMap.key);
                                            if (attachment == null) {
                                                throw new System.Exception("Timeline attachment not found: " + (attachmentMap.key || ""));
                                            }
                                            $t15 = Bridge.getEnumerator(Bridge.cast(attachmentMap.value, System.Collections.Generic.Dictionary$2(System.String,System.Object)));
                                            try {
                                                while ($t15.moveNext()) {
                                                    var timelineMap6 = $t15.Current;
                                                    var values6 = Bridge.cast(timelineMap6.value, System.Collections.Generic.List$1(System.Object));
                                                    var keyMapEnumerator10 = values6.GetEnumerator();
                                                    if (!keyMapEnumerator10.moveNext()) {
                                                        continue;
                                                    }
                                                    var keyMap10 = Bridge.cast(keyMapEnumerator10.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                                                    var frames4 = values6.Count;
                                                    var timelineName4 = timelineMap6.key;
                                                    if (Bridge.referenceEquals(timelineName4, "deform")) {
                                                        var vertexAttachment = Bridge.cast(attachment, Spine.VertexAttachment);
                                                        var weighted = vertexAttachment.bones != null;
                                                        var vertices = vertexAttachment.vertices;
                                                        var deformLength = weighted ? (((Bridge.Int.div(vertices.length, 3)) | 0)) << 1 : vertices.length;

                                                        var timeline15 = new Spine.DeformTimeline(frames4, frames4, slot.Index, vertexAttachment);
                                                        var time8 = Spine.SkeletonJson.GetFloat(keyMap10, "time", 0);
                                                        for (var frame10 = 0, bezier7 = 0; ; frame10 = (frame10 + 1) | 0) {
                                                            var deform;
                                                            if (!keyMap10.containsKey("vertices")) {
                                                                deform = weighted ? System.Array.init(deformLength, 0, System.Single) : vertices;
                                                            } else {
                                                                deform = System.Array.init(deformLength, 0, System.Single);
                                                                var start = Spine.SkeletonJson.GetInt$1(keyMap10, "offset", 0);
                                                                var verticesValue = Spine.SkeletonJson.GetFloatArray(keyMap10, "vertices", 1);
                                                                System.Array.copy(verticesValue, 0, deform, start, verticesValue.length);
                                                                if (scale !== 1) {
                                                                    for (var i1 = start, n1 = (i1 + verticesValue.length) | 0; i1 < n1; i1 = (i1 + 1) | 0) {
                                                                        deform[i1] *= scale;
                                                                    }
                                                                }

                                                                if (!weighted) {
                                                                    for (var i2 = 0; i2 < deformLength; i2 = (i2 + 1) | 0) {
                                                                        deform[i2] += vertices[i2];
                                                                    }
                                                                }
                                                            }

                                                            timeline15.SetFrame(frame10, time8, deform);
                                                            if (!keyMapEnumerator10.moveNext()) {
                                                                timeline15.Shrink(bezier7);
                                                                break;
                                                            }
                                                            var nextMap7 = Bridge.cast(keyMapEnumerator10.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                                                            var time27 = Spine.SkeletonJson.GetFloat(nextMap7, "time", 0);
                                                            if (keyMap10.containsKey("curve")) {
                                                                var curve7 = keyMap10.getItem("curve");
                                                                bezier7 = Spine.SkeletonJson.ReadCurve(curve7, timeline15, bezier7, frame10, 0, time8, time27, 0, 1, 1);
                                                            }
                                                            time8 = time27;
                                                            keyMap10 = nextMap7;
                                                        }
                                                        timelines.Add(timeline15);
                                                    } else if (Bridge.referenceEquals(timelineName4, "sequence")) {
                                                        var timeline16 = new Spine.SequenceTimeline(frames4, slot.index, attachment);
                                                        var lastDelay = 0;
                                                        for (var frame11 = 0; keyMap10 != null; keyMap10 = keyMapEnumerator10.moveNext() ? Bridge.cast(keyMapEnumerator10.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object)) : null, frame11 = (frame11 + 1) | 0) {

                                                            var delay = Spine.SkeletonJson.GetFloat(keyMap10, "delay", lastDelay);
                                                            var sequenceMode = System.Nullable.getValue(Bridge.cast(Bridge.unbox(System.Enum.parse(Spine.SequenceMode, Spine.SkeletonJson.GetString(keyMap10, "mode", "hold"), true), Spine.SequenceMode), System.Int32));
                                                            timeline16.SetFrame(frame11, Spine.SkeletonJson.GetFloat(keyMap10, "time", 0), sequenceMode, Spine.SkeletonJson.GetInt$1(keyMap10, "index", 0), delay);
                                                            lastDelay = delay;
                                                        }
                                                        timelines.Add(timeline16);
                                                    }
                                                }
                                            } finally {
                                                if (Bridge.is($t15, System.IDisposable)) {
                                                    $t15.System$IDisposable$Dispose();
                                                }
                                            }
                                        }
                                    } finally {
                                        if (Bridge.is($t14, System.IDisposable)) {
                                            $t14.System$IDisposable$Dispose();
                                        }
                                    }
                                }
                            } finally {
                                if (Bridge.is($t13, System.IDisposable)) {
                                    $t13.System$IDisposable$Dispose();
                                }
                            }
                        }
                    } finally {
                        if (Bridge.is($t12, System.IDisposable)) {
                            $t12.System$IDisposable$Dispose();
                        }
                    }
                }

                // Draw order timeline.
                if (map.containsKey("drawOrder")) {
                    var values7 = Bridge.cast(map.getItem("drawOrder"), System.Collections.Generic.List$1(System.Object));
                    var timeline17 = new Spine.DrawOrderTimeline(values7.Count);
                    var slotCount = skeletonData.slots.Count;
                    var frame12 = 0;
                    $t16 = Bridge.getEnumerator(values7);
                    try {
                        while ($t16.moveNext()) {
                            var keyMap11 = Bridge.cast($t16.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                            var drawOrder = null;
                            if (keyMap11.containsKey("offsets")) {
                                drawOrder = System.Array.init(slotCount, 0, System.Int32);
                                for (var i3 = (slotCount - 1) | 0; i3 >= 0; i3 = (i3 - 1) | 0) {
                                    drawOrder[i3] = -1;
                                }
                                var offsets = Bridge.cast(keyMap11.getItem("offsets"), System.Collections.Generic.List$1(System.Object));
                                var unchanged = System.Array.init(((slotCount - offsets.Count) | 0), 0, System.Int32);
                                var originalIndex = 0, unchangedIndex = 0;
                                $t17 = Bridge.getEnumerator(offsets);
                                try {
                                    while ($t17.moveNext()) {
                                        var offsetMap = Bridge.cast($t17.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                                        var slotIndex1 = this.FindSlotIndex(skeletonData, Bridge.cast(offsetMap.getItem("slot"), System.String));
                                        // Collect unchanged items.
                                        while (originalIndex !== slotIndex1) {
                                            unchanged[Bridge.identity(unchangedIndex, ((unchangedIndex = (unchangedIndex + 1) | 0)))] = Bridge.identity(originalIndex, ((originalIndex = (originalIndex + 1) | 0)));
                                        }
                                        // Set changed items.
                                        var index1 = (originalIndex + Bridge.Int.clip32(System.Nullable.getValue(Bridge.cast(Bridge.unbox(offsetMap.getItem("offset"), System.Single), System.Single)))) | 0;
                                        drawOrder[index1] = Bridge.identity(originalIndex, ((originalIndex = (originalIndex + 1) | 0)));
                                    }
                                } finally {
                                    if (Bridge.is($t17, System.IDisposable)) {
                                        $t17.System$IDisposable$Dispose();
                                    }
                                }
                                // Collect remaining unchanged items.
                                while (originalIndex < slotCount) {
                                    unchanged[Bridge.identity(unchangedIndex, ((unchangedIndex = (unchangedIndex + 1) | 0)))] = Bridge.identity(originalIndex, ((originalIndex = (originalIndex + 1) | 0)));
                                }
                                // Fill in unchanged items.
                                for (var i4 = (slotCount - 1) | 0; i4 >= 0; i4 = (i4 - 1) | 0) {
                                    if (drawOrder[i4] === -1) {
                                        drawOrder[i4] = unchanged[((unchangedIndex = (unchangedIndex - 1) | 0))];
                                    }
                                }
                            }
                            timeline17.SetFrame(frame12, Spine.SkeletonJson.GetFloat(keyMap11, "time", 0), drawOrder);
                            frame12 = (frame12 + 1) | 0;
                        }
                    } finally {
                        if (Bridge.is($t16, System.IDisposable)) {
                            $t16.System$IDisposable$Dispose();
                        }
                    }
                    timelines.Add(timeline17);
                }

                // Event timeline.
                if (map.containsKey("events")) {
                    var eventsMap = Bridge.cast(map.getItem("events"), System.Collections.Generic.List$1(System.Object));
                    var timeline18 = new Spine.EventTimeline(eventsMap.Count);
                    var frame13 = 0;
                    $t18 = Bridge.getEnumerator(eventsMap);
                    try {
                        while ($t18.moveNext()) {
                            var keyMap12 = Bridge.cast($t18.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                            var eventData = skeletonData.FindEvent(Bridge.cast(keyMap12.getItem("name"), System.String));
                            if (eventData == null) {
                                throw new System.Exception(System.String.concat("Event not found: ", keyMap12.getItem("name")));
                            }
                            var e = ($t19 = new Spine.Event(Spine.SkeletonJson.GetFloat(keyMap12, "time", 0), eventData), $t19.intValue = Spine.SkeletonJson.GetInt$1(keyMap12, "int", eventData.Int), $t19.floatValue = Spine.SkeletonJson.GetFloat(keyMap12, "float", eventData.Float), $t19.stringValue = Spine.SkeletonJson.GetString(keyMap12, "string", eventData.String), $t19);
                            if (e.data.AudioPath != null) {
                                e.volume = Spine.SkeletonJson.GetFloat(keyMap12, "volume", eventData.Volume);
                                e.balance = Spine.SkeletonJson.GetFloat(keyMap12, "balance", eventData.Balance);
                            }
                            timeline18.SetFrame(frame13, e);
                            frame13 = (frame13 + 1) | 0;
                        }
                    } finally {
                        if (Bridge.is($t18, System.IDisposable)) {
                            $t18.System$IDisposable$Dispose();
                        }
                    }
                    timelines.Add(timeline18);
                }
                timelines.TrimExcess();
                var duration = 0;
                var items = timelines.Items;
                for (var i5 = 0, n2 = timelines.Count; i5 < n2; i5 = (i5 + 1) | 0) {
                    duration = Math.max(duration, items[i5].Duration);
                }
                skeletonData.animations.Add(new Spine.Animation(name, timelines, duration));
            },
            /*Spine.SkeletonJson.ReadAnimation end.*/


        },
        overloads: {
            "ReadSkeletonData(TextReader)": "ReadSkeletonData$1"
        }
    });
    /*Spine.SkeletonJson end.*/

    /*Spine.Skin+SkinKeyComparer start.*/
    Bridge.define("Spine.Skin.SkinKeyComparer", {
        inherits: [System.Collections.Generic.IEqualityComparer$1(Spine.Skin.SkinKey)],
        $kind: 1002,
        statics: {
            fields: {
                Instance: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Skin.SkinKeyComparer#init", this ); }

                    this.Instance = new Spine.Skin.SkinKeyComparer();
                }
            }
        },
        alias: [
            "System$Collections$Generic$IEqualityComparer$1$Spine$Skin$SkinKey$equals2", "System$Collections$Generic$IEqualityComparer$1$equals2",
            "System$Collections$Generic$IEqualityComparer$1$Spine$Skin$SkinKey$getHashCode2", "System$Collections$Generic$IEqualityComparer$1$getHashCode2"
        ],
        methods: {
            /*Spine.Skin+SkinKeyComparer.System$Collections$Generic$IEqualityComparer$1$Spine$Skin$SkinKey$equals2 start.*/
            System$Collections$Generic$IEqualityComparer$1$Spine$Skin$SkinKey$equals2: function (e1, e2) {
if ( TRACE ) { TRACE( "Spine.Skin.SkinKeyComparer#System$Collections$Generic$IEqualityComparer$1$Spine$Skin$SkinKey$equals2", this ); }

                return e1.slotIndex === e2.slotIndex && System.String.equals(e1.name, e2.name, 4);
            },
            /*Spine.Skin+SkinKeyComparer.System$Collections$Generic$IEqualityComparer$1$Spine$Skin$SkinKey$equals2 end.*/

            /*Spine.Skin+SkinKeyComparer.System$Collections$Generic$IEqualityComparer$1$Spine$Skin$SkinKey$getHashCode2 start.*/
            System$Collections$Generic$IEqualityComparer$1$Spine$Skin$SkinKey$getHashCode2: function (e) {
if ( TRACE ) { TRACE( "Spine.Skin.SkinKeyComparer#System$Collections$Generic$IEqualityComparer$1$Spine$Skin$SkinKey$getHashCode2", this ); }

                return e.hashCode;
            },
            /*Spine.Skin+SkinKeyComparer.System$Collections$Generic$IEqualityComparer$1$Spine$Skin$SkinKey$getHashCode2 end.*/


        }
    });
    /*Spine.Skin+SkinKeyComparer end.*/

    /*Spine.TrackEntry start.*/
    /**
     * <p>Stores settings and other state for the playback of an animation on an {@link } track.</p><p>References to a track entry must not be kept after the {@link } event occurs.</p>
     *
     * @public
     * @class Spine.TrackEntry
     * @implements  Spine.Pool$1.IPoolable
     */
    Bridge.define("Spine.TrackEntry", {
        inherits: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#inherits", this ); }
 return [Spine.Pool$1.IPoolable(Spine.TrackEntry)]; },
        fields: {
            animation: null,
            previous: null,
            next: null,
            mixingFrom: null,
            mixingTo: null,
            trackIndex: 0,
            loop: false,
            holdPrevious: false,
            reverse: false,
            shortestRotation: false,
            eventThreshold: 0,
            mixAttachmentThreshold: 0,
            alphaAttachmentThreshold: 0,
            mixDrawOrderThreshold: 0,
            animationStart: 0,
            animationEnd: 0,
            animationLast: 0,
            nextAnimationLast: 0,
            delay: 0,
            trackTime: 0,
            trackLast: 0,
            nextTrackLast: 0,
            trackEnd: 0,
            timeScale: 0,
            alpha: 0,
            mixTime: 0,
            mixDuration: 0,
            interruptAlpha: 0,
            totalAlpha: 0,
            mixBlend: 0,
            timelineMode: null,
            timelineHoldMix: null,
            timelinesRotation: null
        },
        events: {
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.TrackEntry
             * @memberof Spine.TrackEntry
             * @function addStart
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.TrackEntry
             * @memberof Spine.TrackEntry
             * @function removeStart
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.TrackEntry
             * @memberof Spine.TrackEntry
             * @function addInterrupt
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.TrackEntry
             * @memberof Spine.TrackEntry
             * @function removeInterrupt
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.TrackEntry
             * @memberof Spine.TrackEntry
             * @function addEnd
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.TrackEntry
             * @memberof Spine.TrackEntry
             * @function removeEnd
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.TrackEntry
             * @memberof Spine.TrackEntry
             * @function addDispose
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.TrackEntry
             * @memberof Spine.TrackEntry
             * @function removeDispose
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.TrackEntry
             * @memberof Spine.TrackEntry
             * @function addComplete
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.TrackEntry
             * @memberof Spine.TrackEntry
             * @function removeComplete
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            Start: null,
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.TrackEntry
             * @memberof Spine.TrackEntry
             * @function addStart
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.TrackEntry
             * @memberof Spine.TrackEntry
             * @function removeStart
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.TrackEntry
             * @memberof Spine.TrackEntry
             * @function addInterrupt
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.TrackEntry
             * @memberof Spine.TrackEntry
             * @function removeInterrupt
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.TrackEntry
             * @memberof Spine.TrackEntry
             * @function addEnd
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.TrackEntry
             * @memberof Spine.TrackEntry
             * @function removeEnd
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.TrackEntry
             * @memberof Spine.TrackEntry
             * @function addDispose
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.TrackEntry
             * @memberof Spine.TrackEntry
             * @function removeDispose
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.TrackEntry
             * @memberof Spine.TrackEntry
             * @function addComplete
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.TrackEntry
             * @memberof Spine.TrackEntry
             * @function removeComplete
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            Interrupt: null,
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.TrackEntry
             * @memberof Spine.TrackEntry
             * @function addStart
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.TrackEntry
             * @memberof Spine.TrackEntry
             * @function removeStart
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.TrackEntry
             * @memberof Spine.TrackEntry
             * @function addInterrupt
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.TrackEntry
             * @memberof Spine.TrackEntry
             * @function removeInterrupt
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.TrackEntry
             * @memberof Spine.TrackEntry
             * @function addEnd
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.TrackEntry
             * @memberof Spine.TrackEntry
             * @function removeEnd
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.TrackEntry
             * @memberof Spine.TrackEntry
             * @function addDispose
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.TrackEntry
             * @memberof Spine.TrackEntry
             * @function removeDispose
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.TrackEntry
             * @memberof Spine.TrackEntry
             * @function addComplete
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.TrackEntry
             * @memberof Spine.TrackEntry
             * @function removeComplete
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            End: null,
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.TrackEntry
             * @memberof Spine.TrackEntry
             * @function addStart
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.TrackEntry
             * @memberof Spine.TrackEntry
             * @function removeStart
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.TrackEntry
             * @memberof Spine.TrackEntry
             * @function addInterrupt
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.TrackEntry
             * @memberof Spine.TrackEntry
             * @function removeInterrupt
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.TrackEntry
             * @memberof Spine.TrackEntry
             * @function addEnd
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.TrackEntry
             * @memberof Spine.TrackEntry
             * @function removeEnd
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.TrackEntry
             * @memberof Spine.TrackEntry
             * @function addDispose
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.TrackEntry
             * @memberof Spine.TrackEntry
             * @function removeDispose
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.TrackEntry
             * @memberof Spine.TrackEntry
             * @function addComplete
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.TrackEntry
             * @memberof Spine.TrackEntry
             * @function removeComplete
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            Dispose: null,
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.TrackEntry
             * @memberof Spine.TrackEntry
             * @function addStart
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.TrackEntry
             * @memberof Spine.TrackEntry
             * @function removeStart
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.TrackEntry
             * @memberof Spine.TrackEntry
             * @function addInterrupt
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.TrackEntry
             * @memberof Spine.TrackEntry
             * @function removeInterrupt
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.TrackEntry
             * @memberof Spine.TrackEntry
             * @function addEnd
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.TrackEntry
             * @memberof Spine.TrackEntry
             * @function removeEnd
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.TrackEntry
             * @memberof Spine.TrackEntry
             * @function addDispose
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.TrackEntry
             * @memberof Spine.TrackEntry
             * @function removeDispose
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.TrackEntry
             * @memberof Spine.TrackEntry
             * @function addComplete
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            /**
             * See {@link } for details. Usage in C# and spine-unity is explained
             {@link }
             on the spine-unity documentation pages.
             *
             * @instance
             * @public
             * @this Spine.TrackEntry
             * @memberof Spine.TrackEntry
             * @function removeComplete
             * @param   {Spine.AnimationState.TrackEntryDelegate}    value
             * @return  {void}
             */
            Complete: null,
            Event: null
        },
        props: {
            /**
             * The index of the track where this entry is either current or queued.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.TrackEntry
             * @function TrackIndex
             * @type number
             * @see {@link AnimationState.GetCurrent(int)}
             */
            TrackIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#TrackIndex#get", this ); }

                    return this.trackIndex;
                }
            },
            /**
             * The animation to apply for this track entry.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.TrackEntry
             * @function Animation
             * @type Spine.Animation
             */
            Animation: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#Animation#get", this ); }

                    return this.animation;
                }
            },
            /**
             * If true, the animation will repeat. If false it will not, instead its last frame is applied if played beyond its
             duration.
             *
             * @instance
             * @public
             * @memberof Spine.TrackEntry
             * @function Loop
             * @type boolean
             */
            Loop: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#Loop#get", this ); }

                    return this.loop;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#Loop#set", this ); }

                    this.loop = value;
                }
            },
            
            Delay: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#Delay#get", this ); }

                    return this.delay;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#Delay#set", this ); }

                    this.delay = value;
                }
            },
            /**
             * Current time in seconds this track entry has been the current track entry. The track time determines
             {@link }. The track time can be set to start the animation at a time other than 0, without affecting
             looping.
             *
             * @instance
             * @public
             * @memberof Spine.TrackEntry
             * @function TrackTime
             * @type number
             */
            TrackTime: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#TrackTime#get", this ); }

                    return this.trackTime;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#TrackTime#set", this ); }

                    this.trackTime = value;
                }
            },
            /**
             * <p>The track time in seconds when this animation will be removed from the track. Defaults to the highest possible float
             value, meaning the animation will be applied until a new animation is set or the track is cleared. If the track end time
             is reached, no other animations are queued for playback, and mixing from any previous animations is complete, then the
             properties keyed by the animation are set to the setup pose and the track is cleared.</p><p>It may be desired to use {@link }  rather than have the animation
             abruptly cease being applied.</p>
             *
             * @instance
             * @public
             * @memberof Spine.TrackEntry
             * @function TrackEnd
             * @type number
             */
            TrackEnd: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#TrackEnd#get", this ); }

                    return this.trackEnd;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#TrackEnd#set", this ); }

                    this.trackEnd = value;
                }
            },
            /**
             * If this track entry is non-looping, the track time in seconds when {@link } is reached, or the current
             {@link } if it has already been reached. If this track entry is looping, the track time when this
             animation will reach its next {@link } (the next loop completion).
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.TrackEntry
             * @function TrackComplete
             * @type number
             */
            TrackComplete: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#TrackComplete#get", this ); }

                    var duration = this.animationEnd - this.animationStart;
                    if (duration !== 0) {
                        if (this.loop) {
                            return duration * (((1 + Bridge.Int.clip32((this.trackTime / duration))) | 0));
                        } // Completion of next loop.
                        if (this.trackTime < duration) {
                            return duration;
                        } // Before duration.
                    }
                    return this.trackTime; // Next update.
                }
            },
            
            AnimationStart: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#AnimationStart#get", this ); }

                    return this.animationStart;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#AnimationStart#set", this ); }

                    this.animationStart = value;
                }
            },
            /**
             * Seconds for the last frame of this animation. Non-looping animations won't play past this time. Looping animations will
             loop back to {@link } at this time. Defaults to the animation {@link }.
             *
             * @instance
             * @public
             * @memberof Spine.TrackEntry
             * @function AnimationEnd
             * @type number
             */
            AnimationEnd: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#AnimationEnd#get", this ); }

                    return this.animationEnd;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#AnimationEnd#set", this ); }

                    this.animationEnd = value;
                }
            },
            /**
             * The time in seconds this animation was last applied. Some timelines use this for one-time triggers. Eg, when this
             animation is applied, event timelines will fire all events between the <pre><code>AnimationLast</code></pre> time (exclusive) and
             <pre><code>AnimationTime</code></pre> (inclusive). Defaults to -1 to ensure triggers on frame 0 happen the first time this animation
             is applied.
             *
             * @instance
             * @public
             * @memberof Spine.TrackEntry
             * @function AnimationLast
             * @type number
             */
            AnimationLast: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#AnimationLast#get", this ); }

                    return this.animationLast;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#AnimationLast#set", this ); }

                    this.animationLast = value;
                    this.nextAnimationLast = value;
                }
            },
            /**
             * Uses {@link } to compute the <pre><code>AnimationTime</code></pre>. When the <pre><code>TrackTime</code></pre> is 0, the
             <pre><code>AnimationTime</code></pre> is equal to the <pre><code>AnimationStart</code></pre> time.
             <p>The <pre><code>animationTime</code></pre> is between {@link } and {@link }, except if this
             track entry is non-looping and {@link } is &gt;= to the animation {@link }, then
             <pre><code>animationTime</code></pre> continues to increase past {@link }.</p>
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.TrackEntry
             * @function AnimationTime
             * @type number
             */
            AnimationTime: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#AnimationTime#get", this ); }

                    if (this.loop) {
                        var duration = this.animationEnd - this.animationStart;
                        if (duration === 0) {
                            return this.animationStart;
                        }
                        return (this.trackTime % duration) + this.animationStart;
                    }
                    var animationTime = this.trackTime + this.animationStart;
                    return this.animationEnd >= this.animation.duration ? animationTime : Math.min(animationTime, this.animationEnd);
                }
            },
            
            TimeScale: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#TimeScale#get", this ); }

                    return this.timeScale;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#TimeScale#set", this ); }

                    this.timeScale = value;
                }
            },
            
            Alpha: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#Alpha#get", this ); }

                    return this.alpha;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#Alpha#set", this ); }

                    this.alpha = value;
                }
            },
            InterruptAlpha: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#InterruptAlpha#get", this ); }

                    return this.interruptAlpha;
                }
            },
            /**
             * When the mix percentage ({@link } / {@link }) is less than the
             <pre><code>EventThreshold</code></pre>, event timelines are applied while this animation is being mixed out. Defaults to 0, so event
             timelines are not applied while this animation is being mixed out.
             *
             * @instance
             * @public
             * @memberof Spine.TrackEntry
             * @function EventThreshold
             * @type number
             */
            EventThreshold: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#EventThreshold#get", this ); }

                    return this.eventThreshold;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#EventThreshold#set", this ); }

                    this.eventThreshold = value;
                }
            },
            
            AlphaAttachmentThreshold: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#AlphaAttachmentThreshold#get", this ); }

                    return this.alphaAttachmentThreshold;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#AlphaAttachmentThreshold#set", this ); }

                    this.alphaAttachmentThreshold = value;
                }
            },
            /**
             * When the mix percentage ({@link } / {@link }) is less than the
             <pre><code>MixAttachmentThreshold</code></pre>, attachment timelines are applied while this animation is being mixed out. Defaults
             to 0, so attachment timelines are not applied while this animation is being mixed out.
             *
             * @instance
             * @public
             * @memberof Spine.TrackEntry
             * @function MixAttachmentThreshold
             * @type number
             */
            MixAttachmentThreshold: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#MixAttachmentThreshold#get", this ); }

                    return this.mixAttachmentThreshold;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#MixAttachmentThreshold#set", this ); }

                    this.mixAttachmentThreshold = value;
                }
            },
            /**
             * When the mix percentage ({@link } / {@link }) is less than the
             <pre><code>MixDrawOrderThreshold</code></pre>, draw order timelines are applied while this animation is being mixed out. Defaults to
             0, so draw order timelines are not applied while this animation is being mixed out.
             *
             * @instance
             * @public
             * @memberof Spine.TrackEntry
             * @function MixDrawOrderThreshold
             * @type number
             */
            MixDrawOrderThreshold: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#MixDrawOrderThreshold#get", this ); }

                    return this.mixDrawOrderThreshold;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#MixDrawOrderThreshold#set", this ); }

                    this.mixDrawOrderThreshold = value;
                }
            },
            /**
             * The animation queued to start after this animation, or null if there is none. <pre><code>next</code></pre> makes up a doubly linked
             list.
             <p>See {@link } to truncate the list.</p>
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.TrackEntry
             * @function Next
             * @type Spine.TrackEntry
             */
            Next: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#Next#get", this ); }

                    return this.next;
                }
            },
            /**
             * The animation queued to play before this animation, or null. <pre><code>previous</code></pre> makes up a doubly linked list.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.TrackEntry
             * @function Previous
             * @type Spine.TrackEntry
             */
            Previous: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#Previous#get", this ); }

                    return this.previous;
                }
            },
            /**
             * Returns true if this track entry has been applied at least once.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.TrackEntry
             * @function WasApplied
             * @type boolean
             * @see {@link AnimationState.Apply(Skeleton)}
             */
            WasApplied: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#WasApplied#get", this ); }

                    return this.nextTrackLast !== -1;
                }
            },
            /**
             * Returns true if there is a {@link } track entry that will become the current track entry during the
             next {@link }.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.TrackEntry
             * @function IsNextReady
             * @type boolean
             */
            IsNextReady: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#IsNextReady#get", this ); }

                    return (this.next != null) && (this.nextTrackLast - this.next.delay >= 0);
                }
            },
            /**
             * Returns true if at least one loop has been completed.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.TrackEntry
             * @function IsComplete
             * @type boolean
             * @see {@link TrackEntry.Complete}
             */
            IsComplete: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#IsComplete#get", this ); }

                    return this.trackTime >= this.animationEnd - this.animationStart;
                }
            },
            /**
             * Seconds from 0 to the {@link } when mixing from the previous animation to this animation. May be
             slightly more than <pre><code>MixDuration</code></pre> when the mix is complete.
             *
             * @instance
             * @public
             * @memberof Spine.TrackEntry
             * @function MixTime
             * @type number
             */
            MixTime: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#MixTime#get", this ); }

                    return this.mixTime;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#MixTime#set", this ); }

                    this.mixTime = value;
                }
            },
            /**
             * <p>Seconds for mixing from the previous animation to this animation. Defaults to the value provided by AnimationStateData
             {@link } based on the animation before this animation (if any).</p><p>The <pre><code>MixDuration</code></pre> can be set manually rather than use the value from
             {@link }. In that case, the <pre><code>MixDuration</code></pre> can be set for a new
             track entry only before {@link } is first called.</p><p>When using <seealso cref="AnimationState.AddAnimation(int, Animation, bool, float)" /> with a <pre><code>Delay</code></pre> &lt;= 0, the
             {@link } is set using the mix duration from the {@link }. If <pre><code>mixDuration</code></pre> is set
             afterward, the delay may need to be adjusted. For example:</p><p><pre><code>entry.Delay = entry.previous.TrackComplete - entry.MixDuration;</code></pre></p><p>Alternatively, {@link } can be used to recompute the delay:</p><p><pre><code>entry.SetMixDuration(0.25f, 0);</code></pre></p>
             *
             * @instance
             * @public
             * @memberof Spine.TrackEntry
             * @function MixDuration
             * @type number
             * @see {@link AnimationState.AddAnimation(int, Animation, bool, float)}
             */
            MixDuration: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#MixDuration#get", this ); }

                    return this.mixDuration;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#MixDuration#set", this ); }

                    this.mixDuration = value;
                }
            },
            /**
             * <p>Controls how properties keyed in the animation are mixed with lower tracks. Defaults to {@link }.</p><p>Track entries on track 0 ignore this setting and always use {@link }.</p><p>The <pre><code>MixBlend</code></pre> can be set for a new track entry only before {@link } is first
              called.</p>
             *
             * @instance
             * @public
             * @memberof Spine.TrackEntry
             * @function MixBlend
             * @type Spine.MixBlend
             */
            MixBlend: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#MixBlend#get", this ); }

                    return this.mixBlend;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#MixBlend#set", this ); }

                    this.mixBlend = value;
                }
            },
            /**
             * The track entry for the previous animation when mixing from the previous animation to this animation, or null if no
             mixing is currently occurring. When mixing from multiple animations, <pre><code>MixingFrom</code></pre> makes up a linked list.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.TrackEntry
             * @function MixingFrom
             * @type Spine.TrackEntry
             */
            MixingFrom: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#MixingFrom#get", this ); }

                    return this.mixingFrom;
                }
            },
            /**
             * The track entry for the next animation when mixing from this animation to the next animation, or null if no mixing is
             currently occurring. When mixing to multiple animations, <pre><code>MixingTo</code></pre> makes up a linked list.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.TrackEntry
             * @function MixingTo
             * @type Spine.TrackEntry
             */
            MixingTo: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#MixingTo#get", this ); }

                    return this.mixingTo;
                }
            },
            /**
             * <p>If true, when mixing from the previous animation to this animation, the previous animation is applied as normal instead
             of being mixed out.</p><p>When mixing between animations that key the same property, if a lower track also keys that property then the value will
             briefly dip toward the lower track value during the mix. This happens because the first animation mixes from 100% to 0%
             while the second animation mixes from 0% to 100%. Setting <pre><code>HoldPrevious</code></pre> to true applies the first animation
             at 100% during the mix so the lower track value is overwritten. Such dipping does not occur on the lowest track which
             keys the property, only when a higher track also keys the property.</p><p>Snapping will occur if <pre><code>HoldPrevious</code></pre> is true and this animation does not key all the same properties as the
             previous animation.</p>
             *
             * @instance
             * @public
             * @memberof Spine.TrackEntry
             * @function HoldPrevious
             * @type boolean
             */
            HoldPrevious: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#HoldPrevious#get", this ); }

                    return this.holdPrevious;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#HoldPrevious#set", this ); }

                    this.holdPrevious = value;
                }
            },
            /**
             * If true, the animation will be applied in reverse. Events are not fired when an animation is applied in reverse.
             *
             * @instance
             * @public
             * @memberof Spine.TrackEntry
             * @function Reverse
             * @type boolean
             */
            Reverse: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#Reverse#get", this ); }

                    return this.reverse;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#Reverse#set", this ); }

                    this.reverse = value;
                }
            },
            /**
             * <p>If true, mixing rotation between tracks always uses the shortest rotation direction. If the rotation is animated, the
             shortest rotation direction may change during the mix.</p><p>If false, the shortest rotation direction is remembered when the mix starts and the same direction is used for the rest
             of the mix. Defaults to false.</p>
             *
             * @instance
             * @public
             * @memberof Spine.TrackEntry
             * @function ShortestRotation
             * @type boolean
             */
            ShortestRotation: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#ShortestRotation#get", this ); }

                    return this.shortestRotation;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#ShortestRotation#set", this ); }

                    this.shortestRotation = value;
                }
            },
            
            IsEmptyAnimation: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#IsEmptyAnimation#get", this ); }

                    return Bridge.referenceEquals(this.animation, Spine.AnimationState.EmptyAnimation);
                }
            }
        },
        alias: ["Reset", "Spine$Pool$1$IPoolable$Spine$TrackEntry$Reset"],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#init", this ); }

                this.timeScale = 1.0;
                this.mixBlend = Spine.MixBlend.Replace;
                this.timelineMode = new (Spine.ExposedList$1(System.Int32)).ctor();
                this.timelineHoldMix = new (Spine.ExposedList$1(Spine.TrackEntry)).ctor();
                this.timelinesRotation = new (Spine.ExposedList$1(System.Single)).ctor();
            }
        },
        methods: {
            /*Spine.TrackEntry.OnStart start.*/
            OnStart: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#OnStart", this ); }

                if (!Bridge.staticEquals(this.Start, null)) {
                    this.Start(this);
                }
            },
            /*Spine.TrackEntry.OnStart end.*/

            /*Spine.TrackEntry.OnInterrupt start.*/
            OnInterrupt: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#OnInterrupt", this ); }

                if (!Bridge.staticEquals(this.Interrupt, null)) {
                    this.Interrupt(this);
                }
            },
            /*Spine.TrackEntry.OnInterrupt end.*/

            /*Spine.TrackEntry.OnEnd start.*/
            OnEnd: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#OnEnd", this ); }

                if (!Bridge.staticEquals(this.End, null)) {
                    this.End(this);
                }
            },
            /*Spine.TrackEntry.OnEnd end.*/

            /*Spine.TrackEntry.OnDispose start.*/
            OnDispose: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#OnDispose", this ); }

                if (!Bridge.staticEquals(this.Dispose, null)) {
                    this.Dispose(this);
                }
            },
            /*Spine.TrackEntry.OnDispose end.*/

            /*Spine.TrackEntry.OnComplete start.*/
            OnComplete: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#OnComplete", this ); }

                if (!Bridge.staticEquals(this.Complete, null)) {
                    this.Complete(this);
                }
            },
            /*Spine.TrackEntry.OnComplete end.*/

            /*Spine.TrackEntry.OnEvent start.*/
            OnEvent: function (e) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#OnEvent", this ); }

                if (!Bridge.staticEquals(this.Event, null)) {
                    this.Event(this, e);
                }
            },
            /*Spine.TrackEntry.OnEvent end.*/

            /*Spine.TrackEntry.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#Reset", this ); }

                this.previous = null;
                this.next = null;
                this.mixingFrom = null;
                this.mixingTo = null;
                this.animation = null;
                // replaces 'listener = null;' since delegates are used for event callbacks
                this.Start = null;
                this.Interrupt = null;
                this.End = null;
                this.Dispose = null;
                this.Complete = null;
                this.Event = null;
                this.timelineMode.Clear();
                this.timelineHoldMix.Clear();
                this.timelinesRotation.Clear();
            },
            /*Spine.TrackEntry.Reset end.*/

            /*Spine.TrackEntry.SetMixDuration start.*/
            
            SetMixDuration: function (mixDuration, delay) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#SetMixDuration", this ); }

                this.mixDuration = mixDuration;
                if (this.previous != null && delay <= 0) {
                    delay += this.previous.TrackComplete - mixDuration;
                }
                this.delay = delay;
            },
            /*Spine.TrackEntry.SetMixDuration end.*/

            /*Spine.TrackEntry.ResetRotationDirections start.*/
            /**
             * <p>Resets the rotation directions for mixing this entry's rotate timelines. This can be useful to avoid bones rotating the
             long way around when using {@link } and starting animations on other tracks.</p><p>Mixing with {@link } involves finding a rotation between two others, which has two possible solutions:
             the short way or the long way around. The two rotations likely change over time, so which direction is the short or long
             way also changes. If the short way was always chosen, bones would flip to the other side when that direction became the
             long way. TrackEntry chooses the short way the first time it is applied and remembers that direction.</p>
             *
             * @instance
             * @public
             * @this Spine.TrackEntry
             * @memberof Spine.TrackEntry
             * @return  {void}
             */
            ResetRotationDirections: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#ResetRotationDirections", this ); }

                this.timelinesRotation.Clear();
            },
            /*Spine.TrackEntry.ResetRotationDirections end.*/

            /*Spine.TrackEntry.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#toString", this ); }

                return this.animation == null ? "<none>" : this.animation.name;
            },
            /*Spine.TrackEntry.toString end.*/

            /*Spine.TrackEntry.AllowImmediateQueue start.*/
            AllowImmediateQueue: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#AllowImmediateQueue", this ); }

                if (this.nextTrackLast < 0) {
                    this.nextTrackLast = 0;
                }
            },
            /*Spine.TrackEntry.AllowImmediateQueue end.*/


        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.TrackEntry end.*/

    /*Spine.TransformConstraint start.*/
    /**
     * <p>Stores the current pose for a transform constraint. A transform constraint adjusts the world transform of the constrained
     bones to match that of the target bone.</p><p>See <a href="http://esotericsoftware.com/spine-transform-constraints">Transform constraints</a> in the Spine User Guide.</p>
     *
     * @public
     * @class Spine.TransformConstraint
     * @implements  Spine.IUpdatable
     */
    Bridge.define("Spine.TransformConstraint", {
        inherits: [Spine.IUpdatable],
        fields: {
            data: null,
            bones: null,
            target: null,
            mixRotate: 0,
            mixX: 0,
            mixY: 0,
            mixScaleX: 0,
            mixScaleY: 0,
            mixShearY: 0,
            active: false
        },
        props: {
            /**
             * The bones that will be modified by this transform constraint.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.TransformConstraint
             * @function Bones
             * @type Spine.ExposedList$1
             */
            Bones: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#Bones#get", this ); }

                    return this.bones;
                }
            },
            /**
             * The target bone whose world transform will be copied to the constrained bones.
             *
             * @instance
             * @public
             * @memberof Spine.TransformConstraint
             * @function Target
             * @type Spine.Bone
             */
            Target: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#Target#get", this ); }

                    return this.target;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#Target#set", this ); }

                    this.target = value;
                }
            },
            /**
             * A percentage (0-1) that controls the mix between the constrained and unconstrained rotation.
             *
             * @instance
             * @public
             * @memberof Spine.TransformConstraint
             * @function MixRotate
             * @type number
             */
            MixRotate: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#MixRotate#get", this ); }

                    return this.mixRotate;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#MixRotate#set", this ); }

                    this.mixRotate = value;
                }
            },
            /**
             * A percentage (0-1) that controls the mix between the constrained and unconstrained translation X.
             *
             * @instance
             * @public
             * @memberof Spine.TransformConstraint
             * @function MixX
             * @type number
             */
            MixX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#MixX#get", this ); }

                    return this.mixX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#MixX#set", this ); }

                    this.mixX = value;
                }
            },
            /**
             * A percentage (0-1) that controls the mix between the constrained and unconstrained translation Y.
             *
             * @instance
             * @public
             * @memberof Spine.TransformConstraint
             * @function MixY
             * @type number
             */
            MixY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#MixY#get", this ); }

                    return this.mixY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#MixY#set", this ); }

                    this.mixY = value;
                }
            },
            /**
             * A percentage (0-1) that controls the mix between the constrained and unconstrained scale X.
             *
             * @instance
             * @public
             * @memberof Spine.TransformConstraint
             * @function MixScaleX
             * @type number
             */
            MixScaleX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#MixScaleX#get", this ); }

                    return this.mixScaleX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#MixScaleX#set", this ); }

                    this.mixScaleX = value;
                }
            },
            /**
             * A percentage (0-1) that controls the mix between the constrained and unconstrained scale Y.
             *
             * @instance
             * @public
             * @memberof Spine.TransformConstraint
             * @function MixScaleY
             * @type number
             */
            MixScaleY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#MixScaleY#get", this ); }

                    return this.mixScaleY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#MixScaleY#set", this ); }

                    this.mixScaleY = value;
                }
            },
            /**
             * A percentage (0-1) that controls the mix between the constrained and unconstrained shear Y.
             *
             * @instance
             * @public
             * @memberof Spine.TransformConstraint
             * @function MixShearY
             * @type number
             */
            MixShearY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#MixShearY#get", this ); }

                    return this.mixShearY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#MixShearY#set", this ); }

                    this.mixShearY = value;
                }
            },
            Active: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#Active#get", this ); }

                    return this.active;
                }
            },
            /**
             * The transform constraint's setup pose data.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.TransformConstraint
             * @function Data
             * @type Spine.TransformConstraintData
             */
            Data: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#Data#get", this ); }

                    return this.data;
                }
            }
        },
        alias: [
            "Update", "Spine$IUpdatable$Update",
            "Active", "Spine$IUpdatable$Active"
        ],
        ctors: {
            $ctor1: function (data, skeleton) {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#$ctor1", this ); }

                var $t, $t1, $t2;
                this.$initialize();
                if (data == null) {
                    throw new System.ArgumentNullException.$ctor3("data", "data cannot be null.");
                }
                if (skeleton == null) {
                    throw new System.ArgumentNullException.$ctor3("skeleton", "skeleton cannot be null.");
                }
                this.data = data;

                this.bones = new (Spine.ExposedList$1(Spine.Bone)).ctor();
                $t = Bridge.getEnumerator(data.bones);
                try {
                    while ($t.moveNext()) {
                        var boneData = $t.Current;
                        this.bones.Add(($t1 = skeleton.bones.Items)[boneData.index]);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                this.target = ($t2 = skeleton.bones.Items)[data.target.index];

                this.mixRotate = data.mixRotate;
                this.mixX = data.mixX;
                this.mixY = data.mixY;
                this.mixScaleX = data.mixScaleX;
                this.mixScaleY = data.mixScaleY;
                this.mixShearY = data.mixShearY;
            },
            /**
             * Copy constructor.
             *
             * @instance
             * @public
             * @this Spine.TransformConstraint
             * @memberof Spine.TransformConstraint
             * @param   {Spine.TransformConstraint}    constraint    
             * @param   {Spine.Skeleton}               skeleton
             * @return  {void}
             */
            ctor: function (constraint, skeleton) {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#ctor", this ); }

                Spine.TransformConstraint.$ctor1.call(this, constraint.data, skeleton);

                this.mixRotate = constraint.mixRotate;
                this.mixX = constraint.mixX;
                this.mixY = constraint.mixY;
                this.mixScaleX = constraint.mixScaleX;
                this.mixScaleY = constraint.mixScaleY;
                this.mixShearY = constraint.mixShearY;
            }
        },
        methods: {
            /*Spine.TransformConstraint.SetToSetupPose start.*/
            SetToSetupPose: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#SetToSetupPose", this ); }

                var data = this.data;
                this.mixRotate = data.mixRotate;
                this.mixX = data.mixX;
                this.mixY = data.mixY;
                this.mixScaleX = data.mixScaleX;
                this.mixScaleY = data.mixScaleY;
                this.mixShearY = data.mixShearY;
            },
            /*Spine.TransformConstraint.SetToSetupPose end.*/

            /*Spine.TransformConstraint.Update start.*/
            Update: function (physics) {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#Update", this ); }

                if (this.mixRotate === 0 && this.mixX === 0 && this.mixY === 0 && this.mixScaleX === 0 && this.mixScaleY === 0 && this.mixShearY === 0) {
                    return;
                }
                if (this.data.local) {
                    if (this.data.relative) {
                        this.ApplyRelativeLocal();
                    } else {
                        this.ApplyAbsoluteLocal();
                    }
                } else {
                    if (this.data.relative) {
                        this.ApplyRelativeWorld();
                    } else {
                        this.ApplyAbsoluteWorld();
                    }
                }
            },
            /*Spine.TransformConstraint.Update end.*/

            /*Spine.TransformConstraint.ApplyAbsoluteWorld start.*/
            ApplyAbsoluteWorld: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#ApplyAbsoluteWorld", this ); }

                var mixRotate = this.mixRotate, mixX = this.mixX, mixY = this.mixY, mixScaleX = this.mixScaleX, mixScaleY = this.mixScaleY, mixShearY = this.mixShearY;
                var translate = mixX !== 0 || mixY !== 0;

                var target = this.target;
                var ta = target.a, tb = target.b, tc = target.c, td = target.d;
                var degRadReflect = ta * td - tb * tc > 0 ? Spine.MathUtils.DegRad : -0.0174532924;
                var offsetRotation = this.data.offsetRotation * degRadReflect, offsetShearY = this.data.offsetShearY * degRadReflect;

                var bones = this.bones.Items;
                for (var i = 0, n = this.bones.Count; i < n; i = (i + 1) | 0) {
                    var bone = bones[i];

                    if (mixRotate !== 0) {
                        var a = bone.a, b = bone.b, c = bone.c, d = bone.d;
                        var r = Spine.MathUtils.Atan2(tc, ta) - Spine.MathUtils.Atan2(c, a) + offsetRotation;
                        if (r > Spine.MathUtils.PI) {
                            r -= Spine.MathUtils.PI2;
                        } else {
                            if (r < -3.14159274) {
                                r += Spine.MathUtils.PI2;
                            }
                        }
                        r *= mixRotate;
                        var cos = Spine.MathUtils.Cos(r), sin = Spine.MathUtils.Sin(r);
                        bone.a = cos * a - sin * c;
                        bone.b = cos * b - sin * d;
                        bone.c = sin * a + cos * c;
                        bone.d = sin * b + cos * d;
                    }

                    if (translate) {
                        var tx = { }, ty = { }; //Vector2 temp = this.temp;
                        target.LocalToWorld(this.data.offsetX, this.data.offsetY, tx, ty); //target.localToWorld(temp.set(data.offsetX, data.offsetY));
                        bone.worldX += (tx.v - bone.worldX) * mixX;
                        bone.worldY += (ty.v - bone.worldY) * mixY;
                    }

                    if (mixScaleX !== 0) {
                        var s = Math.sqrt(bone.a * bone.a + bone.c * bone.c);
                        if (s !== 0) {
                            s = (s + (Math.sqrt(ta * ta + tc * tc) - s + this.data.offsetScaleX) * mixScaleX) / s;
                        }
                        bone.a *= s;
                        bone.c *= s;
                    }
                    if (mixScaleY !== 0) {
                        var s1 = Math.sqrt(bone.b * bone.b + bone.d * bone.d);
                        if (s1 !== 0) {
                            s1 = (s1 + (Math.sqrt(tb * tb + td * td) - s1 + this.data.offsetScaleY) * mixScaleY) / s1;
                        }
                        bone.b *= s1;
                        bone.d *= s1;
                    }

                    if (mixShearY > 0) {
                        var b1 = bone.b, d1 = bone.d;
                        var by = Spine.MathUtils.Atan2(d1, b1);
                        var r1 = Spine.MathUtils.Atan2(td, tb) - Spine.MathUtils.Atan2(tc, ta) - (by - Spine.MathUtils.Atan2(bone.c, bone.a));
                        if (r1 > Spine.MathUtils.PI) {
                            r1 -= Spine.MathUtils.PI2;
                        } else {
                            if (r1 < -3.14159274) {
                                r1 += Spine.MathUtils.PI2;
                            }
                        }
                        r1 = by + (r1 + offsetShearY) * mixShearY;
                        var s2 = Math.sqrt(b1 * b1 + d1 * d1);
                        bone.b = Spine.MathUtils.Cos(r1) * s2;
                        bone.d = Spine.MathUtils.Sin(r1) * s2;
                    }

                    bone.UpdateAppliedTransform();
                }
            },
            /*Spine.TransformConstraint.ApplyAbsoluteWorld end.*/

            /*Spine.TransformConstraint.ApplyRelativeWorld start.*/
            ApplyRelativeWorld: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#ApplyRelativeWorld", this ); }

                var mixRotate = this.mixRotate, mixX = this.mixX, mixY = this.mixY, mixScaleX = this.mixScaleX, mixScaleY = this.mixScaleY, mixShearY = this.mixShearY;
                var translate = mixX !== 0 || mixY !== 0;

                var target = this.target;
                var ta = target.a, tb = target.b, tc = target.c, td = target.d;
                var degRadReflect = ta * td - tb * tc > 0 ? Spine.MathUtils.DegRad : -0.0174532924;
                var offsetRotation = this.data.offsetRotation * degRadReflect, offsetShearY = this.data.offsetShearY * degRadReflect;

                var bones = this.bones.Items;
                for (var i = 0, n = this.bones.Count; i < n; i = (i + 1) | 0) {
                    var bone = bones[i];

                    if (mixRotate !== 0) {
                        var a = bone.a, b = bone.b, c = bone.c, d = bone.d;
                        var r = Spine.MathUtils.Atan2(tc, ta) + offsetRotation;
                        if (r > Spine.MathUtils.PI) {
                            r -= Spine.MathUtils.PI2;
                        } else {
                            if (r < -3.14159274) {
                                r += Spine.MathUtils.PI2;
                            }
                        }
                        r *= mixRotate;
                        var cos = Spine.MathUtils.Cos(r), sin = Spine.MathUtils.Sin(r);
                        bone.a = cos * a - sin * c;
                        bone.b = cos * b - sin * d;
                        bone.c = sin * a + cos * c;
                        bone.d = sin * b + cos * d;
                    }

                    if (translate) {
                        var tx = { }, ty = { }; //Vector2 temp = this.temp;
                        target.LocalToWorld(this.data.offsetX, this.data.offsetY, tx, ty); //target.localToWorld(temp.set(data.offsetX, data.offsetY));
                        bone.worldX += tx.v * mixX;
                        bone.worldY += ty.v * mixY;
                    }

                    if (mixScaleX !== 0) {
                        var s = (Math.sqrt(ta * ta + tc * tc) - 1 + this.data.offsetScaleX) * mixScaleX + 1;
                        bone.a *= s;
                        bone.c *= s;
                    }
                    if (mixScaleY !== 0) {
                        var s1 = (Math.sqrt(tb * tb + td * td) - 1 + this.data.offsetScaleY) * mixScaleY + 1;
                        bone.b *= s1;
                        bone.d *= s1;
                    }

                    if (mixShearY > 0) {
                        var r1 = Spine.MathUtils.Atan2(td, tb) - Spine.MathUtils.Atan2(tc, ta);
                        if (r1 > Spine.MathUtils.PI) {
                            r1 -= Spine.MathUtils.PI2;
                        } else {
                            if (r1 < -3.14159274) {
                                r1 += Spine.MathUtils.PI2;
                            }
                        }
                        var b1 = bone.b, d1 = bone.d;
                        r1 = Spine.MathUtils.Atan2(d1, b1) + (r1 - 1.57079637 + offsetShearY) * mixShearY;
                        var s2 = Math.sqrt(b1 * b1 + d1 * d1);
                        bone.b = Spine.MathUtils.Cos(r1) * s2;
                        bone.d = Spine.MathUtils.Sin(r1) * s2;
                    }

                    bone.UpdateAppliedTransform();
                }
            },
            /*Spine.TransformConstraint.ApplyRelativeWorld end.*/

            /*Spine.TransformConstraint.ApplyAbsoluteLocal start.*/
            ApplyAbsoluteLocal: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#ApplyAbsoluteLocal", this ); }

                var mixRotate = this.mixRotate, mixX = this.mixX, mixY = this.mixY, mixScaleX = this.mixScaleX, mixScaleY = this.mixScaleY, mixShearY = this.mixShearY;

                var target = this.target;

                var bones = this.bones.Items;
                for (var i = 0, n = this.bones.Count; i < n; i = (i + 1) | 0) {
                    var bone = bones[i];

                    var rotation = bone.arotation;
                    if (mixRotate !== 0) {
                        rotation += (target.arotation - rotation + this.data.offsetRotation) * mixRotate;
                    }

                    var x = bone.ax, y = bone.ay;
                    x += (target.ax - x + this.data.offsetX) * mixX;
                    y += (target.ay - y + this.data.offsetY) * mixY;

                    var scaleX = bone.ascaleX, scaleY = bone.ascaleY;
                    if (mixScaleX !== 0 && scaleX !== 0) {
                        scaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * mixScaleX) / scaleX;
                    }
                    if (mixScaleY !== 0 && scaleY !== 0) {
                        scaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * mixScaleY) / scaleY;
                    }

                    var shearY = bone.ashearY;
                    if (mixShearY !== 0) {
                        shearY += (target.ashearY - shearY + this.data.offsetShearY) * mixShearY;
                    }

                    bone.UpdateWorldTransform$1(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);
                }
            },
            /*Spine.TransformConstraint.ApplyAbsoluteLocal end.*/

            /*Spine.TransformConstraint.ApplyRelativeLocal start.*/
            ApplyRelativeLocal: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#ApplyRelativeLocal", this ); }

                var mixRotate = this.mixRotate, mixX = this.mixX, mixY = this.mixY, mixScaleX = this.mixScaleX, mixScaleY = this.mixScaleY, mixShearY = this.mixShearY;

                var target = this.target;

                var bones = this.bones.Items;
                for (var i = 0, n = this.bones.Count; i < n; i = (i + 1) | 0) {
                    var bone = bones[i];

                    var rotation = bone.arotation + (target.arotation + this.data.offsetRotation) * mixRotate;
                    var x = bone.ax + (target.ax + this.data.offsetX) * mixX;
                    var y = bone.ay + (target.ay + this.data.offsetY) * mixY;
                    var scaleX = bone.ascaleX * (((target.ascaleX - 1 + this.data.offsetScaleX) * mixScaleX) + 1);
                    var scaleY = bone.ascaleY * (((target.ascaleY - 1 + this.data.offsetScaleY) * mixScaleY) + 1);
                    var shearY = bone.ashearY + (target.ashearY + this.data.offsetShearY) * mixShearY;

                    bone.UpdateWorldTransform$1(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);
                }
            },
            /*Spine.TransformConstraint.ApplyRelativeLocal end.*/

            /*Spine.TransformConstraint.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#toString", this ); }

                return this.data.name;
            },
            /*Spine.TransformConstraint.toString end.*/


        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.TransformConstraint end.*/

    /*Spine.TransformConstraintData start.*/
    Bridge.define("Spine.TransformConstraintData", {
        inherits: [Spine.ConstraintData],
        fields: {
            bones: null,
            target: null,
            mixRotate: 0,
            mixX: 0,
            mixY: 0,
            mixScaleX: 0,
            mixScaleY: 0,
            mixShearY: 0,
            offsetRotation: 0,
            offsetX: 0,
            offsetY: 0,
            offsetScaleX: 0,
            offsetScaleY: 0,
            offsetShearY: 0,
            relative: false,
            local: false
        },
        props: {
            Bones: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#Bones#get", this ); }

                    return this.bones;
                }
            },
            Target: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#Target#get", this ); }

                    return this.target;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#Target#set", this ); }

                    this.target = value;
                }
            },
            /**
             * A percentage (0-1) that controls the mix between the constrained and unconstrained rotation.
             *
             * @instance
             * @public
             * @memberof Spine.TransformConstraintData
             * @function MixRotate
             * @type number
             */
            MixRotate: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#MixRotate#get", this ); }

                    return this.mixRotate;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#MixRotate#set", this ); }

                    this.mixRotate = value;
                }
            },
            /**
             * A percentage (0-1) that controls the mix between the constrained and unconstrained translation X.
             *
             * @instance
             * @public
             * @memberof Spine.TransformConstraintData
             * @function MixX
             * @type number
             */
            MixX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#MixX#get", this ); }

                    return this.mixX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#MixX#set", this ); }

                    this.mixX = value;
                }
            },
            /**
             * A percentage (0-1) that controls the mix between the constrained and unconstrained translation Y.
             *
             * @instance
             * @public
             * @memberof Spine.TransformConstraintData
             * @function MixY
             * @type number
             */
            MixY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#MixY#get", this ); }

                    return this.mixY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#MixY#set", this ); }

                    this.mixY = value;
                }
            },
            /**
             * A percentage (0-1) that controls the mix between the constrained and unconstrained scale X.
             *
             * @instance
             * @public
             * @memberof Spine.TransformConstraintData
             * @function MixScaleX
             * @type number
             */
            MixScaleX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#MixScaleX#get", this ); }

                    return this.mixScaleX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#MixScaleX#set", this ); }

                    this.mixScaleX = value;
                }
            },
            /**
             * A percentage (0-1) that controls the mix between the constrained and unconstrained scale Y.
             *
             * @instance
             * @public
             * @memberof Spine.TransformConstraintData
             * @function MixScaleY
             * @type number
             */
            MixScaleY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#MixScaleY#get", this ); }

                    return this.mixScaleY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#MixScaleY#set", this ); }

                    this.mixScaleY = value;
                }
            },
            /**
             * A percentage (0-1) that controls the mix between the constrained and unconstrained shear Y.
             *
             * @instance
             * @public
             * @memberof Spine.TransformConstraintData
             * @function MixShearY
             * @type number
             */
            MixShearY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#MixShearY#get", this ); }

                    return this.mixShearY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#MixShearY#set", this ); }

                    this.mixShearY = value;
                }
            },
            OffsetRotation: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#OffsetRotation#get", this ); }

                    return this.offsetRotation;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#OffsetRotation#set", this ); }

                    this.offsetRotation = value;
                }
            },
            OffsetX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#OffsetX#get", this ); }

                    return this.offsetX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#OffsetX#set", this ); }

                    this.offsetX = value;
                }
            },
            OffsetY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#OffsetY#get", this ); }

                    return this.offsetY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#OffsetY#set", this ); }

                    this.offsetY = value;
                }
            },
            OffsetScaleX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#OffsetScaleX#get", this ); }

                    return this.offsetScaleX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#OffsetScaleX#set", this ); }

                    this.offsetScaleX = value;
                }
            },
            OffsetScaleY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#OffsetScaleY#get", this ); }

                    return this.offsetScaleY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#OffsetScaleY#set", this ); }

                    this.offsetScaleY = value;
                }
            },
            OffsetShearY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#OffsetShearY#get", this ); }

                    return this.offsetShearY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#OffsetShearY#set", this ); }

                    this.offsetShearY = value;
                }
            },
            Relative: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#Relative#get", this ); }

                    return this.relative;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#Relative#set", this ); }

                    this.relative = value;
                }
            },
            Local: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#Local#get", this ); }

                    return this.local;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#Local#set", this ); }

                    this.local = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#init", this ); }

                this.bones = new (Spine.ExposedList$1(Spine.BoneData)).ctor();
            },
            ctor: function (name) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#ctor", this ); }

                this.$initialize();
                Spine.ConstraintData.ctor.call(this, name);
            }
        }
    });
    /*Spine.TransformConstraintData end.*/

    /*Spine.Unity.IHasSkeletonDataAsset start.*/
    /**
     * Holds a reference to a SkeletonDataAsset.
     *
     * @abstract
     * @public
     * @class Spine.Unity.IHasSkeletonDataAsset
     * @implements  Spine.Unity.ISpineComponent
     */
    Bridge.define("Spine.Unity.IHasSkeletonDataAsset", {
        inherits: [Spine.Unity.ISpineComponent],
        $kind: 3
    });
    /*Spine.Unity.IHasSkeletonDataAsset end.*/

    /*Spine.Unity.BlendModeMaterialsAsset start.*/
    Bridge.define("Spine.Unity.BlendModeMaterialsAsset", {
        inherits: [Spine.Unity.SkeletonDataModifierAsset],
        statics: {
            methods: {
                /*Spine.Unity.BlendModeMaterialsAsset.ApplyMaterials:static start.*/
                ApplyMaterials: function (skeletonData, multiplyTemplate, screenTemplate, additiveTemplate, includeAdditiveSlots) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterialsAsset#ApplyMaterials", this ); }

                    var $t, $t1;
                    if (skeletonData == null) {
                        throw new System.ArgumentNullException.$ctor1("skeletonData");
                    }

                    var materialCache = new Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache();
                    try {
                        var entryBuffer = new (System.Collections.Generic.List$1(Spine.Skin.SkinEntry)).ctor();
                        var slotsItems = skeletonData.Slots.Items;
                        for (var slotIndex = 0, slotCount = skeletonData.Slots.Count; slotIndex < slotCount; slotIndex = (slotIndex + 1) | 0) {
                            var slot = slotsItems[slotIndex];
                            if (slot.BlendMode === Spine.BlendMode.Normal) {
                                continue;
                            }
                            if (!includeAdditiveSlots && slot.BlendMode === Spine.BlendMode.Additive) {
                                continue;
                            }

                            entryBuffer.clear();
                            $t = Bridge.getEnumerator(skeletonData.Skins);
                            try {
                                while ($t.moveNext()) {
                                    var skin = $t.Current;
                                    skin.GetAttachments(slotIndex, entryBuffer);
                                }
                            } finally {
                                if (Bridge.is($t, System.IDisposable)) {
                                    $t.System$IDisposable$Dispose();
                                }
                            }

                            var templateMaterial = null;
                            switch (slot.BlendMode) {
                                case Spine.BlendMode.Multiply: 
                                    templateMaterial = multiplyTemplate;
                                    break;
                                case Spine.BlendMode.Screen: 
                                    templateMaterial = screenTemplate;
                                    break;
                                case Spine.BlendMode.Additive: 
                                    templateMaterial = additiveTemplate;
                                    break;
                            }
                            if (templateMaterial == null) {
                                continue;
                            }

                            $t1 = Bridge.getEnumerator(entryBuffer);
                            try {
                                while ($t1.moveNext()) {
                                    var entry = $t1.Current;
                                    var renderableAttachment = Bridge.as(entry.Attachment, Spine.IHasTextureRegion);
                                    if (renderableAttachment != null) {
                                        renderableAttachment.Spine$IHasTextureRegion$Region = materialCache.CloneAtlasRegionWithMaterial(Bridge.cast(renderableAttachment.Spine$IHasTextureRegion$Region, Spine.AtlasRegion), templateMaterial);
                                    }
                                }
                            } finally {
                                if (Bridge.is($t1, System.IDisposable)) {
                                    $t1.System$IDisposable$Dispose();
                                }
                            }
                        }

                    }
                    finally {
                        if (Bridge.hasValue(materialCache)) {
                            materialCache.System$IDisposable$Dispose();
                        }
                    }
                    //attachmentBuffer.Clear();
                },
                /*Spine.Unity.BlendModeMaterialsAsset.ApplyMaterials:static end.*/


            }
        },
        fields: {
            multiplyMaterialTemplate: null,
            screenMaterialTemplate: null,
            additiveMaterialTemplate: null,
            applyAdditiveMaterial: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterialsAsset#init", this ); }

                this.applyAdditiveMaterial = true;
            }
        },
        methods: {
            /*Spine.Unity.BlendModeMaterialsAsset.Apply start.*/
            Apply: function (skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterialsAsset#Apply", this ); }

                Spine.Unity.BlendModeMaterialsAsset.ApplyMaterials(skeletonData, this.multiplyMaterialTemplate, this.screenMaterialTemplate, this.additiveMaterialTemplate, this.applyAdditiveMaterial);
            },
            /*Spine.Unity.BlendModeMaterialsAsset.Apply end.*/


        }
    });
    /*Spine.Unity.BlendModeMaterialsAsset end.*/

    /*Spine.Unity.IAnimationStateComponent start.*/
    /**
     * A Spine-Unity Component that uses a Spine.AnimationState to animate its skeleton.
     *
     * @abstract
     * @public
     * @class Spine.Unity.IAnimationStateComponent
     * @implements  Spine.Unity.ISpineComponent
     */
    Bridge.define("Spine.Unity.IAnimationStateComponent", {
        inherits: [Spine.Unity.ISpineComponent],
        $kind: 3
    });
    /*Spine.Unity.IAnimationStateComponent end.*/

    /*Spine.Unity.IHasSkeletonComponent start.*/
    /**
     * A Spine-Unity Component that holds a reference to an ISkeletonComponent.
     *
     * @abstract
     * @public
     * @class Spine.Unity.IHasSkeletonComponent
     * @implements  Spine.Unity.ISpineComponent
     */
    Bridge.define("Spine.Unity.IHasSkeletonComponent", {
        inherits: [Spine.Unity.ISpineComponent],
        $kind: 3
    });
    /*Spine.Unity.IHasSkeletonComponent end.*/

    /*Spine.Unity.IHasSkeletonRenderer start.*/
    /**
     * A Spine-Unity Component that holds a reference to a SkeletonRenderer.
     *
     * @abstract
     * @public
     * @class Spine.Unity.IHasSkeletonRenderer
     * @implements  Spine.Unity.ISpineComponent
     */
    Bridge.define("Spine.Unity.IHasSkeletonRenderer", {
        inherits: [Spine.Unity.ISpineComponent],
        $kind: 3
    });
    /*Spine.Unity.IHasSkeletonRenderer end.*/

    /*Spine.Unity.ISkeletonAnimation start.*/
    /**
     * A Spine-Unity Component that animates a Skeleton but not necessarily with a Spine.AnimationState.
     *
     * @abstract
     * @public
     * @class Spine.Unity.ISkeletonAnimation
     * @implements  Spine.Unity.ISpineComponent
     */
    Bridge.define("Spine.Unity.ISkeletonAnimation", {
        inherits: [Spine.Unity.ISpineComponent],
        $kind: 3
    });
    /*Spine.Unity.ISkeletonAnimation end.*/

    /*Spine.Unity.ISkeletonComponent start.*/
    /**
     * A Spine-Unity Component that manages a Spine.Skeleton instance, instantiated from a SkeletonDataAsset.
     *
     * @abstract
     * @public
     * @class Spine.Unity.ISkeletonComponent
     * @implements  Spine.Unity.ISpineComponent
     */
    Bridge.define("Spine.Unity.ISkeletonComponent", {
        inherits: [Spine.Unity.ISpineComponent],
        $kind: 3
    });
    /*Spine.Unity.ISkeletonComponent end.*/

    /*Spine.Unity.MaterialsTextureLoader start.*/
    Bridge.define("Spine.Unity.MaterialsTextureLoader", {
        inherits: [Spine.TextureLoader],
        fields: {
            atlasAsset: null
        },
        alias: [
            "Load", "Spine$TextureLoader$Load",
            "Unload", "Spine$TextureLoader$Unload"
        ],
        ctors: {
            ctor: function (atlasAsset) {
if ( TRACE ) { TRACE( "Spine.Unity.MaterialsTextureLoader#ctor", this ); }

                this.$initialize();
                this.atlasAsset = atlasAsset;
            }
        },
        methods: {
            /*Spine.Unity.MaterialsTextureLoader.Load start.*/
            Load: function (page, path) {
if ( TRACE ) { TRACE( "Spine.Unity.MaterialsTextureLoader#Load", this ); }

                var $t;
                var name = System.IO.Path.GetFileNameWithoutExtension(path);
                var material = null;
                $t = Bridge.getEnumerator(this.atlasAsset.materials);
                try {
                    while ($t.moveNext()) {
                        var other = $t.Current;
                        if (other.mainTexture == null) {
                            UnityEngine.Debug.LogError$2("Material is missing texture: " + (other.name || ""), other);
                            return;
                        }
                        var textureName = other.mainTexture.name;
                        if (Bridge.referenceEquals(textureName, name) || (this.atlasAsset.OnDemandTextureLoader != null && Bridge.referenceEquals(textureName, this.atlasAsset.OnDemandTextureLoader.GetPlaceholderTextureName(name)))) {
                            material = other;
                            break;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                if (material == null) {
                    UnityEngine.Debug.LogError$2("Material with texture name \"" + (name || "") + "\" not found for atlas asset: " + (this.atlasAsset.name || ""), this.atlasAsset);
                    return;
                }
                page.rendererObject = material;

                // Very old atlas files expected the texture's actual size to be used at runtime.
                if (page.width === 0 || page.height === 0) {
                    page.width = material.mainTexture.width;
                    page.height = material.mainTexture.height;
                }
            },
            /*Spine.Unity.MaterialsTextureLoader.Load end.*/

            /*Spine.Unity.MaterialsTextureLoader.Unload start.*/
            Unload: function (texture) {
if ( TRACE ) { TRACE( "Spine.Unity.MaterialsTextureLoader#Unload", this ); }
 },
            /*Spine.Unity.MaterialsTextureLoader.Unload end.*/


        }
    });
    /*Spine.Unity.MaterialsTextureLoader end.*/

    /*Spine.Unity.NoOpTextureLoader start.*/
    Bridge.define("Spine.Unity.NoOpTextureLoader", {
        inherits: [Spine.TextureLoader],
        alias: [
            "Load", "Spine$TextureLoader$Load",
            "Unload", "Spine$TextureLoader$Unload"
        ],
        methods: {
            /*Spine.Unity.NoOpTextureLoader.Load start.*/
            Load: function (page, path) {
if ( TRACE ) { TRACE( "Spine.Unity.NoOpTextureLoader#Load", this ); }
 },
            /*Spine.Unity.NoOpTextureLoader.Load end.*/

            /*Spine.Unity.NoOpTextureLoader.Unload start.*/
            Unload: function (texture) {
if ( TRACE ) { TRACE( "Spine.Unity.NoOpTextureLoader#Unload", this ); }
 },
            /*Spine.Unity.NoOpTextureLoader.Unload end.*/


        }
    });
    /*Spine.Unity.NoOpTextureLoader end.*/

    /*Spine.Unity.RegionlessAttachmentLoader start.*/
    Bridge.define("Spine.Unity.RegionlessAttachmentLoader", {
        inherits: [Spine.AttachmentLoader],
        statics: {
            fields: {
                emptyRegion: null
            },
            props: {
                EmptyRegion: {
                    get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.RegionlessAttachmentLoader#EmptyRegion#get", this ); }

                        var $t, $t1, $t2;
                        if (Spine.Unity.RegionlessAttachmentLoader.emptyRegion == null) {
                            var hiddenShader = UnityEngine.Shader.Find("Spine/Special/HiddenPass");
                            if (hiddenShader == null) {
                                UnityEngine.Debug.LogError$2("Shader \"Spine/Special/HiddenPass\" not found while loading SkeletonDataAsset with 0 Atlas Assets. Please add this shader to Project Settings - Graphics - Always Included Shaders, or make sure your SkeletonDataAssets all have an AtlasAsset assigned.");
                            }
                            Spine.Unity.RegionlessAttachmentLoader.emptyRegion = ($t = new Spine.AtlasRegion(), $t.name = "Empty AtlasRegion", $t.page = ($t1 = new Spine.AtlasPage(), $t1.name = "Empty AtlasPage", $t1.rendererObject = ($t2 = new UnityEngine.Material.$ctor2(hiddenShader), $t2.name = "NoRender Material", $t2), $t1), $t);
                        }
                        return Spine.Unity.RegionlessAttachmentLoader.emptyRegion;
                    }
                }
            }
        },
        alias: [
            "NewRegionAttachment", "Spine$AttachmentLoader$NewRegionAttachment",
            "NewMeshAttachment", "Spine$AttachmentLoader$NewMeshAttachment",
            "NewBoundingBoxAttachment", "Spine$AttachmentLoader$NewBoundingBoxAttachment",
            "NewPathAttachment", "Spine$AttachmentLoader$NewPathAttachment",
            "NewPointAttachment", "Spine$AttachmentLoader$NewPointAttachment",
            "NewClippingAttachment", "Spine$AttachmentLoader$NewClippingAttachment"
        ],
        methods: {
            /*Spine.Unity.RegionlessAttachmentLoader.NewRegionAttachment start.*/
            NewRegionAttachment: function (skin, name, path, sequence) {
if ( TRACE ) { TRACE( "Spine.Unity.RegionlessAttachmentLoader#NewRegionAttachment", this ); }

                var $t;
                var attachment = ($t = new Spine.RegionAttachment.$ctor1(name), $t.Region = Spine.Unity.RegionlessAttachmentLoader.EmptyRegion, $t);
                return attachment;
            },
            /*Spine.Unity.RegionlessAttachmentLoader.NewRegionAttachment end.*/

            /*Spine.Unity.RegionlessAttachmentLoader.NewMeshAttachment start.*/
            NewMeshAttachment: function (skin, name, path, sequence) {
if ( TRACE ) { TRACE( "Spine.Unity.RegionlessAttachmentLoader#NewMeshAttachment", this ); }

                var $t;
                var attachment = ($t = new Spine.MeshAttachment.$ctor1(name), $t.Region = Spine.Unity.RegionlessAttachmentLoader.EmptyRegion, $t);
                return attachment;
            },
            /*Spine.Unity.RegionlessAttachmentLoader.NewMeshAttachment end.*/

            /*Spine.Unity.RegionlessAttachmentLoader.NewBoundingBoxAttachment start.*/
            NewBoundingBoxAttachment: function (skin, name) {
if ( TRACE ) { TRACE( "Spine.Unity.RegionlessAttachmentLoader#NewBoundingBoxAttachment", this ); }

                return new Spine.BoundingBoxAttachment.$ctor1(name);
            },
            /*Spine.Unity.RegionlessAttachmentLoader.NewBoundingBoxAttachment end.*/

            /*Spine.Unity.RegionlessAttachmentLoader.NewPathAttachment start.*/
            NewPathAttachment: function (skin, name) {
if ( TRACE ) { TRACE( "Spine.Unity.RegionlessAttachmentLoader#NewPathAttachment", this ); }

                return new Spine.PathAttachment.$ctor1(name);
            },
            /*Spine.Unity.RegionlessAttachmentLoader.NewPathAttachment end.*/

            /*Spine.Unity.RegionlessAttachmentLoader.NewPointAttachment start.*/
            NewPointAttachment: function (skin, name) {
if ( TRACE ) { TRACE( "Spine.Unity.RegionlessAttachmentLoader#NewPointAttachment", this ); }

                return new Spine.PointAttachment.$ctor1(name);
            },
            /*Spine.Unity.RegionlessAttachmentLoader.NewPointAttachment end.*/

            /*Spine.Unity.RegionlessAttachmentLoader.NewClippingAttachment start.*/
            NewClippingAttachment: function (skin, name) {
if ( TRACE ) { TRACE( "Spine.Unity.RegionlessAttachmentLoader#NewClippingAttachment", this ); }

                return new Spine.ClippingAttachment.$ctor1(name);
            },
            /*Spine.Unity.RegionlessAttachmentLoader.NewClippingAttachment end.*/


        }
    });
    /*Spine.Unity.RegionlessAttachmentLoader end.*/

    /*Spine.Unity.SkeletonMecanimRootMotion start.*/
    /**
     * Add this component to a SkeletonMecanim GameObject
     to turn motion of a selected root bone into Transform or RigidBody motion.
     Local bone translation movement is used as motion.
     All top-level bones of the skeleton are moved to compensate the root
     motion bone location, keeping the distance relationship between bones intact.
     *
     * @public
     * @class Spine.Unity.SkeletonMecanimRootMotion
     * @augments Spine.Unity.SkeletonRootMotionBase
     */
    Bridge.define("Spine.Unity.SkeletonMecanimRootMotion", {
        inherits: [Spine.Unity.SkeletonRootMotionBase],
        statics: {
            fields: {
                DefaultMecanimLayerFlags: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#init", this ); }

                    this.DefaultMecanimLayerFlags = -1;
                }
            }
        },
        fields: {
            mecanimLayerFlags: 0,
            movementDelta: null,
            rotationDelta: 0,
            skeletonMecanim: null
        },
        props: {
            SkeletonMecanim: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#SkeletonMecanim#get", this ); }

                    return UnityEngine.Object.op_Implicit(this.skeletonMecanim) ? this.skeletonMecanim : (this.skeletonMecanim = this.GetComponent(Spine.Unity.SkeletonMecanim));
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#init", this ); }

                this.movementDelta = new UnityEngine.Vector2();
                this.mecanimLayerFlags = -1;
            }
        },
        methods: {
            /*Spine.Unity.SkeletonMecanimRootMotion.GetRemainingRootMotion start.*/
            GetRemainingRootMotion: function (layerIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#GetRemainingRootMotion", this ); }

                var pair = this.skeletonMecanim.Translator.GetActiveAnimationAndTime(layerIndex);
                var animation = pair.key;
                var time = pair.value;
                if (animation == null) {
                    return pc.Vec2.ZERO.clone();
                }

                var start = time;
                var end = animation.Duration;
                return this.GetAnimationRootMotion$1(start, end, animation);
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.GetRemainingRootMotion end.*/

            /*Spine.Unity.SkeletonMecanimRootMotion.GetRootMotionInfo start.*/
            GetRootMotionInfo: function (layerIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#GetRootMotionInfo", this ); }

                var pair = this.skeletonMecanim.Translator.GetActiveAnimationAndTime(layerIndex);
                var animation = pair.key;
                var time = pair.value;
                if (animation == null) {
                    return new Spine.Unity.SkeletonRootMotionBase.RootMotionInfo();
                }
                return this.GetAnimationRootMotionInfo(animation, time);
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.GetRootMotionInfo end.*/

            /*Spine.Unity.SkeletonMecanimRootMotion.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#Reset", this ); }

                Spine.Unity.SkeletonRootMotionBase.prototype.Reset.call(this);
                this.mecanimLayerFlags = Spine.Unity.SkeletonMecanimRootMotion.DefaultMecanimLayerFlags;
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.Reset end.*/

            /*Spine.Unity.SkeletonMecanimRootMotion.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#Initialize", this ); }

                Spine.Unity.SkeletonRootMotionBase.prototype.Initialize.call(this);
                this.skeletonMecanim = this.GetComponent(Spine.Unity.SkeletonMecanim);
                if (UnityEngine.Object.op_Implicit(this.skeletonMecanim)) {
                    this.skeletonMecanim.Translator.removeOnClipApplied(Bridge.fn.cacheBind(this, this.OnClipApplied));
                    this.skeletonMecanim.Translator.addOnClipApplied(Bridge.fn.cacheBind(this, this.OnClipApplied));
                }
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.Initialize end.*/

            /*Spine.Unity.SkeletonMecanimRootMotion.OnClipApplied start.*/
            OnClipApplied: function (animation, layerIndex, weight, time, lastTime, playsBackward) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#OnClipApplied", this ); }


                if (((this.mecanimLayerFlags & 1 << layerIndex) === 0) || weight === 0) {
                    return;
                }

                if (!playsBackward) {
                    this.movementDelta = this.movementDelta.$clone().add( this.GetAnimationRootMotion$1(lastTime, time, animation).scale( weight ) );
                } else {
                    this.movementDelta = this.movementDelta.$clone().sub( this.GetAnimationRootMotion$1(time, lastTime, animation).scale( weight ) );
                }
                if (this.transformRotation) {
                    if (!playsBackward) {
                        this.rotationDelta += weight * this.GetAnimationRootMotionRotation$1(lastTime, time, animation);
                    } else {
                        this.rotationDelta -= weight * this.GetAnimationRootMotionRotation$1(time, lastTime, animation);
                    }
                }
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.OnClipApplied end.*/

            /*Spine.Unity.SkeletonMecanimRootMotion.CalculateAnimationsMovementDelta start.*/
            CalculateAnimationsMovementDelta: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#CalculateAnimationsMovementDelta", this ); }

                // Note: movement delta is not gathered after animation but
                // in OnClipApplied after every applied animation.
                var result = this.movementDelta.$clone();
                this.movementDelta = pc.Vec2.ZERO.clone();
                return result.$clone();
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.CalculateAnimationsMovementDelta end.*/

            /*Spine.Unity.SkeletonMecanimRootMotion.CalculateAnimationsRotationDelta start.*/
            CalculateAnimationsRotationDelta: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#CalculateAnimationsRotationDelta", this ); }

                // Note: movement delta is not gathered after animation but
                // in OnClipApplied after every applied animation.
                var result = this.rotationDelta;
                this.rotationDelta = 0;
                return result;
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.CalculateAnimationsRotationDelta end.*/


        }
    });
    /*Spine.Unity.SkeletonMecanimRootMotion end.*/

    /*Spine.Unity.SkeletonRootMotion start.*/
    /**
     * Add this component to a SkeletonAnimation or SkeletonGraphic GameObject
     to turn motion of a selected root bone into Transform or RigidBody motion.
     Local bone translation movement is used as motion.
     All top-level bones of the skeleton are moved to compensate the root
     motion bone location, keeping the distance relationship between bones intact.
     *
     * @public
     * @class Spine.Unity.SkeletonRootMotion
     * @augments Spine.Unity.SkeletonRootMotionBase
     */
    Bridge.define("Spine.Unity.SkeletonRootMotion", {
        inherits: [Spine.Unity.SkeletonRootMotionBase],
        statics: {
            fields: {
                DefaultAnimationTrackFlags: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#init", this ); }

                    this.DefaultAnimationTrackFlags = -1;
                }
            }
        },
        fields: {
            animationTrackFlags: 0,
            animationState: null,
            skeletonGraphic: null
        },
        props: {
            AdditionalScale: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#AdditionalScale#get", this ); }

                    return UnityEngine.Object.op_Implicit(this.skeletonGraphic) ? this.skeletonGraphic.MeshScale : 1.0;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#init", this ); }

                this.animationTrackFlags = -1;
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRootMotion.GetRemainingRootMotion start.*/
            GetRemainingRootMotion: function (trackIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#GetRemainingRootMotion", this ); }

                var track = this.animationState.GetCurrent(trackIndex);
                if (track == null) {
                    return pc.Vec2.ZERO.clone();
                }

                var animation = track.Animation;
                var start = track.AnimationTime;
                var end = animation.Duration;
                return this.GetAnimationRootMotion$1(start, end, animation);
            },
            /*Spine.Unity.SkeletonRootMotion.GetRemainingRootMotion end.*/

            /*Spine.Unity.SkeletonRootMotion.GetRootMotionInfo start.*/
            GetRootMotionInfo: function (trackIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#GetRootMotionInfo", this ); }

                var track = this.animationState.GetCurrent(trackIndex);
                if (track == null) {
                    return new Spine.Unity.SkeletonRootMotionBase.RootMotionInfo();
                }

                var animation = track.Animation;
                var time = track.AnimationTime;
                return this.GetAnimationRootMotionInfo(track.Animation, time);
            },
            /*Spine.Unity.SkeletonRootMotion.GetRootMotionInfo end.*/

            /*Spine.Unity.SkeletonRootMotion.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#Reset", this ); }

                Spine.Unity.SkeletonRootMotionBase.prototype.Reset.call(this);
                this.animationTrackFlags = Spine.Unity.SkeletonRootMotion.DefaultAnimationTrackFlags;
            },
            /*Spine.Unity.SkeletonRootMotion.Reset end.*/

            /*Spine.Unity.SkeletonRootMotion.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#Initialize", this ); }

                Spine.Unity.SkeletonRootMotionBase.prototype.Initialize.call(this);
                var animstateComponent = Bridge.as(this.skeletonComponent, Spine.Unity.IAnimationStateComponent);
                this.animationState = (animstateComponent != null) ? animstateComponent.Spine$Unity$IAnimationStateComponent$AnimationState : null;

                this.skeletonGraphic = this.GetComponent(Spine.Unity.SkeletonGraphic);
            },
            /*Spine.Unity.SkeletonRootMotion.Initialize end.*/

            /*Spine.Unity.SkeletonRootMotion.CalculateAnimationsMovementDelta start.*/
            CalculateAnimationsMovementDelta: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#CalculateAnimationsMovementDelta", this ); }

                var localDelta = pc.Vec2.ZERO.clone();
                var trackCount = this.animationState.Tracks.Count;

                for (var trackIndex = 0; trackIndex < trackCount; trackIndex = (trackIndex + 1) | 0) {
                    // note: animationTrackFlags != -1 below covers trackIndex >= 32,
                    // with -1 corresponding to entry "everything" of the dropdown list.
                    if (this.animationTrackFlags !== -1 && (this.animationTrackFlags & 1 << trackIndex) === 0) {
                        continue;
                    }

                    var track = this.animationState.GetCurrent(trackIndex);
                    var next = null;
                    while (track != null) {
                        var animation = track.Animation;
                        var start = track.AnimationLast;
                        var end = track.AnimationTime;
                        var currentDelta = { v : this.GetAnimationRootMotion$1(start, end, animation) };
                        if (!pc.Vec2.equals( currentDelta.v, pc.Vec2.ZERO.clone() )) {
                            this.ApplyMixAlphaToDelta$1(currentDelta, next, track);
                            localDelta = localDelta.$clone().add( currentDelta.v.$clone() );
                        }

                        // Traverse mixingFrom chain.
                        next = track;
                        track = track.MixingFrom;
                    }
                }
                return localDelta.$clone();
            },
            /*Spine.Unity.SkeletonRootMotion.CalculateAnimationsMovementDelta end.*/

            /*Spine.Unity.SkeletonRootMotion.CalculateAnimationsRotationDelta start.*/
            CalculateAnimationsRotationDelta: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#CalculateAnimationsRotationDelta", this ); }

                var localDelta = 0;
                var trackCount = this.animationState.Tracks.Count;

                for (var trackIndex = 0; trackIndex < trackCount; trackIndex = (trackIndex + 1) | 0) {
                    // note: animationTrackFlags != -1 below covers trackIndex >= 32,
                    // with -1 corresponding to entry "everything" of the dropdown list.
                    if (this.animationTrackFlags !== -1 && (this.animationTrackFlags & 1 << trackIndex) === 0) {
                        continue;
                    }

                    var track = this.animationState.GetCurrent(trackIndex);
                    var next = null;
                    while (track != null) {
                        var animation = track.Animation;
                        var start = track.AnimationLast;
                        var end = track.AnimationTime;
                        var currentDelta = { v : this.GetAnimationRootMotionRotation$1(start, end, animation) };
                        if (currentDelta.v !== 0) {
                            this.ApplyMixAlphaToDelta(currentDelta, next, track);
                            localDelta += currentDelta.v;
                        }

                        // Traverse mixingFrom chain.
                        next = track;
                        track = track.MixingFrom;
                    }
                }
                return localDelta;
            },
            /*Spine.Unity.SkeletonRootMotion.CalculateAnimationsRotationDelta end.*/

            /*Spine.Unity.SkeletonRootMotion.ApplyMixAlphaToDelta$1 start.*/
            ApplyMixAlphaToDelta$1: function (currentDelta, next, track) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#ApplyMixAlphaToDelta$1", this ); }

                var mixAlpha = { v : 1 };
                this.GetMixAlpha(mixAlpha, next, track);
                currentDelta.v = currentDelta.v.$clone().scale( mixAlpha.v );
            },
            /*Spine.Unity.SkeletonRootMotion.ApplyMixAlphaToDelta$1 end.*/

            /*Spine.Unity.SkeletonRootMotion.ApplyMixAlphaToDelta start.*/
            ApplyMixAlphaToDelta: function (currentDelta, next, track) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#ApplyMixAlphaToDelta", this ); }

                var mixAlpha = { v : 1 };
                this.GetMixAlpha(mixAlpha, next, track);
                currentDelta.v *= mixAlpha.v;
            },
            /*Spine.Unity.SkeletonRootMotion.ApplyMixAlphaToDelta end.*/

            /*Spine.Unity.SkeletonRootMotion.GetMixAlpha start.*/
            GetMixAlpha: function (cumulatedMixAlpha, next, track) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#GetMixAlpha", this ); }

                // code below based on AnimationState.cs
                var mix;
                if (next != null) {
                    if (next.MixDuration === 0) { // Single frame mix to undo mixingFrom changes.
                        mix = 1;
                    } else {
                        mix = next.MixTime / next.MixDuration;
                        if (mix > 1) {
                            mix = 1;
                        }
                    }
                    var mixAndAlpha = track.Alpha * next.InterruptAlpha * (1 - mix);
                    cumulatedMixAlpha.v *= mixAndAlpha;
                } else {
                    if (track.MixDuration === 0) {
                        mix = 1;
                    } else {
                        mix = track.Alpha * (track.MixTime / track.MixDuration);
                        if (mix > 1) {
                            mix = 1;
                        }
                    }
                    cumulatedMixAlpha.v *= mix;
                }
            },
            /*Spine.Unity.SkeletonRootMotion.GetMixAlpha end.*/


        },
        overloads: {
            "ApplyMixAlphaToDelta(Vector2, TrackEntry, TrackEntry)": "ApplyMixAlphaToDelta$1"
        }
    });
    /*Spine.Unity.SkeletonRootMotion end.*/

    /*Spine.Unity.SpineAnimation start.*/
    Bridge.define("Spine.Unity.SpineAnimation", {
        inherits: [Spine.Unity.SpineAttributeBase],
        ctors: {
            
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField, avoidGenericMenu) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAnimation#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }
                if (avoidGenericMenu === void 0) { avoidGenericMenu = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);

                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
                this.avoidGenericMenu = avoidGenericMenu;
            }
        }
    });
    /*Spine.Unity.SpineAnimation end.*/
    /** @namespace System */

    /**
     * @memberof System
     * @callback System.Func
     * @param   {Spine.Unity.SpineAtlasAsset}    arg
     * @return  {Spine.TextureLoader}
     */


    /*Spine.Unity.SpineAtlasAsset start.*/
    /**
     * Loads and stores a Spine atlas and list of materials.
     *
     * @public
     * @class Spine.Unity.SpineAtlasAsset
     * @augments Spine.Unity.AtlasAssetBase
     */
    Bridge.define("Spine.Unity.SpineAtlasAsset", {
        inherits: [Spine.Unity.AtlasAssetBase],
        statics: {
            methods: {
                /*Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance:static start.*/
                /**
                 * Creates a runtime AtlasAsset
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SpineAtlasAsset
                 * @memberof Spine.Unity.SpineAtlasAsset
                 * @param   {UnityEngine.TextAsset}           atlasText                 
                 * @param   {Array.<UnityEngine.Material>}    materials                 
                 * @param   {boolean}                         initialize                
                 * @param   {System.Func}                     newCustomTextureLoader    When not null, a function instantiating
                 a custom <pre><code>TextureLoader</code></pre> with the newly created <pre><code>SpineAtlasAsset</code></pre> as argument
                 is used instead of instantiating the default <pre><code>MaterialsTextureLoader</code></pre>.
                 A valid parameter is e.g. <pre><code>(a) =&gt; new CustomTextureLoader(a)</code></pre>
                 * @return  {Spine.Unity.SpineAtlasAsset}
                 */
                CreateRuntimeInstance: function (atlasText, materials, initialize, newCustomTextureLoader) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#CreateRuntimeInstance", this ); }

                    if (newCustomTextureLoader === void 0) { newCustomTextureLoader = null; }

                    var atlasAsset = UnityEngine.ScriptableObject.CreateInstance(Spine.Unity.SpineAtlasAsset);
                    atlasAsset.Reset();
                    atlasAsset.atlasFile = atlasText;
                    atlasAsset.materials = materials;
                    if (!Bridge.staticEquals(newCustomTextureLoader, null)) {
                        atlasAsset.customTextureLoader = newCustomTextureLoader(atlasAsset);
                    }

                    if (initialize) {
                        atlasAsset.GetAtlas();
                    }

                    return atlasAsset;
                },
                /*Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance:static end.*/

                /*Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance$1:static start.*/
                /**
                 * Creates a runtime AtlasAsset. Only providing the textures is slower
                 because it has to search for atlas page matches.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SpineAtlasAsset
                 * @memberof Spine.Unity.SpineAtlasAsset
                 * @param   {UnityEngine.TextAsset}            atlasText                 
                 * @param   {Array.<UnityEngine.Texture2D>}    textures                  An array of all textures referenced in the provided <pre><code>atlasText</code></pre>
                 atlas asset JSON file. When procedurally creating textures, each <pre><code>Texture.name</code></pre>
                 needs to be set to the atlas page texture filename without the .png extension,
                 e.g. 'my_skeleton' if the png filename listed in the atlas asset file is 'my_skeleton.png'.
                 * @param   {UnityEngine.Material}             materialPropertySource    
                 * @param   {boolean}                          initialize                
                 * @param   {System.Func}                      newCustomTextureLoader    
                 * @param   {boolean}                          renameMaterial            If true, newly created materials will be renamed to the atlas texture page name.
                 If false, the materials keep the name of the <pre><code>materialPropertySource</code></pre> material they are copied from.
                 * @return  {Spine.Unity.SpineAtlasAsset}
                 * @see {@link SpineAtlasAsset.CreateRuntimeInstance(TextAsset, Material[], bool, Func{SpineAtlasAsset, TextureLoader})}
                 */
                CreateRuntimeInstance$1: function (atlasText, textures, materialPropertySource, initialize, newCustomTextureLoader, renameMaterial) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#CreateRuntimeInstance$1", this ); }

                    if (newCustomTextureLoader === void 0) { newCustomTextureLoader = null; }
                    if (renameMaterial === void 0) { renameMaterial = false; }

                    // Get atlas page names.
                    var atlasString = atlasText.text;
                    atlasString = System.String.replaceAll(atlasString, "\r", "");
                    var atlasLines = System.String.split(atlasString, [10].map(function (i) {{ return String.fromCharCode(i); }}));
                    var pages = new (System.Collections.Generic.List$1(System.String)).ctor();
                    for (var i = 0; i < ((atlasLines.length - 1) | 0); i = (i + 1) | 0) {
                        var line = atlasLines[i].trim();
                        if (System.String.endsWith(line, ".png")) {
                            pages.add(System.String.replaceAll(line, ".png", ""));
                        }
                    }

                    // Populate Materials[] by matching texture names with page names.
                    var materials = System.Array.init(pages.Count, null, UnityEngine.Material);
                    for (var i1 = 0, n = pages.Count; i1 < n; i1 = (i1 + 1) | 0) {
                        var mat = null;

                        // Search for a match.
                        var pageName = pages.getItem(i1);
                        for (var j = 0, m = textures.length; j < m; j = (j + 1) | 0) {
                            if (System.String.equals(pageName, textures[j].name, 5)) {
                                // Match found.
                                mat = new UnityEngine.Material.$ctor1(materialPropertySource);
                                mat.mainTexture = textures[j];
                                if (renameMaterial) {
                                    mat.name = pageName;
                                }
                                break;
                            }
                        }

                        if (mat != null) {
                            materials[i1] = mat;
                        } else {
                            throw new System.ArgumentException.$ctor1("Could not find matching atlas page in the texture array.");
                        }
                    }

                    // Create AtlasAsset normally
                    return Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance(atlasText, materials, initialize, newCustomTextureLoader);
                },
                /*Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance$1:static end.*/

                /*Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance$2:static start.*/
                
                CreateRuntimeInstance$2: function (atlasText, textures, shader, initialize, newCustomTextureLoader) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#CreateRuntimeInstance$2", this ); }

                    if (newCustomTextureLoader === void 0) { newCustomTextureLoader = null; }

                    if (shader == null) {
                        shader = UnityEngine.Shader.Find("Spine/Skeleton");
                    }

                    var materialProperySource = new UnityEngine.Material.$ctor2(shader);
                    return Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance$1(atlasText, textures, materialProperySource, initialize, newCustomTextureLoader);
                },
                /*Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance$2:static end.*/


            }
        },
        fields: {
            atlasFile: null,
            materials: null,
            customTextureLoader: null,
            atlas: null
        },
        props: {
            IsLoaded: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#IsLoaded#get", this ); }

                    return this.atlas != null;
                }
            },
            Materials: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#Materials#get", this ); }

                    return this.materials;
                }
            },
            MaterialCount: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#MaterialCount#get", this ); }

                    return this.materials == null ? 0 : this.materials.length;
                }
            },
            PrimaryMaterial: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#PrimaryMaterial#get", this ); }

                    return this.materials[0];
                }
            }
        },
        methods: {
            /*Spine.Unity.SpineAtlasAsset.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#Reset", this ); }

                this.Clear();
            },
            /*Spine.Unity.SpineAtlasAsset.Reset end.*/

            /*Spine.Unity.SpineAtlasAsset.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#Clear", this ); }

                this.atlas = null;
            },
            /*Spine.Unity.SpineAtlasAsset.Clear end.*/

            /*Spine.Unity.SpineAtlasAsset.GetAtlas start.*/
            /**
             * @instance
             * @public
             * @override
             * @this Spine.Unity.SpineAtlasAsset
             * @memberof Spine.Unity.SpineAtlasAsset
             * @param   {boolean}        onlyMetaData
             * @return  {Spine.Atlas}                    The atlas or null if it could not be loaded.
             */
            GetAtlas: function (onlyMetaData) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#GetAtlas", this ); }

                if (onlyMetaData === void 0) { onlyMetaData = false; }
                if (this.atlasFile == null) {
                    UnityEngine.Debug.LogError$2("Atlas file not set for atlas asset: " + (this.name || ""), this);
                    this.Clear();
                    return null;
                }

                if (!onlyMetaData && (this.materials == null || this.materials.length === 0)) {
                    UnityEngine.Debug.LogError$2("Materials not set for atlas asset: " + (this.name || ""), this);
                    this.Clear();
                    return null;
                }

                if (this.atlas != null) {
                    return this.atlas;
                }

                try {
                    var loader;
                    if (!onlyMetaData) {
                        loader = this.customTextureLoader == null ? new Spine.Unity.MaterialsTextureLoader(this) : this.customTextureLoader;
                    } else {
                        loader = new Spine.Unity.NoOpTextureLoader();
                    }
                    this.atlas = new Spine.Atlas.$ctor1(new System.IO.StringReader(this.atlasFile.text), "", loader);
                    this.atlas.FlipV();
                    return this.atlas;
                } catch (ex) {
                    ex = System.Exception.create(ex);
                    UnityEngine.Debug.LogError$2("Error reading atlas file for atlas asset: " + (this.name || "") + "\n" + (ex.Message || "") + "\n" + (ex.StackTrace || ""), this);
                    return null;
                }
            },
            /*Spine.Unity.SpineAtlasAsset.GetAtlas end.*/

            /*Spine.Unity.SpineAtlasAsset.GenerateMesh start.*/
            GenerateMesh: function (name, mesh, material, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#GenerateMesh", this ); }

                if (scale === void 0) { scale = 0.01; }
                var region = this.atlas.FindRegion(name);
                material.v = null;
                if (region != null) {
                    if (mesh == null) {
                        mesh = new UnityEngine.Mesh.ctor();
                        mesh.name = name;
                    }

                    var verts = System.Array.init(4, function (){
                        return new UnityEngine.Vector3();
                    }, UnityEngine.Vector3);
                    var uvs = System.Array.init(4, function (){
                        return new UnityEngine.Vector2();
                    }, UnityEngine.Vector2);
                    var colors = System.Array.init([
                        new pc.Color( 1, 1, 1, 1 ), 
                        new pc.Color( 1, 1, 1, 1 ), 
                        new pc.Color( 1, 1, 1, 1 ), 
                        new pc.Color( 1, 1, 1, 1 )
                    ], UnityEngine.Color);
                    var triangles = System.Array.init([
                        0, 
                        1, 
                        2, 
                        2, 
                        3, 
                        0
                    ], System.Int32);

                    var left, right, top, bottom;
                    left = region.width / -2.0;
                    right = left * -1.0;
                    top = region.height / 2.0;
                    bottom = top * -1;

                    verts[0] = new pc.Vec3( left, bottom, 0 ).clone().scale( scale );
                    verts[1] = new pc.Vec3( left, top, 0 ).clone().scale( scale );
                    verts[2] = new pc.Vec3( right, top, 0 ).clone().scale( scale );
                    verts[3] = new pc.Vec3( right, bottom, 0 ).clone().scale( scale );
                    var u, v, u2, v2;
                    u = region.u;
                    v = region.v;
                    u2 = region.u2;
                    v2 = region.v2;

                    if (region.degrees === 90) {
                        uvs[0] = new pc.Vec2( u2, v2 );
                        uvs[1] = new pc.Vec2( u, v2 );
                        uvs[2] = new pc.Vec2( u, v );
                        uvs[3] = new pc.Vec2( u2, v );
                    } else {
                        uvs[0] = new pc.Vec2( u, v2 );
                        uvs[1] = new pc.Vec2( u, v );
                        uvs[2] = new pc.Vec2( u2, v );
                        uvs[3] = new pc.Vec2( u2, v2 );
                    }

                    mesh.triangles = System.Array.init(0, 0, System.Int32);
                    mesh.vertices = verts;
                    mesh.uv = uvs;
                    mesh.colors = colors;
                    mesh.triangles = triangles;
                    mesh.RecalculateNormals();
                    mesh.RecalculateBounds();

                    material.v = Bridge.cast(region.page.rendererObject, UnityEngine.Material);
                } else {
                    mesh = null;
                }

                return mesh;
            },
            /*Spine.Unity.SpineAtlasAsset.GenerateMesh end.*/


        }
    });
    /*Spine.Unity.SpineAtlasAsset end.*/

    /*Spine.Unity.SpineAttachment start.*/
    Bridge.define("Spine.Unity.SpineAttachment", {
        inherits: [Spine.Unity.SpineAttributeBase],
        statics: {
            methods: {
                /*Spine.Unity.SpineAttachment.getHierarchy:static start.*/
                getHierarchy: function (fullPath) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment#getHierarchy", this ); }

                    return new Spine.Unity.SpineAttachment.Hierarchy.$ctor1(fullPath);
                },
                /*Spine.Unity.SpineAttachment.getHierarchy:static end.*/

                /*Spine.Unity.SpineAttachment.getAttachment:static start.*/
                getAttachment: function (attachmentPath, skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment#getAttachment", this ); }

                    var hierarchy = Spine.Unity.SpineAttachment.getHierarchy(attachmentPath);
                    if (System.String.isNullOrEmpty(hierarchy.name)) {
                        return null;
                    }

                    var slot = skeletonData.FindSlot(hierarchy.slot);
                    if (slot == null) {
                        return null;
                    }
                    return skeletonData.FindSkin(hierarchy.skin).GetAttachment(slot.Index, hierarchy.name);
                },
                /*Spine.Unity.SpineAttachment.getAttachment:static end.*/

                /*Spine.Unity.SpineAttachment.getAttachment$1:static start.*/
                getAttachment$1: function (attachmentPath, skeletonDataAsset) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment#getAttachment$1", this ); }

                    return Spine.Unity.SpineAttachment.getAttachment(attachmentPath, skeletonDataAsset.GetSkeletonData(true));
                },
                /*Spine.Unity.SpineAttachment.getAttachment$1:static end.*/


            }
        },
        fields: {
            returnAttachmentPath: false,
            currentSkinOnly: false,
            placeholdersOnly: false,
            skinField: null,
            slotField: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment#init", this ); }

                this.returnAttachmentPath = false;
                this.currentSkinOnly = false;
                this.placeholdersOnly = false;
                this.skinField = "";
                this.slotField = "";
            },
            
            ctor: function (currentSkinOnly, returnAttachmentPath, placeholdersOnly, slotField, dataField, skinField, includeNone, fallbackToTextField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment#ctor", this ); }

                if (currentSkinOnly === void 0) { currentSkinOnly = true; }
                if (returnAttachmentPath === void 0) { returnAttachmentPath = false; }
                if (placeholdersOnly === void 0) { placeholdersOnly = false; }
                if (slotField === void 0) { slotField = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (skinField === void 0) { skinField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.currentSkinOnly = currentSkinOnly;
                this.returnAttachmentPath = returnAttachmentPath;
                this.placeholdersOnly = placeholdersOnly;
                this.slotField = slotField;
                this.dataField = dataField;
                this.skinField = skinField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpineAttachment end.*/

    /*Spine.Unity.SpineBone start.*/
    Bridge.define("Spine.Unity.SpineBone", {
        inherits: [Spine.Unity.SpineAttributeBase],
        statics: {
            methods: {
                /*Spine.Unity.SpineBone.getBone:static start.*/
                getBone: function (boneName, renderer) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineBone#getBone", this ); }

                    return renderer.skeleton == null ? null : renderer.skeleton.FindBone(boneName);
                },
                /*Spine.Unity.SpineBone.getBone:static end.*/

                /*Spine.Unity.SpineBone.getBoneData:static start.*/
                getBoneData: function (boneName, skeletonDataAsset) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineBone#getBoneData", this ); }

                    var data = skeletonDataAsset.GetSkeletonData(true);
                    return data.FindBone(boneName);
                },
                /*Spine.Unity.SpineBone.getBoneData:static end.*/


            }
        },
        ctors: {
            
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineBone#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpineBone end.*/

    /*Spine.Unity.SpineEvent start.*/
    Bridge.define("Spine.Unity.SpineEvent", {
        inherits: [Spine.Unity.SpineAttributeBase],
        fields: {
            /**
             * Smart popup menu for Spine Events (Spine.EventData)
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SpineEvent
             * @default false
             * @type boolean
             */
            audioOnly: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineEvent#init", this ); }

                this.audioOnly = false;
            },
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField, audioOnly) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineEvent#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }
                if (audioOnly === void 0) { audioOnly = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
                this.audioOnly = audioOnly;
            }
        }
    });
    /*Spine.Unity.SpineEvent end.*/

    /*Spine.Unity.SpineIkConstraint start.*/
    Bridge.define("Spine.Unity.SpineIkConstraint", {
        inherits: [Spine.Unity.SpineAttributeBase],
        ctors: {
            /**
             * Smart popup menu for Spine IK Constraints (Spine.IkConstraint)
             *
             * @instance
             * @public
             * @this Spine.Unity.SpineIkConstraint
             * @memberof Spine.Unity.SpineIkConstraint
             * @param   {string}     startsWith             Filters popup results to elements that begin with supplied string.
             * @param   {string}     dataField              If specified, a locally scoped field with the name supplied by in dataField will be used to fill the popup results.
             Valid types are SkeletonDataAsset and SkeletonRenderer (and derivatives).
             If left empty and the script the attribute is applied to is derived from Component, GetComponent(SkeletonRenderer)() will be called as a fallback.
             * @param   {boolean}    includeNone            If true, the dropdown list will include a "none" option which stored as an empty string.
             * @param   {boolean}    fallbackToTextField    If true, and an animation list source can't be found, the field will fall back to a normal text field. If false, it will show an error.
             * @return  {void}
             */
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineIkConstraint#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpineIkConstraint end.*/

    /*Spine.Unity.SpinePathConstraint start.*/
    Bridge.define("Spine.Unity.SpinePathConstraint", {
        inherits: [Spine.Unity.SpineAttributeBase],
        ctors: {
            /**
             * Smart popup menu for Spine Events (Spine.PathConstraint)
             *
             * @instance
             * @public
             * @this Spine.Unity.SpinePathConstraint
             * @memberof Spine.Unity.SpinePathConstraint
             * @param   {string}     startsWith             Filters popup results to elements that begin with supplied string.
             * @param   {string}     dataField              If specified, a locally scoped field with the name supplied by in dataField will be used to fill the popup results.
             Valid types are SkeletonDataAsset and SkeletonRenderer (and derivatives).
             If left empty and the script the attribute is applied to is derived from Component, GetComponent(SkeletonRenderer)() will be called as a fallback.
             * @param   {boolean}    includeNone            If true, the dropdown list will include a "none" option which stored as an empty string.
             * @param   {boolean}    fallbackToTextField
             * @return  {void}
             */
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpinePathConstraint#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpinePathConstraint end.*/

    /*Spine.Unity.SpineSkin start.*/
    Bridge.define("Spine.Unity.SpineSkin", {
        inherits: [Spine.Unity.SpineAttributeBase],
        fields: {
            
            defaultAsEmptyString: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSkin#init", this ); }

                this.defaultAsEmptyString = false;
            },
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField, defaultAsEmptyString, avoidGenericMenu) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSkin#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = false; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }
                if (defaultAsEmptyString === void 0) { defaultAsEmptyString = false; }
                if (avoidGenericMenu === void 0) { avoidGenericMenu = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);

                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
                this.defaultAsEmptyString = defaultAsEmptyString;
                this.avoidGenericMenu = avoidGenericMenu;
            }
        }
    });
    /*Spine.Unity.SpineSkin end.*/

    /*Spine.Unity.SpineSlot start.*/
    Bridge.define("Spine.Unity.SpineSlot", {
        inherits: [Spine.Unity.SpineAttributeBase],
        fields: {
            containsBoundingBoxes: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSlot#init", this ); }

                this.containsBoundingBoxes = false;
            },
            
            ctor: function (startsWith, dataField, containsBoundingBoxes, includeNone, fallbackToTextField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSlot#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (containsBoundingBoxes === void 0) { containsBoundingBoxes = false; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.containsBoundingBoxes = containsBoundingBoxes;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpineSlot end.*/

    /*Spine.Unity.SpineSpriteAtlasAsset start.*/
    /**
     * Loads and stores a Spine atlas and list of materials.
     *
     * @public
     * @class Spine.Unity.SpineSpriteAtlasAsset
     * @augments Spine.Unity.AtlasAssetBase
     */
    Bridge.define("Spine.Unity.SpineSpriteAtlasAsset", {
        inherits: [Spine.Unity.AtlasAssetBase],
        statics: {
            methods: {
                /*Spine.Unity.SpineSpriteAtlasAsset.CreateRuntimeInstance:static start.*/
                /**
                 * Creates a runtime AtlasAsset
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SpineSpriteAtlasAsset
                 * @memberof Spine.Unity.SpineSpriteAtlasAsset
                 * @param   {UnityEngine.U2D.SpriteAtlas}          spriteAtlasFile    
                 * @param   {Array.<UnityEngine.Material>}         materials          
                 * @param   {boolean}                              initialize
                 * @return  {Spine.Unity.SpineSpriteAtlasAsset}
                 */
                CreateRuntimeInstance: function (spriteAtlasFile, materials, initialize) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#CreateRuntimeInstance", this ); }

                    var atlasAsset = UnityEngine.ScriptableObject.CreateInstance(Spine.Unity.SpineSpriteAtlasAsset);
                    atlasAsset.Reset();
                    atlasAsset.spriteAtlasFile = spriteAtlasFile;
                    atlasAsset.materials = materials;

                    if (initialize) {
                        atlasAsset.GetAtlas();
                    }

                    return atlasAsset;
                },
                /*Spine.Unity.SpineSpriteAtlasAsset.CreateRuntimeInstance:static end.*/

                /*Spine.Unity.SpineSpriteAtlasAsset.AccessPackedTexture:static start.*/
                AccessPackedTexture: function (sprites) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#AccessPackedTexture", this ); }

                    return sprites[0].texture;
                },
                /*Spine.Unity.SpineSpriteAtlasAsset.AccessPackedTexture:static end.*/

                /*Spine.Unity.SpineSpriteAtlasAsset.AccessPackedSprites:static start.*/
                AccessPackedSprites: function (spriteAtlas) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#AccessPackedSprites", this ); }

                    var sprites = null;
                    if (sprites == null) {
                        sprites = System.Array.init(spriteAtlas.spriteCount, null, UnityEngine.Sprite);
                        spriteAtlas.GetSprites(sprites);
                        if (sprites.length === 0) {
                            return null;
                        }
                    }
                    return sprites;
                },
                /*Spine.Unity.SpineSpriteAtlasAsset.AccessPackedSprites:static end.*/


            }
        },
        fields: {
            spriteAtlasFile: null,
            materials: null,
            atlas: null,
            updateRegionsInPlayMode: false,
            savedRegions: null
        },
        props: {
            IsLoaded: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#IsLoaded#get", this ); }

                    return this.atlas != null;
                }
            },
            Materials: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#Materials#get", this ); }

                    return this.materials;
                }
            },
            MaterialCount: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#MaterialCount#get", this ); }

                    return this.materials == null ? 0 : this.materials.length;
                }
            },
            PrimaryMaterial: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#PrimaryMaterial#get", this ); }

                    return this.materials[0];
                }
            }
        },
        methods: {
            /*Spine.Unity.SpineSpriteAtlasAsset.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#Reset", this ); }

                this.Clear();
            },
            /*Spine.Unity.SpineSpriteAtlasAsset.Reset end.*/

            /*Spine.Unity.SpineSpriteAtlasAsset.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#Clear", this ); }

                this.atlas = null;
            },
            /*Spine.Unity.SpineSpriteAtlasAsset.Clear end.*/

            /*Spine.Unity.SpineSpriteAtlasAsset.GetAtlas start.*/
            /**
             * @instance
             * @public
             * @override
             * @this Spine.Unity.SpineSpriteAtlasAsset
             * @memberof Spine.Unity.SpineSpriteAtlasAsset
             * @param   {boolean}        onlyMetaData
             * @return  {Spine.Atlas}                    The atlas or null if it could not be loaded.
             */
            GetAtlas: function (onlyMetaData) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#GetAtlas", this ); }

                if (onlyMetaData === void 0) { onlyMetaData = false; }
                if (this.spriteAtlasFile == null) {
                    UnityEngine.Debug.LogError$2("SpriteAtlas file not set for SpineSpriteAtlasAsset: " + (this.name || ""), this);
                    this.Clear();
                    return null;
                }

                if (!onlyMetaData && (this.materials == null || this.materials.length === 0)) {
                    UnityEngine.Debug.LogError$2("Materials not set for SpineSpriteAtlasAsset: " + (this.name || ""), this);
                    this.Clear();
                    return null;
                }

                if (this.atlas != null) {
                    return this.atlas;
                }

                try {
                    this.atlas = this.LoadAtlas(this.spriteAtlasFile);
                    return this.atlas;
                } catch (ex) {
                    ex = System.Exception.create(ex);
                    UnityEngine.Debug.LogError$2("Error analyzing SpriteAtlas for SpineSpriteAtlasAsset: " + (this.name || "") + "\n" + (ex.Message || "") + "\n" + (ex.StackTrace || ""), this);
                    return null;
                }
            },
            /*Spine.Unity.SpineSpriteAtlasAsset.GetAtlas end.*/

            /*Spine.Unity.SpineSpriteAtlasAsset.AssignRegionsFromSavedRegions start.*/
            AssignRegionsFromSavedRegions: function (sprites, usedAtlas) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#AssignRegionsFromSavedRegions", this ); }

                var $t;

                if (this.savedRegions == null || this.savedRegions.length !== sprites.length) {
                    return;
                }

                var i = 0;
                $t = Bridge.getEnumerator(usedAtlas);
                try {
                    while ($t.moveNext()) {
                        var region = $t.Current;
                        var savedRegion = this.savedRegions[i];
                        var page = region.page;

                        region.degrees = savedRegion.packingRotation === UnityEngine.SpritePackingRotation.None ? 0 : 90;

                        var x = savedRegion.x;
                        var y = savedRegion.y;
                        var width = savedRegion.width;
                        var height = savedRegion.height;

                        region.u = x / page.width;
                        region.v = y / page.height;
                        if (region.degrees === 90) {
                            region.u2 = (x + height) / page.width;
                            region.v2 = (y + width) / page.height;
                        } else {
                            region.u2 = (x + width) / page.width;
                            region.v2 = (y + height) / page.height;
                        }
                        region.x = Bridge.Int.clip32(x);
                        region.y = Bridge.Int.clip32(y);
                        region.width = Math.abs(Bridge.Int.clip32(width));
                        region.height = Math.abs(Bridge.Int.clip32(height));

                        // flip upside down
                        var temp = region.v;
                        region.v = region.v2;
                        region.v2 = temp;

                        region.originalWidth = Bridge.Int.clip32(width);
                        region.originalHeight = Bridge.Int.clip32(height);

                        // note: currently sprite pivot offsets are ignored.
                        // Sprite sprite = sprites[i];
                        region.offsetX = 0; //sprite.pivot.x;
                        region.offsetY = 0; //sprite.pivot.y;

                        i = (i + 1) | 0;
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SpineSpriteAtlasAsset.AssignRegionsFromSavedRegions end.*/

            /*Spine.Unity.SpineSpriteAtlasAsset.LoadAtlas start.*/
            LoadAtlas: function (spriteAtlas) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#LoadAtlas", this ); }


                var pages = new (System.Collections.Generic.List$1(Spine.AtlasPage)).ctor();
                var regions = new (System.Collections.Generic.List$1(Spine.AtlasRegion)).ctor();

                var sprites = System.Array.init(spriteAtlas.spriteCount, null, UnityEngine.Sprite);
                spriteAtlas.GetSprites(sprites);
                if (sprites.length === 0) {
                    return new Spine.Atlas.ctor(pages, regions);
                }

                var texture = null;
                texture = Spine.Unity.SpineSpriteAtlasAsset.AccessPackedTexture(sprites);

                var material = this.materials[0];
                material.mainTexture = texture;

                var page = new Spine.AtlasPage();
                page.name = spriteAtlas.name;
                page.width = texture.width;
                page.height = texture.height;
                page.format = Spine.Format.RGBA8888;

                page.minFilter = Spine.TextureFilter.Linear;
                page.magFilter = Spine.TextureFilter.Linear;
                page.uWrap = Spine.TextureWrap.ClampToEdge;
                page.vWrap = Spine.TextureWrap.ClampToEdge;
                page.rendererObject = material;
                pages.add(page);

                sprites = Spine.Unity.SpineSpriteAtlasAsset.AccessPackedSprites(spriteAtlas);

                var i = 0;
                for (; i < sprites.length; i = (i + 1) | 0) {
                    var sprite = sprites[i];
                    var region = new Spine.AtlasRegion();
                    region.name = System.String.replaceAll(sprite.name, "(Clone)", "");
                    region.page = page;
                    region.degrees = sprite.packingRotation === UnityEngine.SpritePackingRotation.None ? 0 : 90;

                    region.u2 = 1;
                    region.v2 = 1;
                    region.width = page.width;
                    region.height = page.height;
                    region.originalWidth = page.width;
                    region.originalHeight = page.height;

                    region.index = i;
                    regions.add(region);
                }

                var atlas = new Spine.Atlas.ctor(pages, regions);
                this.AssignRegionsFromSavedRegions(sprites, atlas);

                return atlas;
            },
            /*Spine.Unity.SpineSpriteAtlasAsset.LoadAtlas end.*/


        }
    });
    /*Spine.Unity.SpineSpriteAtlasAsset end.*/

    /*Spine.Unity.SpineTransformConstraint start.*/
    Bridge.define("Spine.Unity.SpineTransformConstraint", {
        inherits: [Spine.Unity.SpineAttributeBase],
        ctors: {
            
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineTransformConstraint#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpineTransformConstraint end.*/

    /*Spine.Unity.WaitForSpineAnimationComplete start.*/
    /**
     * Use this as a condition-blocking yield instruction for Unity Coroutines.
     The routine will pause until the AnimationState.TrackEntry fires its Complete event.
     It can be configured to trigger on the End event as well to cover interruption.
     <p />
     See the {@link }
     and {@link }
     for more information on when track events will be triggered.
     *
     * @public
     * @class Spine.Unity.WaitForSpineAnimationComplete
     * @augments Spine.Unity.WaitForSpineAnimation
     * @implements  System.Collections.IEnumerator
     */
    Bridge.define("Spine.Unity.WaitForSpineAnimationComplete", {
        inherits: [Spine.Unity.WaitForSpineAnimation,System.Collections.IEnumerator],
        ctors: {
            ctor: function (trackEntry, includeEndEvent) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimationComplete#ctor", this ); }

                if (includeEndEvent === void 0) { includeEndEvent = false; }

                this.$initialize();
                Spine.Unity.WaitForSpineAnimation.ctor.call(this, trackEntry, includeEndEvent ? (20) : Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.Complete);
            }
        },
        methods: {
            /*Spine.Unity.WaitForSpineAnimationComplete.NowWaitFor$1 start.*/
            /**
             * One optimization high-frequency YieldInstruction returns is to cache instances to minimize GC pressure.
             Use NowWaitFor to reuse the same instance of WaitForSpineAnimationComplete.
             *
             * @instance
             * @public
             * @this Spine.Unity.WaitForSpineAnimationComplete
             * @memberof Spine.Unity.WaitForSpineAnimationComplete
             * @param   {Spine.TrackEntry}                             trackEntry         
             * @param   {boolean}                                      includeEndEvent
             * @return  {Spine.Unity.WaitForSpineAnimationComplete}
             */
            NowWaitFor$1: function (trackEntry, includeEndEvent) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimationComplete#NowWaitFor$1", this ); }

                if (includeEndEvent === void 0) { includeEndEvent = false; }
                this.SafeSubscribe(trackEntry, includeEndEvent ? (20) : Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.Complete);
                return this;
            },
            /*Spine.Unity.WaitForSpineAnimationComplete.NowWaitFor$1 end.*/


        },
        overloads: {
            "NowWaitFor(Spine.TrackEntry, bool)": "NowWaitFor$1"
        }
    });
    /*Spine.Unity.WaitForSpineAnimationComplete end.*/

    /*Spine.Unity.WaitForSpineAnimationEnd start.*/
    /**
     * Use this as a condition-blocking yield instruction for Unity Coroutines.
     The routine will pause until the AnimationState.TrackEntry fires its End event.
     <p />
     See the {@link }
     and {@link }
     for more information on when track events will be triggered.
     *
     * @public
     * @class Spine.Unity.WaitForSpineAnimationEnd
     * @augments Spine.Unity.WaitForSpineAnimation
     * @implements  System.Collections.IEnumerator
     */
    Bridge.define("Spine.Unity.WaitForSpineAnimationEnd", {
        inherits: [Spine.Unity.WaitForSpineAnimation,System.Collections.IEnumerator],
        ctors: {
            ctor: function (trackEntry) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimationEnd#ctor", this ); }

                this.$initialize();
                Spine.Unity.WaitForSpineAnimation.ctor.call(this, trackEntry, Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.End);
            }
        },
        methods: {
            /*Spine.Unity.WaitForSpineAnimationEnd.NowWaitFor$1 start.*/
            /**
             * One optimization high-frequency YieldInstruction returns is to cache instances to minimize GC pressure.
             Use NowWaitFor to reuse the same instance of WaitForSpineAnimationComplete.
             *
             * @instance
             * @public
             * @this Spine.Unity.WaitForSpineAnimationEnd
             * @memberof Spine.Unity.WaitForSpineAnimationEnd
             * @param   {Spine.TrackEntry}                        trackEntry
             * @return  {Spine.Unity.WaitForSpineAnimationEnd}
             */
            NowWaitFor$1: function (trackEntry) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimationEnd#NowWaitFor$1", this ); }

                this.SafeSubscribe(trackEntry, Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.End);
                return this;
            },
            /*Spine.Unity.WaitForSpineAnimationEnd.NowWaitFor$1 end.*/


        },
        overloads: {
            "NowWaitFor(Spine.TrackEntry)": "NowWaitFor$1"
        }
    });
    /*Spine.Unity.WaitForSpineAnimationEnd end.*/

    /*Spine.CurveTimeline1 start.*/
    /**
     * The base class for a {@link } that sets one property.
     *
     * @abstract
     * @public
     * @class Spine.CurveTimeline1
     * @augments Spine.CurveTimeline
     */
    Bridge.define("Spine.CurveTimeline1", {
        inherits: [Spine.CurveTimeline],
        statics: {
            fields: {
                ENTRIES: 0,
                VALUE: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.CurveTimeline1#init", this ); }

                    this.ENTRIES = 2;
                    this.VALUE = 1;
                }
            }
        },
        props: {
            FrameEntries: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.CurveTimeline1#FrameEntries#get", this ); }

                    return Spine.CurveTimeline1.ENTRIES;
                }
            }
        },
        ctors: {
            /**
             * @instance
             * @public
             * @this Spine.CurveTimeline1
             * @memberof Spine.CurveTimeline1
             * @param   {number}    frameCount     
             * @param   {number}    bezierCount    The maximum number of Bezier curves. See {@link }.
             * @param   {string}    propertyId
             * @return  {void}
             */
            ctor: function (frameCount, bezierCount, propertyId) {
if ( TRACE ) { TRACE( "Spine.CurveTimeline1#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline.ctor.call(this, frameCount, bezierCount, [propertyId]);
            }
        },
        methods: {
            /*Spine.CurveTimeline1.SetFrame start.*/
            /**
             * Sets the time and value for the specified frame.
             *
             * @instance
             * @public
             * @this Spine.CurveTimeline1
             * @memberof Spine.CurveTimeline1
             * @param   {number}    frame    Between 0 and <pre><code>frameCount</code></pre>, inclusive.
             * @param   {number}    time     The frame time in seconds
             * @param   {number}    value
             * @return  {void}
             */
            SetFrame: function (frame, time, value) {
if ( TRACE ) { TRACE( "Spine.CurveTimeline1#SetFrame", this ); }

                frame = frame << 1;
                this.frames[frame] = time;
                this.frames[((frame + Spine.CurveTimeline1.VALUE) | 0)] = value;
            },
            /*Spine.CurveTimeline1.SetFrame end.*/

            /*Spine.CurveTimeline1.GetCurveValue start.*/
            /**
             * Returns the interpolated value for the specified time.
             *
             * @instance
             * @public
             * @this Spine.CurveTimeline1
             * @memberof Spine.CurveTimeline1
             * @param   {number}    time
             * @return  {number}
             */
            GetCurveValue: function (time) {
if ( TRACE ) { TRACE( "Spine.CurveTimeline1#GetCurveValue", this ); }

                var frames = this.frames;
                var i = (frames.length - 2) | 0;
                for (var ii = 2; ii <= i; ii = (ii + 2) | 0) {
                    if (frames[ii] > time) {
                        i = (ii - 2) | 0;
                        break;
                    }
                }

                var curveType = Bridge.Int.clip32(this.curves[i >> 1]);
                switch (curveType) {
                    case Spine.CurveTimeline.LINEAR: 
                        var before = frames[i], value = frames[((i + Spine.CurveTimeline1.VALUE) | 0)];
                        return value + (time - before) / (frames[((i + Spine.CurveTimeline1.ENTRIES) | 0)] - before) * (frames[((((i + Spine.CurveTimeline1.ENTRIES) | 0) + Spine.CurveTimeline1.VALUE) | 0)] - value);
                    case Spine.CurveTimeline.STEPPED: 
                        return frames[((i + Spine.CurveTimeline1.VALUE) | 0)];
                }
                return this.GetBezierValue(time, i, Spine.CurveTimeline1.VALUE, ((curveType - Spine.CurveTimeline.BEZIER) | 0));
            },
            /*Spine.CurveTimeline1.GetCurveValue end.*/

            /*Spine.CurveTimeline1.GetRelativeValue start.*/
            GetRelativeValue: function (time, alpha, blend, current, setup) {
if ( TRACE ) { TRACE( "Spine.CurveTimeline1#GetRelativeValue", this ); }

                if (time < this.frames[0]) {
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            return setup;
                        case Spine.MixBlend.First: 
                            return current + (setup - current) * alpha;
                    }
                    return current;
                }
                var value = this.GetCurveValue(time);
                switch (blend) {
                    case Spine.MixBlend.Setup: 
                        return setup + value * alpha;
                    case Spine.MixBlend.First: 
                    case Spine.MixBlend.Replace: 
                        value += setup - current;
                        break;
                }
                return current + value * alpha;
            },
            /*Spine.CurveTimeline1.GetRelativeValue end.*/

            /*Spine.CurveTimeline1.GetAbsoluteValue start.*/
            GetAbsoluteValue: function (time, alpha, blend, current, setup) {
if ( TRACE ) { TRACE( "Spine.CurveTimeline1#GetAbsoluteValue", this ); }

                if (time < this.frames[0]) {
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            return setup;
                        case Spine.MixBlend.First: 
                            return current + (setup - current) * alpha;
                    }
                    return current;
                }
                var value = this.GetCurveValue(time);
                if (blend === Spine.MixBlend.Setup) {
                    return setup + (value - setup) * alpha;
                }
                return current + (value - current) * alpha;
            },
            /*Spine.CurveTimeline1.GetAbsoluteValue end.*/

            /*Spine.CurveTimeline1.GetAbsoluteValue$1 start.*/
            GetAbsoluteValue$1: function (time, alpha, blend, current, setup, value) {
if ( TRACE ) { TRACE( "Spine.CurveTimeline1#GetAbsoluteValue$1", this ); }

                if (time < this.frames[0]) {
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            return setup;
                        case Spine.MixBlend.First: 
                            return current + (setup - current) * alpha;
                    }
                    return current;
                }
                if (blend === Spine.MixBlend.Setup) {
                    return setup + (value - setup) * alpha;
                }
                return current + (value - current) * alpha;
            },
            /*Spine.CurveTimeline1.GetAbsoluteValue$1 end.*/

            /*Spine.CurveTimeline1.GetScaleValue start.*/
            GetScaleValue: function (time, alpha, blend, direction, current, setup) {
if ( TRACE ) { TRACE( "Spine.CurveTimeline1#GetScaleValue", this ); }

                var frames = this.frames;
                if (time < frames[0]) {
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            return setup;
                        case Spine.MixBlend.First: 
                            return current + (setup - current) * alpha;
                    }
                    return current;
                }
                var value = this.GetCurveValue(time) * setup;
                if (alpha === 1) {
                    if (blend === Spine.MixBlend.Add) {
                        return current + value - setup;
                    }
                    return value;
                }
                // Mixing out uses sign of setup or current pose, else use sign of key.
                if (direction === Spine.MixDirection.Out) {
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            return setup + (Math.abs(value) * Bridge.Int.sign(setup) - setup) * alpha;
                        case Spine.MixBlend.First: 
                        case Spine.MixBlend.Replace: 
                            return current + (Math.abs(value) * Bridge.Int.sign(current) - current) * alpha;
                    }
                } else {
                    var s;
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            s = Math.abs(setup) * Bridge.Int.sign(value);
                            return s + (value - s) * alpha;
                        case Spine.MixBlend.First: 
                        case Spine.MixBlend.Replace: 
                            s = Math.abs(current) * Bridge.Int.sign(value);
                            return s + (value - s) * alpha;
                    }
                }
                return current + (value - setup) * alpha;
            },
            /*Spine.CurveTimeline1.GetScaleValue end.*/


        },
        overloads: {
            "GetAbsoluteValue(float, float, MixBlend, float, float, float)": "GetAbsoluteValue$1"
        }
    });
    /*Spine.CurveTimeline1 end.*/

    /*Spine.Atlas start.*/
    Bridge.define("Spine.Atlas", {
        inherits: [System.Collections.Generic.IEnumerable$1(Spine.AtlasRegion)],
        statics: {
            methods: {
                /*Spine.Atlas.ReadEntry:static start.*/
                ReadEntry: function (entry, line) {
if ( TRACE ) { TRACE( "Spine.Atlas#ReadEntry", this ); }

                    if (line == null) {
                        return 0;
                    }
                    line = line.trim();
                    if (line.length === 0) {
                        return 0;
                    }
                    var colon = System.String.indexOf(line, String.fromCharCode(58));
                    if (colon === -1) {
                        return 0;
                    }
                    entry[0] = line.substr(0, colon).trim();
                    for (var i = 1, lastMatch = (colon + 1) | 0; ; i = (i + 1) | 0) {
                        var comma = System.String.indexOf(line, String.fromCharCode(44), lastMatch);
                        if (comma === -1) {
                            entry[i] = line.substr(lastMatch).trim();
                            return i;
                        }
                        entry[i] = line.substr(lastMatch, ((comma - lastMatch) | 0)).trim();
                        lastMatch = (comma + 1) | 0;
                        if (i === 4) {
                            return 4;
                        }
                    }
                },
                /*Spine.Atlas.ReadEntry:static end.*/


            }
        },
        fields: {
            pages: null,
            regions: null,
            textureLoader: null
        },
        props: {
            Regions: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Atlas#Regions#get", this ); }

                    return this.regions;
                }
            },
            Pages: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Atlas#Pages#get", this ); }

                    return this.pages;
                }
            }
        },
        alias: ["GetEnumerator", ["System$Collections$Generic$IEnumerable$1$Spine$AtlasRegion$GetEnumerator", "System$Collections$Generic$IEnumerable$1$GetEnumerator"]],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Atlas#init", this ); }

                this.pages = new (System.Collections.Generic.List$1(Spine.AtlasPage)).ctor();
                this.regions = new (System.Collections.Generic.List$1(Spine.AtlasRegion)).ctor();
            },
            ctor: function (pages, regions) {
if ( TRACE ) { TRACE( "Spine.Atlas#ctor", this ); }

                this.$initialize();
                if (pages == null) {
                    throw new System.ArgumentNullException.$ctor3("pages", "pages cannot be null.");
                }
                if (regions == null) {
                    throw new System.ArgumentNullException.$ctor3("regions", "regions cannot be null.");
                }
                this.pages = pages;
                this.regions = regions;
                this.textureLoader = null;
            },
            $ctor1: function (reader, imagesDir, textureLoader) {
if ( TRACE ) { TRACE( "Spine.Atlas#$ctor1", this ); }

                this.$initialize();
                if (reader == null) {
                    throw new System.ArgumentNullException.$ctor3("reader", "reader cannot be null.");
                }
                if (imagesDir == null) {
                    throw new System.ArgumentNullException.$ctor3("imagesDir", "imagesDir cannot be null.");
                }
                if (textureLoader == null) {
                    throw new System.ArgumentNullException.$ctor3("textureLoader", "textureLoader cannot be null.");
                }
                this.textureLoader = textureLoader;

                var entry = System.Array.init(5, null, System.String);
                var page = null;
                var region = null;

                var pageFields = new (System.Collections.Generic.Dictionary$2(System.String,Function)).$ctor4(5);
                pageFields.add("size", function () {
                    page.width = System.Int32.parseWithProvider(entry[1], 7, System.Globalization.CultureInfo.invariantCulture);
                    page.height = System.Int32.parseWithProvider(entry[2], 7, System.Globalization.CultureInfo.invariantCulture);
                });
                pageFields.add("format", function () {
                    page.format = System.Nullable.getValue(Bridge.cast(Bridge.unbox(System.Enum.parse(Spine.Format, entry[1], false), Spine.Format), System.Int32));
                });
                pageFields.add("filter", function () {
                    page.minFilter = System.Nullable.getValue(Bridge.cast(Bridge.unbox(System.Enum.parse(Spine.TextureFilter, entry[1], false), Spine.TextureFilter), System.Int32));
                    page.magFilter = System.Nullable.getValue(Bridge.cast(Bridge.unbox(System.Enum.parse(Spine.TextureFilter, entry[2], false), Spine.TextureFilter), System.Int32));
                });
                pageFields.add("repeat", function () {
                    if (System.String.indexOf(entry[1], String.fromCharCode(120)) !== -1) {
                        page.uWrap = Spine.TextureWrap.Repeat;
                    }
                    if (System.String.indexOf(entry[1], String.fromCharCode(121)) !== -1) {
                        page.vWrap = Spine.TextureWrap.Repeat;
                    }
                });
                pageFields.add("pma", function () {
                    page.pma = Bridge.referenceEquals(entry[1], "true");
                });

                var regionFields = new (System.Collections.Generic.Dictionary$2(System.String,Function)).$ctor4(8);
                regionFields.add("xy", function () { // Deprecated, use bounds.
                    region.x = System.Int32.parseWithProvider(entry[1], 7, System.Globalization.CultureInfo.invariantCulture);
                    region.y = System.Int32.parseWithProvider(entry[2], 7, System.Globalization.CultureInfo.invariantCulture);
                });
                regionFields.add("size", function () { // Deprecated, use bounds.
                    region.width = System.Int32.parseWithProvider(entry[1], 7, System.Globalization.CultureInfo.invariantCulture);
                    region.height = System.Int32.parseWithProvider(entry[2], 7, System.Globalization.CultureInfo.invariantCulture);
                });
                regionFields.add("bounds", function () {
                    region.x = System.Int32.parseWithProvider(entry[1], 7, System.Globalization.CultureInfo.invariantCulture);
                    region.y = System.Int32.parseWithProvider(entry[2], 7, System.Globalization.CultureInfo.invariantCulture);
                    region.width = System.Int32.parseWithProvider(entry[3], 7, System.Globalization.CultureInfo.invariantCulture);
                    region.height = System.Int32.parseWithProvider(entry[4], 7, System.Globalization.CultureInfo.invariantCulture);
                });
                regionFields.add("offset", function () { // Deprecated, use offsets.
                    region.offsetX = System.Int32.parseWithProvider(entry[1], 7, System.Globalization.CultureInfo.invariantCulture);
                    region.offsetY = System.Int32.parseWithProvider(entry[2], 7, System.Globalization.CultureInfo.invariantCulture);
                });
                regionFields.add("orig", function () { // Deprecated, use offsets.
                    region.originalWidth = System.Int32.parseWithProvider(entry[1], 7, System.Globalization.CultureInfo.invariantCulture);
                    region.originalHeight = System.Int32.parseWithProvider(entry[2], 7, System.Globalization.CultureInfo.invariantCulture);
                });
                regionFields.add("offsets", function () {
                    region.offsetX = System.Int32.parseWithProvider(entry[1], 7, System.Globalization.CultureInfo.invariantCulture);
                    region.offsetY = System.Int32.parseWithProvider(entry[2], 7, System.Globalization.CultureInfo.invariantCulture);
                    region.originalWidth = System.Int32.parseWithProvider(entry[3], 7, System.Globalization.CultureInfo.invariantCulture);
                    region.originalHeight = System.Int32.parseWithProvider(entry[4], 7, System.Globalization.CultureInfo.invariantCulture);
                });
                regionFields.add("rotate", function () {
                    var value = entry[1];
                    if (Bridge.referenceEquals(value, "true")) {
                        region.degrees = 90;
                    } else {
                        if (!Bridge.referenceEquals(value, "false")) {
                            region.degrees = System.Int32.parseWithProvider(value, 7, System.Globalization.CultureInfo.invariantCulture);
                        }
                    }
                });
                regionFields.add("index", function () {
                    region.index = System.Int32.parseWithProvider(entry[1], 7, System.Globalization.CultureInfo.invariantCulture);
                });

                var line = reader.ReadLine();
                // Ignore empty lines before first entry.
                while (line != null && line.trim().length === 0) {
                    line = reader.ReadLine();
                }
                // Header entries.
                while (true) {
                    if (line == null || line.trim().length === 0) {
                        break;
                    }
                    if (Spine.Atlas.ReadEntry(entry, line) === 0) {
                        break;
                    } // Silently ignore all header fields.
                    line = reader.ReadLine();
                }
                // Page and region entries.
                var names = null;
                var values = null;
                while (true) {
                    if (line == null) {
                        break;
                    }
                    if (line.trim().length === 0) {
                        page = null;
                        line = reader.ReadLine();
                    } else if (page == null) {
                        page = new Spine.AtlasPage();
                        page.name = line.trim();
                        while (true) {
                            if (Spine.Atlas.ReadEntry(entry, (line = reader.ReadLine())) === 0) {
                                break;
                            }
                            var field = { };
                            if (pageFields.tryGetValue(entry[0], field)) {
                                field.v();
                            } // Silently ignore unknown page fields.
                        }
                        textureLoader.Spine$TextureLoader$Load(page, System.IO.Path.Combine(imagesDir, page.name));
                        this.pages.add(page);
                    } else {
                        region = new Spine.AtlasRegion();
                        region.page = page;
                        region.name = line;
                        while (true) {
                            var count = Spine.Atlas.ReadEntry(entry, (line = reader.ReadLine()));
                            if (count === 0) {
                                break;
                            }
                            var field1 = { };
                            if (regionFields.tryGetValue(entry[0], field1)) {
                                field1.v();
                            } else {
                                if (names == null) {
                                    names = new (System.Collections.Generic.List$1(System.String)).$ctor2(8);
                                    values = new (System.Collections.Generic.List$1(System.Array.type(System.Int32))).$ctor2(8);
                                }
                                names.add(entry[0]);
                                var entryValues = System.Array.init(count, 0, System.Int32);
                                for (var i = 0; i < count; i = (i + 1) | 0) {
                                    System.Int32.tryParseWithProvider(entry[((i + 1) | 0)], 511, System.Globalization.CultureInfo.invariantCulture, Bridge.ref(entryValues, i));
                                } // Silently ignore non-integer values.
                                values.add(entryValues);
                            }
                        }
                        if (region.originalWidth === 0 && region.originalHeight === 0) {
                            region.originalWidth = region.width;
                            region.originalHeight = region.height;
                        }
                        if (names != null && names.Count > 0) {
                            region.names = names.ToArray();
                            region.values = values.ToArray();
                            names.clear();
                            values.clear();
                        }
                        region.u = region.x / page.width;
                        region.v = region.y / page.height;
                        if (region.degrees === 90) {
                            region.u2 = (((region.x + region.height) | 0)) / page.width;
                            region.v2 = (((region.y + region.width) | 0)) / page.height;

                            var tempSwap = region.packedWidth;
                            region.packedWidth = region.packedHeight;
                            region.packedHeight = tempSwap;
                        } else {
                            region.u2 = (((region.x + region.width) | 0)) / page.width;
                            region.v2 = (((region.y + region.height) | 0)) / page.height;
                        }
                        this.regions.add(region);
                    }
                }
            }
        },
        methods: {
            /*Spine.Atlas.GetEnumerator start.*/
            GetEnumerator: function () {
if ( TRACE ) { TRACE( "Spine.Atlas#GetEnumerator", this ); }

                return this.regions.GetEnumerator().$clone();
            },
            /*Spine.Atlas.GetEnumerator end.*/

            /*Spine.Atlas.System$Collections$IEnumerable$GetEnumerator start.*/
            System$Collections$IEnumerable$GetEnumerator: function () {
if ( TRACE ) { TRACE( "Spine.Atlas#System$Collections$IEnumerable$GetEnumerator", this ); }

                return this.regions.GetEnumerator().$clone();
            },
            /*Spine.Atlas.System$Collections$IEnumerable$GetEnumerator end.*/

            /*Spine.Atlas.FlipV start.*/
            FlipV: function () {
if ( TRACE ) { TRACE( "Spine.Atlas#FlipV", this ); }

                for (var i = 0, n = this.regions.Count; i < n; i = (i + 1) | 0) {
                    var region = this.regions.getItem(i);
                    region.v = 1 - region.v;
                    region.v2 = 1 - region.v2;
                }
            },
            /*Spine.Atlas.FlipV end.*/

            /*Spine.Atlas.FindRegion start.*/
            /**
             * Returns the first region found with the specified name. This method uses string comparison to find the region, so the result
             should be cached rather than calling this method multiple times.
             *
             * @instance
             * @public
             * @this Spine.Atlas
             * @memberof Spine.Atlas
             * @param   {string}               name
             * @return  {Spine.AtlasRegion}            The region, or null.
             */
            FindRegion: function (name) {
if ( TRACE ) { TRACE( "Spine.Atlas#FindRegion", this ); }

                for (var i = 0, n = this.regions.Count; i < n; i = (i + 1) | 0) {
                    if (Bridge.referenceEquals(this.regions.getItem(i).name, name)) {
                        return this.regions.getItem(i);
                    }
                }
                return null;
            },
            /*Spine.Atlas.FindRegion end.*/

            /*Spine.Atlas.Dispose start.*/
            Dispose: function () {
if ( TRACE ) { TRACE( "Spine.Atlas#Dispose", this ); }

                if (this.textureLoader == null) {
                    return;
                }
                for (var i = 0, n = this.pages.Count; i < n; i = (i + 1) | 0) {
                    this.textureLoader.Spine$TextureLoader$Unload(this.pages.getItem(i).rendererObject);
                }
            },
            /*Spine.Atlas.Dispose end.*/


        }
    });
    /*Spine.Atlas end.*/

    /*Spine.BoundingBoxAttachment start.*/
    /**
     * Attachment that has a polygon for bounds checking.
     *
     * @public
     * @class Spine.BoundingBoxAttachment
     * @augments Spine.VertexAttachment
     */
    Bridge.define("Spine.BoundingBoxAttachment", {
        inherits: [Spine.VertexAttachment],
        ctors: {
            $ctor1: function (name) {
if ( TRACE ) { TRACE( "Spine.BoundingBoxAttachment#$ctor1", this ); }

                this.$initialize();
                Spine.VertexAttachment.$ctor1.call(this, name);
            },
            /**
             * Copy constructor.
             *
             * @instance
             * @protected
             * @this Spine.BoundingBoxAttachment
             * @memberof Spine.BoundingBoxAttachment
             * @param   {Spine.BoundingBoxAttachment}    other
             * @return  {void}
             */
            ctor: function (other) {
if ( TRACE ) { TRACE( "Spine.BoundingBoxAttachment#ctor", this ); }

                this.$initialize();
                Spine.VertexAttachment.ctor.call(this, other);
            }
        },
        methods: {
            /*Spine.BoundingBoxAttachment.Copy start.*/
            Copy: function () {
if ( TRACE ) { TRACE( "Spine.BoundingBoxAttachment#Copy", this ); }

                return new Spine.BoundingBoxAttachment.ctor(this);
            },
            /*Spine.BoundingBoxAttachment.Copy end.*/


        }
    });
    /*Spine.BoundingBoxAttachment end.*/

    /*Spine.ClippingAttachment start.*/
    Bridge.define("Spine.ClippingAttachment", {
        inherits: [Spine.VertexAttachment],
        fields: {
            endSlot: null
        },
        props: {
            EndSlot: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.ClippingAttachment#EndSlot#get", this ); }

                    return this.endSlot;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.ClippingAttachment#EndSlot#set", this ); }

                    this.endSlot = value;
                }
            }
        },
        ctors: {
            $ctor1: function (name) {
if ( TRACE ) { TRACE( "Spine.ClippingAttachment#$ctor1", this ); }

                this.$initialize();
                Spine.VertexAttachment.$ctor1.call(this, name);
            },
            /**
             * Copy constructor.
             *
             * @instance
             * @protected
             * @this Spine.ClippingAttachment
             * @memberof Spine.ClippingAttachment
             * @param   {Spine.ClippingAttachment}    other
             * @return  {void}
             */
            ctor: function (other) {
if ( TRACE ) { TRACE( "Spine.ClippingAttachment#ctor", this ); }

                this.$initialize();
                Spine.VertexAttachment.ctor.call(this, other);
                this.endSlot = other.endSlot;
            }
        },
        methods: {
            /*Spine.ClippingAttachment.Copy start.*/
            Copy: function () {
if ( TRACE ) { TRACE( "Spine.ClippingAttachment#Copy", this ); }

                return new Spine.ClippingAttachment.ctor(this);
            },
            /*Spine.ClippingAttachment.Copy end.*/


        }
    });
    /*Spine.ClippingAttachment end.*/

    /*Spine.CurveTimeline2 start.*/
    /**
     * The base class for a {@link } which sets two properties.
     *
     * @abstract
     * @public
     * @class Spine.CurveTimeline2
     * @augments Spine.CurveTimeline
     */
    Bridge.define("Spine.CurveTimeline2", {
        inherits: [Spine.CurveTimeline],
        statics: {
            fields: {
                ENTRIES: 0,
                VALUE1: 0,
                VALUE2: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.CurveTimeline2#init", this ); }

                    this.ENTRIES = 3;
                    this.VALUE1 = 1;
                    this.VALUE2 = 2;
                }
            }
        },
        props: {
            FrameEntries: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.CurveTimeline2#FrameEntries#get", this ); }

                    return Spine.CurveTimeline2.ENTRIES;
                }
            }
        },
        ctors: {
            /**
             * @instance
             * @public
             * @this Spine.CurveTimeline2
             * @memberof Spine.CurveTimeline2
             * @param   {number}    frameCount     
             * @param   {number}    bezierCount    The maximum number of Bezier curves. See {@link }.
             * @param   {string}    propertyId1    
             * @param   {string}    propertyId2
             * @return  {void}
             */
            ctor: function (frameCount, bezierCount, propertyId1, propertyId2) {
if ( TRACE ) { TRACE( "Spine.CurveTimeline2#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline.ctor.call(this, frameCount, bezierCount, [propertyId1, propertyId2]);
            }
        },
        methods: {
            /*Spine.CurveTimeline2.SetFrame start.*/
            /**
             * Sets the time and values for the specified frame.
             *
             * @instance
             * @public
             * @this Spine.CurveTimeline2
             * @memberof Spine.CurveTimeline2
             * @param   {number}    frame     Between 0 and <pre><code>frameCount</code></pre>, inclusive.
             * @param   {number}    time      The frame time in seconds.
             * @param   {number}    value1    
             * @param   {number}    value2
             * @return  {void}
             */
            SetFrame: function (frame, time, value1, value2) {
if ( TRACE ) { TRACE( "Spine.CurveTimeline2#SetFrame", this ); }

                frame = Bridge.Int.mul(frame, Spine.CurveTimeline2.ENTRIES);
                this.frames[frame] = time;
                this.frames[((frame + Spine.CurveTimeline2.VALUE1) | 0)] = value1;
                this.frames[((frame + Spine.CurveTimeline2.VALUE2) | 0)] = value2;
            },
            /*Spine.CurveTimeline2.SetFrame end.*/


        }
    });
    /*Spine.CurveTimeline2 end.*/

    /*Spine.DeformTimeline start.*/
    /**
     * Changes a slot's {@link } to deform a {@link }.
     *
     * @public
     * @class Spine.DeformTimeline
     * @augments Spine.CurveTimeline
     * @implements  Spine.ISlotTimeline
     */
    Bridge.define("Spine.DeformTimeline", {
        inherits: [Spine.CurveTimeline,Spine.ISlotTimeline],
        fields: {
            slotIndex: 0,
            attachment: null,
            vertices: null
        },
        props: {
            SlotIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.DeformTimeline#SlotIndex#get", this ); }

                    return this.slotIndex;
                }
            },
            /**
             * The attachment that will be deformed.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.DeformTimeline
             * @function Attachment
             * @type Spine.VertexAttachment
             * @see {@link VertexAttachment.TimelineAttachment}
             */
            Attachment: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.DeformTimeline#Attachment#get", this ); }

                    return this.attachment;
                }
            },
            /**
             * The vertices for each frame.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.DeformTimeline
             * @function Vertices
             * @type Array.<Array.<number>>
             */
            Vertices: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.DeformTimeline#Vertices#get", this ); }

                    return this.vertices;
                }
            }
        },
        alias: ["SlotIndex", "Spine$ISlotTimeline$SlotIndex"],
        ctors: {
            ctor: function (frameCount, bezierCount, slotIndex, attachment) {
if ( TRACE ) { TRACE( "Spine.DeformTimeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline.ctor.call(this, frameCount, bezierCount, [Spine.Property.Deform + "|" + slotIndex + "|" + attachment.Id]);
                this.slotIndex = slotIndex;
                this.attachment = attachment;
                this.vertices = System.Array.init(frameCount, null, System.Array.type(System.Single));
            }
        },
        methods: {
            /*Spine.DeformTimeline.SetFrame start.*/
            /**
             * Sets the time and vertices for the specified frame.
             *
             * @instance
             * @public
             * @this Spine.DeformTimeline
             * @memberof Spine.DeformTimeline
             * @param   {number}            frame       Between 0 and <pre><code>frameCount</code></pre>, inclusive.
             * @param   {number}            time        The frame time in seconds.
             * @param   {Array.<number>}    vertices    Vertex positions for an unweighted VertexAttachment, or deform offsets if it has weights.
             * @return  {void}
             */
            SetFrame: function (frame, time, vertices) {
if ( TRACE ) { TRACE( "Spine.DeformTimeline#SetFrame", this ); }

                this.frames[frame] = time;
                this.vertices[frame] = vertices;
            },
            /*Spine.DeformTimeline.SetFrame end.*/

            /*Spine.DeformTimeline.setBezier start.*/
            /**
             * @instance
             * @public
             * @this Spine.DeformTimeline
             * @memberof Spine.DeformTimeline
             * @param   {number}    bezier    
             * @param   {number}    frame     
             * @param   {number}    value     
             * @param   {number}    time1     
             * @param   {number}    value1    Ignored (0 is used for a deform timeline).
             * @param   {number}    cx1       
             * @param   {number}    cy1       
             * @param   {number}    cx2       
             * @param   {number}    cy2       
             * @param   {number}    time2     
             * @param   {number}    value2    Ignored (1 is used for a deform timeline).
             * @return  {void}
             */
            setBezier: function (bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2) {
if ( TRACE ) { TRACE( "Spine.DeformTimeline#setBezier", this ); }

                var curves = this.curves;
                var i = (this.FrameCount + Bridge.Int.mul(bezier, Spine.CurveTimeline.BEZIER_SIZE)) | 0;
                if (value === 0) {
                    curves[frame] = (Spine.CurveTimeline.BEZIER + i) | 0;
                }
                var tmpx = (time1 - cx1 * 2 + cx2) * 0.03, tmpy = cy2 * 0.03 - cy1 * 0.06;
                var dddx = ((cx1 - cx2) * 3 - time1 + time2) * 0.006, dddy = (cy1 - cy2 + 0.333333343) * 0.018;
                var ddx = tmpx * 2 + dddx, ddy = tmpy * 2 + dddy;
                var dx = (cx1 - time1) * 0.3 + tmpx + dddx * 0.166666672, dy = cy1 * 0.3 + tmpy + dddy * 0.166666672;
                var x = time1 + dx, y = dy;
                for (var n = (i + Spine.CurveTimeline.BEZIER_SIZE) | 0; i < n; i = (i + 2) | 0) {
                    curves[i] = x;
                    curves[((i + 1) | 0)] = y;
                    dx += ddx;
                    dy += ddy;
                    ddx += dddx;
                    ddy += dddy;
                    x += dx;
                    y += dy;
                }
            },
            /*Spine.DeformTimeline.setBezier end.*/

            /*Spine.DeformTimeline.GetCurvePercent start.*/
            /**
             * Returns the interpolated percentage for the specified time.
             *
             * @instance
             * @private
             * @this Spine.DeformTimeline
             * @memberof Spine.DeformTimeline
             * @param   {number}    time     
             * @param   {number}    frame    The frame before <pre><code>time</code></pre>.
             * @return  {number}
             */
            GetCurvePercent: function (time, frame) {
if ( TRACE ) { TRACE( "Spine.DeformTimeline#GetCurvePercent", this ); }

                var curves = this.curves;
                var i = Bridge.Int.clip32(curves[frame]);
                switch (i) {
                    case Spine.CurveTimeline.LINEAR: 
                        var x = this.frames[frame];
                        return (time - x) / (this.frames[((frame + this.FrameEntries) | 0)] - x);
                    case Spine.CurveTimeline.STEPPED: 
                        return 0;
                }
                i = (i - Spine.CurveTimeline.BEZIER) | 0;
                if (curves[i] > time) {
                    var x1 = this.frames[frame];
                    return curves[((i + 1) | 0)] * (time - x1) / (curves[i] - x1);
                }
                var n = (i + Spine.CurveTimeline.BEZIER_SIZE) | 0;
                for (i = (i + 2) | 0; i < n; i = (i + 2) | 0) {
                    if (curves[i] >= time) {
                        var x2 = curves[((i - 2) | 0)], y = curves[((i - 1) | 0)];
                        return y + (time - x2) / (curves[i] - x2) * (curves[((i + 1) | 0)] - y);
                    }
                }
                { // scope added to prevent compile error "float x and y declared in enclosing scope"
                    var x3 = curves[((n - 2) | 0)], y1 = curves[((n - 1) | 0)];
                    return y1 + (1 - y1) * (time - x3) / (this.frames[((frame + this.FrameEntries) | 0)] - x3);
                }
            },
            /*Spine.DeformTimeline.GetCurvePercent end.*/

            /*Spine.DeformTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.DeformTimeline#Apply", this ); }

                var $t;

                var slot = ($t = skeleton.slots.Items)[this.slotIndex];
                if (!slot.bone.active) {
                    return;
                }
                var vertexAttachment = Bridge.as(slot.attachment, Spine.VertexAttachment);
                if (vertexAttachment == null || !Bridge.referenceEquals(vertexAttachment.TimelineAttachment, this.attachment)) {
                    return;
                }

                var deformArray = slot.deform;
                if (deformArray.Count === 0) {
                    blend = Spine.MixBlend.Setup;
                }

                var vertices = this.vertices;
                var vertexCount = vertices[0].length;

                var deform;

                var frames = this.frames;
                if (time < frames[0]) {
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            deformArray.Clear();
                            return;
                        case Spine.MixBlend.First: 
                            if (alpha === 1) {
                                deformArray.Clear();
                                return;
                            }
                            // Ensure size and preemptively set count.
                            if (deformArray.Capacity < vertexCount) {
                                deformArray.Capacity = vertexCount;
                            }
                            deformArray.Count = vertexCount;
                            deform = deformArray.Items;
                            if (vertexAttachment.bones == null) {
                                // Unweighted vertex positions.
                                var setupVertices = vertexAttachment.vertices;
                                for (var i = 0; i < vertexCount; i = (i + 1) | 0) {
                                    deform[i] += (setupVertices[i] - deform[i]) * alpha;
                                }
                            } else {
                                // Weighted deform offsets.
                                alpha = 1 - alpha;
                                for (var i1 = 0; i1 < vertexCount; i1 = (i1 + 1) | 0) {
                                    deform[i1] *= alpha;
                                }
                            }
                            return;
                    }
                    return;
                }

                // Ensure size and preemptively set count.
                if (deformArray.Capacity < vertexCount) {
                    deformArray.Capacity = vertexCount;
                }
                deformArray.Count = vertexCount;
                deform = deformArray.Items;

                if (time >= frames[((frames.length - 1) | 0)]) { // Time is after last frame.
                    var lastVertices = vertices[((frames.length - 1) | 0)];
                    if (alpha === 1) {
                        if (blend === Spine.MixBlend.Add) {
                            if (vertexAttachment.bones == null) {
                                // Unweighted vertex positions, no alpha.
                                var setupVertices1 = vertexAttachment.vertices;
                                for (var i2 = 0; i2 < vertexCount; i2 = (i2 + 1) | 0) {
                                    deform[i2] += lastVertices[i2] - setupVertices1[i2];
                                }
                            } else {
                                // Weighted deform offsets, no alpha.
                                for (var i3 = 0; i3 < vertexCount; i3 = (i3 + 1) | 0) {
                                    deform[i3] += lastVertices[i3];
                                }
                            }
                        } else {
                            // Vertex positions or deform offsets, no alpha.
                            System.Array.copy(lastVertices, 0, deform, 0, vertexCount);
                        }
                    } else {
                        switch (blend) {
                            case Spine.MixBlend.Setup: 
                                {
                                    if (vertexAttachment.bones == null) {
                                        // Unweighted vertex positions, with alpha.
                                        var setupVertices2 = vertexAttachment.vertices;
                                        for (var i4 = 0; i4 < vertexCount; i4 = (i4 + 1) | 0) {
                                            var setup = setupVertices2[i4];
                                            deform[i4] = setup + (lastVertices[i4] - setup) * alpha;
                                        }
                                    } else {
                                        // Weighted deform offsets, with alpha.
                                        for (var i5 = 0; i5 < vertexCount; i5 = (i5 + 1) | 0) {
                                            deform[i5] = lastVertices[i5] * alpha;
                                        }
                                    }
                                    break;
                                }
                            case Spine.MixBlend.First: 
                            case Spine.MixBlend.Replace: 
                                // Vertex positions or deform offsets, with alpha.
                                for (var i6 = 0; i6 < vertexCount; i6 = (i6 + 1) | 0) {
                                    deform[i6] += (lastVertices[i6] - deform[i6]) * alpha;
                                }
                                break;
                            case Spine.MixBlend.Add: 
                                if (vertexAttachment.bones == null) {
                                    // Unweighted vertex positions, no alpha.
                                    var setupVertices3 = vertexAttachment.vertices;
                                    for (var i7 = 0; i7 < vertexCount; i7 = (i7 + 1) | 0) {
                                        deform[i7] += (lastVertices[i7] - setupVertices3[i7]) * alpha;
                                    }
                                } else {
                                    // Weighted deform offsets, alpha.
                                    for (var i8 = 0; i8 < vertexCount; i8 = (i8 + 1) | 0) {
                                        deform[i8] += lastVertices[i8] * alpha;
                                    }
                                }
                                break;
                        }
                    }
                    return;
                }

                var frame = Spine.Timeline.Search(frames, time);
                var percent = this.GetCurvePercent(time, frame);
                var prevVertices = vertices[frame];
                var nextVertices = vertices[((frame + 1) | 0)];

                if (alpha === 1) {
                    if (blend === Spine.MixBlend.Add) {
                        if (vertexAttachment.bones == null) {
                            // Unweighted vertex positions, no alpha.
                            var setupVertices4 = vertexAttachment.vertices;
                            for (var i9 = 0; i9 < vertexCount; i9 = (i9 + 1) | 0) {
                                var prev = prevVertices[i9];
                                deform[i9] += prev + (nextVertices[i9] - prev) * percent - setupVertices4[i9];
                            }
                        } else {
                            // Weighted deform offsets, no alpha.
                            for (var i10 = 0; i10 < vertexCount; i10 = (i10 + 1) | 0) {
                                var prev1 = prevVertices[i10];
                                deform[i10] += prev1 + (nextVertices[i10] - prev1) * percent;
                            }
                        }
                    } else {
                        // Vertex positions or deform offsets, no alpha.
                        for (var i11 = 0; i11 < vertexCount; i11 = (i11 + 1) | 0) {
                            var prev2 = prevVertices[i11];
                            deform[i11] = prev2 + (nextVertices[i11] - prev2) * percent;
                        }
                    }
                } else {
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            {
                                if (vertexAttachment.bones == null) {
                                    // Unweighted vertex positions, with alpha.
                                    var setupVertices5 = vertexAttachment.vertices;
                                    for (var i12 = 0; i12 < vertexCount; i12 = (i12 + 1) | 0) {
                                        var prev3 = prevVertices[i12], setup1 = setupVertices5[i12];
                                        deform[i12] = setup1 + (prev3 + (nextVertices[i12] - prev3) * percent - setup1) * alpha;
                                    }
                                } else {
                                    // Weighted deform offsets, with alpha.
                                    for (var i13 = 0; i13 < vertexCount; i13 = (i13 + 1) | 0) {
                                        var prev4 = prevVertices[i13];
                                        deform[i13] = (prev4 + (nextVertices[i13] - prev4) * percent) * alpha;
                                    }
                                }
                                break;
                            }
                        case Spine.MixBlend.First: 
                        case Spine.MixBlend.Replace: 
                            {
                                // Vertex positions or deform offsets, with alpha.
                                for (var i14 = 0; i14 < vertexCount; i14 = (i14 + 1) | 0) {
                                    var prev5 = prevVertices[i14];
                                    deform[i14] += (prev5 + (nextVertices[i14] - prev5) * percent - deform[i14]) * alpha;
                                }
                                break;
                            }
                        case Spine.MixBlend.Add: 
                            if (vertexAttachment.bones == null) {
                                // Unweighted vertex positions, with alpha.
                                var setupVertices6 = vertexAttachment.vertices;
                                for (var i15 = 0; i15 < vertexCount; i15 = (i15 + 1) | 0) {
                                    var prev6 = prevVertices[i15];
                                    deform[i15] += (prev6 + (nextVertices[i15] - prev6) * percent - setupVertices6[i15]) * alpha;
                                }
                            } else {
                                // Weighted deform offsets, with alpha.
                                for (var i16 = 0; i16 < vertexCount; i16 = (i16 + 1) | 0) {
                                    var prev7 = prevVertices[i16];
                                    deform[i16] += (prev7 + (nextVertices[i16] - prev7) * percent) * alpha;
                                }
                            }
                            break;
                    }
                }
            },
            /*Spine.DeformTimeline.Apply end.*/


        }
    });
    /*Spine.DeformTimeline end.*/

    /*Spine.IkConstraintTimeline start.*/
    /**
     * Changes an IK constraint's {@link }, {@link },
     {@link }, {@link }, and {@link }.
     *
     * @public
     * @class Spine.IkConstraintTimeline
     * @augments Spine.CurveTimeline
     */
    Bridge.define("Spine.IkConstraintTimeline", {
        inherits: [Spine.CurveTimeline],
        statics: {
            fields: {
                ENTRIES: 0,
                MIX: 0,
                SOFTNESS: 0,
                BEND_DIRECTION: 0,
                COMPRESS: 0,
                STRETCH: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraintTimeline#init", this ); }

                    this.ENTRIES = 6;
                    this.MIX = 1;
                    this.SOFTNESS = 2;
                    this.BEND_DIRECTION = 3;
                    this.COMPRESS = 4;
                    this.STRETCH = 5;
                }
            }
        },
        fields: {
            constraintIndex: 0
        },
        props: {
            FrameEntries: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraintTimeline#FrameEntries#get", this ); }

                    return Spine.IkConstraintTimeline.ENTRIES;
                }
            },
            /**
             * The index of the IK constraint in {@link } that will be changed when this timeline is
             applied.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.IkConstraintTimeline
             * @function IkConstraintIndex
             * @type number
             */
            IkConstraintIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraintTimeline#IkConstraintIndex#get", this ); }

                    return this.constraintIndex;
                }
            }
        },
        ctors: {
            ctor: function (frameCount, bezierCount, ikConstraintIndex) {
if ( TRACE ) { TRACE( "Spine.IkConstraintTimeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline.ctor.call(this, frameCount, bezierCount, [Spine.Property.IkConstraint + "|" + ikConstraintIndex]);
                this.constraintIndex = ikConstraintIndex;
            }
        },
        methods: {
            /*Spine.IkConstraintTimeline.SetFrame start.*/
            /**
             * Sets the time, mix, softness, bend direction, compress, and stretch for the specified frame.
             *
             * @instance
             * @public
             * @this Spine.IkConstraintTimeline
             * @memberof Spine.IkConstraintTimeline
             * @param   {number}     frame            Between 0 and <pre><code>frameCount</code></pre>, inclusive.
             * @param   {number}     time             The frame time in seconds.
             * @param   {number}     mix              
             * @param   {number}     softness         
             * @param   {number}     bendDirection    1 or -1.
             * @param   {boolean}    compress         
             * @param   {boolean}    stretch
             * @return  {void}
             */
            SetFrame: function (frame, time, mix, softness, bendDirection, compress, stretch) {
if ( TRACE ) { TRACE( "Spine.IkConstraintTimeline#SetFrame", this ); }

                frame = Bridge.Int.mul(frame, Spine.IkConstraintTimeline.ENTRIES);
                this.frames[frame] = time;
                this.frames[((frame + Spine.IkConstraintTimeline.MIX) | 0)] = mix;
                this.frames[((frame + Spine.IkConstraintTimeline.SOFTNESS) | 0)] = softness;
                this.frames[((frame + Spine.IkConstraintTimeline.BEND_DIRECTION) | 0)] = bendDirection;
                this.frames[((frame + Spine.IkConstraintTimeline.COMPRESS) | 0)] = compress ? 1 : 0;
                this.frames[((frame + Spine.IkConstraintTimeline.STRETCH) | 0)] = stretch ? 1 : 0;
            },
            /*Spine.IkConstraintTimeline.SetFrame end.*/

            /*Spine.IkConstraintTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.IkConstraintTimeline#Apply", this ); }

                var $t;
                var constraint = ($t = skeleton.ikConstraints.Items)[this.constraintIndex];
                if (!constraint.active) {
                    return;
                }

                var frames = this.frames;
                if (time < frames[0]) {
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            constraint.mix = constraint.data.mix;
                            constraint.softness = constraint.data.softness;
                            constraint.bendDirection = constraint.data.bendDirection;
                            constraint.compress = constraint.data.compress;
                            constraint.stretch = constraint.data.stretch;
                            return;
                        case Spine.MixBlend.First: 
                            constraint.mix += (constraint.data.mix - constraint.mix) * alpha;
                            constraint.softness += (constraint.data.softness - constraint.softness) * alpha;
                            constraint.bendDirection = constraint.data.bendDirection;
                            constraint.compress = constraint.data.compress;
                            constraint.stretch = constraint.data.stretch;
                            return;
                    }
                    return;
                }

                var mix, softness;
                var i = Spine.Timeline.Search$1(frames, time, Spine.IkConstraintTimeline.ENTRIES), curveType = Bridge.Int.clip32(this.curves[((Bridge.Int.div(i, Spine.IkConstraintTimeline.ENTRIES)) | 0)]);
                switch (curveType) {
                    case Spine.CurveTimeline.LINEAR: 
                        var before = frames[i];
                        mix = frames[((i + Spine.IkConstraintTimeline.MIX) | 0)];
                        softness = frames[((i + Spine.IkConstraintTimeline.SOFTNESS) | 0)];
                        var t = (time - before) / (frames[((i + Spine.IkConstraintTimeline.ENTRIES) | 0)] - before);
                        mix += (frames[((((i + Spine.IkConstraintTimeline.ENTRIES) | 0) + Spine.IkConstraintTimeline.MIX) | 0)] - mix) * t;
                        softness += (frames[((((i + Spine.IkConstraintTimeline.ENTRIES) | 0) + Spine.IkConstraintTimeline.SOFTNESS) | 0)] - softness) * t;
                        break;
                    case Spine.CurveTimeline.STEPPED: 
                        mix = frames[((i + Spine.IkConstraintTimeline.MIX) | 0)];
                        softness = frames[((i + Spine.IkConstraintTimeline.SOFTNESS) | 0)];
                        break;
                    default: 
                        mix = this.GetBezierValue(time, i, Spine.IkConstraintTimeline.MIX, ((curveType - Spine.CurveTimeline.BEZIER) | 0));
                        softness = this.GetBezierValue(time, i, Spine.IkConstraintTimeline.SOFTNESS, ((((curveType + Spine.CurveTimeline.BEZIER_SIZE) | 0) - Spine.CurveTimeline.BEZIER) | 0));
                        break;
                }

                if (blend === Spine.MixBlend.Setup) {
                    constraint.mix = constraint.data.mix + (mix - constraint.data.mix) * alpha;
                    constraint.softness = constraint.data.softness + (softness - constraint.data.softness) * alpha;
                    if (direction === Spine.MixDirection.Out) {
                        constraint.bendDirection = constraint.data.bendDirection;
                        constraint.compress = constraint.data.compress;
                        constraint.stretch = constraint.data.stretch;
                    } else {
                        constraint.bendDirection = Bridge.Int.clip32(frames[((i + Spine.IkConstraintTimeline.BEND_DIRECTION) | 0)]);
                        constraint.compress = frames[((i + Spine.IkConstraintTimeline.COMPRESS) | 0)] !== 0;
                        constraint.stretch = frames[((i + Spine.IkConstraintTimeline.STRETCH) | 0)] !== 0;
                    }
                } else {
                    constraint.mix += (mix - constraint.mix) * alpha;
                    constraint.softness += (softness - constraint.softness) * alpha;
                    if (direction === Spine.MixDirection.In) {
                        constraint.bendDirection = Bridge.Int.clip32(frames[((i + Spine.IkConstraintTimeline.BEND_DIRECTION) | 0)]);
                        constraint.compress = frames[((i + Spine.IkConstraintTimeline.COMPRESS) | 0)] !== 0;
                        constraint.stretch = frames[((i + Spine.IkConstraintTimeline.STRETCH) | 0)] !== 0;
                    }
                }
            },
            /*Spine.IkConstraintTimeline.Apply end.*/


        }
    });
    /*Spine.IkConstraintTimeline end.*/

    /*Spine.MeshAttachment start.*/
    /**
     * Attachment that displays a texture region using a mesh.
     *
     * @public
     * @class Spine.MeshAttachment
     * @augments Spine.VertexAttachment
     * @implements  Spine.IHasTextureRegion
     */
    Bridge.define("Spine.MeshAttachment", {
        inherits: [Spine.VertexAttachment,Spine.IHasTextureRegion],
        fields: {
            region: null,
            path: null,
            regionUVs: null,
            uvs: null,
            triangles: null,
            r: 0,
            g: 0,
            b: 0,
            a: 0,
            hullLength: 0,
            parentMesh: null,
            sequence: null,
            Edges: null,
            Width: 0,
            Height: 0
        },
        props: {
            Region: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#Region#get", this ); }

                    return this.region;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#Region#set", this ); }

                    if (value == null) {
                        throw new System.ArgumentNullException.$ctor3("region", "region cannot be null.");
                    }
                    this.region = value;
                }
            },
            HullLength: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#HullLength#get", this ); }

                    return this.hullLength;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#HullLength#set", this ); }

                    this.hullLength = value;
                }
            },
            RegionUVs: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#RegionUVs#get", this ); }

                    return this.regionUVs;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#RegionUVs#set", this ); }

                    this.regionUVs = value;
                }
            },
            /**
             * The UV pair for each vertex, normalized within the entire texture.
             <seealso cref="MeshAttachment.UpdateRegion" />
             *
             * @instance
             * @public
             * @memberof Spine.MeshAttachment
             * @function UVs
             * @type Array.<number>
             * @see {@link MeshAttachment.UpdateRegion}
             */
            UVs: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#UVs#get", this ); }

                    return this.uvs;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#UVs#set", this ); }

                    this.uvs = value;
                }
            },
            Triangles: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#Triangles#get", this ); }

                    return this.triangles;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#Triangles#set", this ); }

                    this.triangles = value;
                }
            },
            R: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#R#get", this ); }

                    return this.r;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#R#set", this ); }

                    this.r = value;
                }
            },
            G: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#G#get", this ); }

                    return this.g;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#G#set", this ); }

                    this.g = value;
                }
            },
            B: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#B#get", this ); }

                    return this.b;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#B#set", this ); }

                    this.b = value;
                }
            },
            A: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#A#get", this ); }

                    return this.a;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#A#set", this ); }

                    this.a = value;
                }
            },
            Path: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#Path#get", this ); }

                    return this.path;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#Path#set", this ); }

                    this.path = value;
                }
            },
            Sequence: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#Sequence#get", this ); }

                    return this.sequence;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#Sequence#set", this ); }

                    this.sequence = value;
                }
            },
            ParentMesh: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#ParentMesh#get", this ); }

                    return this.parentMesh;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#ParentMesh#set", this ); }

                    this.parentMesh = value;
                    if (value != null) {
                        this.bones = value.bones;
                        this.vertices = value.vertices;
                        this.worldVerticesLength = value.worldVerticesLength;
                        this.regionUVs = value.regionUVs;
                        this.triangles = value.triangles;
                        this.HullLength = value.HullLength;
                        this.Edges = value.Edges;
                        this.Width = value.Width;
                        this.Height = value.Height;
                    }
                }
            }
        },
        alias: [
            "Region", "Spine$IHasTextureRegion$Region",
            "R", "Spine$IHasTextureRegion$R",
            "G", "Spine$IHasTextureRegion$G",
            "B", "Spine$IHasTextureRegion$B",
            "A", "Spine$IHasTextureRegion$A",
            "Path", "Spine$IHasTextureRegion$Path",
            "Sequence", "Spine$IHasTextureRegion$Sequence",
            "UpdateRegion", "Spine$IHasTextureRegion$UpdateRegion"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#init", this ); }

                this.r = 1;
                this.g = 1;
                this.b = 1;
                this.a = 1;
            },
            $ctor1: function (name) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#$ctor1", this ); }

                this.$initialize();
                Spine.VertexAttachment.$ctor1.call(this, name);
            },
            /**
             * Copy constructor. Use {@link } if the other mesh is a linked mesh.
             *
             * @instance
             * @protected
             * @this Spine.MeshAttachment
             * @memberof Spine.MeshAttachment
             * @param   {Spine.MeshAttachment}    other
             * @return  {void}
             */
            ctor: function (other) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#ctor", this ); }

                this.$initialize();
                Spine.VertexAttachment.ctor.call(this, other);

                if (this.parentMesh != null) {
                    throw new System.ArgumentException.$ctor1("Use newLinkedMesh to copy a linked mesh.");
                }

                this.region = other.region;
                this.path = other.path;
                this.r = other.r;
                this.g = other.g;
                this.b = other.b;
                this.a = other.a;

                this.regionUVs = System.Array.init(other.regionUVs.length, 0, System.Single);
                System.Array.copy(other.regionUVs, 0, this.regionUVs, 0, this.regionUVs.length);

                this.uvs = System.Array.init(other.uvs.length, 0, System.Single);
                System.Array.copy(other.uvs, 0, this.uvs, 0, this.uvs.length);

                this.triangles = System.Array.init(other.triangles.length, 0, System.Int32);
                System.Array.copy(other.triangles, 0, this.triangles, 0, this.triangles.length);

                this.hullLength = other.hullLength;
                this.sequence = other.sequence == null ? null : new Spine.Sequence.ctor(other.sequence);

                // Nonessential.
                if (other.Edges != null) {
                    this.Edges = System.Array.init(other.Edges.length, 0, System.Int32);
                    System.Array.copy(other.Edges, 0, this.Edges, 0, this.Edges.length);
                }
                this.Width = other.Width;
                this.Height = other.Height;
            }
        },
        methods: {
            /*Spine.MeshAttachment.UpdateRegion start.*/
            UpdateRegion: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#UpdateRegion", this ); }

                var regionUVs = this.regionUVs;
                if (this.uvs == null || this.uvs.length !== regionUVs.length) {
                    this.uvs = System.Array.init(regionUVs.length, 0, System.Single);
                }
                var uvs = this.uvs;
                var n = uvs.length;
                var u, v, width, height;

                if (Bridge.is(this.region, Spine.AtlasRegion)) {
                    u = this.region.u;
                    v = this.region.v;
                    var region = Bridge.cast(this.region, Spine.AtlasRegion);
                    // Note: difference from reference implementation.
                    // Covers rotation since region.width and height are already setup accordingly.
                    var textureWidth = this.region.width / (region.u2 - region.u);
                    var textureHeight = this.region.height / (region.v2 - region.v);
                    switch (region.degrees) {
                        case 90: 
                            u -= (region.originalHeight - region.offsetY - region.packedWidth) / textureWidth;
                            v -= (region.originalWidth - region.offsetX - region.packedHeight) / textureHeight;
                            width = region.originalHeight / textureWidth;
                            height = region.originalWidth / textureHeight;
                            for (var i = 0; i < n; i = (i + 2) | 0) {
                                uvs[i] = u + regionUVs[((i + 1) | 0)] * width;
                                uvs[((i + 1) | 0)] = v + (1 - regionUVs[i]) * height;
                            }
                            return;
                        case 180: 
                            u -= (region.originalWidth - region.offsetX - region.packedWidth) / textureWidth;
                            v -= region.offsetY / textureHeight;
                            width = region.originalWidth / textureWidth;
                            height = region.originalHeight / textureHeight;
                            for (var i1 = 0; i1 < n; i1 = (i1 + 2) | 0) {
                                uvs[i1] = u + (1 - regionUVs[i1]) * width;
                                uvs[((i1 + 1) | 0)] = v + (1 - regionUVs[((i1 + 1) | 0)]) * height;
                            }
                            return;
                        case 270: 
                            u -= region.offsetY / textureWidth;
                            v -= region.offsetX / textureHeight;
                            width = region.originalHeight / textureWidth;
                            height = region.originalWidth / textureHeight;
                            for (var i2 = 0; i2 < n; i2 = (i2 + 2) | 0) {
                                uvs[i2] = u + (1 - regionUVs[((i2 + 1) | 0)]) * width;
                                uvs[((i2 + 1) | 0)] = v + regionUVs[i2] * height;
                            }
                            return;
                    }
                    u -= region.offsetX / textureWidth;
                    v -= (region.originalHeight - region.offsetY - region.packedHeight) / textureHeight;
                    width = region.originalWidth / textureWidth;
                    height = region.originalHeight / textureHeight;
                } else if (this.region == null) {
                    u = (v = 0);
                    width = (height = 1);
                } else {
                    u = this.region.u;
                    v = this.region.v;
                    width = this.region.u2 - u;
                    height = this.region.v2 - v;
                }
                for (var i3 = 0; i3 < n; i3 = (i3 + 2) | 0) {
                    uvs[i3] = u + regionUVs[i3] * width;
                    uvs[((i3 + 1) | 0)] = v + regionUVs[((i3 + 1) | 0)] * height;
                }
            },
            /*Spine.MeshAttachment.UpdateRegion end.*/

            /*Spine.MeshAttachment.ComputeWorldVertices start.*/
            /**
             * If the attachment has a {@link }, the region may be changed.
             *
             * @instance
             * @public
             * @override
             * @this Spine.MeshAttachment
             * @memberof Spine.MeshAttachment
             * @param   {Spine.Slot}        slot             
             * @param   {number}            start            
             * @param   {number}            count            
             * @param   {Array.<number>}    worldVertices    
             * @param   {number}            offset           
             * @param   {number}            stride
             * @return  {void}
             */
            ComputeWorldVertices: function (slot, start, count, worldVertices, offset, stride) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#ComputeWorldVertices", this ); }

                if (stride === void 0) { stride = 2; }
                if (this.sequence != null) {
                    this.sequence.Apply(slot, this);
                }
                Spine.VertexAttachment.prototype.ComputeWorldVertices.call(this, slot, start, count, worldVertices, offset, stride);
            },
            /*Spine.MeshAttachment.ComputeWorldVertices end.*/

            /*Spine.MeshAttachment.NewLinkedMesh start.*/
            
            NewLinkedMesh: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#NewLinkedMesh", this ); }

                var mesh = new Spine.MeshAttachment.$ctor1(this.Name);

                mesh.timelineAttachment = this.timelineAttachment;
                mesh.region = this.region;
                mesh.path = this.path;
                mesh.r = this.r;
                mesh.g = this.g;
                mesh.b = this.b;
                mesh.a = this.a;
                mesh.ParentMesh = this.parentMesh != null ? this.parentMesh : this;
                if (mesh.Region != null) {
                    mesh.UpdateRegion();
                }
                return mesh;
            },
            /*Spine.MeshAttachment.NewLinkedMesh end.*/

            /*Spine.MeshAttachment.Copy start.*/
            Copy: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#Copy", this ); }

                return this.parentMesh != null ? this.NewLinkedMesh() : new Spine.MeshAttachment.ctor(this);
            },
            /*Spine.MeshAttachment.Copy end.*/


        }
    });
    /*Spine.MeshAttachment end.*/

    /*Spine.PathAttachment start.*/
    Bridge.define("Spine.PathAttachment", {
        inherits: [Spine.VertexAttachment],
        fields: {
            lengths: null,
            closed: false,
            constantSpeed: false
        },
        props: {
            /**
             * The length in the setup pose from the start of the path to the end of each curve.
             *
             * @instance
             * @public
             * @memberof Spine.PathAttachment
             * @function Lengths
             * @type Array.<number>
             */
            Lengths: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathAttachment#Lengths#get", this ); }

                    return this.lengths;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathAttachment#Lengths#set", this ); }

                    this.lengths = value;
                }
            },
            /**
             * If true, the start and end knots are connected.
             *
             * @instance
             * @public
             * @memberof Spine.PathAttachment
             * @function Closed
             * @type boolean
             */
            Closed: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathAttachment#Closed#get", this ); }

                    return this.closed;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathAttachment#Closed#set", this ); }

                    this.closed = value;
                }
            },
            /**
             * If true, additional calculations are performed to make computing positions along the path more accurate and movement along
             the path have a constant speed.
             *
             * @instance
             * @public
             * @memberof Spine.PathAttachment
             * @function ConstantSpeed
             * @type boolean
             */
            ConstantSpeed: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathAttachment#ConstantSpeed#get", this ); }

                    return this.constantSpeed;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathAttachment#ConstantSpeed#set", this ); }

                    this.constantSpeed = value;
                }
            }
        },
        ctors: {
            $ctor1: function (name) {
if ( TRACE ) { TRACE( "Spine.PathAttachment#$ctor1", this ); }

                this.$initialize();
                Spine.VertexAttachment.$ctor1.call(this, name);
            },
            /**
             * Copy constructor.
             *
             * @instance
             * @protected
             * @this Spine.PathAttachment
             * @memberof Spine.PathAttachment
             * @param   {Spine.PathAttachment}    other
             * @return  {void}
             */
            ctor: function (other) {
if ( TRACE ) { TRACE( "Spine.PathAttachment#ctor", this ); }

                this.$initialize();
                Spine.VertexAttachment.ctor.call(this, other);

                this.lengths = System.Array.init(other.lengths.length, 0, System.Single);
                System.Array.copy(other.lengths, 0, this.lengths, 0, this.lengths.length);

                this.closed = other.closed;
                this.constantSpeed = other.constantSpeed;
            }
        },
        methods: {
            /*Spine.PathAttachment.Copy start.*/
            Copy: function () {
if ( TRACE ) { TRACE( "Spine.PathAttachment#Copy", this ); }

                return new Spine.PathAttachment.ctor(this);
            },
            /*Spine.PathAttachment.Copy end.*/


        }
    });
    /*Spine.PathAttachment end.*/

    /*Spine.PathConstraintMixTimeline start.*/
    /**
     * Changes a path constraint's {@link }, {@link }, and
     {@link }.
     *
     * @public
     * @class Spine.PathConstraintMixTimeline
     * @augments Spine.CurveTimeline
     */
    Bridge.define("Spine.PathConstraintMixTimeline", {
        inherits: [Spine.CurveTimeline],
        statics: {
            fields: {
                ENTRIES: 0,
                ROTATE: 0,
                X: 0,
                Y: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintMixTimeline#init", this ); }

                    this.ENTRIES = 4;
                    this.ROTATE = 1;
                    this.X = 2;
                    this.Y = 3;
                }
            }
        },
        fields: {
            constraintIndex: 0
        },
        props: {
            FrameEntries: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintMixTimeline#FrameEntries#get", this ); }

                    return Spine.PathConstraintMixTimeline.ENTRIES;
                }
            },
            /**
             * The index of the path constraint slot in {@link } that will be changed when this timeline
             is applied.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.PathConstraintMixTimeline
             * @function PathConstraintIndex
             * @type number
             */
            PathConstraintIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintMixTimeline#PathConstraintIndex#get", this ); }

                    return this.constraintIndex;
                }
            }
        },
        ctors: {
            ctor: function (frameCount, bezierCount, pathConstraintIndex) {
if ( TRACE ) { TRACE( "Spine.PathConstraintMixTimeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline.ctor.call(this, frameCount, bezierCount, [Spine.Property.PathConstraintMix + "|" + pathConstraintIndex]);
                this.constraintIndex = pathConstraintIndex;
            }
        },
        methods: {
            /*Spine.PathConstraintMixTimeline.SetFrame start.*/
            /**
             * Sets the time and color for the specified frame.
             *
             * @instance
             * @public
             * @this Spine.PathConstraintMixTimeline
             * @memberof Spine.PathConstraintMixTimeline
             * @param   {number}    frame        Between 0 and <pre><code>frameCount</code></pre>, inclusive.
             * @param   {number}    time         The frame time in seconds.
             * @param   {number}    mixRotate    
             * @param   {number}    mixX         
             * @param   {number}    mixY
             * @return  {void}
             */
            SetFrame: function (frame, time, mixRotate, mixX, mixY) {
if ( TRACE ) { TRACE( "Spine.PathConstraintMixTimeline#SetFrame", this ); }

                frame = frame << 2;
                this.frames[frame] = time;
                this.frames[((frame + Spine.PathConstraintMixTimeline.ROTATE) | 0)] = mixRotate;
                this.frames[((frame + Spine.PathConstraintMixTimeline.X) | 0)] = mixX;
                this.frames[((frame + Spine.PathConstraintMixTimeline.Y) | 0)] = mixY;
            },
            /*Spine.PathConstraintMixTimeline.SetFrame end.*/

            /*Spine.PathConstraintMixTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.PathConstraintMixTimeline#Apply", this ); }

                var $t;
                var constraint = ($t = skeleton.pathConstraints.Items)[this.constraintIndex];
                if (!constraint.active) {
                    return;
                }

                var frames = this.frames;
                if (time < frames[0]) {
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            constraint.mixRotate = constraint.data.mixRotate;
                            constraint.mixX = constraint.data.mixX;
                            constraint.mixY = constraint.data.mixY;
                            return;
                        case Spine.MixBlend.First: 
                            constraint.mixRotate += (constraint.data.mixRotate - constraint.mixRotate) * alpha;
                            constraint.mixX += (constraint.data.mixX - constraint.mixX) * alpha;
                            constraint.mixY += (constraint.data.mixY - constraint.mixY) * alpha;
                            return;
                    }
                    return;
                }

                var rotate, x, y;
                var i = Spine.Timeline.Search$1(frames, time, Spine.PathConstraintMixTimeline.ENTRIES), curveType = Bridge.Int.clip32(this.curves[i >> 2]);
                switch (curveType) {
                    case Spine.CurveTimeline.LINEAR: 
                        var before = frames[i];
                        rotate = frames[((i + Spine.PathConstraintMixTimeline.ROTATE) | 0)];
                        x = frames[((i + Spine.PathConstraintMixTimeline.X) | 0)];
                        y = frames[((i + Spine.PathConstraintMixTimeline.Y) | 0)];
                        var t = (time - before) / (frames[((i + Spine.PathConstraintMixTimeline.ENTRIES) | 0)] - before);
                        rotate += (frames[((((i + Spine.PathConstraintMixTimeline.ENTRIES) | 0) + Spine.PathConstraintMixTimeline.ROTATE) | 0)] - rotate) * t;
                        x += (frames[((((i + Spine.PathConstraintMixTimeline.ENTRIES) | 0) + Spine.PathConstraintMixTimeline.X) | 0)] - x) * t;
                        y += (frames[((((i + Spine.PathConstraintMixTimeline.ENTRIES) | 0) + Spine.PathConstraintMixTimeline.Y) | 0)] - y) * t;
                        break;
                    case Spine.CurveTimeline.STEPPED: 
                        rotate = frames[((i + Spine.PathConstraintMixTimeline.ROTATE) | 0)];
                        x = frames[((i + Spine.PathConstraintMixTimeline.X) | 0)];
                        y = frames[((i + Spine.PathConstraintMixTimeline.Y) | 0)];
                        break;
                    default: 
                        rotate = this.GetBezierValue(time, i, Spine.PathConstraintMixTimeline.ROTATE, ((curveType - Spine.CurveTimeline.BEZIER) | 0));
                        x = this.GetBezierValue(time, i, Spine.PathConstraintMixTimeline.X, ((((curveType + Spine.CurveTimeline.BEZIER_SIZE) | 0) - Spine.CurveTimeline.BEZIER) | 0));
                        y = this.GetBezierValue(time, i, Spine.PathConstraintMixTimeline.Y, ((((curveType + 36) | 0) - Spine.CurveTimeline.BEZIER) | 0));
                        break;
                }

                if (blend === Spine.MixBlend.Setup) {
                    var data = constraint.data;
                    constraint.mixRotate = data.mixRotate + (rotate - data.mixRotate) * alpha;
                    constraint.mixX = data.mixX + (x - data.mixX) * alpha;
                    constraint.mixY = data.mixY + (y - data.mixY) * alpha;
                } else {
                    constraint.mixRotate += (rotate - constraint.mixRotate) * alpha;
                    constraint.mixX += (x - constraint.mixX) * alpha;
                    constraint.mixY += (y - constraint.mixY) * alpha;
                }
            },
            /*Spine.PathConstraintMixTimeline.Apply end.*/


        }
    });
    /*Spine.PathConstraintMixTimeline end.*/

    /*Spine.PowOut start.*/
    Bridge.define("Spine.PowOut", {
        inherits: [Spine.Pow],
        ctors: {
            ctor: function (power) {
if ( TRACE ) { TRACE( "Spine.PowOut#ctor", this ); }

                this.$initialize();
                Spine.Pow.ctor.call(this, power);
            }
        },
        methods: {
            /*Spine.PowOut.Apply$1 start.*/
            Apply$1: function (a) {
if ( TRACE ) { TRACE( "Spine.PowOut#Apply$1", this ); }

                return Math.pow(a - 1, this.Power) * (this.Power % 2 === 0 ? -1 : 1) + 1;
            },
            /*Spine.PowOut.Apply$1 end.*/


        },
        overloads: {
            "Apply(float)": "Apply$1"
        }
    });
    /*Spine.PowOut end.*/

    /*Spine.RGB2Timeline start.*/
    /**
     * Changes the RGB for a slot's {@link } and {@link } for two color tinting.
     *
     * @public
     * @class Spine.RGB2Timeline
     * @augments Spine.CurveTimeline
     * @implements  Spine.ISlotTimeline
     */
    Bridge.define("Spine.RGB2Timeline", {
        inherits: [Spine.CurveTimeline,Spine.ISlotTimeline],
        statics: {
            fields: {
                ENTRIES: 0,
                R: 0,
                G: 0,
                B: 0,
                R2: 0,
                G2: 0,
                B2: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.RGB2Timeline#init", this ); }

                    this.ENTRIES = 7;
                    this.R = 1;
                    this.G = 2;
                    this.B = 3;
                    this.R2 = 4;
                    this.G2 = 5;
                    this.B2 = 6;
                }
            }
        },
        fields: {
            slotIndex: 0
        },
        props: {
            FrameEntries: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RGB2Timeline#FrameEntries#get", this ); }

                    return Spine.RGB2Timeline.ENTRIES;
                }
            },
            /**
             * The index of the slot in {@link } that will be changed when this timeline is applied. The
             {@link } must have a dark color available.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.RGB2Timeline
             * @function SlotIndex
             * @type number
             */
            SlotIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RGB2Timeline#SlotIndex#get", this ); }

                    return this.slotIndex;
                }
            }
        },
        alias: ["SlotIndex", "Spine$ISlotTimeline$SlotIndex"],
        ctors: {
            ctor: function (frameCount, bezierCount, slotIndex) {
if ( TRACE ) { TRACE( "Spine.RGB2Timeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline.ctor.call(this, frameCount, bezierCount, [Spine.Property.RGB + "|" + slotIndex, Spine.Property.RGB2 + "|" + slotIndex]);
                this.slotIndex = slotIndex;
            }
        },
        methods: {
            /*Spine.RGB2Timeline.SetFrame start.*/
            /**
             * Sets the time, light color, and dark color for the specified frame.
             *
             * @instance
             * @public
             * @this Spine.RGB2Timeline
             * @memberof Spine.RGB2Timeline
             * @param   {number}    frame    Between 0 and <pre><code>frameCount</code></pre>, inclusive.
             * @param   {number}    time     The frame time in seconds.
             * @param   {number}    r        
             * @param   {number}    g        
             * @param   {number}    b        
             * @param   {number}    r2       
             * @param   {number}    g2       
             * @param   {number}    b2
             * @return  {void}
             */
            SetFrame: function (frame, time, r, g, b, r2, g2, b2) {
if ( TRACE ) { TRACE( "Spine.RGB2Timeline#SetFrame", this ); }

                frame = Bridge.Int.mul(frame, Spine.RGB2Timeline.ENTRIES);
                this.frames[frame] = time;
                this.frames[((frame + Spine.RGB2Timeline.R) | 0)] = r;
                this.frames[((frame + Spine.RGB2Timeline.G) | 0)] = g;
                this.frames[((frame + Spine.RGB2Timeline.B) | 0)] = b;
                this.frames[((frame + Spine.RGB2Timeline.R2) | 0)] = r2;
                this.frames[((frame + Spine.RGB2Timeline.G2) | 0)] = g2;
                this.frames[((frame + Spine.RGB2Timeline.B2) | 0)] = b2;
            },
            /*Spine.RGB2Timeline.SetFrame end.*/

            /*Spine.RGB2Timeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.RGB2Timeline#Apply", this ); }

                var $t;
                var slot = ($t = skeleton.slots.Items)[this.slotIndex];
                if (!slot.bone.active) {
                    return;
                }

                var frames = this.frames;
                if (time < frames[0]) {
                    var setup = slot.data;
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            slot.r = setup.r;
                            slot.g = setup.g;
                            slot.b = setup.b;
                            slot.ClampColor();
                            slot.r2 = setup.r2;
                            slot.g2 = setup.g2;
                            slot.b2 = setup.b2;
                            slot.ClampSecondColor();
                            return;
                        case Spine.MixBlend.First: 
                            slot.r += (slot.r - setup.r) * alpha;
                            slot.g += (slot.g - setup.g) * alpha;
                            slot.b += (slot.b - setup.b) * alpha;
                            slot.ClampColor();
                            slot.r2 += (slot.r2 - setup.r2) * alpha;
                            slot.g2 += (slot.g2 - setup.g2) * alpha;
                            slot.b2 += (slot.b2 - setup.b2) * alpha;
                            slot.ClampSecondColor();
                            return;
                    }
                    return;
                }

                var r, g, b, r2, g2, b2;
                var i = Spine.Timeline.Search$1(frames, time, Spine.RGB2Timeline.ENTRIES), curveType = Bridge.Int.clip32(this.curves[((Bridge.Int.div(i, Spine.RGB2Timeline.ENTRIES)) | 0)]);
                switch (curveType) {
                    case Spine.CurveTimeline.LINEAR: 
                        var before = frames[i];
                        r = frames[((i + Spine.RGB2Timeline.R) | 0)];
                        g = frames[((i + Spine.RGB2Timeline.G) | 0)];
                        b = frames[((i + Spine.RGB2Timeline.B) | 0)];
                        r2 = frames[((i + Spine.RGB2Timeline.R2) | 0)];
                        g2 = frames[((i + Spine.RGB2Timeline.G2) | 0)];
                        b2 = frames[((i + Spine.RGB2Timeline.B2) | 0)];
                        var t = (time - before) / (frames[((i + Spine.RGB2Timeline.ENTRIES) | 0)] - before);
                        r += (frames[((((i + Spine.RGB2Timeline.ENTRIES) | 0) + Spine.RGB2Timeline.R) | 0)] - r) * t;
                        g += (frames[((((i + Spine.RGB2Timeline.ENTRIES) | 0) + Spine.RGB2Timeline.G) | 0)] - g) * t;
                        b += (frames[((((i + Spine.RGB2Timeline.ENTRIES) | 0) + Spine.RGB2Timeline.B) | 0)] - b) * t;
                        r2 += (frames[((((i + Spine.RGB2Timeline.ENTRIES) | 0) + Spine.RGB2Timeline.R2) | 0)] - r2) * t;
                        g2 += (frames[((((i + Spine.RGB2Timeline.ENTRIES) | 0) + Spine.RGB2Timeline.G2) | 0)] - g2) * t;
                        b2 += (frames[((((i + Spine.RGB2Timeline.ENTRIES) | 0) + Spine.RGB2Timeline.B2) | 0)] - b2) * t;
                        break;
                    case Spine.CurveTimeline.STEPPED: 
                        r = frames[((i + Spine.RGB2Timeline.R) | 0)];
                        g = frames[((i + Spine.RGB2Timeline.G) | 0)];
                        b = frames[((i + Spine.RGB2Timeline.B) | 0)];
                        r2 = frames[((i + Spine.RGB2Timeline.R2) | 0)];
                        g2 = frames[((i + Spine.RGB2Timeline.G2) | 0)];
                        b2 = frames[((i + Spine.RGB2Timeline.B2) | 0)];
                        break;
                    default: 
                        r = this.GetBezierValue(time, i, Spine.RGB2Timeline.R, ((curveType - Spine.CurveTimeline.BEZIER) | 0));
                        g = this.GetBezierValue(time, i, Spine.RGB2Timeline.G, ((((curveType + Spine.CurveTimeline.BEZIER_SIZE) | 0) - Spine.CurveTimeline.BEZIER) | 0));
                        b = this.GetBezierValue(time, i, Spine.RGB2Timeline.B, ((((curveType + 36) | 0) - Spine.CurveTimeline.BEZIER) | 0));
                        r2 = this.GetBezierValue(time, i, Spine.RGB2Timeline.R2, ((((curveType + 54) | 0) - Spine.CurveTimeline.BEZIER) | 0));
                        g2 = this.GetBezierValue(time, i, Spine.RGB2Timeline.G2, ((((curveType + 72) | 0) - Spine.CurveTimeline.BEZIER) | 0));
                        b2 = this.GetBezierValue(time, i, Spine.RGB2Timeline.B2, ((((curveType + 90) | 0) - Spine.CurveTimeline.BEZIER) | 0));
                        break;
                }

                if (alpha === 1) {
                    slot.r = r;
                    slot.g = g;
                    slot.b = b;
                    slot.r2 = r2;
                    slot.g2 = g2;
                    slot.b2 = b2;
                } else {
                    var br, bg, bb, br2, bg2, bb2;
                    if (blend === Spine.MixBlend.Setup) {
                        var setup1 = slot.data;
                        br = setup1.r;
                        bg = setup1.g;
                        bb = setup1.b;
                        br2 = setup1.r2;
                        bg2 = setup1.g2;
                        bb2 = setup1.b2;
                    } else {
                        br = slot.r;
                        bg = slot.g;
                        bb = slot.b;
                        br2 = slot.r2;
                        bg2 = slot.g2;
                        bb2 = slot.b2;
                    }
                    slot.r = br + (r - br) * alpha;
                    slot.g = bg + (g - bg) * alpha;
                    slot.b = bb + (b - bb) * alpha;
                    slot.r2 = br2 + (r2 - br2) * alpha;
                    slot.g2 = bg2 + (g2 - bg2) * alpha;
                    slot.b2 = bb2 + (b2 - bb2) * alpha;
                }
                slot.ClampColor();
                slot.ClampSecondColor();
            },
            /*Spine.RGB2Timeline.Apply end.*/


        }
    });
    /*Spine.RGB2Timeline end.*/

    /*Spine.RGBA2Timeline start.*/
    /**
     * Changes a slot's {@link } and {@link } for two color tinting.
     *
     * @public
     * @class Spine.RGBA2Timeline
     * @augments Spine.CurveTimeline
     * @implements  Spine.ISlotTimeline
     */
    Bridge.define("Spine.RGBA2Timeline", {
        inherits: [Spine.CurveTimeline,Spine.ISlotTimeline],
        statics: {
            fields: {
                ENTRIES: 0,
                R: 0,
                G: 0,
                B: 0,
                A: 0,
                R2: 0,
                G2: 0,
                B2: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.RGBA2Timeline#init", this ); }

                    this.ENTRIES = 8;
                    this.R = 1;
                    this.G = 2;
                    this.B = 3;
                    this.A = 4;
                    this.R2 = 5;
                    this.G2 = 6;
                    this.B2 = 7;
                }
            }
        },
        fields: {
            slotIndex: 0
        },
        props: {
            FrameEntries: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RGBA2Timeline#FrameEntries#get", this ); }

                    return Spine.RGBA2Timeline.ENTRIES;
                }
            },
            /**
             * The index of the slot in {@link } that will be changed when this timeline is applied. The
             {@link } must have a dark color available.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.RGBA2Timeline
             * @function SlotIndex
             * @type number
             */
            SlotIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RGBA2Timeline#SlotIndex#get", this ); }

                    return this.slotIndex;
                }
            }
        },
        alias: ["SlotIndex", "Spine$ISlotTimeline$SlotIndex"],
        ctors: {
            ctor: function (frameCount, bezierCount, slotIndex) {
if ( TRACE ) { TRACE( "Spine.RGBA2Timeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline.ctor.call(this, frameCount, bezierCount, [Spine.Property.RGB + "|" + slotIndex, Spine.Property.Alpha + "|" + slotIndex, Spine.Property.RGB2 + "|" + slotIndex]);
                this.slotIndex = slotIndex;
            }
        },
        methods: {
            /*Spine.RGBA2Timeline.SetFrame start.*/
            /**
             * Sets the time, light color, and dark color for the specified frame.
             *
             * @instance
             * @public
             * @this Spine.RGBA2Timeline
             * @memberof Spine.RGBA2Timeline
             * @param   {number}    frame    Between 0 and <pre><code>frameCount</code></pre>, inclusive.
             * @param   {number}    time     The frame time in seconds.
             * @param   {number}    r        
             * @param   {number}    g        
             * @param   {number}    b        
             * @param   {number}    a        
             * @param   {number}    r2       
             * @param   {number}    g2       
             * @param   {number}    b2
             * @return  {void}
             */
            SetFrame: function (frame, time, r, g, b, a, r2, g2, b2) {
if ( TRACE ) { TRACE( "Spine.RGBA2Timeline#SetFrame", this ); }

                frame = frame << 3;
                this.frames[frame] = time;
                this.frames[((frame + Spine.RGBA2Timeline.R) | 0)] = r;
                this.frames[((frame + Spine.RGBA2Timeline.G) | 0)] = g;
                this.frames[((frame + Spine.RGBA2Timeline.B) | 0)] = b;
                this.frames[((frame + Spine.RGBA2Timeline.A) | 0)] = a;
                this.frames[((frame + Spine.RGBA2Timeline.R2) | 0)] = r2;
                this.frames[((frame + Spine.RGBA2Timeline.G2) | 0)] = g2;
                this.frames[((frame + Spine.RGBA2Timeline.B2) | 0)] = b2;
            },
            /*Spine.RGBA2Timeline.SetFrame end.*/

            /*Spine.RGBA2Timeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.RGBA2Timeline#Apply", this ); }

                var $t;
                var slot = ($t = skeleton.slots.Items)[this.slotIndex];
                if (!slot.bone.active) {
                    return;
                }

                var frames = this.frames;
                if (time < frames[0]) {
                    var setup = slot.data;
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            slot.r = setup.r;
                            slot.g = setup.g;
                            slot.b = setup.b;
                            slot.a = setup.a;
                            slot.ClampColor();
                            slot.r2 = setup.r2;
                            slot.g2 = setup.g2;
                            slot.b2 = setup.b2;
                            slot.ClampSecondColor();
                            return;
                        case Spine.MixBlend.First: 
                            slot.r += (slot.r - setup.r) * alpha;
                            slot.g += (slot.g - setup.g) * alpha;
                            slot.b += (slot.b - setup.b) * alpha;
                            slot.a += (slot.a - setup.a) * alpha;
                            slot.ClampColor();
                            slot.r2 += (slot.r2 - setup.r2) * alpha;
                            slot.g2 += (slot.g2 - setup.g2) * alpha;
                            slot.b2 += (slot.b2 - setup.b2) * alpha;
                            slot.ClampSecondColor();
                            return;
                    }
                    return;
                }

                var r, g, b, a, r2, g2, b2;
                var i = Spine.Timeline.Search$1(frames, time, Spine.RGBA2Timeline.ENTRIES), curveType = Bridge.Int.clip32(this.curves[i >> 3]);
                switch (curveType) {
                    case Spine.CurveTimeline.LINEAR: 
                        var before = frames[i];
                        r = frames[((i + Spine.RGBA2Timeline.R) | 0)];
                        g = frames[((i + Spine.RGBA2Timeline.G) | 0)];
                        b = frames[((i + Spine.RGBA2Timeline.B) | 0)];
                        a = frames[((i + Spine.RGBA2Timeline.A) | 0)];
                        r2 = frames[((i + Spine.RGBA2Timeline.R2) | 0)];
                        g2 = frames[((i + Spine.RGBA2Timeline.G2) | 0)];
                        b2 = frames[((i + Spine.RGBA2Timeline.B2) | 0)];
                        var t = (time - before) / (frames[((i + Spine.RGBA2Timeline.ENTRIES) | 0)] - before);
                        r += (frames[((((i + Spine.RGBA2Timeline.ENTRIES) | 0) + Spine.RGBA2Timeline.R) | 0)] - r) * t;
                        g += (frames[((((i + Spine.RGBA2Timeline.ENTRIES) | 0) + Spine.RGBA2Timeline.G) | 0)] - g) * t;
                        b += (frames[((((i + Spine.RGBA2Timeline.ENTRIES) | 0) + Spine.RGBA2Timeline.B) | 0)] - b) * t;
                        a += (frames[((((i + Spine.RGBA2Timeline.ENTRIES) | 0) + Spine.RGBA2Timeline.A) | 0)] - a) * t;
                        r2 += (frames[((((i + Spine.RGBA2Timeline.ENTRIES) | 0) + Spine.RGBA2Timeline.R2) | 0)] - r2) * t;
                        g2 += (frames[((((i + Spine.RGBA2Timeline.ENTRIES) | 0) + Spine.RGBA2Timeline.G2) | 0)] - g2) * t;
                        b2 += (frames[((((i + Spine.RGBA2Timeline.ENTRIES) | 0) + Spine.RGBA2Timeline.B2) | 0)] - b2) * t;
                        break;
                    case Spine.CurveTimeline.STEPPED: 
                        r = frames[((i + Spine.RGBA2Timeline.R) | 0)];
                        g = frames[((i + Spine.RGBA2Timeline.G) | 0)];
                        b = frames[((i + Spine.RGBA2Timeline.B) | 0)];
                        a = frames[((i + Spine.RGBA2Timeline.A) | 0)];
                        r2 = frames[((i + Spine.RGBA2Timeline.R2) | 0)];
                        g2 = frames[((i + Spine.RGBA2Timeline.G2) | 0)];
                        b2 = frames[((i + Spine.RGBA2Timeline.B2) | 0)];
                        break;
                    default: 
                        r = this.GetBezierValue(time, i, Spine.RGBA2Timeline.R, ((curveType - Spine.CurveTimeline.BEZIER) | 0));
                        g = this.GetBezierValue(time, i, Spine.RGBA2Timeline.G, ((((curveType + Spine.CurveTimeline.BEZIER_SIZE) | 0) - Spine.CurveTimeline.BEZIER) | 0));
                        b = this.GetBezierValue(time, i, Spine.RGBA2Timeline.B, ((((curveType + 36) | 0) - Spine.CurveTimeline.BEZIER) | 0));
                        a = this.GetBezierValue(time, i, Spine.RGBA2Timeline.A, ((((curveType + 54) | 0) - Spine.CurveTimeline.BEZIER) | 0));
                        r2 = this.GetBezierValue(time, i, Spine.RGBA2Timeline.R2, ((((curveType + 72) | 0) - Spine.CurveTimeline.BEZIER) | 0));
                        g2 = this.GetBezierValue(time, i, Spine.RGBA2Timeline.G2, ((((curveType + 90) | 0) - Spine.CurveTimeline.BEZIER) | 0));
                        b2 = this.GetBezierValue(time, i, Spine.RGBA2Timeline.B2, ((((curveType + 108) | 0) - Spine.CurveTimeline.BEZIER) | 0));
                        break;
                }

                if (alpha === 1) {
                    slot.r = r;
                    slot.g = g;
                    slot.b = b;
                    slot.a = a;
                    slot.r2 = r2;
                    slot.g2 = g2;
                    slot.b2 = b2;
                } else {
                    var br, bg, bb, ba, br2, bg2, bb2;
                    if (blend === Spine.MixBlend.Setup) {
                        br = slot.data.r;
                        bg = slot.data.g;
                        bb = slot.data.b;
                        ba = slot.data.a;
                        br2 = slot.data.r2;
                        bg2 = slot.data.g2;
                        bb2 = slot.data.b2;
                    } else {
                        br = slot.r;
                        bg = slot.g;
                        bb = slot.b;
                        ba = slot.a;
                        br2 = slot.r2;
                        bg2 = slot.g2;
                        bb2 = slot.b2;
                    }
                    slot.r = br + (r - br) * alpha;
                    slot.g = bg + (g - bg) * alpha;
                    slot.b = bb + (b - bb) * alpha;
                    slot.a = ba + (a - ba) * alpha;
                    slot.r2 = br2 + (r2 - br2) * alpha;
                    slot.g2 = bg2 + (g2 - bg2) * alpha;
                    slot.b2 = bb2 + (b2 - bb2) * alpha;
                }
                slot.ClampColor();
                slot.ClampSecondColor();
            },
            /*Spine.RGBA2Timeline.Apply end.*/


        }
    });
    /*Spine.RGBA2Timeline end.*/

    /*Spine.RGBATimeline start.*/
    /**
     * Changes a slot's {@link }.
     *
     * @public
     * @class Spine.RGBATimeline
     * @augments Spine.CurveTimeline
     * @implements  Spine.ISlotTimeline
     */
    Bridge.define("Spine.RGBATimeline", {
        inherits: [Spine.CurveTimeline,Spine.ISlotTimeline],
        statics: {
            fields: {
                ENTRIES: 0,
                R: 0,
                G: 0,
                B: 0,
                A: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.RGBATimeline#init", this ); }

                    this.ENTRIES = 5;
                    this.R = 1;
                    this.G = 2;
                    this.B = 3;
                    this.A = 4;
                }
            }
        },
        fields: {
            slotIndex: 0
        },
        props: {
            FrameEntries: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RGBATimeline#FrameEntries#get", this ); }

                    return Spine.RGBATimeline.ENTRIES;
                }
            },
            SlotIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RGBATimeline#SlotIndex#get", this ); }

                    return this.slotIndex;
                }
            }
        },
        alias: ["SlotIndex", "Spine$ISlotTimeline$SlotIndex"],
        ctors: {
            ctor: function (frameCount, bezierCount, slotIndex) {
if ( TRACE ) { TRACE( "Spine.RGBATimeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline.ctor.call(this, frameCount, bezierCount, [Spine.Property.RGB + "|" + slotIndex, Spine.Property.Alpha + "|" + slotIndex]);
                this.slotIndex = slotIndex;
            }
        },
        methods: {
            /*Spine.RGBATimeline.SetFrame start.*/
            /**
             * Sets the time and color for the specified frame.
             *
             * @instance
             * @public
             * @this Spine.RGBATimeline
             * @memberof Spine.RGBATimeline
             * @param   {number}    frame    Between 0 and <pre><code>frameCount</code></pre>, inclusive.
             * @param   {number}    time     The frame time in seconds.
             * @param   {number}    r        
             * @param   {number}    g        
             * @param   {number}    b        
             * @param   {number}    a
             * @return  {void}
             */
            SetFrame: function (frame, time, r, g, b, a) {
if ( TRACE ) { TRACE( "Spine.RGBATimeline#SetFrame", this ); }

                frame = Bridge.Int.mul(frame, Spine.RGBATimeline.ENTRIES);
                this.frames[frame] = time;
                this.frames[((frame + Spine.RGBATimeline.R) | 0)] = r;
                this.frames[((frame + Spine.RGBATimeline.G) | 0)] = g;
                this.frames[((frame + Spine.RGBATimeline.B) | 0)] = b;
                this.frames[((frame + Spine.RGBATimeline.A) | 0)] = a;
            },
            /*Spine.RGBATimeline.SetFrame end.*/

            /*Spine.RGBATimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.RGBATimeline#Apply", this ); }

                var $t;
                var slot = ($t = skeleton.slots.Items)[this.slotIndex];
                if (!slot.bone.active) {
                    return;
                }

                var frames = this.frames;
                if (time < frames[0]) {
                    var setup = slot.data;
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            slot.r = setup.r;
                            slot.g = setup.g;
                            slot.b = setup.b;
                            slot.a = setup.a;
                            return;
                        case Spine.MixBlend.First: 
                            slot.r += (setup.r - slot.r) * alpha;
                            slot.g += (setup.g - slot.g) * alpha;
                            slot.b += (setup.b - slot.b) * alpha;
                            slot.a += (setup.a - slot.a) * alpha;
                            slot.ClampColor();
                            return;
                    }
                    return;
                }

                var r, g, b, a;
                var i = Spine.Timeline.Search$1(frames, time, Spine.RGBATimeline.ENTRIES), curveType = Bridge.Int.clip32(this.curves[((Bridge.Int.div(i, Spine.RGBATimeline.ENTRIES)) | 0)]);
                switch (curveType) {
                    case Spine.CurveTimeline.LINEAR: 
                        var before = frames[i];
                        r = frames[((i + Spine.RGBATimeline.R) | 0)];
                        g = frames[((i + Spine.RGBATimeline.G) | 0)];
                        b = frames[((i + Spine.RGBATimeline.B) | 0)];
                        a = frames[((i + Spine.RGBATimeline.A) | 0)];
                        var t = (time - before) / (frames[((i + Spine.RGBATimeline.ENTRIES) | 0)] - before);
                        r += (frames[((((i + Spine.RGBATimeline.ENTRIES) | 0) + Spine.RGBATimeline.R) | 0)] - r) * t;
                        g += (frames[((((i + Spine.RGBATimeline.ENTRIES) | 0) + Spine.RGBATimeline.G) | 0)] - g) * t;
                        b += (frames[((((i + Spine.RGBATimeline.ENTRIES) | 0) + Spine.RGBATimeline.B) | 0)] - b) * t;
                        a += (frames[((((i + Spine.RGBATimeline.ENTRIES) | 0) + Spine.RGBATimeline.A) | 0)] - a) * t;
                        break;
                    case Spine.CurveTimeline.STEPPED: 
                        r = frames[((i + Spine.RGBATimeline.R) | 0)];
                        g = frames[((i + Spine.RGBATimeline.G) | 0)];
                        b = frames[((i + Spine.RGBATimeline.B) | 0)];
                        a = frames[((i + Spine.RGBATimeline.A) | 0)];
                        break;
                    default: 
                        r = this.GetBezierValue(time, i, Spine.RGBATimeline.R, ((curveType - Spine.CurveTimeline.BEZIER) | 0));
                        g = this.GetBezierValue(time, i, Spine.RGBATimeline.G, ((((curveType + Spine.CurveTimeline.BEZIER_SIZE) | 0) - Spine.CurveTimeline.BEZIER) | 0));
                        b = this.GetBezierValue(time, i, Spine.RGBATimeline.B, ((((curveType + 36) | 0) - Spine.CurveTimeline.BEZIER) | 0));
                        a = this.GetBezierValue(time, i, Spine.RGBATimeline.A, ((((curveType + 54) | 0) - Spine.CurveTimeline.BEZIER) | 0));
                        break;
                }

                if (alpha === 1) {
                    slot.r = r;
                    slot.g = g;
                    slot.b = b;
                    slot.a = a;
                } else {
                    var br, bg, bb, ba;
                    if (blend === Spine.MixBlend.Setup) {
                        br = slot.data.r;
                        bg = slot.data.g;
                        bb = slot.data.b;
                        ba = slot.data.a;
                    } else {
                        br = slot.r;
                        bg = slot.g;
                        bb = slot.b;
                        ba = slot.a;
                    }
                    slot.r = br + (r - br) * alpha;
                    slot.g = bg + (g - bg) * alpha;
                    slot.b = bb + (b - bb) * alpha;
                    slot.a = ba + (a - ba) * alpha;
                }
                slot.ClampColor();
            },
            /*Spine.RGBATimeline.Apply end.*/


        }
    });
    /*Spine.RGBATimeline end.*/

    /*Spine.RGBTimeline start.*/
    /**
     * Changes the RGB for a slot's {@link }.
     *
     * @public
     * @class Spine.RGBTimeline
     * @augments Spine.CurveTimeline
     * @implements  Spine.ISlotTimeline
     */
    Bridge.define("Spine.RGBTimeline", {
        inherits: [Spine.CurveTimeline,Spine.ISlotTimeline],
        statics: {
            fields: {
                ENTRIES: 0,
                R: 0,
                G: 0,
                B: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.RGBTimeline#init", this ); }

                    this.ENTRIES = 4;
                    this.R = 1;
                    this.G = 2;
                    this.B = 3;
                }
            }
        },
        fields: {
            slotIndex: 0
        },
        props: {
            FrameEntries: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RGBTimeline#FrameEntries#get", this ); }

                    return Spine.RGBTimeline.ENTRIES;
                }
            },
            SlotIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RGBTimeline#SlotIndex#get", this ); }

                    return this.slotIndex;
                }
            }
        },
        alias: ["SlotIndex", "Spine$ISlotTimeline$SlotIndex"],
        ctors: {
            ctor: function (frameCount, bezierCount, slotIndex) {
if ( TRACE ) { TRACE( "Spine.RGBTimeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline.ctor.call(this, frameCount, bezierCount, [Spine.Property.RGB + "|" + slotIndex]);
                this.slotIndex = slotIndex;
            }
        },
        methods: {
            /*Spine.RGBTimeline.SetFrame start.*/
            /**
             * Sets the time and color for the specified frame.
             *
             * @instance
             * @public
             * @this Spine.RGBTimeline
             * @memberof Spine.RGBTimeline
             * @param   {number}    frame    Between 0 and <pre><code>frameCount</code></pre>, inclusive.
             * @param   {number}    time     The frame time in seconds.
             * @param   {number}    r        
             * @param   {number}    g        
             * @param   {number}    b
             * @return  {void}
             */
            SetFrame: function (frame, time, r, g, b) {
if ( TRACE ) { TRACE( "Spine.RGBTimeline#SetFrame", this ); }

                frame = frame << 2;
                this.frames[frame] = time;
                this.frames[((frame + Spine.RGBTimeline.R) | 0)] = r;
                this.frames[((frame + Spine.RGBTimeline.G) | 0)] = g;
                this.frames[((frame + Spine.RGBTimeline.B) | 0)] = b;
            },
            /*Spine.RGBTimeline.SetFrame end.*/

            /*Spine.RGBTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.RGBTimeline#Apply", this ); }

                var $t;
                var slot = ($t = skeleton.slots.Items)[this.slotIndex];
                if (!slot.bone.active) {
                    return;
                }

                var frames = this.frames;
                if (time < frames[0]) {
                    var setup = slot.data;
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            slot.r = setup.r;
                            slot.g = setup.g;
                            slot.b = setup.b;
                            return;
                        case Spine.MixBlend.First: 
                            slot.r += (setup.r - slot.r) * alpha;
                            slot.g += (setup.g - slot.g) * alpha;
                            slot.b += (setup.b - slot.b) * alpha;
                            slot.ClampColor();
                            return;
                    }
                    return;
                }

                var r, g, b;
                var i = Spine.Timeline.Search$1(frames, time, Spine.RGBTimeline.ENTRIES), curveType = Bridge.Int.clip32(this.curves[i >> 2]);
                switch (curveType) {
                    case Spine.CurveTimeline.LINEAR: 
                        var before = frames[i];
                        r = frames[((i + Spine.RGBTimeline.R) | 0)];
                        g = frames[((i + Spine.RGBTimeline.G) | 0)];
                        b = frames[((i + Spine.RGBTimeline.B) | 0)];
                        var t = (time - before) / (frames[((i + Spine.RGBTimeline.ENTRIES) | 0)] - before);
                        r += (frames[((((i + Spine.RGBTimeline.ENTRIES) | 0) + Spine.RGBTimeline.R) | 0)] - r) * t;
                        g += (frames[((((i + Spine.RGBTimeline.ENTRIES) | 0) + Spine.RGBTimeline.G) | 0)] - g) * t;
                        b += (frames[((((i + Spine.RGBTimeline.ENTRIES) | 0) + Spine.RGBTimeline.B) | 0)] - b) * t;
                        break;
                    case Spine.CurveTimeline.STEPPED: 
                        r = frames[((i + Spine.RGBTimeline.R) | 0)];
                        g = frames[((i + Spine.RGBTimeline.G) | 0)];
                        b = frames[((i + Spine.RGBTimeline.B) | 0)];
                        break;
                    default: 
                        r = this.GetBezierValue(time, i, Spine.RGBTimeline.R, ((curveType - Spine.CurveTimeline.BEZIER) | 0));
                        g = this.GetBezierValue(time, i, Spine.RGBTimeline.G, ((((curveType + Spine.CurveTimeline.BEZIER_SIZE) | 0) - Spine.CurveTimeline.BEZIER) | 0));
                        b = this.GetBezierValue(time, i, Spine.RGBTimeline.B, ((((curveType + 36) | 0) - Spine.CurveTimeline.BEZIER) | 0));
                        break;
                }

                if (alpha === 1) {
                    slot.r = r;
                    slot.g = g;
                    slot.b = b;
                } else {
                    var br, bg, bb;
                    if (blend === Spine.MixBlend.Setup) {
                        var setup1 = slot.data;
                        br = setup1.r;
                        bg = setup1.g;
                        bb = setup1.b;
                    } else {
                        br = slot.r;
                        bg = slot.g;
                        bb = slot.b;
                    }
                    slot.r = br + (r - br) * alpha;
                    slot.g = bg + (g - bg) * alpha;
                    slot.b = bb + (b - bb) * alpha;
                }
                slot.ClampColor();
            },
            /*Spine.RGBTimeline.Apply end.*/


        }
    });
    /*Spine.RGBTimeline end.*/

    /*Spine.TransformConstraintTimeline start.*/
    /**
     * Changes a transform constraint's mixes.
     *
     * @public
     * @class Spine.TransformConstraintTimeline
     * @augments Spine.CurveTimeline
     */
    Bridge.define("Spine.TransformConstraintTimeline", {
        inherits: [Spine.CurveTimeline],
        statics: {
            fields: {
                ENTRIES: 0,
                ROTATE: 0,
                X: 0,
                Y: 0,
                SCALEX: 0,
                SCALEY: 0,
                SHEARY: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintTimeline#init", this ); }

                    this.ENTRIES = 7;
                    this.ROTATE = 1;
                    this.X = 2;
                    this.Y = 3;
                    this.SCALEX = 4;
                    this.SCALEY = 5;
                    this.SHEARY = 6;
                }
            }
        },
        fields: {
            constraintIndex: 0
        },
        props: {
            FrameEntries: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintTimeline#FrameEntries#get", this ); }

                    return Spine.TransformConstraintTimeline.ENTRIES;
                }
            },
            /**
             * The index of the transform constraint in {@link } that will be changed when this
             timeline is applied.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.TransformConstraintTimeline
             * @function TransformConstraintIndex
             * @type number
             */
            TransformConstraintIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintTimeline#TransformConstraintIndex#get", this ); }

                    return this.constraintIndex;
                }
            }
        },
        ctors: {
            ctor: function (frameCount, bezierCount, transformConstraintIndex) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintTimeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline.ctor.call(this, frameCount, bezierCount, [Spine.Property.TransformConstraint + "|" + transformConstraintIndex]);
                this.constraintIndex = transformConstraintIndex;
            }
        },
        methods: {
            /*Spine.TransformConstraintTimeline.SetFrame start.*/
            /**
             * Sets the time, rotate mix, translate mix, scale mix, and shear mix for the specified frame.
             *
             * @instance
             * @public
             * @this Spine.TransformConstraintTimeline
             * @memberof Spine.TransformConstraintTimeline
             * @param   {number}    frame        Between 0 and <pre><code>frameCount</code></pre>, inclusive.
             * @param   {number}    time         The frame time in seconds.
             * @param   {number}    mixRotate    
             * @param   {number}    mixX         
             * @param   {number}    mixY         
             * @param   {number}    mixScaleX    
             * @param   {number}    mixScaleY    
             * @param   {number}    mixShearY
             * @return  {void}
             */
            SetFrame: function (frame, time, mixRotate, mixX, mixY, mixScaleX, mixScaleY, mixShearY) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintTimeline#SetFrame", this ); }

                frame = Bridge.Int.mul(frame, Spine.TransformConstraintTimeline.ENTRIES);
                this.frames[frame] = time;
                this.frames[((frame + Spine.TransformConstraintTimeline.ROTATE) | 0)] = mixRotate;
                this.frames[((frame + Spine.TransformConstraintTimeline.X) | 0)] = mixX;
                this.frames[((frame + Spine.TransformConstraintTimeline.Y) | 0)] = mixY;
                this.frames[((frame + Spine.TransformConstraintTimeline.SCALEX) | 0)] = mixScaleX;
                this.frames[((frame + Spine.TransformConstraintTimeline.SCALEY) | 0)] = mixScaleY;
                this.frames[((frame + Spine.TransformConstraintTimeline.SHEARY) | 0)] = mixShearY;
            },
            /*Spine.TransformConstraintTimeline.SetFrame end.*/

            /*Spine.TransformConstraintTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintTimeline#Apply", this ); }

                var $t;
                var constraint = ($t = skeleton.transformConstraints.Items)[this.constraintIndex];
                if (!constraint.active) {
                    return;
                }

                var frames = this.frames;
                if (time < frames[0]) {
                    var data = constraint.data;
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            constraint.mixRotate = data.mixRotate;
                            constraint.mixX = data.mixX;
                            constraint.mixY = data.mixY;
                            constraint.mixScaleX = data.mixScaleX;
                            constraint.mixScaleY = data.mixScaleY;
                            constraint.mixShearY = data.mixShearY;
                            return;
                        case Spine.MixBlend.First: 
                            constraint.mixRotate += (data.mixRotate - constraint.mixRotate) * alpha;
                            constraint.mixX += (data.mixX - constraint.mixX) * alpha;
                            constraint.mixY += (data.mixY - constraint.mixY) * alpha;
                            constraint.mixScaleX += (data.mixScaleX - constraint.mixScaleX) * alpha;
                            constraint.mixScaleY += (data.mixScaleY - constraint.mixScaleY) * alpha;
                            constraint.mixShearY += (data.mixShearY - constraint.mixShearY) * alpha;
                            return;
                    }
                    return;
                }

                var rotate = { }, x = { }, y = { }, scaleX = { }, scaleY = { }, shearY = { };
                this.GetCurveValue(rotate, x, y, scaleX, scaleY, shearY, time);

                if (blend === Spine.MixBlend.Setup) {
                    var data1 = constraint.data;
                    constraint.mixRotate = data1.mixRotate + (rotate.v - data1.mixRotate) * alpha;
                    constraint.mixX = data1.mixX + (x.v - data1.mixX) * alpha;
                    constraint.mixY = data1.mixY + (y.v - data1.mixY) * alpha;
                    constraint.mixScaleX = data1.mixScaleX + (scaleX.v - data1.mixScaleX) * alpha;
                    constraint.mixScaleY = data1.mixScaleY + (scaleY.v - data1.mixScaleY) * alpha;
                    constraint.mixShearY = data1.mixShearY + (shearY.v - data1.mixShearY) * alpha;
                } else {
                    constraint.mixRotate += (rotate.v - constraint.mixRotate) * alpha;
                    constraint.mixX += (x.v - constraint.mixX) * alpha;
                    constraint.mixY += (y.v - constraint.mixY) * alpha;
                    constraint.mixScaleX += (scaleX.v - constraint.mixScaleX) * alpha;
                    constraint.mixScaleY += (scaleY.v - constraint.mixScaleY) * alpha;
                    constraint.mixShearY += (shearY.v - constraint.mixShearY) * alpha;
                }
            },
            /*Spine.TransformConstraintTimeline.Apply end.*/

            /*Spine.TransformConstraintTimeline.GetCurveValue start.*/
            GetCurveValue: function (rotate, x, y, scaleX, scaleY, shearY, time) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintTimeline#GetCurveValue", this ); }


                var frames = this.frames;
                var i = Spine.Timeline.Search$1(frames, time, Spine.TransformConstraintTimeline.ENTRIES), curveType = Bridge.Int.clip32(this.curves[((Bridge.Int.div(i, Spine.TransformConstraintTimeline.ENTRIES)) | 0)]);
                switch (curveType) {
                    case Spine.CurveTimeline.LINEAR: 
                        var before = frames[i];
                        rotate.v = frames[((i + Spine.TransformConstraintTimeline.ROTATE) | 0)];
                        x.v = frames[((i + Spine.TransformConstraintTimeline.X) | 0)];
                        y.v = frames[((i + Spine.TransformConstraintTimeline.Y) | 0)];
                        scaleX.v = frames[((i + Spine.TransformConstraintTimeline.SCALEX) | 0)];
                        scaleY.v = frames[((i + Spine.TransformConstraintTimeline.SCALEY) | 0)];
                        shearY.v = frames[((i + Spine.TransformConstraintTimeline.SHEARY) | 0)];
                        var t = (time - before) / (frames[((i + Spine.TransformConstraintTimeline.ENTRIES) | 0)] - before);
                        rotate.v += (frames[((((i + Spine.TransformConstraintTimeline.ENTRIES) | 0) + Spine.TransformConstraintTimeline.ROTATE) | 0)] - rotate.v) * t;
                        x.v += (frames[((((i + Spine.TransformConstraintTimeline.ENTRIES) | 0) + Spine.TransformConstraintTimeline.X) | 0)] - x.v) * t;
                        y.v += (frames[((((i + Spine.TransformConstraintTimeline.ENTRIES) | 0) + Spine.TransformConstraintTimeline.Y) | 0)] - y.v) * t;
                        scaleX.v += (frames[((((i + Spine.TransformConstraintTimeline.ENTRIES) | 0) + Spine.TransformConstraintTimeline.SCALEX) | 0)] - scaleX.v) * t;
                        scaleY.v += (frames[((((i + Spine.TransformConstraintTimeline.ENTRIES) | 0) + Spine.TransformConstraintTimeline.SCALEY) | 0)] - scaleY.v) * t;
                        shearY.v += (frames[((((i + Spine.TransformConstraintTimeline.ENTRIES) | 0) + Spine.TransformConstraintTimeline.SHEARY) | 0)] - shearY.v) * t;
                        break;
                    case Spine.CurveTimeline.STEPPED: 
                        rotate.v = frames[((i + Spine.TransformConstraintTimeline.ROTATE) | 0)];
                        x.v = frames[((i + Spine.TransformConstraintTimeline.X) | 0)];
                        y.v = frames[((i + Spine.TransformConstraintTimeline.Y) | 0)];
                        scaleX.v = frames[((i + Spine.TransformConstraintTimeline.SCALEX) | 0)];
                        scaleY.v = frames[((i + Spine.TransformConstraintTimeline.SCALEY) | 0)];
                        shearY.v = frames[((i + Spine.TransformConstraintTimeline.SHEARY) | 0)];
                        break;
                    default: 
                        rotate.v = this.GetBezierValue(time, i, Spine.TransformConstraintTimeline.ROTATE, ((curveType - Spine.CurveTimeline.BEZIER) | 0));
                        x.v = this.GetBezierValue(time, i, Spine.TransformConstraintTimeline.X, ((((curveType + Spine.CurveTimeline.BEZIER_SIZE) | 0) - Spine.CurveTimeline.BEZIER) | 0));
                        y.v = this.GetBezierValue(time, i, Spine.TransformConstraintTimeline.Y, ((((curveType + 36) | 0) - Spine.CurveTimeline.BEZIER) | 0));
                        scaleX.v = this.GetBezierValue(time, i, Spine.TransformConstraintTimeline.SCALEX, ((((curveType + 54) | 0) - Spine.CurveTimeline.BEZIER) | 0));
                        scaleY.v = this.GetBezierValue(time, i, Spine.TransformConstraintTimeline.SCALEY, ((((curveType + 72) | 0) - Spine.CurveTimeline.BEZIER) | 0));
                        shearY.v = this.GetBezierValue(time, i, Spine.TransformConstraintTimeline.SHEARY, ((((curveType + 90) | 0) - Spine.CurveTimeline.BEZIER) | 0));
                        break;
                }
            },
            /*Spine.TransformConstraintTimeline.GetCurveValue end.*/


        }
    });
    /*Spine.TransformConstraintTimeline end.*/

    /*Spine.Unity.AnimationReferenceAsset start.*/
    Bridge.define("Spine.Unity.AnimationReferenceAsset", {
        inherits: [UnityEngine.ScriptableObject,Spine.Unity.IHasSkeletonDataAsset],
        statics: {
            fields: {
                QuietSkeletonData: false
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationReferenceAsset#init", this ); }

                    this.QuietSkeletonData = true;
                }
            },
            methods: {
                op_Implicit: function (asset) {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationReferenceAsset#op_Implicit", this ); }

                    return asset.Animation;
                }
            }
        },
        fields: {
            skeletonDataAsset: null,
            animationName: null,
            animation: null
        },
        props: {
            SkeletonDataAsset: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationReferenceAsset#SkeletonDataAsset#get", this ); }

                    return this.skeletonDataAsset;
                }
            },
            Animation: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationReferenceAsset#Animation#get", this ); }

                    if (this.animation == null) {
                        this.Initialize();
                    }
                    return this.animation;
                }
            }
        },
        alias: ["SkeletonDataAsset", "Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset"],
        methods: {
            /*Spine.Unity.AnimationReferenceAsset.Clear start.*/
            /**
             * Clears the cached animation corresponding to a loaded SkeletonData object.
             Use this to force a reload for the next time Animation is called.
             *
             * @instance
             * @public
             * @this Spine.Unity.AnimationReferenceAsset
             * @memberof Spine.Unity.AnimationReferenceAsset
             * @return  {void}
             */
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationReferenceAsset#Clear", this ); }

                this.animation = null;
            },
            /*Spine.Unity.AnimationReferenceAsset.Clear end.*/

            /*Spine.Unity.AnimationReferenceAsset.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationReferenceAsset#Initialize", this ); }

                if (this.skeletonDataAsset == null) {
                    return;
                }
                var skeletonData = this.skeletonDataAsset.GetSkeletonData(Spine.Unity.AnimationReferenceAsset.QuietSkeletonData);
                this.animation = skeletonData != null ? skeletonData.FindAnimation(this.animationName) : null;
                if (this.animation == null) {
                    UnityEngine.Debug.LogWarningFormat("Animation '{0}' not found in SkeletonData : {1}.", [this.animationName, this.skeletonDataAsset.name]);
                }
            },
            /*Spine.Unity.AnimationReferenceAsset.Initialize end.*/


        }
    });
    /*Spine.Unity.AnimationReferenceAsset end.*/

    /*Spine.Unity.PointFollower start.*/
    Bridge.define("Spine.Unity.PointFollower", {
        inherits: [UnityEngine.MonoBehaviour,Spine.Unity.IHasSkeletonRenderer,Spine.Unity.IHasSkeletonComponent],
        fields: {
            skeletonRenderer: null,
            slotName: null,
            pointAttachmentName: null,
            followRotation: false,
            followSkeletonFlip: false,
            followSkeletonZPosition: false,
            skeletonTransform: null,
            skeletonTransformIsParent: false,
            point: null,
            bone: null,
            valid: false
        },
        props: {
            SkeletonRenderer: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#SkeletonRenderer#get", this ); }

                    return this.skeletonRenderer;
                }
            },
            SkeletonComponent: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#SkeletonComponent#get", this ); }

                    return Bridge.as(this.skeletonRenderer, Spine.Unity.ISkeletonComponent);
                }
            },
            IsValid: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#IsValid#get", this ); }

                    return this.valid;
                }
            }
        },
        alias: [
            "SkeletonRenderer", "Spine$Unity$IHasSkeletonRenderer$SkeletonRenderer",
            "SkeletonComponent", "Spine$Unity$IHasSkeletonComponent$SkeletonComponent"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#init", this ); }

                this.followRotation = true;
                this.followSkeletonFlip = true;
                this.followSkeletonZPosition = false;
            }
        },
        methods: {
            /*Spine.Unity.PointFollower.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#Initialize", this ); }

                this.valid = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) && this.skeletonRenderer.valid;
                if (!this.valid) {
                    return;
                }

                this.UpdateReferences();

            },
            /*Spine.Unity.PointFollower.Initialize end.*/

            /*Spine.Unity.PointFollower.HandleRebuildRenderer start.*/
            HandleRebuildRenderer: function (skeletonRenderer) {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#HandleRebuildRenderer", this ); }

                this.Initialize();
            },
            /*Spine.Unity.PointFollower.HandleRebuildRenderer end.*/

            /*Spine.Unity.PointFollower.UpdateReferences start.*/
            UpdateReferences: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#UpdateReferences", this ); }

                this.skeletonTransform = this.skeletonRenderer.transform;
                this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuildRenderer));
                this.skeletonRenderer.addOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuildRenderer));
                this.skeletonTransformIsParent = Bridge.referenceEquals(this.skeletonTransform, this.transform.parent);

                this.bone = null;
                this.point = null;
                if (!System.String.isNullOrEmpty(this.pointAttachmentName)) {
                    var skeleton = this.skeletonRenderer.Skeleton;

                    var slot = skeleton.FindSlot(this.slotName);
                    if (slot != null) {
                        var slotIndex = slot.Data.Index;
                        this.bone = slot.Bone;
                        this.point = Bridge.as(skeleton.GetAttachment(slotIndex, this.pointAttachmentName), Spine.PointAttachment);
                    }
                }
            },
            /*Spine.Unity.PointFollower.UpdateReferences end.*/

            /*Spine.Unity.PointFollower.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#OnDestroy", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuildRenderer));
                }
            },
            /*Spine.Unity.PointFollower.OnDestroy end.*/

            /*Spine.Unity.PointFollower.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#LateUpdate", this ); }

                var $t;

                if (this.point == null) {
                    if (System.String.isNullOrEmpty(this.pointAttachmentName)) {
                        return;
                    }
                    this.UpdateReferences();
                    if (this.point == null) {
                        return;
                    }
                }

                var worldPos = new UnityEngine.Vector2();
                this.point.ComputeWorldPosition(this.bone, Bridge.ref(worldPos, "x"), Bridge.ref(worldPos, "y"));
                var rotation = this.point.ComputeWorldRotation(this.bone);

                var thisTransform = this.transform;
                if (this.skeletonTransformIsParent) {
                    // Recommended setup: Use local transform properties if Spine GameObject is the immediate parent
                    thisTransform.localPosition = new pc.Vec3( worldPos.x, worldPos.y, this.followSkeletonZPosition ? 0.0 : thisTransform.localPosition.z );
                    if (this.followRotation) {
                        var halfRotation = rotation * 0.5 * UnityEngine.Mathf.Deg2Rad;

                        var q = Bridge.getDefaultValue(UnityEngine.Quaternion);
                        q.z = Math.sin(halfRotation);
                        q.w = Math.cos(halfRotation);
                        thisTransform.localRotation = q.$clone();
                    }
                } else {
                    // For special cases: Use transform world properties if transform relationship is complicated
                    var targetWorldPosition = this.skeletonTransform.TransformPoint$1(new pc.Vec3( worldPos.x, worldPos.y, 0.0 ));
                    if (!this.followSkeletonZPosition) {
                        targetWorldPosition.z = thisTransform.position.z;
                    }

                    var transformParent = thisTransform.parent;
                    if (UnityEngine.Component.op_Inequality(transformParent, null)) {
                        var m = transformParent.localToWorldMatrix.$clone();
                        if (m.e00 * m.e11 - m.e01 * m.e10 < 0) {
                            rotation = -rotation;
                        }
                    }

                    if (this.followRotation) {
                        var transformWorldRotation = this.skeletonTransform.rotation.getPositiveEulerAngles().$clone();
                        thisTransform.SetPositionAndRotation(targetWorldPosition, new pc.Quat().setFromEulerAngles_Unity( transformWorldRotation.x, transformWorldRotation.y, transformWorldRotation.z + rotation ));
                    } else {
                        thisTransform.position = targetWorldPosition.$clone();
                    }
                }

                if (this.followSkeletonFlip) {
                    var localScale = thisTransform.localScale.$clone();
                    localScale.y = Math.abs(localScale.y) * ($t = this.bone.Skeleton.ScaleX * this.bone.Skeleton.ScaleY, ($t === 0 ? 1 : Math.sign($t)));
                    thisTransform.localScale = localScale.$clone();
                }
            },
            /*Spine.Unity.PointFollower.LateUpdate end.*/


        }
    });
    /*Spine.Unity.PointFollower end.*/
    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.SkeletonRenderer.InstructionDelegate
     * @param   {Spine.Unity.SkeletonRendererInstruction}    instruction
     * @return  {void}
     */

    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.MeshGeneratorDelegate
     * @param   {Spine.Unity.MeshGeneratorBuffers}    buffers
     * @return  {void}
     */


    /*Spine.Unity.SkeletonRenderer start.*/
    /**
     * Base class of animated Spine skeleton components. This component manages and renders a skeleton.
     *
     * @public
     * @class Spine.Unity.SkeletonRenderer
     * @augments UnityEngine.MonoBehaviour
     * @implements  Spine.Unity.ISkeletonComponent
     * @implements  Spine.Unity.IHasSkeletonDataAsset
     */
    Bridge.define("Spine.Unity.SkeletonRenderer", {
        inherits: [UnityEngine.MonoBehaviour,Spine.Unity.ISkeletonComponent,Spine.Unity.IHasSkeletonDataAsset],
        statics: {
            fields: {
                /**
                 * Shader property value used as Stencil comparison function for {@link }.
                 *
                 * @static
                 * @public
                 * @memberof Spine.Unity.SkeletonRenderer
                 * @constant
                 * @default 8
                 * @type UnityEngine.Rendering.CompareFunction
                 */
                STENCIL_COMP_MASKINTERACTION_NONE: 0,
                /**
                 * Shader property value used as Stencil comparison function for {@link }.
                 *
                 * @static
                 * @public
                 * @memberof Spine.Unity.SkeletonRenderer
                 * @constant
                 * @default 4
                 * @type UnityEngine.Rendering.CompareFunction
                 */
                STENCIL_COMP_MASKINTERACTION_VISIBLE_INSIDE: 0,
                /**
                 * Shader property value used as Stencil comparison function for {@link }.
                 *
                 * @static
                 * @public
                 * @memberof Spine.Unity.SkeletonRenderer
                 * @constant
                 * @default 5
                 * @type UnityEngine.Rendering.CompareFunction
                 */
                STENCIL_COMP_MASKINTERACTION_VISIBLE_OUTSIDE: 0,
                /**
                 * Shader property ID used for the Stencil comparison function.
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof Spine.Unity.SkeletonRenderer
                 * @type number
                 */
                STENCIL_COMP_PARAM_ID: 0,
                SUBMESH_DUMMY_PARAM_ID: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#init", this ); }

                    this.STENCIL_COMP_MASKINTERACTION_NONE = UnityEngine.Rendering.CompareFunction.Always;
                    this.STENCIL_COMP_MASKINTERACTION_VISIBLE_INSIDE = UnityEngine.Rendering.CompareFunction.LessEqual;
                    this.STENCIL_COMP_MASKINTERACTION_VISIBLE_OUTSIDE = UnityEngine.Rendering.CompareFunction.Greater;
                    this.STENCIL_COMP_PARAM_ID = UnityEngine.Shader.PropertyToID("_StencilComp");
                    this.SUBMESH_DUMMY_PARAM_ID = UnityEngine.Shader.PropertyToID("_Submesh");
                }
            },
            methods: {
                /*Spine.Unity.SkeletonRenderer.NewSpineGameObject:static start.*/
                NewSpineGameObject: function (T, skeletonDataAsset, quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#NewSpineGameObject", this ); }

                    if (quiet === void 0) { quiet = false; }
                    return Spine.Unity.SkeletonRenderer.AddSpineComponent(T, new UnityEngine.GameObject.$ctor2("New Spine GameObject"), skeletonDataAsset, quiet);
                },
                /*Spine.Unity.SkeletonRenderer.NewSpineGameObject:static end.*/

                /*Spine.Unity.SkeletonRenderer.AddSpineComponent:static start.*/
                /**
                 * Add and prepare a Spine component that derives from SkeletonRenderer to a GameObject at runtime.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonRenderer
                 * @memberof Spine.Unity.SkeletonRenderer
                 * @param   {Function}                         T                    T should be SkeletonRenderer or any of its derived classes.
                 * @param   {UnityEngine.GameObject}           gameObject           
                 * @param   {Spine.Unity.SkeletonDataAsset}    skeletonDataAsset    
                 * @param   {boolean}                          quiet
                 * @return  {T}
                 */
                AddSpineComponent: function (T, gameObject, skeletonDataAsset, quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#AddSpineComponent", this ); }

                    if (quiet === void 0) { quiet = false; }
                    var c = Bridge.rValue(gameObject.AddComponent(T));
                    if (skeletonDataAsset != null) {
Bridge.rValue(                        c).skeletonDataAsset = skeletonDataAsset;
Bridge.rValue(                        c).Initialize(false, quiet);
                    }
                    return Bridge.rValue(c);
                },
                /*Spine.Unity.SkeletonRenderer.AddSpineComponent:static end.*/


            }
        },
        fields: {
            skeletonDataAsset: null,
            /**
             * Skin name to use when the Skeleton is initialized.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @type string
             */
            initialSkinName: null,
            /**
             * Enable this parameter when overwriting the Skeleton's skin from an editor script.
             Otherwise any changes will be overwritten by the next inspector update.
             * Flip X and Y to use when the Skeleton is initialized.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @type boolean
             */
            initialFlipX: false,
            /**
             * Enable this parameter when overwriting the Skeleton's skin from an editor script.
             Otherwise any changes will be overwritten by the next inspector update.
             * Flip X and Y to use when the Skeleton is initialized.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @type boolean
             */
            initialFlipY: false,
            updateMode: 0,
            /**
             * Update mode used when the MeshRenderer becomes invisible
             (when <pre><code>OnBecameInvisible()</code></pre> is called). Update mode is automatically
             reset to <pre><code>UpdateMode.FullUpdate</code></pre> when the mesh becomes visible again.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @type Spine.Unity.UpdateMode
             */
            updateWhenInvisible: 0,
            /**
             * Slot names used to populate separatorSlots list when the Skeleton is initialized. Changing this after initialization does nothing.
             *
             * @instance
             * @protected
             * @memberof Spine.Unity.SkeletonRenderer
             * @type Array.<string>
             */
            separatorSlotNames: null,
            /**
             * Slots that determine where the render is split. This is used by components such as SkeletonRenderSeparator so that the skeleton can be rendered by two separate renderers on different GameObjects.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonRenderer
             * @type System.Collections.Generic.List$1
             */
            separatorSlots: null,
            zSpacing: 0,
            /**
             * Use Spine's clipping feature. If false, ClippingAttachments will be ignored.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default true
             * @type boolean
             */
            useClipping: false,
            /**
             * If true, triangles will not be updated. Enable this as an optimization if the skeleton does not make use of attachment swapping or hiding, or draw order keys. Otherwise, setting this to false may cause errors in rendering.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default false
             * @type boolean
             */
            immutableTriangles: false,
            /**
             * Multiply vertex color RGB with vertex color alpha. Set this to true if the shader used for rendering is a premultiplied alpha shader. Setting this to false disables single-batch additive slots.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default true
             * @type boolean
             */
            pmaVertexColors: false,
            /**
             * Clears the state of the render and skeleton when this component or its GameObject is disabled. This prevents previous state from being retained when it is enabled again. When pooling your skeleton, setting this to true can be helpful.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default false
             * @type boolean
             */
            clearStateOnDisable: false,
            /**
             * If true, second colors on slots will be added to the output Mesh as UV2 and UV3. A special "tint black" shader that interprets UV2 and UV3 as black point colors is required to render this properly.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default false
             * @type boolean
             */
            tintBlack: false,
            /**
             * If true, the renderer assumes the skeleton only requires one Material and one submesh to render. This allows the MeshGenerator to skip checking for changes in Materials. Enable this as an optimization if the skeleton only uses one Material.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default false
             * @type boolean
             */
            singleSubmesh: false,
            /**
             * Applies only when 3+ submeshes are used (2+ materials with alternating order, e.g. "A B A").
             If true, GPU instancing is disabled at all materials and MaterialPropertyBlocks are assigned at each
             material to prevent aggressive batching of submeshes by e.g. the LWRP renderer, leading to incorrect
             draw order (e.g. "A1 B A2" changed to "A1A2 B").
             You can disable this parameter when everything is drawn correctly to save the additional performance cost.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default false
             * @type boolean
             */
            fixDrawOrder: false,
            /**
             * If true, the mesh generator adds normals to the output mesh. For better performance and reduced memory requirements, use a shader that assumes the desired normal.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default false
             * @type boolean
             */
            addNormals: false,
            /**
             * If true, tangents are calculated every frame and added to the Mesh. Enable this when using a shader that uses lighting that requires tangents.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default false
             * @type boolean
             */
            calculateTangents: false,
            /**
             * This enum controls the mode under which the sprite will interact with the masking system.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @type UnityEngine.SpriteMaskInteraction
             */
            maskInteraction: 0,
            /**
             * Material references for switching material sets at runtime when {@link } changes.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @type Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials
             */
            maskMaterials: null,
            disableRenderingOnOverride: false,
            customMaterialOverride: null,
            customSlotMaterials: null,
            currentInstructions: null,
            meshGenerator: null,
            rendererBuffers: null,
            meshRenderer: null,
            meshFilter: null,
            valid: false,
            skeleton: null,
            /**
             * @instance
             * @protected
             * @memberof Spine.Unity.SkeletonRenderer
             * @type UnityEngine.Vector2
             * @see {@link PhysicsPositionInheritanceFactor}
             */
            physicsPositionInheritanceFactor: null,
            /**
             * @instance
             * @protected
             * @memberof Spine.Unity.SkeletonRenderer
             * @default 1.0
             * @type number
             * @see {@link PhysicsRotationInheritanceFactor}
             */
            physicsRotationInheritanceFactor: 0,
            /**
             * Reference transform relative to which physics movement will be calculated, or null to use world location.
             *
             * @instance
             * @protected
             * @memberof Spine.Unity.SkeletonRenderer
             * @type UnityEngine.Transform
             */
            physicsMovementRelativeTo: null,
            /**
             * Used for applying Transform translation to skeleton PhysicsConstraints.
             *
             * @instance
             * @protected
             * @memberof Spine.Unity.SkeletonRenderer
             * @type UnityEngine.Vector3
             */
            lastPosition: null,
            /**
             * Used for applying Transform rotation to skeleton PhysicsConstraints.
             *
             * @instance
             * @protected
             * @memberof Spine.Unity.SkeletonRenderer
             * @type number
             */
            lastRotation: 0,
            reusedPropertyBlock: null
        },
        events: {
            generateMeshOverride: null,
            /**
             * Occurs after the vertex data is populated every frame, before the vertices are pushed into the mesh.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @function addOnPostProcessVertices
             * @param   {Spine.Unity.MeshGeneratorDelegate}    value
             * @return  {void}
             */
            /**
             * Occurs after the vertex data is populated every frame, before the vertices are pushed into the mesh.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @function removeOnPostProcessVertices
             * @param   {Spine.Unity.MeshGeneratorDelegate}    value
             * @return  {void}
             */
            OnPostProcessVertices: null,
            /**
             * OnRebuild is raised after the Skeleton is successfully initialized.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @function addOnRebuild
             * @param   {Spine.Unity.SkeletonRenderer.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            /**
             * OnRebuild is raised after the Skeleton is successfully initialized.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @function removeOnRebuild
             * @param   {Spine.Unity.SkeletonRenderer.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            OnRebuild: null,
            /**
             * OnMeshAndMaterialsUpdated is called at the end of LateUpdate after the Mesh and
             all materials have been updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @function addOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonRenderer.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            /**
             * OnMeshAndMaterialsUpdated is called at the end of LateUpdate after the Mesh and
             all materials have been updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @function removeOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonRenderer.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            OnMeshAndMaterialsUpdated: null
        },
        props: {
            /**
             * Update mode to optionally limit updates to e.g. only apply animations but not update the mesh.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @function UpdateMode
             * @type Spine.Unity.UpdateMode
             */
            UpdateMode: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#UpdateMode#get", this ); }

                    return this.updateMode;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#UpdateMode#set", this ); }

                    this.updateMode = value;
                }
            },
            /**
             * Use this Dictionary to override a Material with a different Material.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonRenderer
             * @function CustomMaterialOverride
             * @type System.Collections.Generic.Dictionary$2
             */
            CustomMaterialOverride: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#CustomMaterialOverride#get", this ); }

                    return this.customMaterialOverride;
                }
            },
            /**
             * Use this Dictionary to use a different Material to render specific Slots.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonRenderer
             * @function CustomSlotMaterials
             * @type System.Collections.Generic.Dictionary$2
             */
            CustomSlotMaterials: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#CustomSlotMaterials#get", this ); }

                    return this.customSlotMaterials;
                }
            },
            /**
             * Returns the {@link } used by this renderer for use with e.g.
             {@link }
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonRenderer
             * @function SkeletonClipping
             * @type Spine.SkeletonClipping
             */
            SkeletonClipping: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#SkeletonClipping#get", this ); }

                    return this.meshGenerator.SkeletonClipping;
                }
            },
            Skeleton: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#Skeleton#get", this ); }

                    this.Initialize(false);
                    return this.skeleton;
                }
            },
            /**
             * When set to non-zero, Transform position movement in X and Y direction
             is applied to skeleton PhysicsConstraints, multiplied by this scale factor.
             Typical values are <pre><code>Vector2.one</code></pre> to apply XY movement 1:1,
             <pre><code>Vector2(2f, 2f)</code></pre> to apply movement with double intensity,
             <pre><code>Vector2(1f, 0f)</code></pre> to apply only horizontal movement, or
             <pre><code>Vector2.zero</code></pre> to not apply any Transform position movement at all.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @function PhysicsPositionInheritanceFactor
             * @type UnityEngine.Vector2
             */
            PhysicsPositionInheritanceFactor: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#PhysicsPositionInheritanceFactor#get", this ); }

                    return this.physicsPositionInheritanceFactor.$clone();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#PhysicsPositionInheritanceFactor#set", this ); }

                    if (pc.Vec2.equals( this.physicsPositionInheritanceFactor, pc.Vec2.ZERO.clone() ) && !pc.Vec2.equals( value, pc.Vec2.ZERO.clone() )) {
                        this.ResetLastPosition();
                    }
                    this.physicsPositionInheritanceFactor = value.$clone();
                }
            },
            /**
             * When set to non-zero, Transform rotation movement is applied to skeleton PhysicsConstraints,
             multiplied by this scale factor. Typical values are <pre><code>1</code></pre> to apply movement 1:1,
             <pre><code>2</code></pre> to apply movement with double intensity, or
             <pre><code>0</code></pre> to not apply any Transform rotation movement at all.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @function PhysicsRotationInheritanceFactor
             * @type number
             */
            PhysicsRotationInheritanceFactor: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#PhysicsRotationInheritanceFactor#get", this ); }

                    return this.physicsRotationInheritanceFactor;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#PhysicsRotationInheritanceFactor#set", this ); }

                    if (this.physicsRotationInheritanceFactor === 0.0 && value !== 0.0) {
                        this.ResetLastRotation();
                    }
                    this.physicsRotationInheritanceFactor = value;
                }
            },
            /**
             * Reference transform relative to which physics movement will be calculated, or null to use world location.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @function PhysicsMovementRelativeTo
             * @type UnityEngine.Transform
             */
            PhysicsMovementRelativeTo: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#PhysicsMovementRelativeTo#get", this ); }

                    return this.physicsMovementRelativeTo;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#PhysicsMovementRelativeTo#set", this ); }

                    this.physicsMovementRelativeTo = value;
                    if (!pc.Vec2.equals( this.physicsPositionInheritanceFactor, pc.Vec2.ZERO.clone() )) {
                        this.ResetLastPosition();
                    }
                    if (this.physicsRotationInheritanceFactor !== 0.0) {
                        this.ResetLastRotation();
                    }
                }
            },
            SkeletonDataAsset: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#SkeletonDataAsset#get", this ); }

                    return this.skeletonDataAsset;
                }
            }
        },
        alias: [
            "Skeleton", "Spine$Unity$ISkeletonComponent$Skeleton",
            "SkeletonDataAsset", "Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset",
            "SkeletonDataAsset", "Spine$Unity$ISkeletonComponent$SkeletonDataAsset"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#init", this ); }

                this.physicsPositionInheritanceFactor = new UnityEngine.Vector2();
                this.lastPosition = new UnityEngine.Vector3();
                this.updateMode = Spine.Unity.UpdateMode.FullUpdate;
                this.updateWhenInvisible = Spine.Unity.UpdateMode.FullUpdate;
                this.separatorSlotNames = System.Array.init(0, null, System.String);
                this.separatorSlots = new (System.Collections.Generic.List$1(Spine.Slot)).ctor();
                this.useClipping = true;
                this.immutableTriangles = false;
                this.pmaVertexColors = true;
                this.clearStateOnDisable = false;
                this.tintBlack = false;
                this.singleSubmesh = false;
                this.fixDrawOrder = false;
                this.addNormals = false;
                this.calculateTangents = false;
                this.maskInteraction = UnityEngine.SpriteMaskInteraction.None;
                this.maskMaterials = new Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials();
                this.disableRenderingOnOverride = true;
                this.customMaterialOverride = new (System.Collections.Generic.Dictionary$2(UnityEngine.Material,UnityEngine.Material)).ctor();
                this.customSlotMaterials = new (System.Collections.Generic.Dictionary$2(Spine.Slot,UnityEngine.Material)).ctor();
                this.currentInstructions = new Spine.Unity.SkeletonRendererInstruction();
                this.meshGenerator = new Spine.Unity.MeshGenerator();
                this.rendererBuffers = new Spine.Unity.MeshRendererBuffers();
                this.physicsPositionInheritanceFactor = pc.Vec2.ONE.clone();
                this.physicsRotationInheritanceFactor = 1.0;
            }
        },
        methods: {
            /**
             * Allows separate code to take over rendering for this SkeletonRenderer component. The subscriber is passed a SkeletonRendererInstruction argument to determine how to render a skeleton.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @event Spine.Unity.SkeletonRenderer#GenerateMeshOverride
             * @return  {Spine.Unity.SkeletonRenderer.InstructionDelegate}
             */
            addGenerateMeshOverride: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#addGenerateMeshOverride", this ); }

                this.addgenerateMeshOverride(value);
                if (this.disableRenderingOnOverride && !Bridge.staticEquals(this.generateMeshOverride, null)) {
                    this.Initialize(false);
                    if (UnityEngine.Object.op_Implicit(this.meshRenderer)) {
                        this.meshRenderer.enabled = false;
                    }
                    this.updateMode = Spine.Unity.UpdateMode.FullUpdate;
                }
            },
            /**
             * Allows separate code to take over rendering for this SkeletonRenderer component. The subscriber is passed a SkeletonRendererInstruction argument to determine how to render a skeleton.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @event Spine.Unity.SkeletonRenderer#GenerateMeshOverride
             * @return  {Spine.Unity.SkeletonRenderer.InstructionDelegate}
             */
            removeGenerateMeshOverride: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#removeGenerateMeshOverride", this ); }

                this.removegenerateMeshOverride(value);
                if (this.disableRenderingOnOverride && Bridge.staticEquals(this.generateMeshOverride, null)) {
                    this.Initialize(false);
                    if (UnityEngine.Object.op_Implicit(this.meshRenderer)) {
                        this.meshRenderer.enabled = true;
                    }
                }
            },
            /*Spine.Unity.SkeletonRenderer.ResetLastPosition start.*/
            ResetLastPosition: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#ResetLastPosition", this ); }

                this.lastPosition = this.GetPhysicsTransformPosition();
            },
            /*Spine.Unity.SkeletonRenderer.ResetLastPosition end.*/

            /*Spine.Unity.SkeletonRenderer.ResetLastRotation start.*/
            ResetLastRotation: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#ResetLastRotation", this ); }

                this.lastRotation = this.GetPhysicsTransformRotation();
            },
            /*Spine.Unity.SkeletonRenderer.ResetLastRotation end.*/

            /*Spine.Unity.SkeletonRenderer.ResetLastPositionAndRotation start.*/
            ResetLastPositionAndRotation: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#ResetLastPositionAndRotation", this ); }

                this.lastPosition = this.GetPhysicsTransformPosition();
                this.lastRotation = this.GetPhysicsTransformRotation();
            },
            /*Spine.Unity.SkeletonRenderer.ResetLastPositionAndRotation end.*/

            /*Spine.Unity.SkeletonRenderer.SetMeshSettings start.*/
            /**
             * Applies MeshGenerator settings to the SkeletonRenderer and its internal MeshGenerator.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @param   {Spine.Unity.MeshGenerator.Settings}    settings
             * @return  {void}
             */
            SetMeshSettings: function (settings) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#SetMeshSettings", this ); }

                this.calculateTangents = settings.calculateTangents;
                this.immutableTriangles = settings.immutableTriangles;
                this.pmaVertexColors = settings.pmaVertexColors;
                this.tintBlack = settings.tintBlack;
                this.useClipping = settings.useClipping;
                this.zSpacing = settings.zSpacing;

                this.meshGenerator.settings = settings.$clone();
            },
            /*Spine.Unity.SkeletonRenderer.SetMeshSettings end.*/

            /*Spine.Unity.SkeletonRenderer.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#Awake", this ); }

                this.Initialize(false);
                if (Bridge.staticEquals(this.generateMeshOverride, null) || !this.disableRenderingOnOverride) {
                    this.updateMode = this.updateWhenInvisible;
                }
            },
            /*Spine.Unity.SkeletonRenderer.Awake end.*/

            /*Spine.Unity.SkeletonRenderer.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#OnDisable", this ); }

                if (this.clearStateOnDisable && this.valid) {
                    this.ClearState();
                }
            },
            /*Spine.Unity.SkeletonRenderer.OnDisable end.*/

            /*Spine.Unity.SkeletonRenderer.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#OnDestroy", this ); }

                this.rendererBuffers.Dispose();
                this.valid = false;
            },
            /*Spine.Unity.SkeletonRenderer.OnDestroy end.*/

            /*Spine.Unity.SkeletonRenderer.ClearState start.*/
            /**
             * Clears the previously generated mesh and resets the skeleton's pose.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @return  {void}
             */
            ClearState: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#ClearState", this ); }

                var meshFilter = this.GetComponent(UnityEngine.MeshFilter);
                if (UnityEngine.Component.op_Inequality(meshFilter, null)) {
                    meshFilter.sharedMesh = null;
                }
                this.currentInstructions.Clear();
                if (this.skeleton != null) {
                    this.skeleton.SetToSetupPose();
                }
            },
            /*Spine.Unity.SkeletonRenderer.ClearState end.*/

            /*Spine.Unity.SkeletonRenderer.EnsureMeshGeneratorCapacity start.*/
            /**
             * Sets a minimum buffer size for the internal MeshGenerator to prevent excess allocations during animation.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @param   {number}    minimumVertexCount
             * @return  {void}
             */
            EnsureMeshGeneratorCapacity: function (minimumVertexCount) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#EnsureMeshGeneratorCapacity", this ); }

                this.meshGenerator.EnsureVertexCapacity(minimumVertexCount);
            },
            /*Spine.Unity.SkeletonRenderer.EnsureMeshGeneratorCapacity end.*/

            /*Spine.Unity.SkeletonRenderer.Initialize start.*/
            /**
             * Initialize this component. Attempts to load the SkeletonData and creates the internal Skeleton object and buffers.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @param   {boolean}    overwrite    If set to <pre><code>true</code></pre>, it will overwrite internal objects if they were already generated. Otherwise, the initialized component will ignore subsequent calls to initialize.
             * @param   {boolean}    quiet
             * @return  {void}
             */
            Initialize: function (overwrite, quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#Initialize", this ); }

                var $t;
                if (quiet === void 0) { quiet = false; }
                if (this.valid && !overwrite) {
                    return;
                }
                // Clear
                {
                    // Note: do not reset meshFilter.sharedMesh or meshRenderer.sharedMaterial to null,
                    // otherwise constant reloading will be triggered at prefabs.
                    this.currentInstructions.Clear();
                    this.rendererBuffers.Clear();
                    this.meshGenerator.Begin();
                    this.skeleton = null;
                    this.valid = false;
                }

                if (this.skeletonDataAsset == null) {
                    return;
                }

                var skeletonData = this.skeletonDataAsset.GetSkeletonData(quiet);
                if (skeletonData == null) {
                    return;
                }
                this.valid = true;

                this.meshFilter = this.GetComponent(UnityEngine.MeshFilter);
                if (UnityEngine.Component.op_Equality(this.meshFilter, null)) {
                    this.meshFilter = this.gameObject.AddComponent(UnityEngine.MeshFilter);
                }

                this.meshRenderer = this.GetComponent(UnityEngine.MeshRenderer);
                this.rendererBuffers.Initialize();

                this.skeleton = ($t = new Spine.Skeleton.$ctor1(skeletonData), $t.ScaleX = this.initialFlipX ? -1 : 1, $t.ScaleY = this.initialFlipY ? -1 : 1, $t);

                this.ResetLastPositionAndRotation();

                if (!System.String.isNullOrEmpty(this.initialSkinName) && !System.String.equals(this.initialSkinName, "default", 4)) {
                    this.skeleton.SetSkin$1(this.initialSkinName);
                }

                this.separatorSlots.clear();
                for (var i = 0; i < this.separatorSlotNames.length; i = (i + 1) | 0) {
                    this.separatorSlots.add(this.skeleton.FindSlot(this.separatorSlotNames[i]));
                }

                // Generate mesh once, required to update mesh bounds for visibility
                var updateModeSaved = this.updateMode;
                this.updateMode = Spine.Unity.UpdateMode.FullUpdate;
                this.UpdateWorldTransform(Spine.Skeleton.Physics.Update);
                this.LateUpdate();
                this.updateMode = updateModeSaved;

                if (!Bridge.staticEquals(this.OnRebuild, null)) {
                    this.OnRebuild(this);
                }

            },
            /*Spine.Unity.SkeletonRenderer.Initialize end.*/

            /*Spine.Unity.SkeletonRenderer.ApplyTransformMovementToPhysics start.*/
            ApplyTransformMovementToPhysics: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#ApplyTransformMovementToPhysics", this ); }

                if (UnityEngine.Application.isPlaying) {
                    if (!pc.Vec2.equals( this.physicsPositionInheritanceFactor, pc.Vec2.ZERO.clone() )) {
                        var position = this.GetPhysicsTransformPosition();
                        var positionDelta = position.$clone().sub( this.lastPosition );

                        positionDelta = this.transform.InverseTransformVector(positionDelta);
                        if (UnityEngine.Component.op_Inequality(this.physicsMovementRelativeTo, null)) {
                            positionDelta = this.physicsMovementRelativeTo.TransformVector(positionDelta);
                        }
                        positionDelta.x *= this.physicsPositionInheritanceFactor.x;
                        positionDelta.y *= this.physicsPositionInheritanceFactor.y;

                        this.skeleton.PhysicsTranslate(positionDelta.x, positionDelta.y);
                        this.lastPosition = position.$clone();
                    }
                    if (this.physicsRotationInheritanceFactor !== 0.0) {
                        var rotation = this.GetPhysicsTransformRotation();
                        this.skeleton.PhysicsRotate(0, 0, this.physicsRotationInheritanceFactor * (rotation - this.lastRotation));
                        this.lastRotation = rotation;
                    }
                }
            },
            /*Spine.Unity.SkeletonRenderer.ApplyTransformMovementToPhysics end.*/

            /*Spine.Unity.SkeletonRenderer.GetPhysicsTransformPosition start.*/
            GetPhysicsTransformPosition: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#GetPhysicsTransformPosition", this ); }

                if (UnityEngine.Component.op_Equality(this.physicsMovementRelativeTo, null)) {
                    return this.transform.position.$clone();
                } else {
                    if (UnityEngine.Component.op_Equality(this.physicsMovementRelativeTo, this.transform.parent)) {
                        return this.transform.localPosition.$clone();
                    } else {
                        return this.physicsMovementRelativeTo.InverseTransformPoint(this.transform.position);
                    }
                }
            },
            /*Spine.Unity.SkeletonRenderer.GetPhysicsTransformPosition end.*/

            /*Spine.Unity.SkeletonRenderer.GetPhysicsTransformRotation start.*/
            GetPhysicsTransformRotation: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#GetPhysicsTransformRotation", this ); }

                if (UnityEngine.Component.op_Equality(this.physicsMovementRelativeTo, null)) {
                    return this.transform.rotation.getPositiveEulerAngles().z;
                } else {
                    if (UnityEngine.Component.op_Equality(this.physicsMovementRelativeTo, this.transform.parent)) {
                        return this.transform.localRotation.getPositiveEulerAngles().z;
                    } else {
                        var relative = this.physicsMovementRelativeTo.rotation.clone().invert().clone().mul( this.transform.rotation );
                        return relative.getPositiveEulerAngles().z;
                    }
                }
            },
            /*Spine.Unity.SkeletonRenderer.GetPhysicsTransformRotation end.*/

            /*Spine.Unity.SkeletonRenderer.UpdateWorldTransform start.*/
            UpdateWorldTransform: function (physics) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#UpdateWorldTransform", this ); }

                this.skeleton.UpdateWorldTransform(physics);
            },
            /*Spine.Unity.SkeletonRenderer.UpdateWorldTransform end.*/

            /*Spine.Unity.SkeletonRenderer.LateUpdate start.*/
            /**
             * Generates a new UnityEngine.Mesh from the internal Skeleton.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @return  {void}
             */
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#LateUpdate", this ); }

                if (!this.valid) {
                    return;
                }


                if (this.updateMode !== Spine.Unity.UpdateMode.FullUpdate) {
                    return;
                }

                this.LateUpdateMesh();
            },
            /*Spine.Unity.SkeletonRenderer.LateUpdate end.*/

            /*Spine.Unity.SkeletonRenderer.LateUpdateMesh start.*/
            LateUpdateMesh: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#LateUpdateMesh", this ); }

                var $t, $t1;
                var doMeshOverride = !Bridge.staticEquals(this.generateMeshOverride, null);
                if ((!UnityEngine.Object.op_Implicit(this.meshRenderer) || !this.meshRenderer.enabled) && !doMeshOverride) {
                    return;
                }
                var currentInstructions = this.currentInstructions;
                var workingSubmeshInstructions = currentInstructions.submeshInstructions;
                var currentSmartMesh = this.rendererBuffers.GetNextMesh(); // Double-buffer for performance.

                var updateTriangles;

                if (this.singleSubmesh) {
                    // STEP 1. Determine a SmartMesh.Instruction. Split up instructions into submeshes. =============================================
                    Spine.Unity.MeshGenerator.GenerateSingleSubmeshInstruction(currentInstructions, this.skeleton, ($t = this.skeletonDataAsset.atlasAssets)[0].PrimaryMaterial);

                    // STEP 1.9. Post-process workingInstructions. ==================================================================================
                    if (this.customMaterialOverride.Count > 0) {
                        Spine.Unity.MeshGenerator.TryReplaceMaterials(workingSubmeshInstructions, this.customMaterialOverride);
                    }

                    // STEP 2. Update vertex buffer based on verts from the attachments. ===========================================================
                    this.meshGenerator.settings = ($t1 = new Spine.Unity.MeshGenerator.Settings(), $t1.pmaVertexColors = this.pmaVertexColors, $t1.zSpacing = this.zSpacing, $t1.useClipping = this.useClipping, $t1.tintBlack = this.tintBlack, $t1.calculateTangents = this.calculateTangents, $t1.addNormals = this.addNormals, $t1);
                    this.meshGenerator.Begin();
                    updateTriangles = Spine.Unity.SkeletonRendererInstruction.GeometryNotEqual(currentInstructions, currentSmartMesh.instructionUsed);
                    if (currentInstructions.hasActiveClipping) {
                        this.meshGenerator.AddSubmesh(workingSubmeshInstructions.Items[0], updateTriangles);
                    } else {
                        this.meshGenerator.BuildMeshWithArrays(currentInstructions, updateTriangles);
                    }

                } else {
                    // STEP 1. Determine a SmartMesh.Instruction. Split up instructions into submeshes. =============================================
                    Spine.Unity.MeshGenerator.GenerateSkeletonRendererInstruction(currentInstructions, this.skeleton, this.customSlotMaterials, this.separatorSlots, doMeshOverride, this.immutableTriangles);

                    // STEP 1.9. Post-process workingInstructions. ==================================================================================
                    if (this.customMaterialOverride.Count > 0) {
                        Spine.Unity.MeshGenerator.TryReplaceMaterials(workingSubmeshInstructions, this.customMaterialOverride);
                    }

                    if (doMeshOverride) {
                        this.generateMeshOverride(currentInstructions);
                        if (this.disableRenderingOnOverride) {
                            return;
                        }
                    }

                    updateTriangles = Spine.Unity.SkeletonRendererInstruction.GeometryNotEqual(currentInstructions, currentSmartMesh.instructionUsed);

                    // STEP 2. Update vertex buffer based on verts from the attachments. ===========================================================
                    this.meshGenerator.settings = ($t1 = new Spine.Unity.MeshGenerator.Settings(), $t1.pmaVertexColors = this.pmaVertexColors, $t1.zSpacing = this.zSpacing, $t1.useClipping = this.useClipping, $t1.tintBlack = this.tintBlack, $t1.calculateTangents = this.calculateTangents, $t1.addNormals = this.addNormals, $t1);
                    this.meshGenerator.Begin();
                    if (currentInstructions.hasActiveClipping) {
                        this.meshGenerator.BuildMesh(currentInstructions, updateTriangles);
                    } else {
                        this.meshGenerator.BuildMeshWithArrays(currentInstructions, updateTriangles);
                    }
                }

                if (!Bridge.staticEquals(this.OnPostProcessVertices, null)) {
                    this.OnPostProcessVertices(this.meshGenerator.Buffers.$clone());
                }

                // STEP 3. Move the mesh data into a UnityEngine.Mesh ===========================================================================
                var currentMesh = currentSmartMesh.mesh;
                this.meshGenerator.FillVertexData(currentMesh);

                this.rendererBuffers.UpdateSharedMaterials(workingSubmeshInstructions);

                var materialsChanged = this.rendererBuffers.MaterialsChangedInLastUpdate();
                if (updateTriangles) { // Check if the triangles should also be updated.
                    this.meshGenerator.FillTriangles(currentMesh);
                    this.meshRenderer.sharedMaterials = this.rendererBuffers.GetUpdatedSharedMaterialsArray();
                } else if (materialsChanged) {
                    this.meshRenderer.sharedMaterials = this.rendererBuffers.GetUpdatedSharedMaterialsArray();
                }
                if (materialsChanged && (this.maskMaterials.AnyMaterialCreated)) {
                    this.maskMaterials = new Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials();
                }

                this.meshGenerator.FillLateVertexData(currentMesh);

                // STEP 4. The UnityEngine.Mesh is ready. Set it as the MeshFilter's mesh. Store the instructions used for that mesh. ===========
                if (UnityEngine.Object.op_Implicit(this.meshFilter)) {
                    this.meshFilter.sharedMesh = currentMesh;
                }
                currentSmartMesh.instructionUsed.Set(currentInstructions);

                if (UnityEngine.Component.op_Inequality(this.meshRenderer, null)) {
                    this.AssignSpriteMaskMaterials();
                }
                if (UnityEngine.Application.isPlaying) {
                    this.HandleOnDemandLoading();
                }

                if (this.fixDrawOrder && this.meshRenderer.sharedMaterials.length > 2) {
                    this.SetMaterialSettingsToFixDrawOrder();
                }

                if (!Bridge.staticEquals(this.OnMeshAndMaterialsUpdated, null)) {
                    this.OnMeshAndMaterialsUpdated(this);
                }
            },
            /*Spine.Unity.SkeletonRenderer.LateUpdateMesh end.*/

            /*Spine.Unity.SkeletonRenderer.OnBecameVisible start.*/
            OnBecameVisible: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#OnBecameVisible", this ); }

                var previousUpdateMode = this.updateMode;
                this.updateMode = Spine.Unity.UpdateMode.FullUpdate;

                // OnBecameVisible is called after LateUpdate()
                if (previousUpdateMode !== Spine.Unity.UpdateMode.FullUpdate) {
                    this.LateUpdate();
                }
            },
            /*Spine.Unity.SkeletonRenderer.OnBecameVisible end.*/

            /*Spine.Unity.SkeletonRenderer.OnBecameInvisible start.*/
            OnBecameInvisible: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#OnBecameInvisible", this ); }

                this.updateMode = this.updateWhenInvisible;
            },
            /*Spine.Unity.SkeletonRenderer.OnBecameInvisible end.*/

            /*Spine.Unity.SkeletonRenderer.FindAndApplySeparatorSlots$1 start.*/
            FindAndApplySeparatorSlots$1: function (startsWith, clearExistingSeparators, updateStringArray) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#FindAndApplySeparatorSlots$1", this ); }

                if (clearExistingSeparators === void 0) { clearExistingSeparators = true; }
                if (updateStringArray === void 0) { updateStringArray = false; }
                if (System.String.isNullOrEmpty(startsWith)) {
                    return;
                }

                this.FindAndApplySeparatorSlots(function (slotName) {
                    return System.String.startsWith(slotName, startsWith);
                }, clearExistingSeparators, updateStringArray);
            },
            /*Spine.Unity.SkeletonRenderer.FindAndApplySeparatorSlots$1 end.*/

            /*Spine.Unity.SkeletonRenderer.FindAndApplySeparatorSlots start.*/
            FindAndApplySeparatorSlots: function (slotNamePredicate, clearExistingSeparators, updateStringArray) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#FindAndApplySeparatorSlots", this ); }

                var $t, $t1, $t2;
                if (clearExistingSeparators === void 0) { clearExistingSeparators = true; }
                if (updateStringArray === void 0) { updateStringArray = false; }
                if (Bridge.staticEquals(slotNamePredicate, null)) {
                    return;
                }
                if (!this.valid) {
                    return;
                }

                if (clearExistingSeparators) {
                    this.separatorSlots.clear();
                }

                var slots = this.skeleton.Slots;
                $t = Bridge.getEnumerator(slots);
                try {
                    while ($t.moveNext()) {
                        var slot = $t.Current;
                        if (slotNamePredicate(slot.Data.Name)) {
                            this.separatorSlots.add(slot);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                if (updateStringArray) {
                    var detectedSeparatorNames = new (System.Collections.Generic.List$1(System.String)).ctor();
                    $t1 = Bridge.getEnumerator(this.skeleton.Slots);
                    try {
                        while ($t1.moveNext()) {
                            var slot1 = $t1.Current;
                            var slotName = slot1.Data.Name;
                            if (slotNamePredicate(slotName)) {
                                detectedSeparatorNames.add(slotName);
                            }
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                    if (!clearExistingSeparators) {
                        var originalNames = this.separatorSlotNames;
                        $t2 = Bridge.getEnumerator(originalNames);
                        try {
                            while ($t2.moveNext()) {
                                var originalName = $t2.Current;
                                detectedSeparatorNames.add(originalName);
                            }
                        } finally {
                            if (Bridge.is($t2, System.IDisposable)) {
                                $t2.System$IDisposable$Dispose();
                            }
                        }
                    }

                    this.separatorSlotNames = detectedSeparatorNames.ToArray();
                }

            },
            /*Spine.Unity.SkeletonRenderer.FindAndApplySeparatorSlots end.*/

            /*Spine.Unity.SkeletonRenderer.ReapplySeparatorSlotNames start.*/
            ReapplySeparatorSlotNames: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#ReapplySeparatorSlotNames", this ); }

                if (!this.valid) {
                    return;
                }

                this.separatorSlots.clear();
                for (var i = 0, n = this.separatorSlotNames.length; i < n; i = (i + 1) | 0) {
                    var slot = this.skeleton.FindSlot(this.separatorSlotNames[i]);
                    if (slot != null) {
                        this.separatorSlots.add(slot);
                    }
                }
            },
            /*Spine.Unity.SkeletonRenderer.ReapplySeparatorSlotNames end.*/

            /*Spine.Unity.SkeletonRenderer.AssignSpriteMaskMaterials start.*/
            AssignSpriteMaskMaterials: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#AssignSpriteMaskMaterials", this ); }

                var $t, $t1, $t2;

                if (UnityEngine.Application.isPlaying) {
                    if (this.maskInteraction !== UnityEngine.SpriteMaskInteraction.None && this.maskMaterials.materialsMaskDisabled.length === 0) {
                        this.maskMaterials.materialsMaskDisabled = this.meshRenderer.sharedMaterials;
                    }
                }

                if (this.maskMaterials.materialsMaskDisabled.length > 0 && ($t = this.maskMaterials.materialsMaskDisabled)[0] != null && this.maskInteraction === UnityEngine.SpriteMaskInteraction.None) {
                    this.meshRenderer.materials = this.maskMaterials.materialsMaskDisabled;
                } else if (this.maskInteraction === UnityEngine.SpriteMaskInteraction.VisibleInsideMask) {
                    if (this.maskMaterials.materialsInsideMask.length === 0 || ($t1 = this.maskMaterials.materialsInsideMask)[0] == null) {
                        if (!this.InitSpriteMaskMaterialsInsideMask()) {
                            return;
                        }
                    }
                    this.meshRenderer.materials = this.maskMaterials.materialsInsideMask;
                } else if (this.maskInteraction === UnityEngine.SpriteMaskInteraction.VisibleOutsideMask) {
                    if (this.maskMaterials.materialsOutsideMask.length === 0 || ($t2 = this.maskMaterials.materialsOutsideMask)[0] == null) {
                        if (!this.InitSpriteMaskMaterialsOutsideMask()) {
                            return;
                        }
                    }
                    this.meshRenderer.materials = this.maskMaterials.materialsOutsideMask;
                }
            },
            /*Spine.Unity.SkeletonRenderer.AssignSpriteMaskMaterials end.*/

            /*Spine.Unity.SkeletonRenderer.InitSpriteMaskMaterialsInsideMask start.*/
            InitSpriteMaskMaterialsInsideMask: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#InitSpriteMaskMaterialsInsideMask", this ); }

                return this.InitSpriteMaskMaterialsForMaskType(Spine.Unity.SkeletonRenderer.STENCIL_COMP_MASKINTERACTION_VISIBLE_INSIDE, Bridge.ref(this.maskMaterials, "materialsInsideMask"));
            },
            /*Spine.Unity.SkeletonRenderer.InitSpriteMaskMaterialsInsideMask end.*/

            /*Spine.Unity.SkeletonRenderer.InitSpriteMaskMaterialsOutsideMask start.*/
            InitSpriteMaskMaterialsOutsideMask: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#InitSpriteMaskMaterialsOutsideMask", this ); }

                return this.InitSpriteMaskMaterialsForMaskType(Spine.Unity.SkeletonRenderer.STENCIL_COMP_MASKINTERACTION_VISIBLE_OUTSIDE, Bridge.ref(this.maskMaterials, "materialsOutsideMask"));
            },
            /*Spine.Unity.SkeletonRenderer.InitSpriteMaskMaterialsOutsideMask end.*/

            /*Spine.Unity.SkeletonRenderer.InitSpriteMaskMaterialsForMaskType start.*/
            InitSpriteMaskMaterialsForMaskType: function (maskFunction, materialsToFill) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#InitSpriteMaskMaterialsForMaskType", this ); }

                var originalMaterials = this.maskMaterials.materialsMaskDisabled;
                materialsToFill.v = System.Array.init(originalMaterials.length, null, UnityEngine.Material);
                for (var i = 0; i < originalMaterials.length; i = (i + 1) | 0) {
                    var originalMaterial = originalMaterials[i];
                    if (originalMaterial == null) {
                        materialsToFill.v[i] = null;
                        continue;
                    }
                    var newMaterial = new UnityEngine.Material.$ctor1(originalMaterial);
                    newMaterial.SetFloat(Spine.Unity.SkeletonRenderer.STENCIL_COMP_PARAM_ID, maskFunction);
                    materialsToFill.v[i] = newMaterial;
                }
                return true;
            },
            /*Spine.Unity.SkeletonRenderer.InitSpriteMaskMaterialsForMaskType end.*/

            /*Spine.Unity.SkeletonRenderer.HandleOnDemandLoading start.*/
            HandleOnDemandLoading: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#HandleOnDemandLoading", this ); }

                var $t, $t1, $t2;
                $t = Bridge.getEnumerator(this.skeletonDataAsset.atlasAssets);
                try {
                    while ($t.moveNext()) {
                        var atlasAsset = $t.Current;
                        if (atlasAsset.TextureLoadingMode !== Spine.Unity.AtlasAssetBase.LoadingMode.Normal) {
                            atlasAsset.BeginCustomTextureLoading();
                            for (var i = 0, count = this.meshRenderer.sharedMaterials.length; i < count; i = (i + 1) | 0) {
                                var overrideMaterial = { v : null };
                                atlasAsset.RequireTexturesLoaded(($t1 = this.meshRenderer.sharedMaterials)[i], overrideMaterial);
                                if (overrideMaterial.v != null) {
                                    ($t2 = this.meshRenderer.sharedMaterials)[i] = overrideMaterial.v;
                                }
                            }
                            atlasAsset.EndCustomTextureLoading();
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonRenderer.HandleOnDemandLoading end.*/

            /*Spine.Unity.SkeletonRenderer.SetMaterialSettingsToFixDrawOrder start.*/
            /**
             * This method was introduced as a workaround for too aggressive submesh draw call batching,
             leading to incorrect draw order when 3+ materials are used at submeshes in alternating order.
             Otherwise, e.g. when using Lightweight Render Pipeline, deliberately separated draw calls
             "A1 B A2" are reordered to "A1A2 B", regardless of batching-related project settings.
             *
             * @instance
             * @private
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @return  {void}
             */
            SetMaterialSettingsToFixDrawOrder: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#SetMaterialSettingsToFixDrawOrder", this ); }

                var $t, $t1;
                if (this.reusedPropertyBlock == null) {
                    this.reusedPropertyBlock = new UnityEngine.MaterialPropertyBlock();
                }

                var hasPerRendererBlock = this.meshRenderer.HasPropertyBlock();
                if (hasPerRendererBlock) {
                    this.meshRenderer.GetPropertyBlock(this.reusedPropertyBlock);
                }

                for (var i = 0; i < this.meshRenderer.sharedMaterials.length; i = (i + 1) | 0) {
                    if (!UnityEngine.Object.op_Implicit(($t = this.meshRenderer.sharedMaterials)[i])) {
                        continue;
                    }

                    if (!hasPerRendererBlock) {
                        this.meshRenderer.GetPropertyBlock$1(this.reusedPropertyBlock, i);
                    }
                    // Note: this parameter shall not exist at any shader, then Unity will create separate
                    // material instances (not in terms of memory cost or leakage).
                    this.reusedPropertyBlock.SetFloat(Spine.Unity.SkeletonRenderer.SUBMESH_DUMMY_PARAM_ID, i);
                    this.meshRenderer.SetPropertyBlock$1(this.reusedPropertyBlock, i);

                    ($t1 = this.meshRenderer.sharedMaterials)[i].enableInstancing = false;
                }
            },
            /*Spine.Unity.SkeletonRenderer.SetMaterialSettingsToFixDrawOrder end.*/


        },
        overloads: {
            "FindAndApplySeparatorSlots(string, bool, bool)": "FindAndApplySeparatorSlots$1"
        }
    });
    /*Spine.Unity.SkeletonRenderer end.*/
    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.SkeletonGraphic.MeshAssignmentDelegateMultiple
     * @param   {number}                          meshCount           
     * @param   {Array.<UnityEngine.Mesh>}        meshes              
     * @param   {Array.<UnityEngine.Material>}    graphicMaterials    
     * @param   {Array.<UnityEngine.Texture>}     textures
     * @return  {void}
     */

    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.SkeletonGraphic.MeshAssignmentDelegateSingle
     * @param   {UnityEngine.Mesh}        mesh               
     * @param   {UnityEngine.Material}    graphicMaterial    
     * @param   {UnityEngine.Texture}     texture
     * @return  {void}
     */

    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.ISkeletonAnimationDelegate
     * @param   {Spine.Unity.ISkeletonAnimation}    animated
     * @return  {void}
     */

    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.SkeletonGraphic.InstructionDelegate
     * @param   {Spine.Unity.SkeletonRendererInstruction}    instruction
     * @return  {void}
     */

    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.SkeletonGraphic.SkeletonRendererDelegate
     * @param   {Spine.Unity.SkeletonGraphic}    skeletonGraphic
     * @return  {void}
     */


    /*Spine.Unity.SkeletonGraphic start.*/
    Bridge.define("Spine.Unity.SkeletonGraphic", {
        inherits: [UnityEngine.UI.MaskableGraphic,Spine.Unity.ISkeletonComponent,Spine.Unity.IAnimationStateComponent,Spine.Unity.ISkeletonAnimation,Spine.Unity.IHasSkeletonDataAsset],
        statics: {
            fields: {
                EditReferenceRect: false,
                SeparatorPartGameObjectName: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#init", this ); }

                    this.EditReferenceRect = false;
                    this.SeparatorPartGameObjectName = "Part";
                }
            },
            methods: {
                /*Spine.Unity.SkeletonGraphic.NewSkeletonGraphicGameObject:static start.*/
                /**
                 * Create a new GameObject with a SkeletonGraphic component.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonGraphic
                 * @memberof Spine.Unity.SkeletonGraphic
                 * @param   {Spine.Unity.SkeletonDataAsset}    skeletonDataAsset    
                 * @param   {UnityEngine.Transform}            parent               
                 * @param   {UnityEngine.Material}             material             Material for the canvas renderer to use. Usually, the default SkeletonGraphic material will work.
                 * @return  {Spine.Unity.SkeletonGraphic}
                 */
                NewSkeletonGraphicGameObject: function (skeletonDataAsset, parent, material) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#NewSkeletonGraphicGameObject", this ); }

                    var sg = Spine.Unity.SkeletonGraphic.AddSkeletonGraphicComponent(new UnityEngine.GameObject.$ctor2("New Spine GameObject"), skeletonDataAsset, material);
                    if (UnityEngine.Component.op_Inequality(parent, null)) {
                        sg.transform.SetParent(parent, false);
                    }
                    return sg;
                },
                /*Spine.Unity.SkeletonGraphic.NewSkeletonGraphicGameObject:static end.*/

                /*Spine.Unity.SkeletonGraphic.AddSkeletonGraphicComponent:static start.*/
                /**
                 * Add a SkeletonGraphic component to a GameObject.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonGraphic
                 * @memberof Spine.Unity.SkeletonGraphic
                 * @param   {UnityEngine.GameObject}           gameObject           
                 * @param   {Spine.Unity.SkeletonDataAsset}    skeletonDataAsset    
                 * @param   {UnityEngine.Material}             material             Material for the canvas renderer to use. Usually, the default SkeletonGraphic material will work.
                 * @return  {Spine.Unity.SkeletonGraphic}
                 */
                AddSkeletonGraphicComponent: function (gameObject, skeletonDataAsset, material) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#AddSkeletonGraphicComponent", this ); }

                    var skeletonGraphic = gameObject.AddComponent(Spine.Unity.SkeletonGraphic);
                    if (skeletonDataAsset != null) {
                        skeletonGraphic.material = material;
                        skeletonGraphic.skeletonDataAsset = skeletonDataAsset;
                        skeletonGraphic.Initialize(false);
                    }
                    var canvasRenderer = gameObject.GetComponent(UnityEngine.CanvasRenderer);
                    if (UnityEngine.Object.op_Implicit(canvasRenderer)) {
                        canvasRenderer.cullTransparentMesh = false;
                    }
                    return skeletonGraphic;
                },
                /*Spine.Unity.SkeletonGraphic.AddSkeletonGraphicComponent:static end.*/

                /*Spine.Unity.SkeletonGraphic.SetRectTransformSize$1:static start.*/
                SetRectTransformSize$1: function (target, size) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#SetRectTransformSize$1", this ); }

                    Spine.Unity.SkeletonGraphic.SetRectTransformSize(target.rectTransform, size);
                },
                /*Spine.Unity.SkeletonGraphic.SetRectTransformSize$1:static end.*/

                /*Spine.Unity.SkeletonGraphic.SetRectTransformSize:static start.*/
                SetRectTransformSize: function (targetRectTransform, size) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#SetRectTransformSize", this ); }

                    var $t;
                    var parentSize = pc.Vec2.ZERO.clone();
                    if (UnityEngine.Component.op_Inequality(targetRectTransform.parent, null)) {
                        var parentTransform = targetRectTransform.parent.GetComponent(UnityEngine.RectTransform);
                        if (UnityEngine.Object.op_Implicit(parentTransform)) {
                            parentSize = parentTransform.rect.size.$clone();
                        }
                    }
                    var anchorAreaSize = ($t = targetRectTransform.anchorMax.$clone().sub( targetRectTransform.anchorMin ), new pc.Vec2( $t.x * parentSize.x, $t.y * parentSize.y ));
                    targetRectTransform.sizeDelta = size.$clone().sub( anchorAreaSize );
                },
                /*Spine.Unity.SkeletonGraphic.SetRectTransformSize:static end.*/


            }
        },
        fields: {
            skeletonDataAsset: null,
            additiveMaterial: null,
            multiplyMaterial: null,
            screenMaterial: null,
            /**
             * Own color to replace <pre><code>Graphic.m_Color</code></pre>.
             *
             * @instance
             * @protected
             * @memberof Spine.Unity.SkeletonGraphic
             * @type UnityEngine.Color
             */
            m_SkeletonColor: null,
            initialSkinName: null,
            initialFlipX: false,
            initialFlipY: false,
            startingAnimation: null,
            startingLoop: false,
            timeScale: 0,
            freeze: false,
            meshScale: 0,
            meshOffset: null,
            layoutScaleMode: 0,
            referenceSize: null,
            /**
             * Offset relative to the pivot position, before potential layout scale is applied.
             *
             * @instance
             * @protected
             * @memberof Spine.Unity.SkeletonGraphic
             * @type UnityEngine.Vector2
             */
            pivotOffset: null,
            referenceScale: 0,
            layoutScale: 0,
            updateMode: 0,
            /**
             * Update mode used when the MeshRenderer becomes invisible
             (when <pre><code>OnBecameInvisible()</code></pre> is called). Update mode is automatically
             reset to <pre><code>UpdateMode.FullUpdate</code></pre> when the mesh becomes visible again.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonGraphic
             * @type Spine.Unity.UpdateMode
             */
            updateWhenInvisible: 0,
            allowMultipleCanvasRenderers: false,
            canvasRenderers: null,
            submeshGraphics: null,
            usedRenderersCount: 0,
            /**
             * Slot names used to populate separatorSlots list when the Skeleton is initialized. Changing this after initialization does nothing.
             *
             * @instance
             * @protected
             * @memberof Spine.Unity.SkeletonGraphic
             * @type Array.<string>
             */
            separatorSlotNames: null,
            /**
             * Slots that determine where the render is split. This is used by components such as SkeletonRenderSeparator so that the skeleton can be rendered by two separate renderers on different GameObjects.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonGraphic
             * @type System.Collections.Generic.List$1
             */
            separatorSlots: null,
            enableSeparatorSlots: false,
            separatorParts: null,
            updateSeparatorPartLocation: false,
            updateSeparatorPartScale: false,
            wasUpdatedAfterInit: false,
            baseTexture: null,
            /**
             * When true, no meshes and materials are assigned at CanvasRenderers if the used override
             AssignMeshOverrideSingleRenderer or AssignMeshOverrideMultipleRenderers is non-null.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonGraphic
             * @default true
             * @type boolean
             */
            disableMeshAssignmentOnOverride: false,
            customTextureOverride: null,
            customMaterialOverride: null,
            overrideTexture: null,
            skeleton: null,
            state: null,
            /**
             * @instance
             * @protected
             * @memberof Spine.Unity.SkeletonGraphic
             * @type UnityEngine.Vector2
             * @see {@link PhysicsPositionInheritanceFactor}
             */
            physicsPositionInheritanceFactor: null,
            /**
             * @instance
             * @protected
             * @memberof Spine.Unity.SkeletonGraphic
             * @default 1.0
             * @type number
             * @see {@link PhysicsRotationInheritanceFactor}
             */
            physicsRotationInheritanceFactor: 0,
            /**
             * Reference transform relative to which physics movement will be calculated, or null to use world location.
             *
             * @instance
             * @protected
             * @memberof Spine.Unity.SkeletonGraphic
             * @type UnityEngine.Transform
             */
            physicsMovementRelativeTo: null,
            /**
             * Used for applying Transform translation to skeleton PhysicsConstraints.
             *
             * @instance
             * @protected
             * @memberof Spine.Unity.SkeletonGraphic
             * @type UnityEngine.Vector2
             */
            lastPosition: null,
            /**
             * Used for applying Transform rotation to skeleton PhysicsConstraints.
             *
             * @instance
             * @protected
             * @memberof Spine.Unity.SkeletonGraphic
             * @type number
             */
            lastRotation: 0,
            meshGenerator: null,
            meshBuffers: null,
            currentInstructions: null,
            meshes: null,
            usedMaterials: null,
            usedTextures: null,
            updateTiming: 0,
            unscaledTime: false
        },
        events: {
            assignMeshOverrideSingle: null,
            assignMeshOverrideMultiple: null,
            /**
             * OnRebuild is raised after the Skeleton is successfully initialized.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function addOnRebuild
             * @param   {Spine.Unity.SkeletonGraphic.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            /**
             * OnRebuild is raised after the Skeleton is successfully initialized.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function removeOnRebuild
             * @param   {Spine.Unity.SkeletonGraphic.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            OnRebuild: null,
            /**
             * OnInstructionsPrepared is raised at the end of <pre><code>LateUpdate</code></pre> after render instructions
             are done, target renderers are prepared, and the mesh is ready to be generated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function addOnInstructionsPrepared
             * @param   {Spine.Unity.SkeletonGraphic.InstructionDelegate}    value
             * @return  {void}
             */
            /**
             * OnInstructionsPrepared is raised at the end of <pre><code>LateUpdate</code></pre> after render instructions
             are done, target renderers are prepared, and the mesh is ready to be generated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function removeOnInstructionsPrepared
             * @param   {Spine.Unity.SkeletonGraphic.InstructionDelegate}    value
             * @return  {void}
             */
            OnInstructionsPrepared: null,
            /**
             * OnMeshAndMaterialsUpdated is raised at the end of <pre><code>Rebuild</code></pre> after the Mesh and
             all materials have been updated. Note that some Unity API calls are not permitted to be issued from
             <pre><code>Rebuild</code></pre>, so you may want to subscribe to {@link } instead
             from where you can issue such preparation calls.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function addOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonGraphic.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            /**
             * OnMeshAndMaterialsUpdated is raised at the end of <pre><code>Rebuild</code></pre> after the Mesh and
             all materials have been updated. Note that some Unity API calls are not permitted to be issued from
             <pre><code>Rebuild</code></pre>, so you may want to subscribe to {@link } instead
             from where you can issue such preparation calls.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function removeOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonGraphic.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            OnMeshAndMaterialsUpdated: null,
            /**
             * OnAnimationRebuild is raised after the SkeletonAnimation component is successfully initialized.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function addOnAnimationRebuild
             * @param   {Spine.Unity.ISkeletonAnimationDelegate}    value
             * @return  {void}
             */
            /**
             * OnAnimationRebuild is raised after the SkeletonAnimation component is successfully initialized.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function removeOnAnimationRebuild
             * @param   {Spine.Unity.ISkeletonAnimationDelegate}    value
             * @return  {void}
             */
            OnAnimationRebuild: null,
            BeforeApply: null,
            UpdateLocal: null,
            UpdateWorld: null,
            UpdateComplete: null,
            /**
             * Occurs after the vertex data populated every frame, before the vertices are pushed into the mesh.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function addOnPostProcessVertices
             * @param   {Spine.Unity.MeshGeneratorDelegate}    value
             * @return  {void}
             */
            /**
             * Occurs after the vertex data populated every frame, before the vertices are pushed into the mesh.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function removeOnPostProcessVertices
             * @param   {Spine.Unity.MeshGeneratorDelegate}    value
             * @return  {void}
             */
            OnPostProcessVertices: null
        },
        props: {
            SkeletonDataAsset: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#SkeletonDataAsset#get", this ); }

                    return this.skeletonDataAsset;
                }
            },
            /**
             * Sets the color of the skeleton. Does not call {@link } and {@link }
             unnecessarily as <pre><code>Graphic.color</code></pre> would otherwise do.
             *
             * @instance
             * @public
             * @override
             * @memberof Spine.Unity.SkeletonGraphic
             * @function color
             * @type UnityEngine.Color
             */
            color: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#color#get", this ); }

                    return this.m_SkeletonColor.$clone();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#color#set", this ); }

                    this.m_SkeletonColor = value.$clone();
                }
            },
            MeshScale: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#MeshScale#get", this ); }

                    return this.meshScale;
                }
            },
            MeshOffset: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#MeshOffset#get", this ); }

                    return this.meshOffset.$clone();
                }
            },
            /**
             * Update mode to optionally limit updates to e.g. only apply animations but not update the mesh.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonGraphic
             * @function UpdateMode
             * @type Spine.Unity.UpdateMode
             */
            UpdateMode: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateMode#get", this ); }

                    return this.updateMode;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateMode#set", this ); }

                    this.updateMode = value;
                }
            },
            SeparatorParts: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#SeparatorParts#get", this ); }

                    return this.separatorParts;
                }
            },
            /**
             * Use this Dictionary to override a Texture with a different Texture.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonGraphic
             * @function CustomTextureOverride
             * @type System.Collections.Generic.Dictionary$2
             */
            CustomTextureOverride: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#CustomTextureOverride#get", this ); }

                    return this.customTextureOverride;
                }
            },
            /**
             * Use this Dictionary to override the Material where the Texture was used at the original atlas.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonGraphic
             * @function CustomMaterialOverride
             * @type System.Collections.Generic.Dictionary$2
             */
            CustomMaterialOverride: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#CustomMaterialOverride#get", this ); }

                    return this.customMaterialOverride;
                }
            },
            OverrideTexture: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#OverrideTexture#get", this ); }

                    return this.overrideTexture;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#OverrideTexture#set", this ); }

                    this.overrideTexture = value;
                    this.canvasRenderer.SetTexture(this.mainTexture); // Refresh canvasRenderer's texture. Make sure it handles null.
                }
            },
            mainTexture: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#mainTexture#get", this ); }

                    if (this.overrideTexture != null) {
                        return this.overrideTexture;
                    }
                    return this.baseTexture;
                }
            },
            Skeleton: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Skeleton#get", this ); }

                    this.Initialize(false);
                    return this.skeleton;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Skeleton#set", this ); }

                    this.skeleton = value;
                }
            },
            SkeletonData: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#SkeletonData#get", this ); }

                    this.Initialize(false);
                    return this.skeleton == null ? null : this.skeleton.Data;
                }
            },
            IsValid: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#IsValid#get", this ); }

                    return this.skeleton != null;
                }
            },
            AnimationState: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#AnimationState#get", this ); }

                    this.Initialize(false);
                    return this.state;
                }
            },
            /**
             * When set to non-zero, Transform position movement in X and Y direction
             is applied to skeleton PhysicsConstraints, multiplied by this scale factor.
             Typical values are <pre><code>Vector2.one</code></pre> to apply XY movement 1:1,
             <pre><code>Vector2(2f, 2f)</code></pre> to apply movement with double intensity,
             <pre><code>Vector2(1f, 0f)</code></pre> to apply only horizontal movement, or
             <pre><code>Vector2.zero</code></pre> to not apply any Transform position movement at all.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonGraphic
             * @function PhysicsPositionInheritanceFactor
             * @type UnityEngine.Vector2
             */
            PhysicsPositionInheritanceFactor: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#PhysicsPositionInheritanceFactor#get", this ); }

                    return this.physicsPositionInheritanceFactor.$clone();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#PhysicsPositionInheritanceFactor#set", this ); }

                    if (pc.Vec2.equals( this.physicsPositionInheritanceFactor, pc.Vec2.ZERO.clone() ) && !pc.Vec2.equals( value, pc.Vec2.ZERO.clone() )) {
                        this.ResetLastPosition();
                    }
                    this.physicsPositionInheritanceFactor = value.$clone();
                }
            },
            /**
             * When set to non-zero, Transform rotation movement is applied to skeleton PhysicsConstraints,
             multiplied by this scale factor. Typical values are <pre><code>1</code></pre> to apply movement 1:1,
             <pre><code>2</code></pre> to apply movement with double intensity, or
             <pre><code>0</code></pre> to not apply any Transform rotation movement at all.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonGraphic
             * @function PhysicsRotationInheritanceFactor
             * @type number
             */
            PhysicsRotationInheritanceFactor: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#PhysicsRotationInheritanceFactor#get", this ); }

                    return this.physicsRotationInheritanceFactor;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#PhysicsRotationInheritanceFactor#set", this ); }

                    if (this.physicsRotationInheritanceFactor === 0.0 && value !== 0.0) {
                        this.ResetLastRotation();
                    }
                    this.physicsRotationInheritanceFactor = value;
                }
            },
            /**
             * Reference transform relative to which physics movement will be calculated, or null to use world location.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonGraphic
             * @function PhysicsMovementRelativeTo
             * @type UnityEngine.Transform
             */
            PhysicsMovementRelativeTo: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#PhysicsMovementRelativeTo#get", this ); }

                    return this.physicsMovementRelativeTo;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#PhysicsMovementRelativeTo#set", this ); }

                    this.physicsMovementRelativeTo = value;
                    if (!pc.Vec2.equals( this.physicsPositionInheritanceFactor, pc.Vec2.ZERO.clone() )) {
                        this.ResetLastPosition();
                    }
                    if (this.physicsRotationInheritanceFactor !== 0.0) {
                        this.ResetLastRotation();
                    }
                }
            },
            MeshGenerator: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#MeshGenerator#get", this ); }

                    return this.meshGenerator;
                }
            },
            /**
             * Returns the {@link } used by this renderer for use with e.g.
             {@link }
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonGraphic
             * @function SkeletonClipping
             * @type Spine.SkeletonClipping
             */
            SkeletonClipping: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#SkeletonClipping#get", this ); }

                    return this.meshGenerator.SkeletonClipping;
                }
            },
            MeshesMultipleCanvasRenderers: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#MeshesMultipleCanvasRenderers#get", this ); }

                    return this.meshes;
                }
            },
            MaterialsMultipleCanvasRenderers: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#MaterialsMultipleCanvasRenderers#get", this ); }

                    return this.usedMaterials;
                }
            },
            TexturesMultipleCanvasRenderers: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#TexturesMultipleCanvasRenderers#get", this ); }

                    return this.usedTextures;
                }
            },
            UpdateTiming: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateTiming#get", this ); }

                    return this.updateTiming;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateTiming#set", this ); }

                    this.updateTiming = value;
                }
            },
            UnscaledTime: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UnscaledTime#get", this ); }

                    return this.unscaledTime;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UnscaledTime#set", this ); }

                    this.unscaledTime = value;
                }
            }
        },
        alias: [
            "SkeletonDataAsset", "Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset",
            "SkeletonDataAsset", "Spine$Unity$ISkeletonComponent$SkeletonDataAsset",
            "Rebuild", "UnityEngine$UI$ICanvasElement$Rebuild",
            "Skeleton", "Spine$Unity$ISkeletonAnimation$Skeleton",
            "Skeleton", "Spine$Unity$ISkeletonComponent$Skeleton",
            "AnimationState", "Spine$Unity$IAnimationStateComponent$AnimationState",
            "addOnAnimationRebuild", "Spine$Unity$ISkeletonAnimation$addOnAnimationRebuild",
            "removeOnAnimationRebuild", "Spine$Unity$ISkeletonAnimation$removeOnAnimationRebuild",
            "addUpdateLocal", "Spine$Unity$ISkeletonAnimation$addUpdateLocal",
            "removeUpdateLocal", "Spine$Unity$ISkeletonAnimation$removeUpdateLocal",
            "addUpdateWorld", "Spine$Unity$ISkeletonAnimation$addUpdateWorld",
            "removeUpdateWorld", "Spine$Unity$ISkeletonAnimation$removeUpdateWorld",
            "addUpdateComplete", "Spine$Unity$ISkeletonAnimation$addUpdateComplete",
            "removeUpdateComplete", "Spine$Unity$ISkeletonAnimation$removeUpdateComplete",
            "UpdateTiming", "Spine$Unity$ISkeletonAnimation$UpdateTiming",
            "UnscaledTime", "Spine$Unity$IAnimationStateComponent$UnscaledTime"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#init", this ); }

                this.m_SkeletonColor = new UnityEngine.Color();
                this.meshOffset = new UnityEngine.Vector2();
                this.referenceSize = new UnityEngine.Vector2();
                this.pivotOffset = new UnityEngine.Vector2();
                this.physicsPositionInheritanceFactor = new UnityEngine.Vector2();
                this.lastPosition = new UnityEngine.Vector2();
                this.m_SkeletonColor = new pc.Color( 1, 1, 1, 1 );
                this.timeScale = 1.0;
                this.meshScale = 1.0;
                this.meshOffset = pc.Vec2.ZERO.clone();
                this.layoutScaleMode = Spine.Unity.SkeletonGraphic.LayoutMode.None;
                this.referenceSize = pc.Vec2.ONE.clone();
                this.pivotOffset = pc.Vec2.ZERO.clone();
                this.referenceScale = 1.0;
                this.layoutScale = 1.0;
                this.updateMode = Spine.Unity.UpdateMode.FullUpdate;
                this.updateWhenInvisible = Spine.Unity.UpdateMode.FullUpdate;
                this.allowMultipleCanvasRenderers = false;
                this.canvasRenderers = new (System.Collections.Generic.List$1(UnityEngine.CanvasRenderer)).ctor();
                this.submeshGraphics = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonSubmeshGraphic)).ctor();
                this.usedRenderersCount = 0;
                this.separatorSlotNames = System.Array.init(0, null, System.String);
                this.separatorSlots = new (System.Collections.Generic.List$1(Spine.Slot)).ctor();
                this.enableSeparatorSlots = false;
                this.separatorParts = new (System.Collections.Generic.List$1(UnityEngine.Transform)).ctor();
                this.updateSeparatorPartLocation = true;
                this.updateSeparatorPartScale = false;
                this.wasUpdatedAfterInit = true;
                this.disableMeshAssignmentOnOverride = true;
                this.customTextureOverride = new (System.Collections.Generic.Dictionary$2(UnityEngine.Texture,UnityEngine.Texture)).ctor();
                this.customMaterialOverride = new (System.Collections.Generic.Dictionary$2(UnityEngine.Texture,UnityEngine.Material)).ctor();
                this.physicsPositionInheritanceFactor = pc.Vec2.ONE.clone();
                this.physicsRotationInheritanceFactor = 1.0;
                this.meshGenerator = new Spine.Unity.MeshGenerator();
                this.currentInstructions = new Spine.Unity.SkeletonRendererInstruction();
                this.meshes = new (Spine.ExposedList$1(UnityEngine.Mesh)).ctor();
                this.usedMaterials = new (Spine.ExposedList$1(UnityEngine.Material)).ctor();
                this.usedTextures = new (Spine.ExposedList$1(UnityEngine.Texture)).ctor();
                this.updateTiming = Spine.Unity.UpdateTiming.InUpdate;
            }
        },
        methods: {
            /**
             * Allows separate code to take over mesh and material assignment for this SkeletonGraphic component.
             Used when <pre><code>allowMultipleCanvasRenderers</code></pre> is false.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonGraphic
             * @event Spine.Unity.SkeletonGraphic#AssignMeshOverrideSingleRenderer
             * @return  {Spine.Unity.SkeletonGraphic.MeshAssignmentDelegateSingle}
             */
            addAssignMeshOverrideSingleRenderer: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#addAssignMeshOverrideSingleRenderer", this ); }

                this.addassignMeshOverrideSingle(value);
                if (this.disableMeshAssignmentOnOverride && !Bridge.staticEquals(this.assignMeshOverrideSingle, null)) {
                    this.Initialize(false);
                }
            },
            /**
             * Allows separate code to take over mesh and material assignment for this SkeletonGraphic component.
             Used when <pre><code>allowMultipleCanvasRenderers</code></pre> is false.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonGraphic
             * @event Spine.Unity.SkeletonGraphic#AssignMeshOverrideSingleRenderer
             * @return  {Spine.Unity.SkeletonGraphic.MeshAssignmentDelegateSingle}
             */
            removeAssignMeshOverrideSingleRenderer: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#removeAssignMeshOverrideSingleRenderer", this ); }

                this.removeassignMeshOverrideSingle(value);
                if (this.disableMeshAssignmentOnOverride && Bridge.staticEquals(this.assignMeshOverrideSingle, null)) {
                    this.Initialize(false);
                }
            },
            /**
             * Allows separate code to take over mesh and material assignment for this SkeletonGraphic component.
             Used when <pre><code>allowMultipleCanvasRenderers</code></pre> is true.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonGraphic
             * @event Spine.Unity.SkeletonGraphic#AssignMeshOverrideMultipleRenderers
             * @return  {Spine.Unity.SkeletonGraphic.MeshAssignmentDelegateMultiple}
             */
            addAssignMeshOverrideMultipleRenderers: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#addAssignMeshOverrideMultipleRenderers", this ); }

                this.addassignMeshOverrideMultiple(value);
                if (this.disableMeshAssignmentOnOverride && !Bridge.staticEquals(this.assignMeshOverrideMultiple, null)) {
                    this.Initialize(false);
                }
            },
            /**
             * Allows separate code to take over mesh and material assignment for this SkeletonGraphic component.
             Used when <pre><code>allowMultipleCanvasRenderers</code></pre> is true.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonGraphic
             * @event Spine.Unity.SkeletonGraphic#AssignMeshOverrideMultipleRenderers
             * @return  {Spine.Unity.SkeletonGraphic.MeshAssignmentDelegateMultiple}
             */
            removeAssignMeshOverrideMultipleRenderers: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#removeAssignMeshOverrideMultipleRenderers", this ); }

                this.removeassignMeshOverrideMultiple(value);
                if (this.disableMeshAssignmentOnOverride && Bridge.staticEquals(this.assignMeshOverrideMultiple, null)) {
                    this.Initialize(false);
                }
            },
            /*Spine.Unity.SkeletonGraphic.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Awake", this ); }

                UnityEngine.UI.MaskableGraphic.prototype.Awake.call(this);
                this.onCullStateChanged.AddListener(Bridge.fn.cacheBind(this, this.OnCullStateChanged));

                this.SyncSubmeshGraphicsWithCanvasRenderers();
                if (!this.IsValid) {
                    this.Initialize(false);
                    if (this.IsValid) {
                        this.Rebuild(UnityEngine.UI.CanvasUpdate.PreRender);
                    }
                }

            },
            /*Spine.Unity.SkeletonGraphic.Awake end.*/

            /*Spine.Unity.SkeletonGraphic.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#OnDestroy", this ); }

                this.Clear();
                UnityEngine.UI.MaskableGraphic.prototype.OnDestroy.call(this);
            },
            /*Spine.Unity.SkeletonGraphic.OnDestroy end.*/

            /*Spine.Unity.SkeletonGraphic.Rebuild start.*/
            Rebuild: function (update) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Rebuild", this ); }

                UnityEngine.UI.MaskableGraphic.prototype.Rebuild.call(this, update);
                if (!this.IsValid) {
                    return;
                }
                if (this.canvasRenderer.cull) {
                    return;
                }
                if (update === UnityEngine.UI.CanvasUpdate.PreRender) {
                    this.PrepareInstructionsAndRenderers(true);
                    this.UpdateMeshToInstructions();
                }
                if (this.allowMultipleCanvasRenderers) {
                    this.canvasRenderer.Clear();
                }
            },
            /*Spine.Unity.SkeletonGraphic.Rebuild end.*/

            /*Spine.Unity.SkeletonGraphic.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#OnDisable", this ); }

                var $t;
                UnityEngine.UI.MaskableGraphic.prototype.OnDisable.call(this);
                $t = Bridge.getEnumerator(this.canvasRenderers);
                try {
                    while ($t.moveNext()) {
                        var canvasRenderer = $t.Current;
                        canvasRenderer.Clear();
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphic.OnDisable end.*/

            /*Spine.Unity.SkeletonGraphic.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Update", this ); }

                if (this.freeze || this.updateTiming !== Spine.Unity.UpdateTiming.InUpdate) {
                    return;
                }
                this.Update$1(this.unscaledTime ? UnityEngine.Time.unscaledDeltaTime : UnityEngine.Time.deltaTime);
            },
            /*Spine.Unity.SkeletonGraphic.Update end.*/

            /*Spine.Unity.SkeletonGraphic.Update$1 start.*/
            Update$1: function (deltaTime) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Update$1", this ); }

                if (!this.IsValid) {
                    return;
                }

                this.wasUpdatedAfterInit = true;
                if (this.updateMode < Spine.Unity.UpdateMode.OnlyAnimationStatus) {
                    return;
                }
                this.UpdateAnimationStatus(deltaTime);

                if (this.updateMode === Spine.Unity.UpdateMode.OnlyAnimationStatus) {
                    return;
                }
                this.ApplyAnimation();
            },
            /*Spine.Unity.SkeletonGraphic.Update$1 end.*/

            /*Spine.Unity.SkeletonGraphic.FixedUpdate start.*/
            FixedUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#FixedUpdate", this ); }

                if (this.freeze || this.updateTiming !== Spine.Unity.UpdateTiming.InFixedUpdate) {
                    return;
                }
                this.Update$1(this.unscaledTime ? UnityEngine.Time.unscaledDeltaTime : UnityEngine.Time.deltaTime);
            },
            /*Spine.Unity.SkeletonGraphic.FixedUpdate end.*/

            /*Spine.Unity.SkeletonGraphic.SyncSubmeshGraphicsWithCanvasRenderers start.*/
            SyncSubmeshGraphicsWithCanvasRenderers: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#SyncSubmeshGraphicsWithCanvasRenderers", this ); }

                var $t;
                this.submeshGraphics.clear();

                $t = Bridge.getEnumerator(this.canvasRenderers);
                try {
                    while ($t.moveNext()) {
                        var canvasRenderer = $t.Current;
                        var submeshGraphic = canvasRenderer.GetComponent(Spine.Unity.SkeletonSubmeshGraphic);
                        if (UnityEngine.MonoBehaviour.op_Equality(submeshGraphic, null)) {
                            submeshGraphic = canvasRenderer.gameObject.AddComponent(Spine.Unity.SkeletonSubmeshGraphic);
                            submeshGraphic.maskable = this.maskable;
                            submeshGraphic.raycastTarget = false;
                        }
                        this.submeshGraphics.add(submeshGraphic);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphic.SyncSubmeshGraphicsWithCanvasRenderers end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateAnimationStatus start.*/
            UpdateAnimationStatus: function (deltaTime) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateAnimationStatus", this ); }

                deltaTime *= this.timeScale;
                this.state.Update(deltaTime);
                this.skeleton.Update(deltaTime);

                this.ApplyTransformMovementToPhysics();

                if (this.updateMode === Spine.Unity.UpdateMode.OnlyAnimationStatus) {
                    this.state.ApplyEventTimelinesOnly(this.skeleton, false);
                    return;
                }
            },
            /*Spine.Unity.SkeletonGraphic.UpdateAnimationStatus end.*/

            /*Spine.Unity.SkeletonGraphic.ApplyTransformMovementToPhysics start.*/
            ApplyTransformMovementToPhysics: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#ApplyTransformMovementToPhysics", this ); }

                if (UnityEngine.Application.isPlaying) {
                    if (!pc.Vec2.equals( this.physicsPositionInheritanceFactor, pc.Vec2.ZERO.clone() )) {
                        var position = this.GetPhysicsTransformPosition();
                        var positionDelta = (position.$clone().sub( this.lastPosition )).scale( 1.0 / ( this.meshScale ) );

                        positionDelta = UnityEngine.Vector2.FromVector3(this.transform.InverseTransformVector(UnityEngine.Vector3.FromVector2(positionDelta)));
                        if (UnityEngine.Component.op_Inequality(this.physicsMovementRelativeTo, null)) {
                            positionDelta = UnityEngine.Vector2.FromVector3(this.physicsMovementRelativeTo.TransformVector(UnityEngine.Vector3.FromVector2(positionDelta)));
                        }
                        positionDelta.x *= this.physicsPositionInheritanceFactor.x;
                        positionDelta.y *= this.physicsPositionInheritanceFactor.y;

                        this.skeleton.PhysicsTranslate(positionDelta.x, positionDelta.y);
                        this.lastPosition = position.$clone();
                    }
                    if (this.physicsRotationInheritanceFactor !== 0.0) {
                        var rotation = this.GetPhysicsTransformRotation();
                        this.skeleton.PhysicsRotate(0, 0, this.physicsRotationInheritanceFactor * (rotation - this.lastRotation));
                        this.lastRotation = rotation;
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphic.ApplyTransformMovementToPhysics end.*/

            /*Spine.Unity.SkeletonGraphic.GetPhysicsTransformPosition start.*/
            GetPhysicsTransformPosition: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#GetPhysicsTransformPosition", this ); }

                if (UnityEngine.Component.op_Equality(this.physicsMovementRelativeTo, null)) {
                    return UnityEngine.Vector2.FromVector3(this.transform.position.$clone());
                } else {
                    if (UnityEngine.Component.op_Equality(this.physicsMovementRelativeTo, this.transform.parent)) {
                        return UnityEngine.Vector2.FromVector3(this.transform.localPosition.$clone());
                    } else {
                        return UnityEngine.Vector2.FromVector3(this.physicsMovementRelativeTo.InverseTransformPoint(this.transform.position));
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphic.GetPhysicsTransformPosition end.*/

            /*Spine.Unity.SkeletonGraphic.GetPhysicsTransformRotation start.*/
            GetPhysicsTransformRotation: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#GetPhysicsTransformRotation", this ); }

                if (UnityEngine.Component.op_Equality(this.physicsMovementRelativeTo, null)) {
                    return this.transform.rotation.getPositiveEulerAngles().z;
                } else {
                    if (UnityEngine.Component.op_Equality(this.physicsMovementRelativeTo, this.transform.parent)) {
                        return this.transform.localRotation.getPositiveEulerAngles().z;
                    } else {
                        var relative = this.physicsMovementRelativeTo.rotation.clone().invert().clone().mul( this.transform.rotation );
                        return relative.getPositiveEulerAngles().z;
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphic.GetPhysicsTransformRotation end.*/

            /*Spine.Unity.SkeletonGraphic.ApplyAnimation start.*/
            ApplyAnimation: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#ApplyAnimation", this ); }

                if (!Bridge.staticEquals(this.BeforeApply, null)) {
                    this.BeforeApply(this);
                }

                if (this.updateMode !== Spine.Unity.UpdateMode.OnlyEventTimelines) {
                    this.state.Apply(this.skeleton);
                } else {
                    this.state.ApplyEventTimelinesOnly(this.skeleton, true);
                }

                this.AfterAnimationApplied();
            },
            /*Spine.Unity.SkeletonGraphic.ApplyAnimation end.*/

            /*Spine.Unity.SkeletonGraphic.AfterAnimationApplied start.*/
            AfterAnimationApplied: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#AfterAnimationApplied", this ); }

                if (!Bridge.staticEquals(this.UpdateLocal, null)) {
                    this.UpdateLocal(this);
                }

                if (Bridge.staticEquals(this.UpdateWorld, null)) {
                    this.UpdateWorldTransform(Spine.Skeleton.Physics.Update);
                } else {
                    this.UpdateWorldTransform(Spine.Skeleton.Physics.Pose);
                    this.UpdateWorld(this);
                    this.UpdateWorldTransform(Spine.Skeleton.Physics.Update);
                }

                if (!Bridge.staticEquals(this.UpdateComplete, null)) {
                    this.UpdateComplete(this);
                }
            },
            /*Spine.Unity.SkeletonGraphic.AfterAnimationApplied end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateWorldTransform start.*/
            UpdateWorldTransform: function (physics) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateWorldTransform", this ); }

                this.skeleton.UpdateWorldTransform(physics);
            },
            /*Spine.Unity.SkeletonGraphic.UpdateWorldTransform end.*/

            /*Spine.Unity.SkeletonGraphic.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#LateUpdate", this ); }

                if (!this.IsValid) {
                    return;
                }
                // instantiation can happen from Update() after this component, leading to a missing Update() call.
                if (!this.wasUpdatedAfterInit) {
                    this.Update$1(0);
                }
                if (this.freeze) {
                    return;
                }
                if (this.updateMode !== Spine.Unity.UpdateMode.FullUpdate) {
                    return;
                }

                if (this.updateTiming === Spine.Unity.UpdateTiming.InLateUpdate) {
                    this.Update$1(this.unscaledTime ? UnityEngine.Time.unscaledDeltaTime : UnityEngine.Time.deltaTime);
                }

                this.UpdateMesh();
            },
            /*Spine.Unity.SkeletonGraphic.LateUpdate end.*/

            /*Spine.Unity.SkeletonGraphic.OnCullStateChanged start.*/
            OnCullStateChanged: function (culled) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#OnCullStateChanged", this ); }

                if (culled) {
                    this.OnBecameInvisible();
                } else {
                    this.OnBecameVisible();
                }
            },
            /*Spine.Unity.SkeletonGraphic.OnCullStateChanged end.*/

            /*Spine.Unity.SkeletonGraphic.OnBecameVisible start.*/
            OnBecameVisible: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#OnBecameVisible", this ); }

                this.updateMode = Spine.Unity.UpdateMode.FullUpdate;
            },
            /*Spine.Unity.SkeletonGraphic.OnBecameVisible end.*/

            /*Spine.Unity.SkeletonGraphic.OnBecameInvisible start.*/
            OnBecameInvisible: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#OnBecameInvisible", this ); }

                this.updateMode = this.updateWhenInvisible;
            },
            /*Spine.Unity.SkeletonGraphic.OnBecameInvisible end.*/

            /*Spine.Unity.SkeletonGraphic.ReapplySeparatorSlotNames start.*/
            ReapplySeparatorSlotNames: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#ReapplySeparatorSlotNames", this ); }

                if (!this.IsValid) {
                    return;
                }

                this.separatorSlots.clear();
                for (var i = 0, n = this.separatorSlotNames.length; i < n; i = (i + 1) | 0) {
                    var slotName = this.separatorSlotNames[i];
                    if (Bridge.referenceEquals(slotName, "")) {
                        continue;
                    }
                    var slot = this.skeleton.FindSlot(slotName);
                    if (slot != null) {
                        this.separatorSlots.add(slot);
                    }
                }
                this.UpdateSeparatorPartParents();
            },
            /*Spine.Unity.SkeletonGraphic.ReapplySeparatorSlotNames end.*/

            /*Spine.Unity.SkeletonGraphic.ResetLastPosition start.*/
            ResetLastPosition: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#ResetLastPosition", this ); }

                this.lastPosition = this.GetPhysicsTransformPosition();
            },
            /*Spine.Unity.SkeletonGraphic.ResetLastPosition end.*/

            /*Spine.Unity.SkeletonGraphic.ResetLastRotation start.*/
            ResetLastRotation: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#ResetLastRotation", this ); }

                this.lastRotation = this.GetPhysicsTransformRotation();
            },
            /*Spine.Unity.SkeletonGraphic.ResetLastRotation end.*/

            /*Spine.Unity.SkeletonGraphic.ResetLastPositionAndRotation start.*/
            ResetLastPositionAndRotation: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#ResetLastPositionAndRotation", this ); }

                this.lastPosition = this.GetPhysicsTransformPosition();
                this.lastRotation = this.GetPhysicsTransformRotation();
            },
            /*Spine.Unity.SkeletonGraphic.ResetLastPositionAndRotation end.*/

            /*Spine.Unity.SkeletonGraphic.GetLastMesh start.*/
            GetLastMesh: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#GetLastMesh", this ); }

                return this.meshBuffers.GetCurrent().mesh;
            },
            /*Spine.Unity.SkeletonGraphic.GetLastMesh end.*/

            /*Spine.Unity.SkeletonGraphic.MatchRectTransformWithBounds start.*/
            MatchRectTransformWithBounds: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#MatchRectTransformWithBounds", this ); }

                if (!this.wasUpdatedAfterInit) {
                    this.Update$1(0);
                }
                this.UpdateMesh();

                if (!this.allowMultipleCanvasRenderers) {
                    return this.MatchRectTransformSingleRenderer();
                } else {
                    return this.MatchRectTransformMultipleRenderers();
                }
            },
            /*Spine.Unity.SkeletonGraphic.MatchRectTransformWithBounds end.*/

            /*Spine.Unity.SkeletonGraphic.MatchRectTransformSingleRenderer start.*/
            MatchRectTransformSingleRenderer: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#MatchRectTransformSingleRenderer", this ); }

                var mesh = this.GetLastMesh();
                if (mesh == null) {
                    return false;
                }
                if (mesh.vertexCount === 0 || pc.Vec3.equals( mesh.bounds.halfExtents.$clone().scale( 2 ), pc.Vec3.ZERO.clone() )) {
                    this.rectTransform.sizeDelta = new pc.Vec2( 50.0, 50.0 );
                    this.rectTransform.pivot = new pc.Vec2( 0.5, 0.5 );
                    return false;
                }
                mesh.RecalculateBounds();
                this.SetRectTransformBounds(mesh.bounds);
                return true;
            },
            /*Spine.Unity.SkeletonGraphic.MatchRectTransformSingleRenderer end.*/

            /*Spine.Unity.SkeletonGraphic.MatchRectTransformMultipleRenderers start.*/
            MatchRectTransformMultipleRenderers: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#MatchRectTransformMultipleRenderers", this ); }

                var $t;
                var anyBoundsAdded = false;
                var combinedBounds = new pc.BoundingBox.ctor();
                for (var i = 0; i < this.canvasRenderers.Count; i = (i + 1) | 0) {
                    var canvasRenderer = this.canvasRenderers.getItem(i);
                    if (!canvasRenderer.gameObject.activeSelf) {
                        continue;
                    }

                    var mesh = ($t = this.meshes.Items)[i];
                    if (mesh == null || mesh.vertexCount === 0) {
                        continue;
                    }

                    mesh.RecalculateBounds();
                    var bounds = mesh.bounds;
                    if (anyBoundsAdded) {
                        combinedBounds.add( bounds );
                    } else {
                        anyBoundsAdded = true;
                        combinedBounds = bounds;
                    }
                }

                if (!anyBoundsAdded || pc.Vec3.equals( combinedBounds.halfExtents.$clone().scale( 2 ), pc.Vec3.ZERO.clone() )) {
                    this.rectTransform.sizeDelta = new pc.Vec2( 50.0, 50.0 );
                    this.rectTransform.pivot = new pc.Vec2( 0.5, 0.5 );
                    return false;
                }

                this.SetRectTransformBounds(combinedBounds);
                return true;
            },
            /*Spine.Unity.SkeletonGraphic.MatchRectTransformMultipleRenderers end.*/

            /*Spine.Unity.SkeletonGraphic.SetRectTransformBounds start.*/
            SetRectTransformBounds: function (combinedBounds) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#SetRectTransformBounds", this ); }

                var $t, $t1;
                var size = combinedBounds.halfExtents.$clone().scale( 2 ).$clone();
                var center = combinedBounds.center.$clone();
                var p = new pc.Vec2( 0.5 - (center.x / size.x), 0.5 - (center.y / size.y) );

                Spine.Unity.SkeletonGraphic.SetRectTransformSize$1(this, UnityEngine.Vector2.FromVector3(size));
                this.rectTransform.pivot = p.$clone();

                $t = Bridge.getEnumerator(this.separatorParts);
                try {
                    while ($t.moveNext()) {
                        var separatorPart = $t.Current;
                        var separatorTransform = separatorPart.GetComponent(UnityEngine.RectTransform);
                        if (UnityEngine.Object.op_Implicit(separatorTransform)) {
                            Spine.Unity.SkeletonGraphic.SetRectTransformSize(separatorTransform, UnityEngine.Vector2.FromVector3(size));
                            separatorTransform.pivot = p.$clone();
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                $t1 = Bridge.getEnumerator(this.submeshGraphics);
                try {
                    while ($t1.moveNext()) {
                        var submeshGraphic = $t1.Current;
                        Spine.Unity.SkeletonGraphic.SetRectTransformSize$1(submeshGraphic, UnityEngine.Vector2.FromVector3(size));
                        submeshGraphic.rectTransform.pivot = p.$clone();
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }
                this.referenceSize = UnityEngine.Vector2.FromVector3(size.$clone());
                this.referenceScale = this.referenceScale * this.layoutScale;
                this.layoutScale = 1.0;
            },
            /*Spine.Unity.SkeletonGraphic.SetRectTransformBounds end.*/

            /*Spine.Unity.SkeletonGraphic.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Clear", this ); }

                this.skeleton = null;
                this.canvasRenderer.Clear();

                for (var i = 0; i < this.canvasRenderers.Count; i = (i + 1) | 0) {
                    this.canvasRenderers.getItem(i).Clear();
                }
                this.DestroyMeshes();
                this.usedMaterials.Clear();
                this.usedTextures.Clear();
                this.DisposeMeshBuffers();
            },
            /*Spine.Unity.SkeletonGraphic.Clear end.*/

            /*Spine.Unity.SkeletonGraphic.TrimRenderers start.*/
            TrimRenderers: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#TrimRenderers", this ); }

                var $t;
                var newList = new (System.Collections.Generic.List$1(UnityEngine.CanvasRenderer)).ctor();
                $t = Bridge.getEnumerator(this.canvasRenderers);
                try {
                    while ($t.moveNext()) {
                        var canvasRenderer = $t.Current;
                        if (canvasRenderer.gameObject.activeSelf) {
                            newList.add(canvasRenderer);
                        } else {
                            if (UnityEngine.Application.isEditor && !UnityEngine.Application.isPlaying) {
                                UnityEngine.Object.DestroyImmediate(canvasRenderer.gameObject);
                            } else {
                                UnityEngine.MonoBehaviour.Destroy(canvasRenderer.gameObject);
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                this.canvasRenderers = newList;
                this.SyncSubmeshGraphicsWithCanvasRenderers();
            },
            /*Spine.Unity.SkeletonGraphic.TrimRenderers end.*/

            /*Spine.Unity.SkeletonGraphic.Initialize start.*/
            Initialize: function (overwrite) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Initialize", this ); }

                var $t, $t1;
                if (this.IsValid && !overwrite) {
                    return;
                }
                if (this.skeletonDataAsset == null) {
                    return;
                }
                var skeletonData = this.skeletonDataAsset.GetSkeletonData(false);
                if (skeletonData == null) {
                    return;
                }

                if (this.skeletonDataAsset.atlasAssets.length <= 0 || ($t = this.skeletonDataAsset.atlasAssets)[0].MaterialCount <= 0) {
                    return;
                }

                this.skeleton = ($t1 = new Spine.Skeleton.$ctor1(skeletonData), $t1.ScaleX = this.initialFlipX ? -1 : 1, $t1.ScaleY = this.initialFlipY ? -1 : 1, $t1);

                this.InitMeshBuffers();
                this.baseTexture = ($t1 = this.skeletonDataAsset.atlasAssets)[0].PrimaryMaterial.mainTexture;
                this.canvasRenderer.SetTexture(this.mainTexture); // Needed for overwriting initializations.

                this.ResetLastPositionAndRotation();

                // Set the initial Skin and Animation
                if (!System.String.isNullOrEmpty(this.initialSkinName)) {
                    this.skeleton.SetSkin$1(this.initialSkinName);
                }

                this.separatorSlots.clear();
                for (var i = 0; i < this.separatorSlotNames.length; i = (i + 1) | 0) {
                    this.separatorSlots.add(this.skeleton.FindSlot(this.separatorSlotNames[i]));
                }

                if (!Bridge.staticEquals(this.OnRebuild, null)) {
                    this.OnRebuild(this);
                }

                this.wasUpdatedAfterInit = false;
                this.state = new Spine.AnimationState(this.skeletonDataAsset.GetAnimationStateData());
                if (this.state == null) {
                    this.Clear();
                    return;
                }

                if (!System.String.isNullOrEmpty(this.startingAnimation)) {
                    var animationObject = this.skeletonDataAsset.GetSkeletonData(false).FindAnimation(this.startingAnimation);
                    if (animationObject != null) {
                        this.state.SetAnimation(0, animationObject, this.startingLoop);
                    }
                }

                if (!Bridge.staticEquals(this.OnAnimationRebuild, null)) {
                    this.OnAnimationRebuild(this);
                }
            },
            /*Spine.Unity.SkeletonGraphic.Initialize end.*/

            /*Spine.Unity.SkeletonGraphic.PrepareInstructionsAndRenderers start.*/
            PrepareInstructionsAndRenderers: function (isInRebuild) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#PrepareInstructionsAndRenderers", this ); }

                if (isInRebuild === void 0) { isInRebuild = false; }
                if (!this.allowMultipleCanvasRenderers) {
                    Spine.Unity.MeshGenerator.GenerateSingleSubmeshInstruction(this.currentInstructions, this.skeleton, null);
                    if (this.canvasRenderers.Count > 0) {
                        this.DisableUnusedCanvasRenderers(0, isInRebuild);
                    }
                    this.usedRenderersCount = 0;
                } else {
                    Spine.Unity.MeshGenerator.GenerateSkeletonRendererInstruction(this.currentInstructions, this.skeleton, null, this.enableSeparatorSlots ? this.separatorSlots : null, this.enableSeparatorSlots ? this.separatorSlots.Count > 0 : false, false);

                    var submeshCount = this.currentInstructions.submeshInstructions.Count;
                    this.EnsureCanvasRendererCount(submeshCount);
                    this.EnsureMeshesCount(submeshCount);
                    this.EnsureUsedTexturesAndMaterialsCount(submeshCount);
                    this.EnsureSeparatorPartCount();
                    this.PrepareRendererGameObjects(this.currentInstructions, isInRebuild);
                }
                if (!Bridge.staticEquals(this.OnInstructionsPrepared, null)) {
                    this.OnInstructionsPrepared(this.currentInstructions);
                }
            },
            /*Spine.Unity.SkeletonGraphic.PrepareInstructionsAndRenderers end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateMesh start.*/
            UpdateMesh: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateMesh", this ); }

                this.PrepareInstructionsAndRenderers();
                this.UpdateMeshToInstructions();
            },
            /*Spine.Unity.SkeletonGraphic.UpdateMesh end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateMeshToInstructions start.*/
            UpdateMeshToInstructions: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateMeshToInstructions", this ); }

                if (!this.IsValid || this.currentInstructions.rawVertexCount < 0) {
                    return;
                }
                Spine.Unity.SkeletonExtensions.SetColor$4(this.skeleton, this.color.$clone());

                if (!this.allowMultipleCanvasRenderers) {
                    this.UpdateMeshSingleCanvasRenderer(this.currentInstructions);
                } else {
                    this.UpdateMaterialsMultipleCanvasRenderers(this.currentInstructions);
                    this.UpdateMeshMultipleCanvasRenderers(this.currentInstructions);
                }

                if (!Bridge.staticEquals(this.OnMeshAndMaterialsUpdated, null)) {
                    this.OnMeshAndMaterialsUpdated(this);
                }
            },
            /*Spine.Unity.SkeletonGraphic.UpdateMeshToInstructions end.*/

            /*Spine.Unity.SkeletonGraphic.HasMultipleSubmeshInstructions start.*/
            HasMultipleSubmeshInstructions: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#HasMultipleSubmeshInstructions", this ); }

                if (!this.IsValid) {
                    return false;
                }
                return Spine.Unity.MeshGenerator.RequiresMultipleSubmeshesByDrawOrder(this.skeleton);
            },
            /*Spine.Unity.SkeletonGraphic.HasMultipleSubmeshInstructions end.*/

            /*Spine.Unity.SkeletonGraphic.InitMeshBuffers start.*/
            InitMeshBuffers: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#InitMeshBuffers", this ); }

                if (this.meshBuffers != null) {
                    this.meshBuffers.GetNext().Clear();
                    this.meshBuffers.GetNext().Clear();
                } else {
                    this.meshBuffers = new (Spine.Unity.DoubleBuffered$1(Spine.Unity.MeshRendererBuffers.SmartMesh))();
                }
            },
            /*Spine.Unity.SkeletonGraphic.InitMeshBuffers end.*/

            /*Spine.Unity.SkeletonGraphic.DisposeMeshBuffers start.*/
            DisposeMeshBuffers: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#DisposeMeshBuffers", this ); }

                if (this.meshBuffers != null) {
                    this.meshBuffers.GetNext().Dispose();
                    this.meshBuffers.GetNext().Dispose();
                    this.meshBuffers = null;
                }
            },
            /*Spine.Unity.SkeletonGraphic.DisposeMeshBuffers end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateMeshSingleCanvasRenderer start.*/
            UpdateMeshSingleCanvasRenderer: function (currentInstructions) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateMeshSingleCanvasRenderer", this ); }

                var $t, $t1;
                var smartMesh = this.meshBuffers.GetNext();
                var updateTriangles = Spine.Unity.SkeletonRendererInstruction.GeometryNotEqual(currentInstructions, smartMesh.instructionUsed);
                this.meshGenerator.Begin();

                var useAddSubmesh = currentInstructions.hasActiveClipping && currentInstructions.submeshInstructions.Count > 0;
                if (useAddSubmesh) {
                    this.meshGenerator.AddSubmesh(($t = currentInstructions.submeshInstructions.Items)[0], updateTriangles);
                } else {
                    this.meshGenerator.BuildMeshWithArrays(currentInstructions, updateTriangles);
                }

                this.meshScale = (UnityEngine.Component.op_Equality(this.canvas, null)) ? 100 : this.canvas.referencePixelsPerUnit;
                if (this.layoutScaleMode !== Spine.Unity.SkeletonGraphic.LayoutMode.None) {
                    this.meshScale *= this.referenceScale;
                    this.layoutScale = this.GetLayoutScale(this.layoutScaleMode);
                    if (true) {
                        this.meshScale *= this.layoutScale;
                    }
                    this.meshOffset = this.pivotOffset.$clone().scale( this.layoutScale );
                } else {
                    this.meshOffset = this.pivotOffset.$clone();
                }
                if (pc.Vec2.equals( this.meshOffset, pc.Vec2.ZERO.clone() )) {
                    this.meshGenerator.ScaleVertexData(this.meshScale);
                } else {
                    this.meshGenerator.ScaleAndOffsetVertexData(this.meshScale, this.meshOffset);
                }

                if (!Bridge.staticEquals(this.OnPostProcessVertices, null)) {
                    this.OnPostProcessVertices(this.meshGenerator.Buffers.$clone());
                }

                var mesh = smartMesh.mesh;
                this.meshGenerator.FillVertexData(mesh);
                if (updateTriangles) {
                    this.meshGenerator.FillTriangles(mesh);
                }
                this.meshGenerator.FillLateVertexData(mesh);

                smartMesh.instructionUsed.Set(currentInstructions);
                if (!Bridge.staticEquals(this.assignMeshOverrideSingle, null)) {
                    this.assignMeshOverrideSingle(mesh, this.canvasRenderer.GetMaterial(), this.mainTexture);
                }

                var assignAtCanvasRenderer = (Bridge.staticEquals(this.assignMeshOverrideSingle, null) || !this.disableMeshAssignmentOnOverride);
                if (assignAtCanvasRenderer) {
                    this.canvasRenderer.SetMesh(mesh);
                } else {
                    this.canvasRenderer.SetMesh(null);
                }

                var assignTexture = false;
                if (currentInstructions.submeshInstructions.Count > 0) {
                    var material = ($t1 = currentInstructions.submeshInstructions.Items)[0].material;
                    if (material != null && !Bridge.referenceEquals(this.baseTexture, material.mainTexture)) {
                        this.baseTexture = material.mainTexture;
                        if (this.overrideTexture == null && assignAtCanvasRenderer) {
                            assignTexture = true;
                        }
                    }
                }

                if (UnityEngine.Application.isPlaying) {
                    this.HandleOnDemandLoading();
                }
                if (assignTexture) {
                    this.canvasRenderer.SetTexture(this.mainTexture);
                }
            },
            /*Spine.Unity.SkeletonGraphic.UpdateMeshSingleCanvasRenderer end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateMaterialsMultipleCanvasRenderers start.*/
            UpdateMaterialsMultipleCanvasRenderers: function (currentInstructions) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateMaterialsMultipleCanvasRenderers", this ); }

                var $t;
                var submeshCount = currentInstructions.submeshInstructions.Count;
                var useOriginalTextureAndMaterial = (this.customMaterialOverride.Count === 0 && this.customTextureOverride.Count === 0);

                var blendModeMaterials = this.skeletonDataAsset.blendModeMaterials;
                var hasBlendModeMaterials = blendModeMaterials.RequiresBlendModeMaterials;

                var pmaVertexColors = this.meshGenerator.settings.pmaVertexColors;
                var usedMaterialItems = this.usedMaterials.Items;
                var usedTextureItems = this.usedTextures.Items;
                for (var i = 0; i < submeshCount; i = (i + 1) | 0) {
                    var submeshInstructionItem = ($t = currentInstructions.submeshInstructions.Items)[i].$clone();
                    var submeshMaterial = submeshInstructionItem.material;
                    if (useOriginalTextureAndMaterial) {
                        if (submeshMaterial == null) {
                            usedMaterialItems[i] = null;
                            usedTextureItems[i] = null;
                            continue;
                        }
                        usedTextureItems[i] = submeshMaterial.mainTexture;
                        if (!hasBlendModeMaterials) {
                            usedMaterialItems[i] = this.materialForRendering;
                        } else {
                            var blendMode = blendModeMaterials.BlendModeForMaterial(submeshMaterial);
                            var usedMaterial = this.materialForRendering;
                            if (blendMode === Spine.BlendMode.Additive && !pmaVertexColors && UnityEngine.Object.op_Implicit(this.additiveMaterial)) {
                                usedMaterial = this.additiveMaterial;
                            } else if (blendMode === Spine.BlendMode.Multiply && UnityEngine.Object.op_Implicit(this.multiplyMaterial)) {
                                usedMaterial = this.multiplyMaterial;
                            } else {
                                if (blendMode === Spine.BlendMode.Screen && UnityEngine.Object.op_Implicit(this.screenMaterial)) {
                                    usedMaterial = this.screenMaterial;
                                }
                            }
                            usedMaterialItems[i] = this.submeshGraphics.getItem(i).GetModifiedMaterial(usedMaterial);
                        }
                    } else {
                        var originalTexture = submeshMaterial.mainTexture;
                        var usedMaterial1 = { };
                        var usedTexture = { };
                        if (!this.customMaterialOverride.tryGetValue(originalTexture, usedMaterial1)) {
                            usedMaterial1.v = this.material;
                        }
                        if (!this.customTextureOverride.tryGetValue(originalTexture, usedTexture)) {
                            usedTexture.v = originalTexture;
                        }

                        usedMaterialItems[i] = this.submeshGraphics.getItem(i).GetModifiedMaterial(usedMaterial1.v);
                        usedTextureItems[i] = usedTexture.v;
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphic.UpdateMaterialsMultipleCanvasRenderers end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateMeshMultipleCanvasRenderers start.*/
            UpdateMeshMultipleCanvasRenderers: function (currentInstructions) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateMeshMultipleCanvasRenderers", this ); }

                var $t;
                this.meshScale = (UnityEngine.Component.op_Equality(this.canvas, null)) ? 100 : this.canvas.referencePixelsPerUnit;
                if (this.layoutScaleMode !== Spine.Unity.SkeletonGraphic.LayoutMode.None) {
                    this.meshScale *= this.referenceScale;
                    this.layoutScale = this.GetLayoutScale(this.layoutScaleMode);
                    if (true) {
                        this.meshScale *= this.layoutScale;
                    }
                    this.meshOffset = this.pivotOffset.$clone().scale( this.layoutScale );
                } else {
                    this.meshOffset = this.pivotOffset.$clone();
                }
                // Generate meshes.
                var submeshCount = currentInstructions.submeshInstructions.Count;
                var meshesItems = this.meshes.Items;
                var useOriginalTextureAndMaterial = (this.customMaterialOverride.Count === 0 && this.customTextureOverride.Count === 0);

                var blendModeMaterials = this.skeletonDataAsset.blendModeMaterials;
                var hasBlendModeMaterials = blendModeMaterials.RequiresBlendModeMaterials;
                var mainCullTransparentMesh = this.canvasRenderer.cullTransparentMesh;
                var pmaVertexColors = this.meshGenerator.settings.pmaVertexColors;
                var usedMaterialItems = this.usedMaterials.Items;
                var usedTextureItems = this.usedTextures.Items;
                for (var i = 0; i < submeshCount; i = (i + 1) | 0) {
                    var submeshInstructionItem = ($t = currentInstructions.submeshInstructions.Items)[i].$clone();
                    this.meshGenerator.Begin();
                    this.meshGenerator.AddSubmesh(submeshInstructionItem);

                    var targetMesh = meshesItems[i];
                    if (pc.Vec2.equals( this.meshOffset, pc.Vec2.ZERO.clone() )) {
                        this.meshGenerator.ScaleVertexData(this.meshScale);
                    } else {
                        this.meshGenerator.ScaleAndOffsetVertexData(this.meshScale, this.meshOffset);
                    }
                    if (!Bridge.staticEquals(this.OnPostProcessVertices, null)) {
                        this.OnPostProcessVertices(this.meshGenerator.Buffers.$clone());
                    }
                    this.meshGenerator.FillVertexData(targetMesh);
                    this.meshGenerator.FillTriangles(targetMesh);
                    this.meshGenerator.FillLateVertexData(targetMesh);

                    var canvasRenderer = this.canvasRenderers.getItem(i);
                    if (Bridge.staticEquals(this.assignMeshOverrideSingle, null) || !this.disableMeshAssignmentOnOverride) {
                        canvasRenderer.SetMesh(targetMesh);
                    } else {
                        canvasRenderer.SetMesh(null);
                    }

                    var submeshGraphic = this.submeshGraphics.getItem(i);
                    if (useOriginalTextureAndMaterial && hasBlendModeMaterials) {
                        var allowCullTransparentMesh = true;
                        var materialBlendMode = blendModeMaterials.BlendModeForMaterial(usedMaterialItems[i]);
                        if ((materialBlendMode === Spine.BlendMode.Normal && submeshInstructionItem.hasPMAAdditiveSlot) || (materialBlendMode === Spine.BlendMode.Additive && pmaVertexColors)) {
                            allowCullTransparentMesh = false;
                        }
                        canvasRenderer.cullTransparentMesh = allowCullTransparentMesh ? mainCullTransparentMesh : false;
                    }
                    canvasRenderer.materialCount = 1;
                }

                if (UnityEngine.Application.isPlaying) {
                    this.HandleOnDemandLoading();
                }
                var assignAtCanvasRenderer = (Bridge.staticEquals(this.assignMeshOverrideSingle, null) || !this.disableMeshAssignmentOnOverride);
                if (assignAtCanvasRenderer) {
                    for (var i1 = 0; i1 < submeshCount; i1 = (i1 + 1) | 0) {
                        var canvasRenderer1 = this.canvasRenderers.getItem(i1);
                        canvasRenderer1.SetMaterial$1(usedMaterialItems[i1], usedTextureItems[i1]);
                    }
                }

                if (!Bridge.staticEquals(this.assignMeshOverrideMultiple, null)) {
                    this.assignMeshOverrideMultiple(submeshCount, meshesItems, usedMaterialItems, usedTextureItems);
                }
            },
            /*Spine.Unity.SkeletonGraphic.UpdateMeshMultipleCanvasRenderers end.*/

            /*Spine.Unity.SkeletonGraphic.HandleOnDemandLoading start.*/
            HandleOnDemandLoading: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#HandleOnDemandLoading", this ); }

                var $t, $t1;
                $t = Bridge.getEnumerator(this.skeletonDataAsset.atlasAssets);
                try {
                    while ($t.moveNext()) {
                        var atlasAsset = $t.Current;
                        if (atlasAsset.TextureLoadingMode !== Spine.Unity.AtlasAssetBase.LoadingMode.Normal) {
                            atlasAsset.BeginCustomTextureLoading();

                            if (!this.allowMultipleCanvasRenderers) {
                                var loadedTexture = { v : null };
                                atlasAsset.RequireTextureLoaded(this.mainTexture, loadedTexture, null);
                                if (UnityEngine.Object.op_Implicit(loadedTexture.v)) {
                                    this.baseTexture = loadedTexture.v;
                                }
                            } else {
                                var textureItems = this.usedTextures.Items;
                                for (var i = 0, count = this.usedTextures.Count; i < count; i = (i + 1) | 0) {
                                    var loadedTexture1 = { v : null };
                                    atlasAsset.RequireTextureLoaded(textureItems[i], loadedTexture1, null);
                                    if (UnityEngine.Object.op_Implicit(loadedTexture1.v)) {
                                        ($t1 = this.usedTextures.Items)[i] = loadedTexture1.v;
                                    }
                                }
                            }
                            atlasAsset.EndCustomTextureLoading();
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphic.HandleOnDemandLoading end.*/

            /*Spine.Unity.SkeletonGraphic.EnsureCanvasRendererCount start.*/
            EnsureCanvasRendererCount: function (targetCount) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#EnsureCanvasRendererCount", this ); }

                var currentCount = this.canvasRenderers.Count;
                for (var i = currentCount; i < targetCount; i = (i + 1) | 0) {
                    var go = new UnityEngine.GameObject.$ctor3(System.String.format("Renderer{0}", [Bridge.box(i, System.Int32)]), UnityEngine.RectTransform);
                    go.transform.SetParent(this.transform, false);
                    go.transform.localPosition = pc.Vec3.ZERO.clone();
                    var canvasRenderer = go.AddComponent(UnityEngine.CanvasRenderer);
                    this.canvasRenderers.add(canvasRenderer);
                    var submeshGraphic = go.AddComponent(Spine.Unity.SkeletonSubmeshGraphic);
                    submeshGraphic.maskable = this.maskable;
                    submeshGraphic.raycastTarget = false;
                    submeshGraphic.rectTransform.pivot = this.rectTransform.pivot.$clone();
                    submeshGraphic.rectTransform.anchorMin = pc.Vec2.ZERO.clone();
                    submeshGraphic.rectTransform.anchorMax = pc.Vec2.ONE.clone();
                    submeshGraphic.rectTransform.sizeDelta = pc.Vec2.ZERO.clone();
                    this.submeshGraphics.add(submeshGraphic);
                }
            },
            /*Spine.Unity.SkeletonGraphic.EnsureCanvasRendererCount end.*/

            /*Spine.Unity.SkeletonGraphic.PrepareRendererGameObjects start.*/
            PrepareRendererGameObjects: function (currentInstructions, isInRebuild) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#PrepareRendererGameObjects", this ); }

                var $t;
                if (isInRebuild === void 0) { isInRebuild = false; }

                var submeshCount = currentInstructions.submeshInstructions.Count;
                this.DisableUnusedCanvasRenderers(submeshCount, isInRebuild);

                var parent = this.separatorParts.Count === 0 ? this.transform : this.separatorParts.getItem(0);
                if (this.updateSeparatorPartLocation) {
                    for (var p = 0; p < this.separatorParts.Count; p = (p + 1) | 0) {
                        var separatorPart = this.separatorParts.getItem(p);
                        if (UnityEngine.Component.op_Equality(separatorPart, null)) {
                            continue;
                        }
                        separatorPart.position = this.transform.position.$clone();
                        separatorPart.rotation = this.transform.rotation.$clone();
                    }
                }
                if (this.updateSeparatorPartScale) {
                    var targetScale = this.transform.lossyScale.$clone();
                    for (var p1 = 0; p1 < this.separatorParts.Count; p1 = (p1 + 1) | 0) {
                        var separatorPart1 = this.separatorParts.getItem(p1);
                        if (UnityEngine.Component.op_Equality(separatorPart1, null)) {
                            continue;
                        }
                        var partParent = separatorPart1.parent;
                        var parentScale = UnityEngine.Component.op_Equality(partParent, null) ? new pc.Vec3( 1, 1, 1 ) : partParent.lossyScale.$clone();
                        separatorPart1.localScale = new pc.Vec3( parentScale.x === 0.0 ? 1.0 : targetScale.x / parentScale.x, parentScale.y === 0.0 ? 1.0 : targetScale.y / parentScale.y, parentScale.z === 0.0 ? 1.0 : targetScale.z / parentScale.z );
                    }
                }

                var separatorSlotGroupIndex = 0;
                var targetSiblingIndex = 0;
                for (var i = 0; i < submeshCount; i = (i + 1) | 0) {
                    var canvasRenderer = this.canvasRenderers.getItem(i);
                    if (UnityEngine.Component.op_Inequality(canvasRenderer, null)) {
                        if (i >= this.usedRenderersCount) {
                            canvasRenderer.gameObject.SetActive(true);
                        }

                        if (UnityEngine.Component.op_Inequality(canvasRenderer.transform.parent, parent.transform) && !isInRebuild) {
                            canvasRenderer.transform.SetParent(parent.transform, false);
                        }

                        canvasRenderer.transform.SetSiblingIndex(Bridge.identity(targetSiblingIndex, ((targetSiblingIndex = (targetSiblingIndex + 1) | 0))));
                    }

                    var submeshGraphic = this.submeshGraphics.getItem(i);
                    if (UnityEngine.MonoBehaviour.op_Inequality(submeshGraphic, null)) {
                        var dstTransform = submeshGraphic.rectTransform;
                        dstTransform.localPosition = pc.Vec3.ZERO.clone();
                        dstTransform.pivot = this.rectTransform.pivot.$clone();
                        dstTransform.anchorMin = pc.Vec2.ZERO.clone();
                        dstTransform.anchorMax = pc.Vec2.ONE.clone();
                        dstTransform.sizeDelta = pc.Vec2.ZERO.clone();
                    }

                    var submeshInstructionItem = ($t = currentInstructions.submeshInstructions.Items)[i].$clone();
                    if (submeshInstructionItem.forceSeparate) {
                        targetSiblingIndex = 0;
                        parent = this.separatorParts.getItem(((separatorSlotGroupIndex = (separatorSlotGroupIndex + 1) | 0)));
                    }
                }
                this.usedRenderersCount = submeshCount;
            },
            /*Spine.Unity.SkeletonGraphic.PrepareRendererGameObjects end.*/

            /*Spine.Unity.SkeletonGraphic.DisableUnusedCanvasRenderers start.*/
            DisableUnusedCanvasRenderers: function (usedCount, isInRebuild) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#DisableUnusedCanvasRenderers", this ); }

                if (isInRebuild === void 0) { isInRebuild = false; }
                for (var i = usedCount; i < this.canvasRenderers.Count; i = (i + 1) | 0) {
                    this.canvasRenderers.getItem(i).Clear();
                    if (!isInRebuild) {
                        this.canvasRenderers.getItem(i).gameObject.SetActive(false);
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphic.DisableUnusedCanvasRenderers end.*/

            /*Spine.Unity.SkeletonGraphic.EnsureMeshesCount start.*/
            EnsureMeshesCount: function (targetCount) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#EnsureMeshesCount", this ); }

                var oldCount = this.meshes.Count;
                this.meshes.EnsureCapacity(targetCount);
                for (var i = oldCount; i < targetCount; i = (i + 1) | 0) {
                    this.meshes.Add(Spine.Unity.SpineMesh.NewSkeletonMesh());
                }
            },
            /*Spine.Unity.SkeletonGraphic.EnsureMeshesCount end.*/

            /*Spine.Unity.SkeletonGraphic.EnsureUsedTexturesAndMaterialsCount start.*/
            EnsureUsedTexturesAndMaterialsCount: function (targetCount) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#EnsureUsedTexturesAndMaterialsCount", this ); }

                var oldCount = this.usedMaterials.Count;
                this.usedMaterials.EnsureCapacity(targetCount);
                this.usedTextures.EnsureCapacity(targetCount);
                for (var i = oldCount; i < targetCount; i = (i + 1) | 0) {
                    this.usedMaterials.Add(null);
                    this.usedTextures.Add(null);
                }
            },
            /*Spine.Unity.SkeletonGraphic.EnsureUsedTexturesAndMaterialsCount end.*/

            /*Spine.Unity.SkeletonGraphic.DestroyMeshes start.*/
            DestroyMeshes: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#DestroyMeshes", this ); }

                var $t;
                $t = Bridge.getEnumerator(this.meshes);
                try {
                    while ($t.moveNext()) {
                        var mesh = $t.Current;
                        UnityEngine.Object.Destroy(mesh);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                this.meshes.Clear();
            },
            /*Spine.Unity.SkeletonGraphic.DestroyMeshes end.*/

            /*Spine.Unity.SkeletonGraphic.EnsureSeparatorPartCount start.*/
            EnsureSeparatorPartCount: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#EnsureSeparatorPartCount", this ); }

                var targetCount = (this.separatorSlots.Count + 1) | 0;
                if (targetCount === 1) {
                    return;
                }

                var currentCount = this.separatorParts.Count;
                for (var i = currentCount; i < targetCount; i = (i + 1) | 0) {
                    var go = new UnityEngine.GameObject.$ctor3(System.String.format("{0}[{1}]", Spine.Unity.SkeletonGraphic.SeparatorPartGameObjectName, Bridge.box(i, System.Int32)), UnityEngine.RectTransform);
                    go.transform.SetParent(this.transform, false);

                    var dstTransform = go.transform.GetComponent(UnityEngine.RectTransform);
                    dstTransform.localPosition = pc.Vec3.ZERO.clone();
                    dstTransform.pivot = this.rectTransform.pivot.$clone();
                    dstTransform.anchorMin = pc.Vec2.ZERO.clone();
                    dstTransform.anchorMax = pc.Vec2.ONE.clone();
                    dstTransform.sizeDelta = pc.Vec2.ZERO.clone();

                    this.separatorParts.add(go.transform);
                }
            },
            /*Spine.Unity.SkeletonGraphic.EnsureSeparatorPartCount end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateSeparatorPartParents start.*/
            UpdateSeparatorPartParents: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateSeparatorPartParents", this ); }

                var usedCount = (this.separatorSlots.Count + 1) | 0;
                if (usedCount === 1) {
                    usedCount = 0; // placed directly at the SkeletonGraphic parent
                    for (var i = 0; i < this.canvasRenderers.Count; i = (i + 1) | 0) {
                        var canvasRenderer = this.canvasRenderers.getItem(i);
                        if (System.String.contains(canvasRenderer.transform.parent.name,Spine.Unity.SkeletonGraphic.SeparatorPartGameObjectName)) {
                            canvasRenderer.transform.SetParent(this.transform, false);
                            canvasRenderer.transform.localPosition = pc.Vec3.ZERO.clone();
                        }
                    }
                }
                for (var i1 = 0; i1 < this.separatorParts.Count; i1 = (i1 + 1) | 0) {
                    var isUsed = i1 < usedCount;
                    this.separatorParts.getItem(i1).gameObject.SetActive(isUsed);
                }
            },
            /*Spine.Unity.SkeletonGraphic.UpdateSeparatorPartParents end.*/

            /*Spine.Unity.SkeletonGraphic.GetLayoutScale start.*/
            GetLayoutScale: function (mode) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#GetLayoutScale", this ); }

                var currentSize = this.GetCurrentRectSize();
                mode = this.GetEffectiveLayoutMode(mode);
                if (mode === Spine.Unity.SkeletonGraphic.LayoutMode.WidthControlsHeight) {
                    return currentSize.x / this.referenceSize.x;
                } else if (mode === Spine.Unity.SkeletonGraphic.LayoutMode.HeightControlsWidth) {
                    return currentSize.y / this.referenceSize.y;
                }
                return 1.0;
            },
            /*Spine.Unity.SkeletonGraphic.GetLayoutScale end.*/

            /*Spine.Unity.SkeletonGraphic.GetEffectiveLayoutMode start.*/
            /**
             * <pre><code>LayoutMode FitInParent</code></pre> and <pre><code>EnvelopeParent</code></pre> actually result in
             <pre><code>HeightControlsWidth</code></pre> or <pre><code>WidthControlsHeight</code></pre> depending on the actual vs reference aspect ratio.
             This method returns the respective <pre><code>LayoutMode</code></pre> of the two for any given input <pre><code>mode</code></pre>.
             *
             * @instance
             * @protected
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @param   {number}    mode
             * @return  {number}
             */
            GetEffectiveLayoutMode: function (mode) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#GetEffectiveLayoutMode", this ); }

                var currentSize = this.GetCurrentRectSize();
                var referenceAspect = this.referenceSize.x / this.referenceSize.y;
                var frameAspect = currentSize.x / currentSize.y;
                if (mode === Spine.Unity.SkeletonGraphic.LayoutMode.FitInParent) {
                    mode = frameAspect > referenceAspect ? Spine.Unity.SkeletonGraphic.LayoutMode.HeightControlsWidth : Spine.Unity.SkeletonGraphic.LayoutMode.WidthControlsHeight;
                } else {
                    if (mode === Spine.Unity.SkeletonGraphic.LayoutMode.EnvelopeParent) {
                        mode = frameAspect > referenceAspect ? Spine.Unity.SkeletonGraphic.LayoutMode.WidthControlsHeight : Spine.Unity.SkeletonGraphic.LayoutMode.HeightControlsWidth;
                    }
                }
                return mode;
            },
            /*Spine.Unity.SkeletonGraphic.GetEffectiveLayoutMode end.*/

            /*Spine.Unity.SkeletonGraphic.GetCurrentRectSize start.*/
            GetCurrentRectSize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#GetCurrentRectSize", this ); }

                return this.rectTransform.rect.size.$clone();
            },
            /*Spine.Unity.SkeletonGraphic.GetCurrentRectSize end.*/


        },
        overloads: {
            "Update(float)": "Update$1"
        }
    });
    /*Spine.Unity.SkeletonGraphic end.*/

    /*Spine.AlphaTimeline start.*/
    /**
     * Changes the alpha for a slot's {@link }.
     *
     * @public
     * @class Spine.AlphaTimeline
     * @augments Spine.CurveTimeline1
     * @implements  Spine.ISlotTimeline
     */
    Bridge.define("Spine.AlphaTimeline", {
        inherits: [Spine.CurveTimeline1,Spine.ISlotTimeline],
        fields: {
            slotIndex: 0
        },
        props: {
            SlotIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.AlphaTimeline#SlotIndex#get", this ); }

                    return this.slotIndex;
                }
            }
        },
        alias: ["SlotIndex", "Spine$ISlotTimeline$SlotIndex"],
        ctors: {
            ctor: function (frameCount, bezierCount, slotIndex) {
if ( TRACE ) { TRACE( "Spine.AlphaTimeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline1.ctor.call(this, frameCount, bezierCount, Spine.Property.Alpha + "|" + slotIndex);
                this.slotIndex = slotIndex;
            }
        },
        methods: {
            /*Spine.AlphaTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.AlphaTimeline#Apply", this ); }

                var $t;
                var slot = ($t = skeleton.slots.Items)[this.slotIndex];
                if (!slot.bone.active) {
                    return;
                }

                var frames = this.frames;
                if (time < frames[0]) {
                    var setup = slot.data;
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            slot.a = setup.a;
                            return;
                        case Spine.MixBlend.First: 
                            slot.a += (setup.a - slot.a) * alpha;
                            slot.ClampColor();
                            return;
                    }
                    return;
                }

                var a = this.GetCurveValue(time);
                if (alpha === 1) {
                    slot.a = a;
                } else {
                    if (blend === Spine.MixBlend.Setup) {
                        slot.a = slot.data.a;
                    }
                    slot.a += (a - slot.a) * alpha;
                }
                slot.ClampColor();
            },
            /*Spine.AlphaTimeline.Apply end.*/


        }
    });
    /*Spine.AlphaTimeline end.*/

    /*Spine.PathConstraintPositionTimeline start.*/
    /**
     * Changes a path constraint's {@link }.
     *
     * @public
     * @class Spine.PathConstraintPositionTimeline
     * @augments Spine.CurveTimeline1
     */
    Bridge.define("Spine.PathConstraintPositionTimeline", {
        inherits: [Spine.CurveTimeline1],
        fields: {
            constraintIndex: 0
        },
        props: {
            /**
             * The index of the path constraint slot in {@link } that will be changed when this timeline
             is applied.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.PathConstraintPositionTimeline
             * @function PathConstraintIndex
             * @type number
             */
            PathConstraintIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintPositionTimeline#PathConstraintIndex#get", this ); }

                    return this.constraintIndex;
                }
            }
        },
        ctors: {
            ctor: function (frameCount, bezierCount, pathConstraintIndex) {
if ( TRACE ) { TRACE( "Spine.PathConstraintPositionTimeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline1.ctor.call(this, frameCount, bezierCount, Spine.Property.PathConstraintPosition + "|" + pathConstraintIndex);
                this.constraintIndex = pathConstraintIndex;
            }
        },
        methods: {
            /*Spine.PathConstraintPositionTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.PathConstraintPositionTimeline#Apply", this ); }

                var $t;
                var constraint = ($t = skeleton.pathConstraints.Items)[this.constraintIndex];
                if (constraint.active) {
                    constraint.position = this.GetAbsoluteValue(time, alpha, blend, constraint.position, constraint.data.position);
                }
            },
            /*Spine.PathConstraintPositionTimeline.Apply end.*/


        }
    });
    /*Spine.PathConstraintPositionTimeline end.*/

    /*Spine.PathConstraintSpacingTimeline start.*/
    /**
     * Changes a path constraint's {@link }.
     *
     * @public
     * @class Spine.PathConstraintSpacingTimeline
     * @augments Spine.CurveTimeline1
     */
    Bridge.define("Spine.PathConstraintSpacingTimeline", {
        inherits: [Spine.CurveTimeline1],
        fields: {
            constraintIndex: 0
        },
        props: {
            /**
             * The index of the path constraint in {@link } that will be changed when this timeline
             is applied.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.PathConstraintSpacingTimeline
             * @function PathConstraintIndex
             * @type number
             */
            PathConstraintIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintSpacingTimeline#PathConstraintIndex#get", this ); }

                    return this.constraintIndex;
                }
            }
        },
        ctors: {
            ctor: function (frameCount, bezierCount, pathConstraintIndex) {
if ( TRACE ) { TRACE( "Spine.PathConstraintSpacingTimeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline1.ctor.call(this, frameCount, bezierCount, Spine.Property.PathConstraintSpacing + "|" + pathConstraintIndex);
                this.constraintIndex = pathConstraintIndex;
            }
        },
        methods: {
            /*Spine.PathConstraintSpacingTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, events, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.PathConstraintSpacingTimeline#Apply", this ); }

                var $t;

                var constraint = ($t = skeleton.pathConstraints.Items)[this.constraintIndex];
                if (constraint.active) {
                    constraint.spacing = this.GetAbsoluteValue(time, alpha, blend, constraint.spacing, constraint.data.spacing);
                }
            },
            /*Spine.PathConstraintSpacingTimeline.Apply end.*/


        }
    });
    /*Spine.PathConstraintSpacingTimeline end.*/

    /*Spine.PhysicsConstraintTimeline start.*/
    /**
     * The base class for most {@link } timelines.
     *
     * @abstract
     * @public
     * @class Spine.PhysicsConstraintTimeline
     * @augments Spine.CurveTimeline1
     */
    Bridge.define("Spine.PhysicsConstraintTimeline", {
        inherits: [Spine.CurveTimeline1],
        fields: {
            constraintIndex: 0
        },
        props: {
            /**
             * The index of the physics constraint in {@link } that will be changed when this timeline
             is applied, or -1 if all physics constraints in the skeleton will be changed.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.PhysicsConstraintTimeline
             * @function PhysicsConstraintIndex
             * @type number
             */
            PhysicsConstraintIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintTimeline#PhysicsConstraintIndex#get", this ); }

                    return this.constraintIndex;
                }
            }
        },
        ctors: {
            /**
             * @instance
             * @public
             * @this Spine.PhysicsConstraintTimeline
             * @memberof Spine.PhysicsConstraintTimeline
             * @param   {number}            frameCount                
             * @param   {number}            bezierCount               
             * @param   {number}            physicsConstraintIndex    -1 for all physics constraints in the skeleton.
             * @param   {Spine.Property}    property
             * @return  {void}
             */
            ctor: function (frameCount, bezierCount, physicsConstraintIndex, property) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintTimeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline1.ctor.call(this, frameCount, bezierCount, property + "|" + physicsConstraintIndex);

                this.constraintIndex = physicsConstraintIndex;
            }
        },
        methods: {
            /*Spine.PhysicsConstraintTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintTimeline#Apply", this ); }

                var $t;
                var constraint;
                if (this.constraintIndex === -1) {
                    var value = time >= this.frames[0] ? this.GetCurveValue(time) : 0;

                    var constraints = skeleton.physicsConstraints.Items;
                    for (var i = 0, n = skeleton.physicsConstraints.Count; i < n; i = (i + 1) | 0) {
                        constraint = constraints[i];
                        if (constraint.active && this.Global(constraint.data)) {
                            this.Set(constraint, this.GetAbsoluteValue$1(time, alpha, blend, this.Get(constraint), this.Setup(constraint), value));
                        }
                    }
                } else {
                    constraint = ($t = skeleton.physicsConstraints.Items)[this.constraintIndex];
                    if (constraint.active) {
                        this.Set(constraint, this.GetAbsoluteValue(time, alpha, blend, this.Get(constraint), this.Setup(constraint)));
                    }
                }
            },
            /*Spine.PhysicsConstraintTimeline.Apply end.*/


        }
    });
    /*Spine.PhysicsConstraintTimeline end.*/

    /*Spine.RotateTimeline start.*/
    /**
     * Changes a bone's local {@link }.
     *
     * @public
     * @class Spine.RotateTimeline
     * @augments Spine.CurveTimeline1
     * @implements  Spine.IBoneTimeline
     */
    Bridge.define("Spine.RotateTimeline", {
        inherits: [Spine.CurveTimeline1,Spine.IBoneTimeline],
        fields: {
            boneIndex: 0
        },
        props: {
            BoneIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RotateTimeline#BoneIndex#get", this ); }

                    return this.boneIndex;
                }
            }
        },
        alias: ["BoneIndex", "Spine$IBoneTimeline$BoneIndex"],
        ctors: {
            ctor: function (frameCount, bezierCount, boneIndex) {
if ( TRACE ) { TRACE( "Spine.RotateTimeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline1.ctor.call(this, frameCount, bezierCount, Spine.Property.Rotate + "|" + boneIndex);
                this.boneIndex = boneIndex;
            }
        },
        methods: {
            /*Spine.RotateTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.RotateTimeline#Apply", this ); }

                var $t;
                var bone = ($t = skeleton.bones.Items)[this.boneIndex];
                if (bone.active) {
                    bone.rotation = this.GetRelativeValue(time, alpha, blend, bone.rotation, bone.data.rotation);
                }
            },
            /*Spine.RotateTimeline.Apply end.*/


        }
    });
    /*Spine.RotateTimeline end.*/

    /*Spine.ScaleTimeline start.*/
    
    Bridge.define("Spine.ScaleTimeline", {
        inherits: [Spine.CurveTimeline2,Spine.IBoneTimeline],
        fields: {
            boneIndex: 0
        },
        props: {
            BoneIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.ScaleTimeline#BoneIndex#get", this ); }

                    return this.boneIndex;
                }
            }
        },
        alias: ["BoneIndex", "Spine$IBoneTimeline$BoneIndex"],
        ctors: {
            ctor: function (frameCount, bezierCount, boneIndex) {
if ( TRACE ) { TRACE( "Spine.ScaleTimeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline2.ctor.call(this, frameCount, bezierCount, Spine.Property.ScaleX + "|" + boneIndex, Spine.Property.ScaleY + "|" + boneIndex);
                this.boneIndex = boneIndex;
            }
        },
        methods: {
            /*Spine.ScaleTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.ScaleTimeline#Apply", this ); }

                var $t;
                var bone = ($t = skeleton.bones.Items)[this.boneIndex];
                if (!bone.active) {
                    return;
                }

                var frames = this.frames;
                if (time < frames[0]) {
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            bone.scaleX = bone.data.scaleX;
                            bone.scaleY = bone.data.scaleY;
                            return;
                        case Spine.MixBlend.First: 
                            bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;
                            bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;
                            return;
                    }
                    return;
                }

                var x, y;
                var i = Spine.Timeline.Search$1(frames, time, Spine.CurveTimeline2.ENTRIES), curveType = Bridge.Int.clip32(this.curves[((Bridge.Int.div(i, Spine.CurveTimeline2.ENTRIES)) | 0)]);
                switch (curveType) {
                    case Spine.CurveTimeline.LINEAR: 
                        var before = frames[i];
                        x = frames[((i + Spine.CurveTimeline2.VALUE1) | 0)];
                        y = frames[((i + Spine.CurveTimeline2.VALUE2) | 0)];
                        var t = (time - before) / (frames[((i + Spine.CurveTimeline2.ENTRIES) | 0)] - before);
                        x += (frames[((((i + Spine.CurveTimeline2.ENTRIES) | 0) + Spine.CurveTimeline2.VALUE1) | 0)] - x) * t;
                        y += (frames[((((i + Spine.CurveTimeline2.ENTRIES) | 0) + Spine.CurveTimeline2.VALUE2) | 0)] - y) * t;
                        break;
                    case Spine.CurveTimeline.STEPPED: 
                        x = frames[((i + Spine.CurveTimeline2.VALUE1) | 0)];
                        y = frames[((i + Spine.CurveTimeline2.VALUE2) | 0)];
                        break;
                    default: 
                        x = this.GetBezierValue(time, i, Spine.CurveTimeline2.VALUE1, ((curveType - Spine.CurveTimeline.BEZIER) | 0));
                        y = this.GetBezierValue(time, i, Spine.CurveTimeline2.VALUE2, ((((curveType + Spine.CurveTimeline.BEZIER_SIZE) | 0) - Spine.CurveTimeline.BEZIER) | 0));
                        break;
                }
                x *= bone.data.scaleX;
                y *= bone.data.scaleY;

                if (alpha === 1) {
                    if (blend === Spine.MixBlend.Add) {
                        bone.scaleX += x - bone.data.scaleX;
                        bone.scaleY += y - bone.data.scaleY;
                    } else {
                        bone.scaleX = x;
                        bone.scaleY = y;
                    }
                } else {
                    // Mixing out uses sign of setup or current pose, else use sign of key.
                    var bx, by;
                    if (direction === Spine.MixDirection.Out) {
                        switch (blend) {
                            case Spine.MixBlend.Setup: 
                                bx = bone.data.scaleX;
                                by = bone.data.scaleY;
                                bone.scaleX = bx + (Math.abs(x) * Bridge.Int.sign(bx) - bx) * alpha;
                                bone.scaleY = by + (Math.abs(y) * Bridge.Int.sign(by) - by) * alpha;
                                break;
                            case Spine.MixBlend.First: 
                            case Spine.MixBlend.Replace: 
                                bx = bone.scaleX;
                                by = bone.scaleY;
                                bone.scaleX = bx + (Math.abs(x) * Bridge.Int.sign(bx) - bx) * alpha;
                                bone.scaleY = by + (Math.abs(y) * Bridge.Int.sign(by) - by) * alpha;
                                break;
                            case Spine.MixBlend.Add: 
                                bone.scaleX += (x - bone.data.scaleX) * alpha;
                                bone.scaleY += (y - bone.data.scaleY) * alpha;
                                break;
                        }
                    } else {
                        switch (blend) {
                            case Spine.MixBlend.Setup: 
                                bx = Math.abs(bone.data.scaleX) * Bridge.Int.sign(x);
                                by = Math.abs(bone.data.scaleY) * Bridge.Int.sign(y);
                                bone.scaleX = bx + (x - bx) * alpha;
                                bone.scaleY = by + (y - by) * alpha;
                                break;
                            case Spine.MixBlend.First: 
                            case Spine.MixBlend.Replace: 
                                bx = Math.abs(bone.scaleX) * Bridge.Int.sign(x);
                                by = Math.abs(bone.scaleY) * Bridge.Int.sign(y);
                                bone.scaleX = bx + (x - bx) * alpha;
                                bone.scaleY = by + (y - by) * alpha;
                                break;
                            case Spine.MixBlend.Add: 
                                bone.scaleX += (x - bone.data.scaleX) * alpha;
                                bone.scaleY += (y - bone.data.scaleY) * alpha;
                                break;
                        }
                    }
                }
            },
            /*Spine.ScaleTimeline.Apply end.*/


        }
    });
    /*Spine.ScaleTimeline end.*/

    /*Spine.ScaleXTimeline start.*/
    
    Bridge.define("Spine.ScaleXTimeline", {
        inherits: [Spine.CurveTimeline1,Spine.IBoneTimeline],
        fields: {
            boneIndex: 0
        },
        props: {
            BoneIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.ScaleXTimeline#BoneIndex#get", this ); }

                    return this.boneIndex;
                }
            }
        },
        alias: ["BoneIndex", "Spine$IBoneTimeline$BoneIndex"],
        ctors: {
            ctor: function (frameCount, bezierCount, boneIndex) {
if ( TRACE ) { TRACE( "Spine.ScaleXTimeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline1.ctor.call(this, frameCount, bezierCount, Spine.Property.ScaleX + "|" + boneIndex);
                this.boneIndex = boneIndex;
            }
        },
        methods: {
            /*Spine.ScaleXTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.ScaleXTimeline#Apply", this ); }

                var $t;
                var bone = ($t = skeleton.bones.Items)[this.boneIndex];
                if (bone.active) {
                    bone.scaleX = this.GetScaleValue(time, alpha, blend, direction, bone.scaleX, bone.data.scaleX);
                }
            },
            /*Spine.ScaleXTimeline.Apply end.*/


        }
    });
    /*Spine.ScaleXTimeline end.*/

    /*Spine.ScaleYTimeline start.*/
    
    Bridge.define("Spine.ScaleYTimeline", {
        inherits: [Spine.CurveTimeline1,Spine.IBoneTimeline],
        fields: {
            boneIndex: 0
        },
        props: {
            BoneIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.ScaleYTimeline#BoneIndex#get", this ); }

                    return this.boneIndex;
                }
            }
        },
        alias: ["BoneIndex", "Spine$IBoneTimeline$BoneIndex"],
        ctors: {
            ctor: function (frameCount, bezierCount, boneIndex) {
if ( TRACE ) { TRACE( "Spine.ScaleYTimeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline1.ctor.call(this, frameCount, bezierCount, Spine.Property.ScaleY + "|" + boneIndex);
                this.boneIndex = boneIndex;
            }
        },
        methods: {
            /*Spine.ScaleYTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.ScaleYTimeline#Apply", this ); }

                var $t;
                var bone = ($t = skeleton.bones.Items)[this.boneIndex];
                if (bone.active) {
                    bone.scaleY = this.GetScaleValue(time, alpha, blend, direction, bone.scaleY, bone.data.scaleY);
                }
            },
            /*Spine.ScaleYTimeline.Apply end.*/


        }
    });
    /*Spine.ScaleYTimeline end.*/

    /*Spine.ShearTimeline start.*/
    /**
     * Changes a bone's local {@link } and {@link }.
     *
     * @public
     * @class Spine.ShearTimeline
     * @augments Spine.CurveTimeline2
     * @implements  Spine.IBoneTimeline
     */
    Bridge.define("Spine.ShearTimeline", {
        inherits: [Spine.CurveTimeline2,Spine.IBoneTimeline],
        fields: {
            boneIndex: 0
        },
        props: {
            BoneIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.ShearTimeline#BoneIndex#get", this ); }

                    return this.boneIndex;
                }
            }
        },
        alias: ["BoneIndex", "Spine$IBoneTimeline$BoneIndex"],
        ctors: {
            ctor: function (frameCount, bezierCount, boneIndex) {
if ( TRACE ) { TRACE( "Spine.ShearTimeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline2.ctor.call(this, frameCount, bezierCount, Spine.Property.ShearX + "|" + boneIndex, Spine.Property.ShearY + "|" + boneIndex);
                this.boneIndex = boneIndex;
            }
        },
        methods: {
            /*Spine.ShearTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.ShearTimeline#Apply", this ); }

                var $t;
                var bone = ($t = skeleton.bones.Items)[this.boneIndex];
                if (!bone.active) {
                    return;
                }

                var frames = this.frames;
                if (time < frames[0]) { // Time is before first frame.
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            bone.shearX = bone.data.shearX;
                            bone.shearY = bone.data.shearY;
                            return;
                        case Spine.MixBlend.First: 
                            bone.shearX += (bone.data.shearX - bone.shearX) * alpha;
                            bone.shearY += (bone.data.shearY - bone.shearY) * alpha;
                            return;
                    }
                    return;
                }

                var x, y;
                var i = Spine.Timeline.Search$1(frames, time, Spine.CurveTimeline2.ENTRIES), curveType = Bridge.Int.clip32(this.curves[((Bridge.Int.div(i, Spine.CurveTimeline2.ENTRIES)) | 0)]);
                switch (curveType) {
                    case Spine.CurveTimeline.LINEAR: 
                        var before = frames[i];
                        x = frames[((i + Spine.CurveTimeline2.VALUE1) | 0)];
                        y = frames[((i + Spine.CurveTimeline2.VALUE2) | 0)];
                        var t = (time - before) / (frames[((i + Spine.CurveTimeline2.ENTRIES) | 0)] - before);
                        x += (frames[((((i + Spine.CurveTimeline2.ENTRIES) | 0) + Spine.CurveTimeline2.VALUE1) | 0)] - x) * t;
                        y += (frames[((((i + Spine.CurveTimeline2.ENTRIES) | 0) + Spine.CurveTimeline2.VALUE2) | 0)] - y) * t;
                        break;
                    case Spine.CurveTimeline.STEPPED: 
                        x = frames[((i + Spine.CurveTimeline2.VALUE1) | 0)];
                        y = frames[((i + Spine.CurveTimeline2.VALUE2) | 0)];
                        break;
                    default: 
                        x = this.GetBezierValue(time, i, Spine.CurveTimeline2.VALUE1, ((curveType - Spine.CurveTimeline.BEZIER) | 0));
                        y = this.GetBezierValue(time, i, Spine.CurveTimeline2.VALUE2, ((((curveType + Spine.CurveTimeline.BEZIER_SIZE) | 0) - Spine.CurveTimeline.BEZIER) | 0));
                        break;
                }

                switch (blend) {
                    case Spine.MixBlend.Setup: 
                        bone.shearX = bone.data.shearX + x * alpha;
                        bone.shearY = bone.data.shearY + y * alpha;
                        break;
                    case Spine.MixBlend.First: 
                    case Spine.MixBlend.Replace: 
                        bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;
                        bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;
                        break;
                    case Spine.MixBlend.Add: 
                        bone.shearX += x * alpha;
                        bone.shearY += y * alpha;
                        break;
                }
            },
            /*Spine.ShearTimeline.Apply end.*/


        }
    });
    /*Spine.ShearTimeline end.*/

    /*Spine.ShearXTimeline start.*/
    /**
     * Changes a bone's local {@link }.
     *
     * @public
     * @class Spine.ShearXTimeline
     * @augments Spine.CurveTimeline1
     * @implements  Spine.IBoneTimeline
     */
    Bridge.define("Spine.ShearXTimeline", {
        inherits: [Spine.CurveTimeline1,Spine.IBoneTimeline],
        fields: {
            boneIndex: 0
        },
        props: {
            BoneIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.ShearXTimeline#BoneIndex#get", this ); }

                    return this.boneIndex;
                }
            }
        },
        alias: ["BoneIndex", "Spine$IBoneTimeline$BoneIndex"],
        ctors: {
            ctor: function (frameCount, bezierCount, boneIndex) {
if ( TRACE ) { TRACE( "Spine.ShearXTimeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline1.ctor.call(this, frameCount, bezierCount, Spine.Property.ShearX + "|" + boneIndex);
                this.boneIndex = boneIndex;
            }
        },
        methods: {
            /*Spine.ShearXTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.ShearXTimeline#Apply", this ); }

                var $t;
                var bone = ($t = skeleton.bones.Items)[this.boneIndex];
                if (bone.active) {
                    bone.shearX = this.GetRelativeValue(time, alpha, blend, bone.shearX, bone.data.shearX);
                }
            },
            /*Spine.ShearXTimeline.Apply end.*/


        }
    });
    /*Spine.ShearXTimeline end.*/

    /*Spine.ShearYTimeline start.*/
    /**
     * Changes a bone's local {@link }.
     *
     * @public
     * @class Spine.ShearYTimeline
     * @augments Spine.CurveTimeline1
     * @implements  Spine.IBoneTimeline
     */
    Bridge.define("Spine.ShearYTimeline", {
        inherits: [Spine.CurveTimeline1,Spine.IBoneTimeline],
        fields: {
            boneIndex: 0
        },
        props: {
            BoneIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.ShearYTimeline#BoneIndex#get", this ); }

                    return this.boneIndex;
                }
            }
        },
        alias: ["BoneIndex", "Spine$IBoneTimeline$BoneIndex"],
        ctors: {
            ctor: function (frameCount, bezierCount, boneIndex) {
if ( TRACE ) { TRACE( "Spine.ShearYTimeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline1.ctor.call(this, frameCount, bezierCount, Spine.Property.ShearY + "|" + boneIndex);
                this.boneIndex = boneIndex;
            }
        },
        methods: {
            /*Spine.ShearYTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.ShearYTimeline#Apply", this ); }

                var $t;
                var bone = ($t = skeleton.bones.Items)[this.boneIndex];
                if (bone.active) {
                    bone.shearY = this.GetRelativeValue(time, alpha, blend, bone.shearY, bone.data.shearY);
                }
            },
            /*Spine.ShearYTimeline.Apply end.*/


        }
    });
    /*Spine.ShearYTimeline end.*/

    /*Spine.TranslateTimeline start.*/
    
    Bridge.define("Spine.TranslateTimeline", {
        inherits: [Spine.CurveTimeline2,Spine.IBoneTimeline],
        fields: {
            boneIndex: 0
        },
        props: {
            BoneIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TranslateTimeline#BoneIndex#get", this ); }

                    return this.boneIndex;
                }
            }
        },
        alias: ["BoneIndex", "Spine$IBoneTimeline$BoneIndex"],
        ctors: {
            ctor: function (frameCount, bezierCount, boneIndex) {
if ( TRACE ) { TRACE( "Spine.TranslateTimeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline2.ctor.call(this, frameCount, bezierCount, Spine.Property.X + "|" + boneIndex, Spine.Property.Y + "|" + boneIndex);
                this.boneIndex = boneIndex;
            }
        },
        methods: {
            /*Spine.TranslateTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.TranslateTimeline#Apply", this ); }

                var $t;
                var bone = ($t = skeleton.bones.Items)[this.boneIndex];
                if (!bone.active) {
                    return;
                }

                var frames = this.frames;
                if (time < frames[0]) {
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            bone.x = bone.data.x;
                            bone.y = bone.data.y;
                            return;
                        case Spine.MixBlend.First: 
                            bone.x += (bone.data.x - bone.x) * alpha;
                            bone.y += (bone.data.y - bone.y) * alpha;
                            return;
                    }
                    return;
                }

                var x = { }, y = { };
                this.GetCurveValue(x, y, time); // note: reference implementation has code inlined

                switch (blend) {
                    case Spine.MixBlend.Setup: 
                        bone.x = bone.data.x + x.v * alpha;
                        bone.y = bone.data.y + y.v * alpha;
                        break;
                    case Spine.MixBlend.First: 
                    case Spine.MixBlend.Replace: 
                        bone.x += (bone.data.x + x.v - bone.x) * alpha;
                        bone.y += (bone.data.y + y.v - bone.y) * alpha;
                        break;
                    case Spine.MixBlend.Add: 
                        bone.x += x.v * alpha;
                        bone.y += y.v * alpha;
                        break;
                }
            },
            /*Spine.TranslateTimeline.Apply end.*/

            /*Spine.TranslateTimeline.GetCurveValue start.*/
            GetCurveValue: function (x, y, time) {
if ( TRACE ) { TRACE( "Spine.TranslateTimeline#GetCurveValue", this ); }

                var i = Spine.Timeline.Search$1(this.frames, time, Spine.CurveTimeline2.ENTRIES), curveType = Bridge.Int.clip32(this.curves[((Bridge.Int.div(i, Spine.CurveTimeline2.ENTRIES)) | 0)]);
                switch (curveType) {
                    case Spine.CurveTimeline.LINEAR: 
                        var before = this.frames[i];
                        x.v = this.frames[((i + Spine.CurveTimeline2.VALUE1) | 0)];
                        y.v = this.frames[((i + Spine.CurveTimeline2.VALUE2) | 0)];
                        var t = (time - before) / (this.frames[((i + Spine.CurveTimeline2.ENTRIES) | 0)] - before);
                        x.v += (this.frames[((((i + Spine.CurveTimeline2.ENTRIES) | 0) + Spine.CurveTimeline2.VALUE1) | 0)] - x.v) * t;
                        y.v += (this.frames[((((i + Spine.CurveTimeline2.ENTRIES) | 0) + Spine.CurveTimeline2.VALUE2) | 0)] - y.v) * t;
                        break;
                    case Spine.CurveTimeline.STEPPED: 
                        x.v = this.frames[((i + Spine.CurveTimeline2.VALUE1) | 0)];
                        y.v = this.frames[((i + Spine.CurveTimeline2.VALUE2) | 0)];
                        break;
                    default: 
                        x.v = this.GetBezierValue(time, i, Spine.CurveTimeline2.VALUE1, ((curveType - Spine.CurveTimeline.BEZIER) | 0));
                        y.v = this.GetBezierValue(time, i, Spine.CurveTimeline2.VALUE2, ((((curveType + Spine.CurveTimeline.BEZIER_SIZE) | 0) - Spine.CurveTimeline.BEZIER) | 0));
                        break;
                }
            },
            /*Spine.TranslateTimeline.GetCurveValue end.*/


        }
    });
    /*Spine.TranslateTimeline end.*/

    /*Spine.TranslateXTimeline start.*/
    
    Bridge.define("Spine.TranslateXTimeline", {
        inherits: [Spine.CurveTimeline1,Spine.IBoneTimeline],
        fields: {
            boneIndex: 0
        },
        props: {
            BoneIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TranslateXTimeline#BoneIndex#get", this ); }

                    return this.boneIndex;
                }
            }
        },
        alias: ["BoneIndex", "Spine$IBoneTimeline$BoneIndex"],
        ctors: {
            ctor: function (frameCount, bezierCount, boneIndex) {
if ( TRACE ) { TRACE( "Spine.TranslateXTimeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline1.ctor.call(this, frameCount, bezierCount, Spine.Property.X + "|" + boneIndex);
                this.boneIndex = boneIndex;
            }
        },
        methods: {
            /*Spine.TranslateXTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.TranslateXTimeline#Apply", this ); }

                var $t;
                var bone = ($t = skeleton.bones.Items)[this.boneIndex];
                if (bone.active) {
                    bone.x = this.GetRelativeValue(time, alpha, blend, bone.x, bone.data.x);
                }
            },
            /*Spine.TranslateXTimeline.Apply end.*/


        }
    });
    /*Spine.TranslateXTimeline end.*/

    /*Spine.TranslateYTimeline start.*/
    
    Bridge.define("Spine.TranslateYTimeline", {
        inherits: [Spine.CurveTimeline1,Spine.IBoneTimeline],
        fields: {
            boneIndex: 0
        },
        props: {
            BoneIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TranslateYTimeline#BoneIndex#get", this ); }

                    return this.boneIndex;
                }
            }
        },
        alias: ["BoneIndex", "Spine$IBoneTimeline$BoneIndex"],
        ctors: {
            ctor: function (frameCount, bezierCount, boneIndex) {
if ( TRACE ) { TRACE( "Spine.TranslateYTimeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline1.ctor.call(this, frameCount, bezierCount, Spine.Property.Y + "|" + boneIndex);
                this.boneIndex = boneIndex;
            }
        },
        methods: {
            /*Spine.TranslateYTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.TranslateYTimeline#Apply", this ); }

                var $t;
                var bone = ($t = skeleton.bones.Items)[this.boneIndex];
                if (bone.active) {
                    bone.y = this.GetRelativeValue(time, alpha, blend, bone.y, bone.data.y);
                }
            },
            /*Spine.TranslateYTimeline.Apply end.*/


        }
    });
    /*Spine.TranslateYTimeline end.*/
    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.UpdateBonesDelegate
     * @param   {Spine.Unity.ISkeletonAnimation}    animated
     * @return  {void}
     */


    /*Spine.Unity.SkeletonAnimation start.*/
    Bridge.define("Spine.Unity.SkeletonAnimation", {
        inherits: [Spine.Unity.SkeletonRenderer,Spine.Unity.ISkeletonAnimation,Spine.Unity.IAnimationStateComponent],
        statics: {
            methods: {
                /*Spine.Unity.SkeletonAnimation.AddToGameObject:static start.*/
                /**
                 * Adds and prepares a SkeletonAnimation component to a GameObject at runtime.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonAnimation
                 * @memberof Spine.Unity.SkeletonAnimation
                 * @param   {UnityEngine.GameObject}           gameObject           
                 * @param   {Spine.Unity.SkeletonDataAsset}    skeletonDataAsset    
                 * @param   {boolean}                          quiet
                 * @return  {Spine.Unity.SkeletonAnimation}                         The newly instantiated SkeletonAnimation
                 */
                AddToGameObject: function (gameObject, skeletonDataAsset, quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#AddToGameObject", this ); }

                    if (quiet === void 0) { quiet = false; }
                    return Spine.Unity.SkeletonRenderer.AddSpineComponent(Spine.Unity.SkeletonAnimation, gameObject, skeletonDataAsset, quiet);
                },
                /*Spine.Unity.SkeletonAnimation.AddToGameObject:static end.*/

                /*Spine.Unity.SkeletonAnimation.NewSkeletonAnimationGameObject:static start.*/
                /**
                 * Instantiates a new UnityEngine.GameObject and adds a prepared SkeletonAnimation component to it.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonAnimation
                 * @memberof Spine.Unity.SkeletonAnimation
                 * @param   {Spine.Unity.SkeletonDataAsset}    skeletonDataAsset    
                 * @param   {boolean}                          quiet
                 * @return  {Spine.Unity.SkeletonAnimation}                         The newly instantiated SkeletonAnimation component.
                 */
                NewSkeletonAnimationGameObject: function (skeletonDataAsset, quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#NewSkeletonAnimationGameObject", this ); }

                    if (quiet === void 0) { quiet = false; }
                    return Spine.Unity.SkeletonRenderer.NewSpineGameObject(Spine.Unity.SkeletonAnimation, skeletonDataAsset, quiet);
                },
                /*Spine.Unity.SkeletonAnimation.NewSkeletonAnimationGameObject:static end.*/


            }
        },
        fields: {
            /**
             * This is the Spine.AnimationState object of this SkeletonAnimation. You can control animations through it.
             Note that this object, like .skeleton, is not guaranteed to exist in Awake. Do all accesses and caching to it in Start
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @type Spine.AnimationState
             */
            state: null,
            wasUpdatedAfterInit: false,
            updateTiming: 0,
            /**
             * If enabled, AnimationState uses unscaled game time
             (<pre><code>Time.unscaledDeltaTime</code></pre> instead of normal game time(<pre><code>Time.deltaTime</code></pre>),
             running animations independent of e.g. game pause (<pre><code>Time.timeScale</code></pre>).
             Instance SkeletonAnimation.timeScale will still be applied.
             *
             * @instance
             * @protected
             * @memberof Spine.Unity.SkeletonAnimation
             * @type boolean
             */
            unscaledTime: false,
            _animationName: null,
            /**
             * Whether or not {@link } should loop. This only applies to the initial animation specified in the inspector, or any subsequent Animations played through .AnimationName. Animations set through state.SetAnimation are unaffected.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @type boolean
             */
            loop: false,
            /**
             * The rate at which animations progress over time. 1 means 100%. 0.5 means 50%.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @default 1
             * @type number
             */
            timeScale: 0
        },
        events: {
            _OnAnimationRebuild: null,
            _BeforeApply: null,
            _UpdateLocal: null,
            _UpdateWorld: null,
            _UpdateComplete: null
        },
        props: {
            /**
             * This is the Spine.AnimationState object of this SkeletonAnimation. You can control animations through it.
             Note that this object, like .skeleton, is not guaranteed to exist in Awake. Do all accesses and caching to it in Start
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonAnimation
             * @function AnimationState
             * @type Spine.AnimationState
             */
            AnimationState: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#AnimationState#get", this ); }

                    this.Initialize(false);
                    return this.state;
                }
            },
            UpdateTiming: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#UpdateTiming#get", this ); }

                    return this.updateTiming;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#UpdateTiming#set", this ); }

                    this.updateTiming = value;
                }
            },
            UnscaledTime: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#UnscaledTime#get", this ); }

                    return this.unscaledTime;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#UnscaledTime#set", this ); }

                    this.unscaledTime = value;
                }
            },
            /**
             * Setting this property sets the animation of the skeleton. If invalid, it will store the animation name for the next time the skeleton is properly initialized.
             Getting this property gets the name of the currently playing animation. If invalid, it will return the last stored animation name set through this property.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @function AnimationName
             * @type string
             */
            AnimationName: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#AnimationName#get", this ); }

                    if (!this.valid) {
                        return this._animationName;
                    } else {
                        var entry = this.state.GetCurrent(0);
                        return entry == null ? null : entry.Animation.Name;
                    }
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#AnimationName#set", this ); }

                    this.Initialize(false);
                    if (Bridge.referenceEquals(this._animationName, value)) {
                        var entry = this.state.GetCurrent(0);
                        if (entry != null && entry.Loop === this.loop) {
                            return;
                        }
                    }
                    this._animationName = value;

                    if (System.String.isNullOrEmpty(value)) {
                        this.state.ClearTrack(0);
                    } else {
                        var animationObject = this.skeletonDataAsset.GetSkeletonData(false).FindAnimation(value);
                        if (animationObject != null) {
                            this.state.SetAnimation(0, animationObject, this.loop);
                        }
                    }
                }
            }
        },
        alias: [
            "AnimationState", "Spine$Unity$IAnimationStateComponent$AnimationState",
            "addOnAnimationRebuild", "Spine$Unity$ISkeletonAnimation$addOnAnimationRebuild",
            "removeOnAnimationRebuild", "Spine$Unity$ISkeletonAnimation$removeOnAnimationRebuild",
            "addUpdateLocal", "Spine$Unity$ISkeletonAnimation$addUpdateLocal",
            "removeUpdateLocal", "Spine$Unity$ISkeletonAnimation$removeUpdateLocal",
            "addUpdateWorld", "Spine$Unity$ISkeletonAnimation$addUpdateWorld",
            "removeUpdateWorld", "Spine$Unity$ISkeletonAnimation$removeUpdateWorld",
            "addUpdateComplete", "Spine$Unity$ISkeletonAnimation$addUpdateComplete",
            "removeUpdateComplete", "Spine$Unity$ISkeletonAnimation$removeUpdateComplete",
            "UpdateTiming", "Spine$Unity$ISkeletonAnimation$UpdateTiming",
            "UnscaledTime", "Spine$Unity$IAnimationStateComponent$UnscaledTime",
            "Skeleton", "Spine$Unity$ISkeletonAnimation$Skeleton"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#init", this ); }

                this.wasUpdatedAfterInit = true;
                this.updateTiming = Spine.Unity.UpdateTiming.InUpdate;
                this.timeScale = 1;
            }
        },
        methods: {
            /**
             * OnAnimationRebuild is raised after the SkeletonAnimation component is successfully initialized.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#OnAnimationRebuild
             * @return  {Spine.Unity.ISkeletonAnimationDelegate}
             */
            addOnAnimationRebuild: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#addOnAnimationRebuild", this ); }

                this.add_OnAnimationRebuild(value);
            },
            /**
             * OnAnimationRebuild is raised after the SkeletonAnimation component is successfully initialized.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#OnAnimationRebuild
             * @return  {Spine.Unity.ISkeletonAnimationDelegate}
             */
            removeOnAnimationRebuild: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#removeOnAnimationRebuild", this ); }

                this.remove_OnAnimationRebuild(value);
            },
            /**
             * Occurs before the animations are applied.
             Use this callback when you want to change the skeleton state before animations are applied on top.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#BeforeApply
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addBeforeApply: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#addBeforeApply", this ); }

                this.add_BeforeApply(value);
            },
            /**
             * Occurs before the animations are applied.
             Use this callback when you want to change the skeleton state before animations are applied on top.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#BeforeApply
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeBeforeApply: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#removeBeforeApply", this ); }

                this.remove_BeforeApply(value);
            },
            /**
             * Occurs after the animations are applied and before world space values are resolved.
             Use this callback when you want to set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#UpdateLocal
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addUpdateLocal: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#addUpdateLocal", this ); }

                this.add_UpdateLocal(value);
            },
            /**
             * Occurs after the animations are applied and before world space values are resolved.
             Use this callback when you want to set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#UpdateLocal
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeUpdateLocal: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#removeUpdateLocal", this ); }

                this.remove_UpdateLocal(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Using this callback will cause the world space values to be solved an extra time.
             Use this callback if want to use bone world space values, and also set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#UpdateWorld
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addUpdateWorld: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#addUpdateWorld", this ); }

                this.add_UpdateWorld(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Using this callback will cause the world space values to be solved an extra time.
             Use this callback if want to use bone world space values, and also set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#UpdateWorld
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeUpdateWorld: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#removeUpdateWorld", this ); }

                this.remove_UpdateWorld(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Use this callback if you want to use bone world space values, but don't intend to modify bone local values.
             This callback can also be used when setting world position and the bone matrix.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#UpdateComplete
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addUpdateComplete: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#addUpdateComplete", this ); }

                this.add_UpdateComplete(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Use this callback if you want to use bone world space values, but don't intend to modify bone local values.
             This callback can also be used when setting world position and the bone matrix.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#UpdateComplete
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeUpdateComplete: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#removeUpdateComplete", this ); }

                this.remove_UpdateComplete(value);
            },
            /*Spine.Unity.SkeletonAnimation.ClearState start.*/
            /**
             * Clears the previously generated mesh, resets the skeleton's pose, and clears all previously active animations.
             *
             * @instance
             * @public
             * @override
             * @this Spine.Unity.SkeletonAnimation
             * @memberof Spine.Unity.SkeletonAnimation
             * @return  {void}
             */
            ClearState: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#ClearState", this ); }

                Spine.Unity.SkeletonRenderer.prototype.ClearState.call(this);
                if (this.state != null) {
                    this.state.ClearTracks();
                }
            },
            /*Spine.Unity.SkeletonAnimation.ClearState end.*/

            /*Spine.Unity.SkeletonAnimation.Initialize start.*/
            /**
             * Initialize this component. Attempts to load the SkeletonData and creates the internal Spine objects and buffers.
             *
             * @instance
             * @public
             * @override
             * @this Spine.Unity.SkeletonAnimation
             * @memberof Spine.Unity.SkeletonAnimation
             * @param   {boolean}    overwrite    If set to <pre><code>true</code></pre>, force overwrite an already initialized object.
             * @param   {boolean}    quiet
             * @return  {void}
             */
            Initialize: function (overwrite, quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#Initialize", this ); }

                if (quiet === void 0) { quiet = false; }
                if (this.valid && !overwrite) {
                    return;
                }
                this.state = null; // prevent applying leftover AnimationState
                Spine.Unity.SkeletonRenderer.prototype.Initialize.call(this, overwrite, quiet);

                if (!this.valid) {
                    return;
                }
                this.state = new Spine.AnimationState(this.skeletonDataAsset.GetAnimationStateData());
                this.wasUpdatedAfterInit = false;

                if (!System.String.isNullOrEmpty(this._animationName)) {
                    var animationObject = this.skeletonDataAsset.GetSkeletonData(false).FindAnimation(this._animationName);
                    if (animationObject != null) {
                        this.state.SetAnimation(0, animationObject, this.loop);
                    }
                }

                if (!Bridge.staticEquals(this._OnAnimationRebuild, null)) {
                    this._OnAnimationRebuild(this);
                }
            },
            /*Spine.Unity.SkeletonAnimation.Initialize end.*/

            /*Spine.Unity.SkeletonAnimation.Update$1 start.*/
            Update$1: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#Update$1", this ); }

                if (this.updateTiming !== Spine.Unity.UpdateTiming.InUpdate) {
                    return;
                }
                this.Update(this.unscaledTime ? UnityEngine.Time.unscaledDeltaTime : UnityEngine.Time.deltaTime);
            },
            /*Spine.Unity.SkeletonAnimation.Update$1 end.*/

            /*Spine.Unity.SkeletonAnimation.Update start.*/
            /**
             * Progresses the AnimationState according to the given deltaTime, and applies it to the Skeleton. Use Time.deltaTime to update manually. Use deltaTime 0 to update without progressing the time.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonAnimation
             * @memberof Spine.Unity.SkeletonAnimation
             * @param   {number}    deltaTime
             * @return  {void}
             */
            Update: function (deltaTime) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#Update", this ); }

                if (!this.valid || this.state == null) {
                    return;
                }

                this.wasUpdatedAfterInit = true;
                if (this.updateMode < Spine.Unity.UpdateMode.OnlyAnimationStatus) {
                    return;
                }
                this.UpdateAnimationStatus(deltaTime);

                if (this.updateMode === Spine.Unity.UpdateMode.OnlyAnimationStatus) {
                    return;
                }
                this.ApplyAnimation();
            },
            /*Spine.Unity.SkeletonAnimation.Update end.*/

            /*Spine.Unity.SkeletonAnimation.FixedUpdate start.*/
            FixedUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#FixedUpdate", this ); }

                if (this.updateTiming !== Spine.Unity.UpdateTiming.InFixedUpdate) {
                    return;
                }
                this.Update(this.unscaledTime ? UnityEngine.Time.unscaledDeltaTime : UnityEngine.Time.deltaTime);
            },
            /*Spine.Unity.SkeletonAnimation.FixedUpdate end.*/

            /*Spine.Unity.SkeletonAnimation.UpdateAnimationStatus start.*/
            UpdateAnimationStatus: function (deltaTime) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#UpdateAnimationStatus", this ); }

                deltaTime *= this.timeScale;
                this.state.Update(deltaTime);
                this.skeleton.Update(deltaTime);

                this.ApplyTransformMovementToPhysics();

                if (this.updateMode === Spine.Unity.UpdateMode.OnlyAnimationStatus) {
                    this.state.ApplyEventTimelinesOnly(this.skeleton, false);
                    return;
                }
            },
            /*Spine.Unity.SkeletonAnimation.UpdateAnimationStatus end.*/

            /*Spine.Unity.SkeletonAnimation.ApplyAnimation start.*/
            ApplyAnimation: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#ApplyAnimation", this ); }

                if (!Bridge.staticEquals(this._BeforeApply, null)) {
                    this._BeforeApply(this);
                }

                if (this.updateMode !== Spine.Unity.UpdateMode.OnlyEventTimelines) {
                    this.state.Apply(this.skeleton);
                } else {
                    this.state.ApplyEventTimelinesOnly(this.skeleton, true);
                }

                this.AfterAnimationApplied();
            },
            /*Spine.Unity.SkeletonAnimation.ApplyAnimation end.*/

            /*Spine.Unity.SkeletonAnimation.AfterAnimationApplied start.*/
            AfterAnimationApplied: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#AfterAnimationApplied", this ); }

                if (!Bridge.staticEquals(this._UpdateLocal, null)) {
                    this._UpdateLocal(this);
                }

                if (Bridge.staticEquals(this._UpdateWorld, null)) {
                    this.UpdateWorldTransform(Spine.Skeleton.Physics.Update);
                } else {
                    this.UpdateWorldTransform(Spine.Skeleton.Physics.Pose);
                    this._UpdateWorld(this);
                    this.UpdateWorldTransform(Spine.Skeleton.Physics.Update);
                }

                if (!Bridge.staticEquals(this._UpdateComplete, null)) {
                    this._UpdateComplete(this);
                }
            },
            /*Spine.Unity.SkeletonAnimation.AfterAnimationApplied end.*/

            /*Spine.Unity.SkeletonAnimation.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#LateUpdate", this ); }

                if (this.updateTiming === Spine.Unity.UpdateTiming.InLateUpdate && this.valid) {
                    this.Update(this.unscaledTime ? UnityEngine.Time.unscaledDeltaTime : UnityEngine.Time.deltaTime);
                }

                // instantiation can happen from Update() after this component, leading to a missing Update() call.
                if (!this.wasUpdatedAfterInit) {
                    this.Update(0);
                }

                Spine.Unity.SkeletonRenderer.prototype.LateUpdate.call(this);
            },
            /*Spine.Unity.SkeletonAnimation.LateUpdate end.*/

            /*Spine.Unity.SkeletonAnimation.OnBecameVisible start.*/
            OnBecameVisible: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#OnBecameVisible", this ); }

                var previousUpdateMode = this.updateMode;
                this.updateMode = Spine.Unity.UpdateMode.FullUpdate;

                // OnBecameVisible is called after LateUpdate()
                if (previousUpdateMode !== Spine.Unity.UpdateMode.FullUpdate && previousUpdateMode !== Spine.Unity.UpdateMode.EverythingExceptMesh) {
                    this.Update(0);
                }
                if (previousUpdateMode !== Spine.Unity.UpdateMode.FullUpdate) {
                    this.LateUpdate();
                }
            },
            /*Spine.Unity.SkeletonAnimation.OnBecameVisible end.*/


        },
        overloads: {
            "Update()": "Update$1"
        }
    });
    /*Spine.Unity.SkeletonAnimation end.*/

    /*Spine.Unity.SkeletonMecanim start.*/
    Bridge.define("Spine.Unity.SkeletonMecanim", {
        inherits: [Spine.Unity.SkeletonRenderer,Spine.Unity.ISkeletonAnimation],
        fields: {
            translator: null,
            wasUpdatedAfterInit: false,
            updateTiming: 0
        },
        events: {
            _OnAnimationRebuild: null,
            _BeforeApply: null,
            _UpdateLocal: null,
            _UpdateWorld: null,
            _UpdateComplete: null
        },
        props: {
            Translator: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#Translator#get", this ); }

                    return this.translator;
                }
            },
            UpdateTiming: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#UpdateTiming#get", this ); }

                    return this.updateTiming;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#UpdateTiming#set", this ); }

                    this.updateTiming = value;
                }
            }
        },
        alias: [
            "addOnAnimationRebuild", "Spine$Unity$ISkeletonAnimation$addOnAnimationRebuild",
            "removeOnAnimationRebuild", "Spine$Unity$ISkeletonAnimation$removeOnAnimationRebuild",
            "addUpdateLocal", "Spine$Unity$ISkeletonAnimation$addUpdateLocal",
            "removeUpdateLocal", "Spine$Unity$ISkeletonAnimation$removeUpdateLocal",
            "addUpdateWorld", "Spine$Unity$ISkeletonAnimation$addUpdateWorld",
            "removeUpdateWorld", "Spine$Unity$ISkeletonAnimation$removeUpdateWorld",
            "addUpdateComplete", "Spine$Unity$ISkeletonAnimation$addUpdateComplete",
            "removeUpdateComplete", "Spine$Unity$ISkeletonAnimation$removeUpdateComplete",
            "UpdateTiming", "Spine$Unity$ISkeletonAnimation$UpdateTiming",
            "Skeleton", "Spine$Unity$ISkeletonAnimation$Skeleton"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#init", this ); }

                this.wasUpdatedAfterInit = true;
                this.updateTiming = Spine.Unity.UpdateTiming.InUpdate;
            }
        },
        methods: {
            /**
             * OnAnimationRebuild is raised after the SkeletonAnimation component is successfully initialized.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#OnAnimationRebuild
             * @return  {Spine.Unity.ISkeletonAnimationDelegate}
             */
            addOnAnimationRebuild: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#addOnAnimationRebuild", this ); }

                this.add_OnAnimationRebuild(value);
            },
            /**
             * OnAnimationRebuild is raised after the SkeletonAnimation component is successfully initialized.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#OnAnimationRebuild
             * @return  {Spine.Unity.ISkeletonAnimationDelegate}
             */
            removeOnAnimationRebuild: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#removeOnAnimationRebuild", this ); }

                this.remove_OnAnimationRebuild(value);
            },
            /**
             * Occurs before the animations are applied.
             Use this callback when you want to change the skeleton state before animations are applied on top.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#BeforeApply
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addBeforeApply: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#addBeforeApply", this ); }

                this.add_BeforeApply(value);
            },
            /**
             * Occurs before the animations are applied.
             Use this callback when you want to change the skeleton state before animations are applied on top.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#BeforeApply
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeBeforeApply: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#removeBeforeApply", this ); }

                this.remove_BeforeApply(value);
            },
            /**
             * Occurs after the animations are applied and before world space values are resolved.
             Use this callback when you want to set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#UpdateLocal
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addUpdateLocal: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#addUpdateLocal", this ); }

                this.add_UpdateLocal(value);
            },
            /**
             * Occurs after the animations are applied and before world space values are resolved.
             Use this callback when you want to set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#UpdateLocal
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeUpdateLocal: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#removeUpdateLocal", this ); }

                this.remove_UpdateLocal(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Using this callback will cause the world space values to be solved an extra time.
             Use this callback if want to use bone world space values, and also set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#UpdateWorld
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addUpdateWorld: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#addUpdateWorld", this ); }

                this.add_UpdateWorld(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Using this callback will cause the world space values to be solved an extra time.
             Use this callback if want to use bone world space values, and also set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#UpdateWorld
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeUpdateWorld: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#removeUpdateWorld", this ); }

                this.remove_UpdateWorld(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Use this callback if you want to use bone world space values, but don't intend to modify bone local values.
             This callback can also be used when setting world position and the bone matrix.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#UpdateComplete
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addUpdateComplete: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#addUpdateComplete", this ); }

                this.add_UpdateComplete(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Use this callback if you want to use bone world space values, but don't intend to modify bone local values.
             This callback can also be used when setting world position and the bone matrix.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#UpdateComplete
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeUpdateComplete: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#removeUpdateComplete", this ); }

                this.remove_UpdateComplete(value);
            },
            /*Spine.Unity.SkeletonMecanim.Initialize start.*/
            Initialize: function (overwrite, quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#Initialize", this ); }

                if (quiet === void 0) { quiet = false; }
                if (this.valid && !overwrite) {
                    return;
                }
                Spine.Unity.SkeletonRenderer.prototype.Initialize.call(this, overwrite, quiet);

                if (!this.valid) {
                    return;
                }

                if (this.translator == null) {
                    this.translator = new Spine.Unity.SkeletonMecanim.MecanimTranslator();
                }
                this.translator.Initialize(this.GetComponent(UnityEngine.Animator), this.skeletonDataAsset);
                this.wasUpdatedAfterInit = false;

                if (!Bridge.staticEquals(this._OnAnimationRebuild, null)) {
                    this._OnAnimationRebuild(this);
                }
            },
            /*Spine.Unity.SkeletonMecanim.Initialize end.*/

            /*Spine.Unity.SkeletonMecanim.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#Update", this ); }

                if (!this.valid || this.updateTiming !== Spine.Unity.UpdateTiming.InUpdate) {
                    return;
                }
                this.UpdateAnimation(UnityEngine.Time.deltaTime);
            },
            /*Spine.Unity.SkeletonMecanim.Update end.*/

            /*Spine.Unity.SkeletonMecanim.Update$1 start.*/
            /**
             * Manual animation update. Required when <pre><code>updateTiming</code></pre> is set to <pre><code>ManualUpdate</code></pre>.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonMecanim
             * @memberof Spine.Unity.SkeletonMecanim
             * @param   {number}    deltaTime    Ignored parameter.
             * @return  {void}
             */
            Update$1: function (deltaTime) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#Update$1", this ); }

                if (!this.valid) {
                    return;
                }
                this.UpdateAnimation(deltaTime);
            },
            /*Spine.Unity.SkeletonMecanim.Update$1 end.*/

            /*Spine.Unity.SkeletonMecanim.FixedUpdate start.*/
            FixedUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#FixedUpdate", this ); }

                if (!this.valid || this.updateTiming !== Spine.Unity.UpdateTiming.InFixedUpdate) {
                    return;
                }
                this.UpdateAnimation(UnityEngine.Time.deltaTime);
            },
            /*Spine.Unity.SkeletonMecanim.FixedUpdate end.*/

            /*Spine.Unity.SkeletonMecanim.UpdateAnimation start.*/
            UpdateAnimation: function (deltaTime) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#UpdateAnimation", this ); }

                this.wasUpdatedAfterInit = true;

                // animation status is kept by Mecanim Animator component
                if (this.updateMode <= Spine.Unity.UpdateMode.OnlyAnimationStatus) {
                    return;
                }

                this.skeleton.Update(deltaTime);

                this.ApplyTransformMovementToPhysics();

                this.ApplyAnimation();
            },
            /*Spine.Unity.SkeletonMecanim.UpdateAnimation end.*/

            /*Spine.Unity.SkeletonMecanim.ApplyAnimation start.*/
            ApplyAnimation: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#ApplyAnimation", this ); }

                if (!Bridge.staticEquals(this._BeforeApply, null)) {
                    this._BeforeApply(this);
                }

                this.translator.Apply(this.skeleton);
                this.AfterAnimationApplied();
            },
            /*Spine.Unity.SkeletonMecanim.ApplyAnimation end.*/

            /*Spine.Unity.SkeletonMecanim.AfterAnimationApplied start.*/
            AfterAnimationApplied: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#AfterAnimationApplied", this ); }

                if (!Bridge.staticEquals(this._UpdateLocal, null)) {
                    this._UpdateLocal(this);
                }

                if (Bridge.staticEquals(this._UpdateWorld, null)) {
                    this.UpdateWorldTransform(Spine.Skeleton.Physics.Update);
                } else {
                    this.UpdateWorldTransform(Spine.Skeleton.Physics.Pose);
                    this._UpdateWorld(this);
                    this.UpdateWorldTransform(Spine.Skeleton.Physics.Update);
                }

                if (!Bridge.staticEquals(this._UpdateComplete, null)) {
                    this._UpdateComplete(this);
                }
            },
            /*Spine.Unity.SkeletonMecanim.AfterAnimationApplied end.*/

            /*Spine.Unity.SkeletonMecanim.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#LateUpdate", this ); }

                if (this.updateTiming === Spine.Unity.UpdateTiming.InLateUpdate && this.valid && this.translator != null && UnityEngine.Component.op_Inequality(this.translator.Animator, null)) {
                    this.UpdateAnimation(UnityEngine.Time.deltaTime);
                }
                // instantiation can happen from Update() after this component, leading to a missing Update() call.
                if (!this.wasUpdatedAfterInit) {
                    this.Update();
                }
                Spine.Unity.SkeletonRenderer.prototype.LateUpdate.call(this);
            },
            /*Spine.Unity.SkeletonMecanim.LateUpdate end.*/

            /*Spine.Unity.SkeletonMecanim.OnBecameVisible start.*/
            OnBecameVisible: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#OnBecameVisible", this ); }

                var previousUpdateMode = this.updateMode;
                this.updateMode = Spine.Unity.UpdateMode.FullUpdate;

                // OnBecameVisible is called after LateUpdate()
                if (previousUpdateMode !== Spine.Unity.UpdateMode.FullUpdate && previousUpdateMode !== Spine.Unity.UpdateMode.EverythingExceptMesh) {
                    this.Update();
                }
                if (previousUpdateMode !== Spine.Unity.UpdateMode.FullUpdate) {
                    this.LateUpdate();
                }
            },
            /*Spine.Unity.SkeletonMecanim.OnBecameVisible end.*/


        },
        overloads: {
            "Update(float)": "Update$1"
        }
    });
    /*Spine.Unity.SkeletonMecanim end.*/

    /*Spine.PhysicsConstraintDampingTimeline start.*/
    /**
     * Changes a physics constraint's {@link }.
     *
     * @public
     * @class Spine.PhysicsConstraintDampingTimeline
     * @augments Spine.PhysicsConstraintTimeline
     */
    Bridge.define("Spine.PhysicsConstraintDampingTimeline", {
        inherits: [Spine.PhysicsConstraintTimeline],
        ctors: {
            ctor: function (frameCount, bezierCount, physicsConstraintIndex) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintDampingTimeline#ctor", this ); }

                this.$initialize();
                Spine.PhysicsConstraintTimeline.ctor.call(this, frameCount, bezierCount, physicsConstraintIndex, Spine.Property.PhysicsConstraintDamping);
            }
        },
        methods: {
            /*Spine.PhysicsConstraintDampingTimeline.Setup start.*/
            Setup: function (constraint) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintDampingTimeline#Setup", this ); }

                return constraint.data.damping;
            },
            /*Spine.PhysicsConstraintDampingTimeline.Setup end.*/

            /*Spine.PhysicsConstraintDampingTimeline.Get start.*/
            Get: function (constraint) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintDampingTimeline#Get", this ); }

                return constraint.damping;
            },
            /*Spine.PhysicsConstraintDampingTimeline.Get end.*/

            /*Spine.PhysicsConstraintDampingTimeline.Set start.*/
            Set: function (constraint, value) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintDampingTimeline#Set", this ); }

                constraint.damping = value;
            },
            /*Spine.PhysicsConstraintDampingTimeline.Set end.*/

            /*Spine.PhysicsConstraintDampingTimeline.Global start.*/
            Global: function (constraint) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintDampingTimeline#Global", this ); }

                return constraint.dampingGlobal;
            },
            /*Spine.PhysicsConstraintDampingTimeline.Global end.*/


        }
    });
    /*Spine.PhysicsConstraintDampingTimeline end.*/

    /*Spine.PhysicsConstraintGravityTimeline start.*/
    /**
     * Changes a physics constraint's {@link }.
     *
     * @public
     * @class Spine.PhysicsConstraintGravityTimeline
     * @augments Spine.PhysicsConstraintTimeline
     */
    Bridge.define("Spine.PhysicsConstraintGravityTimeline", {
        inherits: [Spine.PhysicsConstraintTimeline],
        ctors: {
            ctor: function (frameCount, bezierCount, physicsConstraintIndex) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintGravityTimeline#ctor", this ); }

                this.$initialize();
                Spine.PhysicsConstraintTimeline.ctor.call(this, frameCount, bezierCount, physicsConstraintIndex, Spine.Property.PhysicsConstraintGravity);
            }
        },
        methods: {
            /*Spine.PhysicsConstraintGravityTimeline.Setup start.*/
            Setup: function (constraint) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintGravityTimeline#Setup", this ); }

                return constraint.data.gravity;
            },
            /*Spine.PhysicsConstraintGravityTimeline.Setup end.*/

            /*Spine.PhysicsConstraintGravityTimeline.Get start.*/
            Get: function (constraint) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintGravityTimeline#Get", this ); }

                return constraint.gravity;
            },
            /*Spine.PhysicsConstraintGravityTimeline.Get end.*/

            /*Spine.PhysicsConstraintGravityTimeline.Set start.*/
            Set: function (constraint, value) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintGravityTimeline#Set", this ); }

                constraint.gravity = value;
            },
            /*Spine.PhysicsConstraintGravityTimeline.Set end.*/

            /*Spine.PhysicsConstraintGravityTimeline.Global start.*/
            Global: function (constraint) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintGravityTimeline#Global", this ); }

                return constraint.gravityGlobal;
            },
            /*Spine.PhysicsConstraintGravityTimeline.Global end.*/


        }
    });
    /*Spine.PhysicsConstraintGravityTimeline end.*/

    /*Spine.PhysicsConstraintInertiaTimeline start.*/
    /**
     * Changes a physics constraint's {@link }.
     *
     * @public
     * @class Spine.PhysicsConstraintInertiaTimeline
     * @augments Spine.PhysicsConstraintTimeline
     */
    Bridge.define("Spine.PhysicsConstraintInertiaTimeline", {
        inherits: [Spine.PhysicsConstraintTimeline],
        ctors: {
            ctor: function (frameCount, bezierCount, physicsConstraintIndex) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintInertiaTimeline#ctor", this ); }

                this.$initialize();
                Spine.PhysicsConstraintTimeline.ctor.call(this, frameCount, bezierCount, physicsConstraintIndex, Spine.Property.PhysicsConstraintInertia);
            }
        },
        methods: {
            /*Spine.PhysicsConstraintInertiaTimeline.Setup start.*/
            Setup: function (constraint) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintInertiaTimeline#Setup", this ); }

                return constraint.data.inertia;
            },
            /*Spine.PhysicsConstraintInertiaTimeline.Setup end.*/

            /*Spine.PhysicsConstraintInertiaTimeline.Get start.*/
            Get: function (constraint) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintInertiaTimeline#Get", this ); }

                return constraint.inertia;
            },
            /*Spine.PhysicsConstraintInertiaTimeline.Get end.*/

            /*Spine.PhysicsConstraintInertiaTimeline.Set start.*/
            Set: function (constraint, value) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintInertiaTimeline#Set", this ); }

                constraint.inertia = value;
            },
            /*Spine.PhysicsConstraintInertiaTimeline.Set end.*/

            /*Spine.PhysicsConstraintInertiaTimeline.Global start.*/
            Global: function (constraint) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintInertiaTimeline#Global", this ); }

                return constraint.inertiaGlobal;
            },
            /*Spine.PhysicsConstraintInertiaTimeline.Global end.*/


        }
    });
    /*Spine.PhysicsConstraintInertiaTimeline end.*/

    /*Spine.PhysicsConstraintMassTimeline start.*/
    /**
     * Changes a physics constraint's {@link }. The timeline values are not inverted.
     *
     * @public
     * @class Spine.PhysicsConstraintMassTimeline
     * @augments Spine.PhysicsConstraintTimeline
     */
    Bridge.define("Spine.PhysicsConstraintMassTimeline", {
        inherits: [Spine.PhysicsConstraintTimeline],
        ctors: {
            ctor: function (frameCount, bezierCount, physicsConstraintIndex) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintMassTimeline#ctor", this ); }

                this.$initialize();
                Spine.PhysicsConstraintTimeline.ctor.call(this, frameCount, bezierCount, physicsConstraintIndex, Spine.Property.PhysicsConstraintMass);
            }
        },
        methods: {
            /*Spine.PhysicsConstraintMassTimeline.Setup start.*/
            Setup: function (constraint) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintMassTimeline#Setup", this ); }

                return 1 / constraint.data.massInverse;
            },
            /*Spine.PhysicsConstraintMassTimeline.Setup end.*/

            /*Spine.PhysicsConstraintMassTimeline.Get start.*/
            Get: function (constraint) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintMassTimeline#Get", this ); }

                return 1 / constraint.massInverse;
            },
            /*Spine.PhysicsConstraintMassTimeline.Get end.*/

            /*Spine.PhysicsConstraintMassTimeline.Set start.*/
            Set: function (constraint, value) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintMassTimeline#Set", this ); }

                constraint.massInverse = 1 / value;
            },
            /*Spine.PhysicsConstraintMassTimeline.Set end.*/

            /*Spine.PhysicsConstraintMassTimeline.Global start.*/
            Global: function (constraint) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintMassTimeline#Global", this ); }

                return constraint.massGlobal;
            },
            /*Spine.PhysicsConstraintMassTimeline.Global end.*/


        }
    });
    /*Spine.PhysicsConstraintMassTimeline end.*/

    /*Spine.PhysicsConstraintMixTimeline start.*/
    /**
     * Changes a physics constraint's {@link }.
     *
     * @public
     * @class Spine.PhysicsConstraintMixTimeline
     * @augments Spine.PhysicsConstraintTimeline
     */
    Bridge.define("Spine.PhysicsConstraintMixTimeline", {
        inherits: [Spine.PhysicsConstraintTimeline],
        ctors: {
            ctor: function (frameCount, bezierCount, physicsConstraintIndex) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintMixTimeline#ctor", this ); }

                this.$initialize();
                Spine.PhysicsConstraintTimeline.ctor.call(this, frameCount, bezierCount, physicsConstraintIndex, Spine.Property.PhysicsConstraintMix);
            }
        },
        methods: {
            /*Spine.PhysicsConstraintMixTimeline.Setup start.*/
            Setup: function (constraint) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintMixTimeline#Setup", this ); }

                return constraint.data.mix;
            },
            /*Spine.PhysicsConstraintMixTimeline.Setup end.*/

            /*Spine.PhysicsConstraintMixTimeline.Get start.*/
            Get: function (constraint) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintMixTimeline#Get", this ); }

                return constraint.mix;
            },
            /*Spine.PhysicsConstraintMixTimeline.Get end.*/

            /*Spine.PhysicsConstraintMixTimeline.Set start.*/
            Set: function (constraint, value) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintMixTimeline#Set", this ); }

                constraint.mix = value;
            },
            /*Spine.PhysicsConstraintMixTimeline.Set end.*/

            /*Spine.PhysicsConstraintMixTimeline.Global start.*/
            Global: function (constraint) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintMixTimeline#Global", this ); }

                return constraint.mixGlobal;
            },
            /*Spine.PhysicsConstraintMixTimeline.Global end.*/


        }
    });
    /*Spine.PhysicsConstraintMixTimeline end.*/

    /*Spine.PhysicsConstraintStrengthTimeline start.*/
    /**
     * Changes a physics constraint's {@link }.
     *
     * @public
     * @class Spine.PhysicsConstraintStrengthTimeline
     * @augments Spine.PhysicsConstraintTimeline
     */
    Bridge.define("Spine.PhysicsConstraintStrengthTimeline", {
        inherits: [Spine.PhysicsConstraintTimeline],
        ctors: {
            ctor: function (frameCount, bezierCount, physicsConstraintIndex) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintStrengthTimeline#ctor", this ); }

                this.$initialize();
                Spine.PhysicsConstraintTimeline.ctor.call(this, frameCount, bezierCount, physicsConstraintIndex, Spine.Property.PhysicsConstraintStrength);
            }
        },
        methods: {
            /*Spine.PhysicsConstraintStrengthTimeline.Setup start.*/
            Setup: function (constraint) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintStrengthTimeline#Setup", this ); }

                return constraint.data.strength;
            },
            /*Spine.PhysicsConstraintStrengthTimeline.Setup end.*/

            /*Spine.PhysicsConstraintStrengthTimeline.Get start.*/
            Get: function (constraint) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintStrengthTimeline#Get", this ); }

                return constraint.strength;
            },
            /*Spine.PhysicsConstraintStrengthTimeline.Get end.*/

            /*Spine.PhysicsConstraintStrengthTimeline.Set start.*/
            Set: function (constraint, value) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintStrengthTimeline#Set", this ); }

                constraint.strength = value;
            },
            /*Spine.PhysicsConstraintStrengthTimeline.Set end.*/

            /*Spine.PhysicsConstraintStrengthTimeline.Global start.*/
            Global: function (constraint) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintStrengthTimeline#Global", this ); }

                return constraint.strengthGlobal;
            },
            /*Spine.PhysicsConstraintStrengthTimeline.Global end.*/


        }
    });
    /*Spine.PhysicsConstraintStrengthTimeline end.*/

    /*Spine.PhysicsConstraintWindTimeline start.*/
    /**
     * Changes a physics constraint's {@link }.
     *
     * @public
     * @class Spine.PhysicsConstraintWindTimeline
     * @augments Spine.PhysicsConstraintTimeline
     */
    Bridge.define("Spine.PhysicsConstraintWindTimeline", {
        inherits: [Spine.PhysicsConstraintTimeline],
        ctors: {
            ctor: function (frameCount, bezierCount, physicsConstraintIndex) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintWindTimeline#ctor", this ); }

                this.$initialize();
                Spine.PhysicsConstraintTimeline.ctor.call(this, frameCount, bezierCount, physicsConstraintIndex, Spine.Property.PhysicsConstraintWind);
            }
        },
        methods: {
            /*Spine.PhysicsConstraintWindTimeline.Setup start.*/
            Setup: function (constraint) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintWindTimeline#Setup", this ); }

                return constraint.data.wind;
            },
            /*Spine.PhysicsConstraintWindTimeline.Setup end.*/

            /*Spine.PhysicsConstraintWindTimeline.Get start.*/
            Get: function (constraint) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintWindTimeline#Get", this ); }

                return constraint.wind;
            },
            /*Spine.PhysicsConstraintWindTimeline.Get end.*/

            /*Spine.PhysicsConstraintWindTimeline.Set start.*/
            Set: function (constraint, value) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintWindTimeline#Set", this ); }

                constraint.wind = value;
            },
            /*Spine.PhysicsConstraintWindTimeline.Set end.*/

            /*Spine.PhysicsConstraintWindTimeline.Global start.*/
            Global: function (constraint) {
if ( TRACE ) { TRACE( "Spine.PhysicsConstraintWindTimeline#Global", this ); }

                return constraint.windGlobal;
            },
            /*Spine.PhysicsConstraintWindTimeline.Global end.*/


        }
    });
    /*Spine.PhysicsConstraintWindTimeline end.*/

    if ( MODULE_reflection ) {
    var $m = Bridge.setMetadata,
        $n = ["System","UnityEngine","System.Collections.Generic","System.Collections","UnityEngine.UI","Spine.Unity","UnityEngine.EventSystems","SharpJson","Spine","System.IO","UnityEngine.U2D","UnityEngine.Rendering","Spine.Unity.AttachmentTools","UnityEngine.Audio","DG.Tweening.Core","DG.Tweening","DG.Tweening.Plugins.Core.PathCore","System.Globalization","DG.Tweening.Plugins.Options"];

    /*AudioManager start.*/
    $m("AudioManager", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"PlayContifieSound","t":8,"sn":"PlayContifieSound","rt":$n[0].Void},{"a":2,"n":"PlayWinSound","t":8,"sn":"PlayWinSound","rt":$n[0].Void},{"a":2,"n":"PlayWoodDestroySound","t":8,"sn":"PlayWoodDestroySound","rt":$n[0].Void},{"a":2,"n":"winUI","t":8,"sn":"winUI","rt":$n[0].Void},{"a":2,"n":"broken","t":4,"rt":$n[1].AudioSource,"sn":"broken"},{"a":2,"n":"contifie","t":4,"rt":$n[1].AudioSource,"sn":"contifie"},{"a":2,"n":"instance","is":true,"t":4,"rt":AudioManager,"sn":"instance"},{"a":2,"n":"win","t":4,"rt":$n[1].AudioSource,"sn":"win"},{"a":2,"n":"winui","t":4,"rt":$n[1].GameObject,"sn":"winui"}]}; }, $n);
    /*AudioManager end.*/

    /*AudioClipsHolder start.*/
    $m("AudioClipsHolder", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"TryGetAudioClip","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"TryGetAudioClip","rt":$n[1].AudioClip,"p":[$n[0].String]},{"at":[new UnityEngine.HideInInspector()],"a":2,"n":"audioPool","t":4,"rt":$n[2].Dictionary$2(System.String,UnityEngine.AudioClip),"sn":"audioPool"},{"a":2,"n":"soundList","t":4,"rt":$n[2].List$1(UnityEngine.AudioClip),"sn":"soundList"}]}; }, $n);
    /*AudioClipsHolder end.*/

    /*Bar start.*/
    $m("Bar", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddBolt","t":8,"pi":[{"n":"bolt","pt":Bolt,"ps":0},{"n":"newPos","pt":$n[1].Vector3,"ps":1}],"sn":"AddBolt","rt":$n[0].Void,"p":[Bolt,$n[1].Vector3]},{"a":1,"n":"Destroy","t":8,"sn":"Destroy$1","rt":$n[0].Void},{"a":2,"n":"Done","t":8,"sn":"Done","rt":$n[0].Void},{"a":2,"n":"Explosion","t":8,"sn":"Explosion","rt":$n[0].Void},{"a":1,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"a":1,"n":"GetAmountBolt","t":8,"sn":"GetAmountBolt","rt":$n[0].Int32,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"Init","t":8,"pi":[{"n":"position","pt":$n[1].Vector2,"ps":0},{"n":"angle","pt":$n[1].Vector3,"ps":1},{"n":"actived","pt":$n[0].Boolean,"ps":2}],"sn":"Init","rt":$n[0].Void,"p":[$n[1].Vector2,$n[1].Vector3,$n[0].Boolean]},{"a":1,"n":"OnCollisionEnter2D","t":8,"pi":[{"n":"collision","pt":$n[1].Collision2D,"ps":0}],"sn":"OnCollisionEnter2D","rt":$n[0].Void,"p":[$n[1].Collision2D]},{"a":1,"n":"OnTriggerEnter2D","t":8,"pi":[{"n":"collision","pt":$n[1].Collider2D,"ps":0}],"sn":"OnTriggerEnter2D","rt":$n[0].Void,"p":[$n[1].Collider2D]},{"a":2,"n":"RemoveBolt","t":8,"pi":[{"n":"bolt","pt":Bolt,"ps":0}],"sn":"RemoveBolt","rt":$n[0].Void,"p":[Bolt]},{"a":1,"n":"SetState","t":8,"pi":[{"n":"amountBolt","pt":$n[0].Int32,"ps":0},{"n":"connectedRigid2D","pt":$n[1].Rigidbody2D,"ps":1}],"sn":"SetState","rt":$n[0].Void,"p":[$n[0].Int32,$n[1].Rigidbody2D]},{"a":1,"n":"SetState","t":8,"pi":[{"n":"amountBolt","pt":$n[0].Int32,"ps":0},{"n":"connectedRigid2D","pt":$n[1].Rigidbody2D,"ps":1},{"n":"newPos","pt":$n[1].Vector3,"ps":2}],"sn":"SetState$1","rt":$n[0].Void,"p":[$n[0].Int32,$n[1].Rigidbody2D,$n[1].Vector3]},{"a":2,"n":"Simulate","t":8,"sn":"Simulate","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"HasDone","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_HasDone","t":8,"rt":$n[0].Boolean,"fg":"HasDone","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_HasDone","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"HasDone"},"fn":"HasDone"},{"a":1,"n":"barHoles","t":4,"rt":System.Array.type(BarHole),"sn":"barHoles"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"bolts","t":4,"rt":$n[2].List$1(Bolt),"sn":"bolts"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"centerOfMass","t":4,"rt":$n[1].Vector3,"sn":"centerOfMass"},{"a":1,"n":"col2D","t":4,"rt":$n[1].Collider2D,"sn":"col2D"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"configCenterOfMass","t":4,"rt":$n[0].Boolean,"sn":"configCenterOfMass","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"hasDone","t":4,"rt":$n[0].Boolean,"sn":"hasDone","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"hingleJoint2D","t":4,"rt":$n[1].HingeJoint2D,"sn":"hingleJoint2D"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"minusgravity","t":4,"rt":$n[0].Boolean,"sn":"minusgravity","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"ready","t":4,"rt":$n[0].Boolean,"sn":"ready","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"rigid2D","t":4,"rt":$n[1].Rigidbody2D,"sn":"rigid2D"},{"a":1,"n":"screwed","t":4,"rt":$n[0].Boolean,"sn":"screwed","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"state","t":4,"rt":$n[0].Int32,"sn":"state","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"timeCount","t":4,"rt":$n[0].Single,"sn":"timeCount","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Bar end.*/

    /*BarHole start.*/
    $m("BarHole", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"ActiveGraphic","t":8,"pi":[{"n":"active","pt":$n[0].Boolean,"ps":0}],"sn":"ActiveGraphic","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":2,"n":"Match","t":8,"pi":[{"n":"bar","pt":Bar,"ps":0}],"sn":"Match","rt":$n[0].Boolean,"p":[Bar],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"OnValidate","t":8,"sn":"OnValidate","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"bar","t":4,"rt":Bar,"sn":"bar"},{"a":1,"n":"graphic","t":4,"rt":$n[1].GameObject,"sn":"graphic"},{"a":1,"n":"spriteMask","t":4,"rt":$n[1].SpriteMask,"sn":"spriteMask"}]}; }, $n);
    /*BarHole end.*/

    /*BoardHole start.*/
    $m("BoardHole", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Reward","t":8,"sn":"Reward","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"Unlock","t":8,"sn":"Unlock","rt":$n[0].Void},{"a":2,"n":"isReward","t":4,"rt":$n[0].Boolean,"sn":"isReward","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"lockObj","t":4,"rt":$n[1].GameObject,"sn":"lockObj"},{"a":2,"n":"locked","t":4,"rt":$n[0].Boolean,"sn":"locked","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"rewardObj","t":4,"rt":$n[1].GameObject,"sn":"rewardObj"}]}; }, $n);
    /*BoardHole end.*/

    /*Bolt start.*/
    $m("Bolt", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Explosion","t":8,"sn":"Explosion","rt":$n[0].Void},{"a":2,"n":"Lock","t":8,"sn":"Lock","rt":$n[0].Void},{"a":2,"n":"MoveTo","t":8,"pi":[{"n":"boardHole","pt":BoardHole,"ps":0}],"sn":"MoveTo","rt":$n[0].Void,"p":[BoardHole]},{"a":2,"n":"MoveToCoroutine","t":8,"pi":[{"n":"boardHole","pt":$n[1].GameObject,"ps":0}],"sn":"MoveToCoroutine","rt":$n[3].IEnumerator,"p":[$n[1].GameObject]},{"a":1,"n":"OnValidate","t":8,"sn":"OnValidate","rt":$n[0].Void},{"a":2,"n":"Position","t":8,"sn":"Position","rt":$n[1].Vector3},{"a":2,"n":"Screw","t":8,"sn":"Screw","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"UnScrew","t":8,"sn":"UnScrew","rt":$n[0].Void},{"a":2,"n":"Unlock","t":8,"sn":"Unlock","rt":$n[0].Void},{"a":1,"n":"col2D","t":4,"rt":$n[1].Collider2D,"sn":"col2D"},{"a":1,"n":"count","t":4,"rt":$n[0].Int32,"sn":"count","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"hand1","t":4,"rt":$n[1].GameObject,"sn":"hand1"},{"a":2,"n":"hand1portrait","t":4,"rt":$n[1].GameObject,"sn":"hand1portrait"},{"a":2,"n":"hand2","t":4,"rt":$n[1].GameObject,"sn":"hand2"},{"a":2,"n":"handlandscape","t":4,"rt":$n[1].GameObject,"sn":"handlandscape"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":2,"n":"isFallingScrew","t":4,"rt":$n[0].Boolean,"sn":"isFallingScrew","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"isScrewed","t":4,"rt":$n[0].Boolean,"sn":"isScrewed","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"locked","t":4,"rt":$n[0].Boolean,"sn":"locked","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"meshRenderer","t":4,"rt":$n[1].MeshRenderer,"sn":"meshRenderer"},{"a":1,"n":"moveto","t":4,"rt":$n[0].Boolean,"sn":"moveto","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"newspr","t":4,"rt":$n[1].SpriteRenderer,"sn":"newspr"},{"a":2,"n":"oldspr","t":4,"rt":$n[1].SpriteRenderer,"sn":"oldspr"},{"a":1,"n":"rigid2D","t":4,"rt":$n[1].Rigidbody2D,"sn":"rigid2D"},{"a":2,"n":"screwBoard","t":4,"rt":$n[0].Boolean,"sn":"screwBoard","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"tutorial2","t":4,"rt":$n[1].GameObject,"sn":"tutorial2"}]}; }, $n);
    /*Bolt end.*/

    /*UserConfig start.*/
    $m("UserConfig", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"CanShowDailyBonus","t":8,"sn":"CanShowDailyBonus","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"HasTurnOffInternet","t":8,"sn":"HasTurnOffInternet","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"Init","t":8,"sn":"Init","rt":$n[0].Void},{"a":2,"n":"AmountBomb","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_AmountBomb","t":8,"rt":$n[0].Int32,"fg":"AmountBomb","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_AmountBomb","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"AmountBomb"},"fn":"AmountBomb"},{"a":2,"n":"AmountInter","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_AmountInter","t":8,"rt":$n[0].Int32,"fg":"AmountInter","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_AmountInter","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"AmountInter"},"fn":"AmountInter"},{"a":2,"n":"AmountScrewdrive","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_AmountScrewdrive","t":8,"rt":$n[0].Int32,"fg":"AmountScrewdrive","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_AmountScrewdrive","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"AmountScrewdrive"},"fn":"AmountScrewdrive"},{"a":2,"n":"BestLevel","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_BestLevel","t":8,"rt":$n[0].Int32,"fg":"BestLevel","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_BestLevel","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"BestLevel"},"fn":"BestLevel"},{"a":2,"n":"Coin","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Coin","t":8,"rt":$n[0].Int32,"fg":"Coin","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_Coin","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"Coin"},"fn":"Coin"},{"a":2,"n":"CurLevel","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_CurLevel","t":8,"rt":$n[0].Int32,"fg":"CurLevel","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_CurLevel","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"CurLevel"},"fn":"CurLevel"},{"a":2,"n":"DailyLogin","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_DailyLogin","t":8,"rt":$n[0].Int32,"fg":"DailyLogin","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_DailyLogin","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"DailyLogin"},"fn":"DailyLogin"},{"a":2,"n":"DayPlayed","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_DayPlayed","t":8,"rt":$n[0].Int32,"fg":"DayPlayed","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_DayPlayed","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"DayPlayed"},"fn":"DayPlayed"},{"a":2,"n":"HasAds","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_HasAds","t":8,"rt":$n[0].Boolean,"fg":"HasAds","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_HasAds","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"HasAds"},"fn":"HasAds"},{"a":2,"n":"Instance","is":true,"t":16,"rt":UserConfig,"g":{"a":2,"n":"get_Instance","t":8,"rt":UserConfig,"fg":"Instance","is":true},"fn":"Instance"},{"a":2,"n":"LevelShowRemoveAds","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_LevelShowRemoveAds","t":8,"rt":$n[0].Int32,"fg":"LevelShowRemoveAds","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_LevelShowRemoveAds","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"LevelShowRemoveAds"},"fn":"LevelShowRemoveAds"},{"a":2,"n":"Music","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Music","t":8,"rt":$n[0].Boolean,"fg":"Music","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_Music","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"Music"},"fn":"Music"},{"a":2,"n":"Rate","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Rate","t":8,"rt":$n[0].Boolean,"fg":"Rate","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_Rate","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"Rate"},"fn":"Rate"},{"a":2,"n":"RetendDay","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_RetendDay","t":8,"rt":$n[0].Int32,"fg":"RetendDay","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_RetendDay","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"RetendDay"},"fn":"RetendDay"},{"a":2,"n":"Sound","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Sound","t":8,"rt":$n[0].Boolean,"fg":"Sound","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_Sound","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"Sound"},"fn":"Sound"},{"a":2,"n":"TotalEarn","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_TotalEarn","t":8,"rt":$n[0].Int32,"fg":"TotalEarn","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_TotalEarn","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"TotalEarn"},"fn":"TotalEarn"},{"a":2,"n":"TotalSpend","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_TotalSpend","t":8,"rt":$n[0].Int32,"fg":"TotalSpend","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_TotalSpend","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"TotalSpend"},"fn":"TotalSpend"},{"a":2,"n":"Vibrate","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Vibrate","t":8,"rt":$n[0].Boolean,"fg":"Vibrate","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_Vibrate","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"Vibrate"},"fn":"Vibrate"},{"a":2,"n":"WinLevel","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_WinLevel","t":8,"rt":$n[0].Int32,"fg":"WinLevel","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_WinLevel","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"WinLevel"},"fn":"WinLevel"},{"a":1,"n":"_instance","is":true,"t":4,"rt":UserConfig,"sn":"_instance"},{"a":1,"n":"amountBomb","t":4,"rt":$n[0].Int32,"sn":"amountBomb","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"amountInter","t":4,"rt":$n[0].Int32,"sn":"amountInter","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"amountPlay","t":4,"rt":$n[0].Int32,"sn":"amountPlay","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"amountScrewdrive","t":4,"rt":$n[0].Int32,"sn":"amountScrewdrive","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"bestLevel","t":4,"rt":$n[0].Int32,"sn":"bestLevel","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"coin","t":4,"rt":$n[0].Int32,"sn":"coin","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"curLevel","t":4,"rt":$n[0].Int32,"sn":"curLevel","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"dailyLogin","t":4,"rt":$n[0].Int32,"sn":"dailyLogin","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"hasAds","t":4,"rt":$n[0].Boolean,"sn":"hasAds","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.HideInInspector()],"a":2,"n":"isLoading","t":4,"rt":$n[0].Boolean,"sn":"isLoading","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.HideInInspector()],"a":2,"n":"isNewDay","t":4,"rt":$n[0].Boolean,"sn":"isNewDay","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.HideInInspector()],"a":2,"n":"isNewUser","t":4,"rt":$n[0].Boolean,"sn":"isNewUser","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"levelShowRemoveAds","t":4,"rt":$n[0].Int32,"sn":"levelShowRemoveAds","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"music","t":4,"rt":$n[0].Boolean,"sn":"music","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"rate","t":4,"rt":$n[0].Boolean,"sn":"rate","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"sound","t":4,"rt":$n[0].Boolean,"sn":"sound","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"totalEarn","t":4,"rt":$n[0].Int32,"sn":"totalEarn","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"totalSpend","t":4,"rt":$n[0].Int32,"sn":"totalSpend","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"vibrate","t":4,"rt":$n[0].Boolean,"sn":"vibrate","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"winLevel","t":4,"rt":$n[0].Int32,"sn":"winLevel","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*UserConfig end.*/

    /*Hint start.*/
    $m("Hint", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"ActivateDeactivateObject","t":8,"sn":"ActivateDeactivateObject","rt":$n[3].IEnumerator},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":2,"n":"hasClicked","t":4,"rt":$n[0].Boolean,"sn":"hasClicked","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"targetObject","t":4,"rt":$n[1].GameObject,"sn":"targetObject"},{"a":2,"n":"tutorial","t":4,"rt":$n[1].GameObject,"sn":"tutorial"}]}; }, $n);
    /*Hint end.*/

    /*IngameTutorial start.*/
    $m("IngameTutorial", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"SetTutorial","t":8,"pi":[{"n":"active","pt":$n[0].Boolean,"ps":0},{"n":"anchorPos","pt":$n[1].Vector3,"ps":1}],"sn":"SetTutorial","rt":$n[0].Void,"p":[$n[0].Boolean,$n[1].Vector3]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":2,"n":"Instance","is":true,"t":4,"rt":IngameTutorial,"sn":"Instance"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"tutorialRect","t":4,"rt":$n[1].RectTransform,"sn":"tutorialRect"}]}; }, $n);
    /*IngameTutorial end.*/

    /*Key start.*/
    $m("Key", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Active","t":8,"sn":"Active","rt":$n[0].Void},{"a":1,"n":"actived","t":4,"rt":$n[0].Boolean,"sn":"actived","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"boardHole","t":4,"rt":BoardHole,"sn":"boardHole"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"bolt","t":4,"rt":Bolt,"sn":"bolt"},{"a":2,"n":"getItem","t":4,"rt":$n[1].AudioSource,"sn":"getItem"}]}; }, $n);
    /*Key end.*/

    /*LevelController start.*/
    $m("LevelController", function () { return {"nested":[LevelController.StateBar,LevelController.StateBolt,LevelController.StateBoardHole],"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"CheckOutMove","t":8,"sn":"CheckOutMove","rt":$n[0].Void},{"a":2,"n":"RecycleLevel","t":8,"sn":"RecycleLevel","rt":$n[0].Void},{"a":2,"n":"ScrewBar","t":8,"sn":"ScrewBar","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":1,"n":"UpdateState","t":8,"sn":"UpdateState","rt":$n[0].Void},{"a":2,"n":"Instance","is":true,"t":4,"rt":LevelController,"sn":"Instance"},{"a":1,"n":"amountBarScrewed","t":4,"rt":$n[0].Int32,"sn":"amountBarScrewed","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"bars","t":4,"rt":System.Array.type(Bar),"sn":"bars"},{"a":1,"n":"boardHoles","t":4,"rt":System.Array.type(BoardHole),"sn":"boardHoles"},{"a":1,"n":"bolts","t":4,"rt":System.Array.type(Bolt),"sn":"bolts"},{"a":2,"n":"confetti","t":4,"rt":$n[1].AudioSource,"sn":"confetti"},{"a":1,"n":"count","t":4,"rt":$n[0].Int32,"sn":"count","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"countToOpenStore","t":4,"rt":$n[0].Int32,"sn":"countToOpenStore","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"currentBolt","t":4,"rt":Bolt,"sn":"currentBolt"},{"a":1,"n":"currentHoleRw","t":4,"rt":BoardHole,"sn":"currentHoleRw"},{"a":2,"n":"firstTouch","t":4,"rt":$n[0].Boolean,"sn":"firstTouch","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"fullSlot","t":4,"rt":$n[0].Boolean,"sn":"fullSlot","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"gameOn","t":4,"rt":$n[0].Boolean,"sn":"gameOn","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"idItem","t":4,"rt":$n[0].Int32,"sn":"idItem","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"isLv2","t":4,"rt":$n[0].Boolean,"sn":"isLv2","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"isUsingItem","t":4,"rt":$n[0].Boolean,"sn":"isUsingItem","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"numScrewOnBar","t":4,"rt":$n[0].Int32,"sn":"numScrewOnBar","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"place","t":4,"rt":$n[1].AudioSource,"sn":"place"},{"a":2,"n":"reset","t":4,"rt":$n[1].GameObject,"sn":"reset"},{"a":2,"n":"select","t":4,"rt":$n[1].AudioSource,"sn":"select"},{"a":2,"n":"store","t":4,"rt":$n[1].GameObject,"sn":"store"},{"a":1,"n":"target","t":4,"rt":$n[0].Int32,"sn":"target","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"timeLim","t":4,"rt":$n[0].Single,"sn":"timeLim","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"timer","t":4,"rt":$n[0].Single,"sn":"timer","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"won","t":4,"rt":$n[0].Boolean,"sn":"won","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*LevelController end.*/

    /*LevelController+StateBar start.*/
    $m("LevelController.StateBar", function () { return {"td":LevelController,"att":1048579,"a":1,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[1].Vector2,$n[1].Vector3,$n[0].Boolean],"pi":[{"n":"pos","pt":$n[1].Vector2,"ps":0},{"n":"rotate","pt":$n[1].Vector3,"ps":1},{"n":"actived","pt":$n[0].Boolean,"ps":2}],"sn":"ctor"},{"a":2,"n":"actived","t":4,"rt":$n[0].Boolean,"sn":"actived","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"pos","t":4,"rt":$n[1].Vector2,"sn":"pos"},{"a":2,"n":"rotate","t":4,"rt":$n[1].Vector3,"sn":"rotate"}]}; }, $n);
    /*LevelController+StateBar end.*/

    /*LevelController+StateBolt start.*/
    $m("LevelController.StateBolt", function () { return {"td":LevelController,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[1].Vector2,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"pos","pt":$n[1].Vector2,"ps":0},{"n":"isLocked","pt":$n[0].Boolean,"ps":1},{"n":"actived","pt":$n[0].Boolean,"ps":2}],"sn":"ctor"},{"a":2,"n":"actived","t":4,"rt":$n[0].Boolean,"sn":"actived","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"isLocked","t":4,"rt":$n[0].Boolean,"sn":"isLocked","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"pos","t":4,"rt":$n[1].Vector2,"sn":"pos"}]}; }, $n);
    /*LevelController+StateBolt end.*/

    /*LevelController+StateBoardHole start.*/
    $m("LevelController.StateBoardHole", function () { return {"td":LevelController,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Boolean],"pi":[{"n":"isLocked","pt":$n[0].Boolean,"ps":0}],"sn":"ctor"},{"a":2,"n":"isLocked","t":4,"rt":$n[0].Boolean,"sn":"isLocked","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*LevelController+StateBoardHole end.*/

    /*LoadEndcard start.*/
    $m("LoadEndcard", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"loadscene77","t":8,"sn":"loadscene77","rt":$n[0].Void},{"a":2,"n":"ins","is":true,"t":4,"rt":LoadEndcard,"sn":"ins"}]}; }, $n);
    /*LoadEndcard end.*/

    /*GameManager start.*/
    $m("GameManager", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"EndGame","t":8,"pi":[{"n":"win","pt":$n[0].Boolean,"ps":0},{"n":"delay","dv":1.5,"o":true,"pt":$n[0].Single,"ps":1}],"sn":"EndGame","rt":$n[0].Void,"p":[$n[0].Boolean,$n[0].Single]},{"a":2,"n":"InstantiatePrefab","t":8,"pi":[{"n":"assetName","pt":$n[0].String,"ps":0}],"sn":"InstantiatePrefab","rt":$n[1].GameObject,"p":[$n[0].String]},{"a":1,"n":"LoadAsset","t":8,"pi":[{"n":"assetName","pt":$n[0].String,"ps":0}],"sn":"LoadAsset","rt":$n[1].GameObject,"p":[$n[0].String]},{"a":1,"n":"OnWin","t":8,"sn":"OnWin","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"MAX_LEVEL","is":true,"t":4,"rt":$n[0].Int32,"sn":"MAX_LEVEL","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"RADIUS_CHECK_BAR","is":true,"t":4,"rt":$n[0].Single,"sn":"RADIUS_CHECK_BAR","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.HideInInspector()],"a":2,"n":"canControl","t":4,"rt":$n[0].Boolean,"sn":"canControl","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.HideInInspector()],"a":2,"n":"count","t":4,"rt":$n[0].Int32,"sn":"count","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.HideInInspector()],"a":2,"n":"currentLevel","t":4,"rt":$n[1].GameObject,"sn":"currentLevel"},{"a":2,"n":"layerBar","t":4,"rt":$n[1].LayerMask,"sn":"layerBar"},{"a":2,"n":"layerBarHole","t":4,"rt":$n[1].LayerMask,"sn":"layerBarHole"},{"a":2,"n":"layerBoardHole","t":4,"rt":$n[1].LayerMask,"sn":"layerBoardHole"},{"at":[new UnityEngine.HeaderAttribute("Scriptable Object"),new UnityEngine.HeaderAttribute("Layer Mask")],"a":2,"n":"layerBolt","t":4,"rt":$n[1].LayerMask,"sn":"layerBolt"},{"at":[new UnityEngine.HideInInspector()],"a":2,"n":"startTime","t":4,"rt":$n[0].Single,"sn":"startTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*GameManager end.*/

    /*RopeMaterial start.*/
    $m("RopeMaterial", function () { return {"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"materials","t":4,"rt":System.Array.type(UnityEngine.Material),"sn":"materials"}]}; }, $n);
    /*RopeMaterial end.*/

    /*LoadingManager start.*/
    $m("LoadingManager", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"LoadAsyncGame","t":8,"pi":[{"n":"scene","pt":$n[0].Int32,"ps":0}],"sn":"LoadAsyncGame","rt":$n[3].IEnumerator,"p":[$n[0].Int32]},{"a":1,"n":"LoadData","t":8,"sn":"LoadData","rt":$n[0].Void},{"a":1,"n":"LoadSceneStart","t":8,"sn":"LoadSceneStart","rt":$n[3].IEnumerator},{"a":2,"n":"PressedRetryBtn","t":8,"sn":"PressedRetryBtn","rt":$n[0].Void},{"a":1,"n":"RegisterPurchaseComplete","t":8,"sn":"RegisterPurchaseComplete","rt":$n[0].Void},{"a":2,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"loadingImg","t":4,"rt":$n[4].Image,"sn":"loadingImg"},{"a":2,"n":"loadingObj","t":4,"rt":$n[1].GameObject,"sn":"loadingObj"},{"a":2,"n":"vfx","t":4,"rt":$n[1].GameObject,"sn":"vfx"}]}; }, $n);
    /*LoadingManager end.*/

    /*SoundManager start.*/
    $m("SoundManager", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"DoPlayOrderedBgm","t":8,"pi":[{"n":"music","ip":true,"pt":$n[0].Array.type(System.String),"ps":0}],"sn":"DoPlayOrderedBgm","rt":$n[3].IEnumerator,"p":[$n[0].Array.type(System.String)]},{"a":2,"n":"GetBGVol","t":8,"sn":"GetBGVol","rt":$n[0].Single,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"GetCatchedAudioClip","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"GetCatchedAudioClip","rt":$n[1].AudioClip,"p":[$n[0].String]},{"a":2,"n":"InitInstance","is":true,"t":8,"pi":[{"n":"parent","pt":$n[1].Transform,"ps":0}],"sn":"InitInstance","rt":$n[0].Void,"p":[$n[1].Transform]},{"a":1,"n":"LoadAudioHolder","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"LoadAudioHolder","rt":AudioClipsHolder,"p":[$n[0].String]},{"a":1,"n":"LoadMusicClip","t":8,"pi":[{"n":"namePath","pt":$n[0].String,"ps":0}],"sn":"LoadMusicClip","rt":$n[1].AudioClip,"p":[$n[0].String]},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"a":1,"n":"OnMusicChanged","t":8,"sn":"OnMusicChanged","rt":$n[0].Void},{"a":2,"n":"PauseSoundMedium","t":8,"sn":"PauseSoundMedium","rt":$n[0].Void},{"a":2,"n":"PlayBGMusic","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0},{"n":"loop","dv":true,"o":true,"pt":$n[0].Boolean,"ps":1},{"n":"overrideMode","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"PlayBGMusic","rt":$n[0].Void,"p":[$n[0].String,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"PlayOrderedBgm","t":8,"pi":[{"n":"music","ip":true,"pt":$n[0].Array.type(System.String),"ps":0}],"sn":"PlayOrderedBgm","rt":$n[0].Void,"p":[$n[0].Array.type(System.String)]},{"a":2,"n":"PlaySound","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0},{"n":"loop","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1},{"n":"delay","dv":0.0,"o":true,"pt":$n[0].Single,"ps":2},{"n":"volumeScale","dv":1.0,"o":true,"pt":$n[0].Single,"ps":3}],"sn":"PlaySound","rt":$n[0].Void,"p":[$n[0].String,$n[0].Boolean,$n[0].Single,$n[0].Single]},{"a":1,"n":"PlaySound","t":8,"pi":[{"n":"clip","pt":$n[1].AudioClip,"ps":0},{"n":"loop","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1},{"n":"delay","dv":0.0,"o":true,"pt":$n[0].Single,"ps":2},{"n":"volumeScale","dv":1.0,"o":true,"pt":$n[0].Single,"ps":3}],"sn":"PlaySound$1","rt":$n[0].Void,"p":[$n[1].AudioClip,$n[0].Boolean,$n[0].Single,$n[0].Single]},{"a":1,"n":"PlaySoundDelay","t":8,"pi":[{"n":"clip","pt":$n[1].AudioClip,"ps":0},{"n":"delay","dv":0.0,"o":true,"pt":$n[0].Single,"ps":1},{"n":"volumeScale","dv":1.0,"o":true,"pt":$n[0].Single,"ps":2}],"sn":"PlaySoundDelay","rt":$n[3].IEnumerator,"p":[$n[1].AudioClip,$n[0].Single,$n[0].Single]},{"a":2,"n":"PlaySoundMedium","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0},{"n":"loop","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1},{"n":"volumeScale","dv":1.0,"o":true,"pt":$n[0].Single,"ps":2}],"sn":"PlaySoundMedium","rt":$n[0].Void,"p":[$n[0].String,$n[0].Boolean,$n[0].Single]},{"a":2,"n":"ResumeBGMusic","t":8,"sn":"ResumeBGMusic","rt":$n[0].Void},{"a":2,"n":"SetBGVol","t":8,"pi":[{"n":"vol","pt":$n[0].Single,"ps":0}],"sn":"SetBGVol","rt":$n[0].Void,"p":[$n[0].Single]},{"a":1,"n":"SetStartTime","t":8,"pi":[{"n":"audio","pt":$n[0].Int32,"ps":0}],"sn":"SetStartTime","rt":$n[0].Boolean,"p":[$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"StopBGMusic","t":8,"sn":"StopBGMusic","rt":$n[0].Void},{"a":1,"n":"StopOrderedBgm","t":8,"sn":"StopOrderedBgm","rt":$n[0].Void},{"a":2,"n":"StopSoundMedium","t":8,"sn":"StopSoundMedium","rt":$n[0].Void},{"a":2,"n":"UnpauseSoundMedium","t":8,"sn":"UnpauseSoundMedium","rt":$n[0].Void},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":1,"n":"MIN_INTERVAL","is":true,"t":4,"rt":$n[0].Single,"sn":"MIN_INTERVAL","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"_startTimes","t":4,"rt":$n[2].Dictionary$2(System.Int32,System.Single),"sn":"_startTimes"},{"a":1,"n":"audioClipHolder","t":4,"rt":AudioClipsHolder,"sn":"audioClipHolder"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"bgMusic","t":4,"rt":$n[1].AudioSource,"sn":"bgMusic"},{"a":1,"n":"bgMusicName","t":4,"rt":$n[0].String,"sn":"bgMusicName"},{"a":1,"n":"fadeInOutTime","t":4,"rt":$n[0].Single,"sn":"fadeInOutTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"fadeInOutTimeMax","t":4,"rt":$n[0].Single,"sn":"fadeInOutTimeMax","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"fadeInning","t":4,"rt":$n[0].Boolean,"sn":"fadeInning","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"fadeOuting","t":4,"rt":$n[0].Boolean,"sn":"fadeOuting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"instance","is":true,"t":4,"rt":SoundManager,"sn":"instance"},{"a":1,"n":"orderBgm","t":4,"rt":$n[3].IEnumerator,"sn":"orderBgm"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"sound","t":4,"rt":$n[1].AudioSource,"sn":"sound"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"sound_medium","t":4,"rt":$n[1].AudioSource,"sn":"sound_medium"},{"a":1,"n":"volume","t":4,"rt":$n[0].Single,"sn":"volume","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*SoundManager end.*/

    /*Saw start.*/
    $m("Saw", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"DeactiveAnimation","t":8,"sn":"DeactiveAnimation","rt":$n[0].Void},{"a":1,"n":"OnTriggerEnter2D","t":8,"pi":[{"n":"collision","pt":$n[1].Collider2D,"ps":0}],"sn":"OnTriggerEnter2D","rt":$n[0].Void,"p":[$n[1].Collider2D]},{"a":1,"n":"OnTriggerExit2D","t":8,"pi":[{"n":"collision","pt":$n[1].Collider2D,"ps":0}],"sn":"OnTriggerExit2D","rt":$n[0].Void,"p":[$n[1].Collider2D]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"active","t":4,"rt":$n[0].Boolean,"sn":"active","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"animation","t":4,"rt":$n[5].SkeletonAnimation,"sn":"animation"},{"a":1,"n":"countTrigger","t":4,"rt":$n[0].Int32,"sn":"countTrigger","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"graphic","t":4,"rt":$n[1].SpriteRenderer,"sn":"graphic"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"visualTrans","t":4,"rt":$n[1].Transform,"sn":"visualTrans"}]}; }, $n);
    /*Saw end.*/

    /*store start.*/
    $m("store", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"click","t":8,"sn":"click","rt":$n[0].Void}]}; }, $n);
    /*store end.*/

    /*AnimatedButton start.*/
    $m("AnimatedButton", function () { return {"nested":[AnimatedButton.ButtonClickedEvent],"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"OnClickAction","t":8,"sn":"OnClickAction","rt":$n[0].Void},{"a":2,"n":"OnPointerClick","t":8,"pi":[{"n":"eventData","pt":$n[6].PointerEventData,"ps":0}],"sn":"OnPointerClick","rt":$n[0].Void,"p":[$n[6].PointerEventData]},{"v":true,"a":2,"n":"OnPointerDown","t":8,"pi":[{"n":"eventData","pt":$n[6].PointerEventData,"ps":0}],"sn":"OnPointerDown","rt":$n[0].Void,"p":[$n[6].PointerEventData]},{"a":2,"n":"OnPointerUp","t":8,"pi":[{"n":"eventData","pt":$n[6].PointerEventData,"ps":0}],"sn":"OnPointerUp","rt":$n[0].Void,"p":[$n[6].PointerEventData]},{"a":1,"n":"Press","t":8,"sn":"Press","rt":$n[0].Void},{"a":2,"n":"onClick","t":16,"rt":AnimatedButton.ButtonClickedEvent,"g":{"a":2,"n":"get_onClick","t":8,"rt":AnimatedButton.ButtonClickedEvent,"fg":"onClick"},"s":{"a":2,"n":"set_onClick","t":8,"p":[AnimatedButton.ButtonClickedEvent],"rt":$n[0].Void,"fs":"onClick"},"fn":"onClick"},{"a":2,"n":"interactable","t":4,"rt":$n[0].Boolean,"sn":"interactable","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"isCLicked","t":4,"rt":$n[0].Boolean,"sn":"isCLicked","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_OnClick","t":4,"rt":AnimatedButton.ButtonClickedEvent,"sn":"m_OnClick"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"tf","t":4,"rt":$n[1].Transform,"sn":"tf"}]}; }, $n);
    /*AnimatedButton end.*/

    /*AnimatedButton+ButtonClickedEvent start.*/
    $m("AnimatedButton.ButtonClickedEvent", function () { return {"td":AnimatedButton,"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*AnimatedButton+ButtonClickedEvent end.*/

    /*AutoDestroy start.*/
    $m("AutoDestroy", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"DestroyObj","t":8,"sn":"DestroyObj","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"delay","t":4,"rt":$n[0].Single,"sn":"delay","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*AutoDestroy end.*/

    /*CameraDistanceConfig start.*/
    $m("CameraDistanceConfig", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"ResizeCamera","t":8,"sn":"ResizeCamera","rt":$n[0].Void},{"a":2,"n":"SaveData","t":8,"sn":"SaveData","rt":$n[0].Void},{"a":2,"n":"configCameraSizes","t":4,"rt":$n[2].List$1(ConfigCameraSize),"sn":"configCameraSizes"},{"a":2,"n":"mainCamera","t":4,"rt":$n[1].Camera,"sn":"mainCamera"}]}; }, $n);
    /*CameraDistanceConfig end.*/

    /*ConfigCameraSize start.*/
    $m("ConfigCameraSize", function () { return {"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"ratio","t":4,"rt":$n[0].Single,"sn":"ratio","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"size","t":4,"rt":$n[0].Single,"sn":"size","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*ConfigCameraSize end.*/

    /*CameraResize start.*/
    $m("CameraResize", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"ResizeCamera","t":8,"pi":[{"n":"defaultSize","pt":$n[0].Single,"ps":0}],"sn":"ResizeCamera","rt":$n[0].Void,"p":[$n[0].Single]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void}]}; }, $n);
    /*CameraResize end.*/

    /*GameplayVariables start.*/
    $m("GameplayVariables", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"amountBomb","is":true,"t":4,"rt":$n[0].String,"sn":"amountBomb"},{"a":2,"n":"amountInter","is":true,"t":4,"rt":$n[0].String,"sn":"amountInter"},{"a":2,"n":"amountScrewdrive","is":true,"t":4,"rt":$n[0].String,"sn":"amountScrewdrive"},{"a":2,"n":"bestLevel","is":true,"t":4,"rt":$n[0].String,"sn":"bestLevel"},{"a":2,"n":"coin","is":true,"t":4,"rt":$n[0].String,"sn":"coin"},{"a":2,"n":"dailyLogin","is":true,"t":4,"rt":$n[0].String,"sn":"dailyLogin"},{"a":2,"n":"dayPlayed","is":true,"t":4,"rt":$n[0].String,"sn":"dayPlayed"},{"a":2,"n":"hasAds","is":true,"t":4,"rt":$n[0].String,"sn":"hasAds"},{"a":2,"n":"lastTimeOpen","is":true,"t":4,"rt":$n[0].String,"sn":"lastTimeOpen"},{"a":2,"n":"levelShowRemoveAds","is":true,"t":4,"rt":$n[0].String,"sn":"levelShowRemoveAds"},{"a":2,"n":"music","is":true,"t":4,"rt":$n[0].String,"sn":"music"},{"a":2,"n":"rate","is":true,"t":4,"rt":$n[0].String,"sn":"rate"},{"a":2,"n":"retendDay","is":true,"t":4,"rt":$n[0].String,"sn":"retendDay"},{"a":2,"n":"skinOwned","is":true,"t":4,"rt":$n[0].String,"sn":"skinOwned"},{"a":2,"n":"skinReward","is":true,"t":4,"rt":$n[0].String,"sn":"skinReward"},{"a":2,"n":"skinUsing","is":true,"t":4,"rt":$n[0].String,"sn":"skinUsing"},{"a":2,"n":"sound","is":true,"t":4,"rt":$n[0].String,"sn":"sound"},{"a":2,"n":"totalEarn","is":true,"t":4,"rt":$n[0].String,"sn":"totalEarn"},{"a":2,"n":"totalSpend","is":true,"t":4,"rt":$n[0].String,"sn":"totalSpend"},{"a":2,"n":"tutUseBomb","is":true,"t":4,"rt":$n[0].String,"sn":"tutUseBomb"},{"a":2,"n":"tutUseScrewdrive","is":true,"t":4,"rt":$n[0].String,"sn":"tutUseScrewdrive"},{"a":2,"n":"vibrate","is":true,"t":4,"rt":$n[0].String,"sn":"vibrate"},{"a":2,"n":"winLevel","is":true,"t":4,"rt":$n[0].String,"sn":"winLevel"}]}; }, $n);
    /*GameplayVariables end.*/

    /*ObjectPool start.*/
    $m("ObjectPool", function () { return {"nested":[ObjectPool.StartupPoolMode,ObjectPool.StartupPool],"att":1048833,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"CountAllPooled","is":true,"t":8,"sn":"CountAllPooled","rt":$n[0].Int32,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"CountPooled","is":true,"t":8,"pi":[{"n":"prefab","pt":System.Object,"ps":0}],"tpc":1,"tprm":["T"],"sn":"CountPooled$1","rt":$n[0].Int32,"p":[System.Object],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"CountPooled","is":true,"t":8,"pi":[{"n":"prefab","pt":$n[1].GameObject,"ps":0}],"sn":"CountPooled","rt":$n[0].Int32,"p":[$n[1].GameObject],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"CountSpawned","is":true,"t":8,"pi":[{"n":"prefab","pt":System.Object,"ps":0}],"tpc":1,"tprm":["T"],"sn":"CountSpawned$1","rt":$n[0].Int32,"p":[System.Object],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"CountSpawned","is":true,"t":8,"pi":[{"n":"prefab","pt":$n[1].GameObject,"ps":0}],"sn":"CountSpawned","rt":$n[0].Int32,"p":[$n[1].GameObject],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"CreatePool","is":true,"t":8,"pi":[{"n":"prefab","pt":System.Object,"ps":0},{"n":"initialPoolSize","pt":$n[0].Int32,"ps":1}],"tpc":1,"tprm":["T"],"sn":"CreatePool$1","rt":$n[0].Void,"p":[System.Object,$n[0].Int32]},{"a":2,"n":"CreatePool","is":true,"t":8,"pi":[{"n":"prefab","pt":$n[1].GameObject,"ps":0},{"n":"initialPoolSize","pt":$n[0].Int32,"ps":1}],"sn":"CreatePool","rt":$n[0].Void,"p":[$n[1].GameObject,$n[0].Int32]},{"a":2,"n":"CreateStartupPools","is":true,"t":8,"sn":"CreateStartupPools","rt":$n[0].Void},{"a":2,"n":"DestroyAll","is":true,"t":8,"pi":[{"n":"prefab","pt":System.Object,"ps":0}],"tpc":1,"tprm":["T"],"sn":"DestroyAll$1","rt":$n[0].Void,"p":[System.Object]},{"a":2,"n":"DestroyAll","is":true,"t":8,"pi":[{"n":"prefab","pt":$n[1].GameObject,"ps":0}],"sn":"DestroyAll","rt":$n[0].Void,"p":[$n[1].GameObject]},{"a":2,"n":"DestroyPooled","is":true,"t":8,"pi":[{"n":"prefab","pt":System.Object,"ps":0}],"tpc":1,"tprm":["T"],"sn":"DestroyPooled$1","rt":$n[0].Void,"p":[System.Object]},{"a":2,"n":"DestroyPooled","is":true,"t":8,"pi":[{"n":"prefab","pt":$n[1].GameObject,"ps":0}],"sn":"DestroyPooled","rt":$n[0].Void,"p":[$n[1].GameObject]},{"a":2,"n":"GetPooled","is":true,"t":8,"pi":[{"n":"prefab","pt":System.Object,"ps":0},{"n":"list","pt":$n[2].List$1(System.Object),"ps":1},{"n":"appendList","pt":$n[0].Boolean,"ps":2}],"tpc":1,"tprm":["T"],"sn":"GetPooled","rt":$n[2].List$1(System.Object),"p":[System.Object,$n[2].List$1(System.Object),$n[0].Boolean]},{"a":2,"n":"GetPooled","is":true,"t":8,"pi":[{"n":"prefab","pt":$n[1].GameObject,"ps":0},{"n":"list","pt":$n[2].List$1(UnityEngine.GameObject),"ps":1},{"n":"appendList","pt":$n[0].Boolean,"ps":2}],"sn":"GetPooled$1","rt":$n[2].List$1(UnityEngine.GameObject),"p":[$n[1].GameObject,$n[2].List$1(UnityEngine.GameObject),$n[0].Boolean]},{"a":2,"n":"GetSpawned","is":true,"t":8,"pi":[{"n":"prefab","pt":System.Object,"ps":0},{"n":"list","pt":$n[2].List$1(System.Object),"ps":1},{"n":"appendList","pt":$n[0].Boolean,"ps":2}],"tpc":1,"tprm":["T"],"sn":"GetSpawned","rt":$n[2].List$1(System.Object),"p":[System.Object,$n[2].List$1(System.Object),$n[0].Boolean]},{"a":2,"n":"GetSpawned","is":true,"t":8,"pi":[{"n":"prefab","pt":$n[1].GameObject,"ps":0},{"n":"list","pt":$n[2].List$1(UnityEngine.GameObject),"ps":1},{"n":"appendList","pt":$n[0].Boolean,"ps":2}],"sn":"GetSpawned$1","rt":$n[2].List$1(UnityEngine.GameObject),"p":[$n[1].GameObject,$n[2].List$1(UnityEngine.GameObject),$n[0].Boolean]},{"a":2,"n":"IsSpawned","is":true,"t":8,"pi":[{"n":"obj","pt":$n[1].GameObject,"ps":0}],"sn":"IsSpawned","rt":$n[0].Boolean,"p":[$n[1].GameObject],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"Recycle","is":true,"t":8,"pi":[{"n":"obj","pt":System.Object,"ps":0}],"tpc":1,"tprm":["T"],"sn":"Recycle$1","rt":$n[0].Void,"p":[System.Object]},{"a":2,"n":"Recycle","is":true,"t":8,"pi":[{"n":"obj","pt":$n[1].GameObject,"ps":0}],"sn":"Recycle","rt":$n[0].Void,"p":[$n[1].GameObject]},{"a":1,"n":"Recycle","is":true,"t":8,"pi":[{"n":"obj","pt":$n[1].GameObject,"ps":0},{"n":"prefab","pt":$n[1].GameObject,"ps":1}],"sn":"Recycle$2","rt":$n[0].Void,"p":[$n[1].GameObject,$n[1].GameObject]},{"a":2,"n":"RecycleAll","is":true,"t":8,"sn":"RecycleAll","rt":$n[0].Void},{"a":2,"n":"RecycleAll","is":true,"t":8,"pi":[{"n":"prefab","pt":System.Object,"ps":0}],"tpc":1,"tprm":["T"],"sn":"RecycleAll$2","rt":$n[0].Void,"p":[System.Object]},{"a":2,"n":"RecycleAll","is":true,"t":8,"pi":[{"n":"prefab","pt":$n[1].GameObject,"ps":0}],"sn":"RecycleAll$1","rt":$n[0].Void,"p":[$n[1].GameObject]},{"a":2,"n":"Spawn","is":true,"t":8,"pi":[{"n":"prefab","pt":System.Object,"ps":0}],"tpc":1,"tprm":["T"],"sn":"Spawn","rt":System.Object,"p":[System.Object]},{"a":2,"n":"Spawn","is":true,"t":8,"pi":[{"n":"prefab","pt":$n[1].GameObject,"ps":0}],"sn":"Spawn$6","rt":$n[1].GameObject,"p":[$n[1].GameObject]},{"a":2,"n":"Spawn","is":true,"t":8,"pi":[{"n":"prefab","pt":System.Object,"ps":0},{"n":"parent","pt":$n[1].Transform,"ps":1}],"tpc":1,"tprm":["T"],"sn":"Spawn$1","rt":System.Object,"p":[System.Object,$n[1].Transform]},{"a":2,"n":"Spawn","is":true,"t":8,"pi":[{"n":"prefab","pt":System.Object,"ps":0},{"n":"position","pt":$n[1].Vector3,"ps":1}],"tpc":1,"tprm":["T"],"sn":"Spawn$4","rt":System.Object,"p":[System.Object,$n[1].Vector3]},{"a":2,"n":"Spawn","is":true,"t":8,"pi":[{"n":"prefab","pt":$n[1].GameObject,"ps":0},{"n":"parent","pt":$n[1].Transform,"ps":1}],"sn":"Spawn$7","rt":$n[1].GameObject,"p":[$n[1].GameObject,$n[1].Transform]},{"a":2,"n":"Spawn","is":true,"t":8,"pi":[{"n":"prefab","pt":$n[1].GameObject,"ps":0},{"n":"position","pt":$n[1].Vector3,"ps":1}],"sn":"Spawn$10","rt":$n[1].GameObject,"p":[$n[1].GameObject,$n[1].Vector3]},{"a":2,"n":"Spawn","is":true,"t":8,"pi":[{"n":"prefab","pt":System.Object,"ps":0},{"n":"parent","pt":$n[1].Transform,"ps":1},{"n":"position","pt":$n[1].Vector3,"ps":2}],"tpc":1,"tprm":["T"],"sn":"Spawn$2","rt":System.Object,"p":[System.Object,$n[1].Transform,$n[1].Vector3]},{"a":2,"n":"Spawn","is":true,"t":8,"pi":[{"n":"prefab","pt":System.Object,"ps":0},{"n":"position","pt":$n[1].Vector3,"ps":1},{"n":"rotation","pt":$n[1].Quaternion,"ps":2}],"tpc":1,"tprm":["T"],"sn":"Spawn$5","rt":System.Object,"p":[System.Object,$n[1].Vector3,$n[1].Quaternion]},{"a":2,"n":"Spawn","is":true,"t":8,"pi":[{"n":"prefab","pt":$n[1].GameObject,"ps":0},{"n":"parent","pt":$n[1].Transform,"ps":1},{"n":"position","pt":$n[1].Vector3,"ps":2}],"sn":"Spawn$8","rt":$n[1].GameObject,"p":[$n[1].GameObject,$n[1].Transform,$n[1].Vector3]},{"a":2,"n":"Spawn","is":true,"t":8,"pi":[{"n":"prefab","pt":$n[1].GameObject,"ps":0},{"n":"position","pt":$n[1].Vector3,"ps":1},{"n":"rotation","pt":$n[1].Quaternion,"ps":2}],"sn":"Spawn$11","rt":$n[1].GameObject,"p":[$n[1].GameObject,$n[1].Vector3,$n[1].Quaternion]},{"a":2,"n":"Spawn","is":true,"t":8,"pi":[{"n":"prefab","pt":System.Object,"ps":0},{"n":"parent","pt":$n[1].Transform,"ps":1},{"n":"position","pt":$n[1].Vector3,"ps":2},{"n":"rotation","pt":$n[1].Quaternion,"ps":3}],"tpc":1,"tprm":["T"],"sn":"Spawn$3","rt":System.Object,"p":[System.Object,$n[1].Transform,$n[1].Vector3,$n[1].Quaternion]},{"a":2,"n":"Spawn","is":true,"t":8,"pi":[{"n":"prefab","pt":$n[1].GameObject,"ps":0},{"n":"parent","pt":$n[1].Transform,"ps":1},{"n":"position","pt":$n[1].Vector3,"ps":2},{"n":"rotation","pt":$n[1].Quaternion,"ps":3}],"sn":"Spawn$9","rt":$n[1].GameObject,"p":[$n[1].GameObject,$n[1].Transform,$n[1].Vector3,$n[1].Quaternion]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"instance","is":true,"t":16,"rt":ObjectPool,"g":{"a":2,"n":"get_instance","t":8,"rt":ObjectPool,"fg":"instance","is":true},"fn":"instance"},{"a":1,"n":"_instance","is":true,"t":4,"rt":ObjectPool,"sn":"_instance"},{"a":1,"n":"pooledObjects","t":4,"rt":$n[2].Dictionary$2(UnityEngine.GameObject,System.Collections.Generic.List$1(UnityEngine.GameObject)),"sn":"pooledObjects"},{"a":1,"n":"spawnedObjects","t":4,"rt":$n[2].Dictionary$2(UnityEngine.GameObject,UnityEngine.GameObject),"sn":"spawnedObjects"},{"a":2,"n":"startupPoolMode","t":4,"rt":ObjectPool.StartupPoolMode,"sn":"startupPoolMode","box":function ($v) { return Bridge.box($v, ObjectPool.StartupPoolMode, System.Enum.toStringFn(ObjectPool.StartupPoolMode));}},{"a":2,"n":"startupPools","t":4,"rt":System.Array.type(ObjectPool.StartupPool),"sn":"startupPools"},{"a":1,"n":"startupPoolsCreated","t":4,"rt":$n[0].Boolean,"sn":"startupPoolsCreated","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"tempList","is":true,"t":4,"rt":$n[2].List$1(UnityEngine.GameObject),"sn":"tempList"}]}; }, $n);
    /*ObjectPool end.*/

    /*ObjectPool+StartupPoolMode start.*/
    $m("ObjectPool.StartupPoolMode", function () { return {"td":ObjectPool,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Awake","is":true,"t":4,"rt":ObjectPool.StartupPoolMode,"sn":"Awake","box":function ($v) { return Bridge.box($v, ObjectPool.StartupPoolMode, System.Enum.toStringFn(ObjectPool.StartupPoolMode));}},{"a":2,"n":"CallManually","is":true,"t":4,"rt":ObjectPool.StartupPoolMode,"sn":"CallManually","box":function ($v) { return Bridge.box($v, ObjectPool.StartupPoolMode, System.Enum.toStringFn(ObjectPool.StartupPoolMode));}},{"a":2,"n":"Start","is":true,"t":4,"rt":ObjectPool.StartupPoolMode,"sn":"Start","box":function ($v) { return Bridge.box($v, ObjectPool.StartupPoolMode, System.Enum.toStringFn(ObjectPool.StartupPoolMode));}}]}; }, $n);
    /*ObjectPool+StartupPoolMode end.*/

    /*ObjectPool+StartupPool start.*/
    $m("ObjectPool.StartupPool", function () { return {"td":ObjectPool,"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"prefab","t":4,"rt":$n[1].GameObject,"sn":"prefab"},{"a":2,"n":"size","t":4,"rt":$n[0].Int32,"sn":"size","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*ObjectPool+StartupPool end.*/

    /*ObjectPoolExtensions start.*/
    $m("ObjectPoolExtensions", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"CountPooled","is":true,"t":8,"pi":[{"n":"prefab","pt":System.Object,"ps":0}],"tpc":1,"tprm":["T"],"sn":"CountPooled$1","rt":$n[0].Int32,"p":[System.Object],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"CountPooled","is":true,"t":8,"pi":[{"n":"prefab","pt":$n[1].GameObject,"ps":0}],"sn":"CountPooled","rt":$n[0].Int32,"p":[$n[1].GameObject],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"CountSpawned","is":true,"t":8,"pi":[{"n":"prefab","pt":System.Object,"ps":0}],"tpc":1,"tprm":["T"],"sn":"CountSpawned$1","rt":$n[0].Int32,"p":[System.Object],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"CountSpawned","is":true,"t":8,"pi":[{"n":"prefab","pt":$n[1].GameObject,"ps":0}],"sn":"CountSpawned","rt":$n[0].Int32,"p":[$n[1].GameObject],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"CreatePool","is":true,"t":8,"pi":[{"n":"prefab","pt":System.Object,"ps":0}],"tpc":1,"tprm":["T"],"sn":"CreatePool$2","rt":$n[0].Void,"p":[System.Object]},{"a":2,"n":"CreatePool","is":true,"t":8,"pi":[{"n":"prefab","pt":$n[1].GameObject,"ps":0}],"sn":"CreatePool","rt":$n[0].Void,"p":[$n[1].GameObject]},{"a":2,"n":"CreatePool","is":true,"t":8,"pi":[{"n":"prefab","pt":System.Object,"ps":0},{"n":"initialPoolSize","pt":$n[0].Int32,"ps":1}],"tpc":1,"tprm":["T"],"sn":"CreatePool$3","rt":$n[0].Void,"p":[System.Object,$n[0].Int32]},{"a":2,"n":"CreatePool","is":true,"t":8,"pi":[{"n":"prefab","pt":$n[1].GameObject,"ps":0},{"n":"initialPoolSize","pt":$n[0].Int32,"ps":1}],"sn":"CreatePool$1","rt":$n[0].Void,"p":[$n[1].GameObject,$n[0].Int32]},{"a":2,"n":"DestroyAll","is":true,"t":8,"pi":[{"n":"prefab","pt":System.Object,"ps":0}],"tpc":1,"tprm":["T"],"sn":"DestroyAll$1","rt":$n[0].Void,"p":[System.Object]},{"a":2,"n":"DestroyAll","is":true,"t":8,"pi":[{"n":"prefab","pt":$n[1].GameObject,"ps":0}],"sn":"DestroyAll","rt":$n[0].Void,"p":[$n[1].GameObject]},{"a":2,"n":"DestroyPooled","is":true,"t":8,"pi":[{"n":"prefab","pt":System.Object,"ps":0}],"tpc":1,"tprm":["T"],"sn":"DestroyPooled$1","rt":$n[0].Void,"p":[System.Object]},{"a":2,"n":"DestroyPooled","is":true,"t":8,"pi":[{"n":"prefab","pt":$n[1].GameObject,"ps":0}],"sn":"DestroyPooled","rt":$n[0].Void,"p":[$n[1].GameObject]},{"a":2,"n":"GetPooled","is":true,"t":8,"pi":[{"n":"prefab","pt":System.Object,"ps":0}],"tpc":1,"tprm":["T"],"sn":"GetPooled","rt":$n[2].List$1(System.Object),"p":[System.Object]},{"a":2,"n":"GetPooled","is":true,"t":8,"pi":[{"n":"prefab","pt":$n[1].GameObject,"ps":0}],"sn":"GetPooled$3","rt":$n[2].List$1(UnityEngine.GameObject),"p":[$n[1].GameObject]},{"a":2,"n":"GetPooled","is":true,"t":8,"pi":[{"n":"prefab","pt":System.Object,"ps":0},{"n":"list","pt":$n[2].List$1(System.Object),"ps":1}],"tpc":1,"tprm":["T"],"sn":"GetPooled$1","rt":$n[2].List$1(System.Object),"p":[System.Object,$n[2].List$1(System.Object)]},{"a":2,"n":"GetPooled","is":true,"t":8,"pi":[{"n":"prefab","pt":$n[1].GameObject,"ps":0},{"n":"list","pt":$n[2].List$1(UnityEngine.GameObject),"ps":1}],"sn":"GetPooled$4","rt":$n[2].List$1(UnityEngine.GameObject),"p":[$n[1].GameObject,$n[2].List$1(UnityEngine.GameObject)]},{"a":2,"n":"GetPooled","is":true,"t":8,"pi":[{"n":"prefab","pt":System.Object,"ps":0},{"n":"list","pt":$n[2].List$1(System.Object),"ps":1},{"n":"appendList","pt":$n[0].Boolean,"ps":2}],"tpc":1,"tprm":["T"],"sn":"GetPooled$2","rt":$n[2].List$1(System.Object),"p":[System.Object,$n[2].List$1(System.Object),$n[0].Boolean]},{"a":2,"n":"GetPooled","is":true,"t":8,"pi":[{"n":"prefab","pt":$n[1].GameObject,"ps":0},{"n":"list","pt":$n[2].List$1(UnityEngine.GameObject),"ps":1},{"n":"appendList","pt":$n[0].Boolean,"ps":2}],"sn":"GetPooled$5","rt":$n[2].List$1(UnityEngine.GameObject),"p":[$n[1].GameObject,$n[2].List$1(UnityEngine.GameObject),$n[0].Boolean]},{"a":2,"n":"GetSpawned","is":true,"t":8,"pi":[{"n":"prefab","pt":System.Object,"ps":0}],"tpc":1,"tprm":["T"],"sn":"GetSpawned","rt":$n[2].List$1(System.Object),"p":[System.Object]},{"a":2,"n":"GetSpawned","is":true,"t":8,"pi":[{"n":"prefab","pt":$n[1].GameObject,"ps":0}],"sn":"GetSpawned$3","rt":$n[2].List$1(UnityEngine.GameObject),"p":[$n[1].GameObject]},{"a":2,"n":"GetSpawned","is":true,"t":8,"pi":[{"n":"prefab","pt":System.Object,"ps":0},{"n":"list","pt":$n[2].List$1(System.Object),"ps":1}],"tpc":1,"tprm":["T"],"sn":"GetSpawned$1","rt":$n[2].List$1(System.Object),"p":[System.Object,$n[2].List$1(System.Object)]},{"a":2,"n":"GetSpawned","is":true,"t":8,"pi":[{"n":"prefab","pt":$n[1].GameObject,"ps":0},{"n":"list","pt":$n[2].List$1(UnityEngine.GameObject),"ps":1}],"sn":"GetSpawned$4","rt":$n[2].List$1(UnityEngine.GameObject),"p":[$n[1].GameObject,$n[2].List$1(UnityEngine.GameObject)]},{"a":2,"n":"GetSpawned","is":true,"t":8,"pi":[{"n":"prefab","pt":System.Object,"ps":0},{"n":"list","pt":$n[2].List$1(System.Object),"ps":1},{"n":"appendList","pt":$n[0].Boolean,"ps":2}],"tpc":1,"tprm":["T"],"sn":"GetSpawned$2","rt":$n[2].List$1(System.Object),"p":[System.Object,$n[2].List$1(System.Object),$n[0].Boolean]},{"a":2,"n":"GetSpawned","is":true,"t":8,"pi":[{"n":"prefab","pt":$n[1].GameObject,"ps":0},{"n":"list","pt":$n[2].List$1(UnityEngine.GameObject),"ps":1},{"n":"appendList","pt":$n[0].Boolean,"ps":2}],"sn":"GetSpawned$5","rt":$n[2].List$1(UnityEngine.GameObject),"p":[$n[1].GameObject,$n[2].List$1(UnityEngine.GameObject),$n[0].Boolean]},{"a":2,"n":"Recycle","is":true,"t":8,"pi":[{"n":"obj","pt":System.Object,"ps":0}],"tpc":1,"tprm":["T"],"sn":"Recycle$1","rt":$n[0].Void,"p":[System.Object]},{"a":2,"n":"Recycle","is":true,"t":8,"pi":[{"n":"obj","pt":$n[1].GameObject,"ps":0}],"sn":"Recycle","rt":$n[0].Void,"p":[$n[1].GameObject]},{"a":2,"n":"RecycleAll","is":true,"t":8,"pi":[{"n":"prefab","pt":System.Object,"ps":0}],"tpc":1,"tprm":["T"],"sn":"RecycleAll$1","rt":$n[0].Void,"p":[System.Object]},{"a":2,"n":"RecycleAll","is":true,"t":8,"pi":[{"n":"prefab","pt":$n[1].GameObject,"ps":0}],"sn":"RecycleAll","rt":$n[0].Void,"p":[$n[1].GameObject]},{"a":2,"n":"Spawn","is":true,"t":8,"pi":[{"n":"prefab","pt":System.Object,"ps":0}],"tpc":1,"tprm":["T"],"sn":"Spawn","rt":System.Object,"p":[System.Object]},{"a":2,"n":"Spawn","is":true,"t":8,"pi":[{"n":"prefab","pt":$n[1].GameObject,"ps":0}],"sn":"Spawn$6","rt":$n[1].GameObject,"p":[$n[1].GameObject]},{"a":2,"n":"Spawn","is":true,"t":8,"pi":[{"n":"prefab","pt":System.Object,"ps":0},{"n":"parent","pt":$n[1].Transform,"ps":1}],"tpc":1,"tprm":["T"],"sn":"Spawn$1","rt":System.Object,"p":[System.Object,$n[1].Transform]},{"a":2,"n":"Spawn","is":true,"t":8,"pi":[{"n":"prefab","pt":System.Object,"ps":0},{"n":"position","pt":$n[1].Vector3,"ps":1}],"tpc":1,"tprm":["T"],"sn":"Spawn$4","rt":System.Object,"p":[System.Object,$n[1].Vector3]},{"a":2,"n":"Spawn","is":true,"t":8,"pi":[{"n":"prefab","pt":$n[1].GameObject,"ps":0},{"n":"parent","pt":$n[1].Transform,"ps":1}],"sn":"Spawn$7","rt":$n[1].GameObject,"p":[$n[1].GameObject,$n[1].Transform]},{"a":2,"n":"Spawn","is":true,"t":8,"pi":[{"n":"prefab","pt":$n[1].GameObject,"ps":0},{"n":"position","pt":$n[1].Vector3,"ps":1}],"sn":"Spawn$10","rt":$n[1].GameObject,"p":[$n[1].GameObject,$n[1].Vector3]},{"a":2,"n":"Spawn","is":true,"t":8,"pi":[{"n":"prefab","pt":System.Object,"ps":0},{"n":"parent","pt":$n[1].Transform,"ps":1},{"n":"position","pt":$n[1].Vector3,"ps":2}],"tpc":1,"tprm":["T"],"sn":"Spawn$2","rt":System.Object,"p":[System.Object,$n[1].Transform,$n[1].Vector3]},{"a":2,"n":"Spawn","is":true,"t":8,"pi":[{"n":"prefab","pt":System.Object,"ps":0},{"n":"position","pt":$n[1].Vector3,"ps":1},{"n":"rotation","pt":$n[1].Quaternion,"ps":2}],"tpc":1,"tprm":["T"],"sn":"Spawn$5","rt":System.Object,"p":[System.Object,$n[1].Vector3,$n[1].Quaternion]},{"a":2,"n":"Spawn","is":true,"t":8,"pi":[{"n":"prefab","pt":$n[1].GameObject,"ps":0},{"n":"parent","pt":$n[1].Transform,"ps":1},{"n":"position","pt":$n[1].Vector3,"ps":2}],"sn":"Spawn$8","rt":$n[1].GameObject,"p":[$n[1].GameObject,$n[1].Transform,$n[1].Vector3]},{"a":2,"n":"Spawn","is":true,"t":8,"pi":[{"n":"prefab","pt":$n[1].GameObject,"ps":0},{"n":"position","pt":$n[1].Vector3,"ps":1},{"n":"rotation","pt":$n[1].Quaternion,"ps":2}],"sn":"Spawn$11","rt":$n[1].GameObject,"p":[$n[1].GameObject,$n[1].Vector3,$n[1].Quaternion]},{"a":2,"n":"Spawn","is":true,"t":8,"pi":[{"n":"prefab","pt":System.Object,"ps":0},{"n":"parent","pt":$n[1].Transform,"ps":1},{"n":"position","pt":$n[1].Vector3,"ps":2},{"n":"rotation","pt":$n[1].Quaternion,"ps":3}],"tpc":1,"tprm":["T"],"sn":"Spawn$3","rt":System.Object,"p":[System.Object,$n[1].Transform,$n[1].Vector3,$n[1].Quaternion]},{"a":2,"n":"Spawn","is":true,"t":8,"pi":[{"n":"prefab","pt":$n[1].GameObject,"ps":0},{"n":"parent","pt":$n[1].Transform,"ps":1},{"n":"position","pt":$n[1].Vector3,"ps":2},{"n":"rotation","pt":$n[1].Quaternion,"ps":3}],"sn":"Spawn$9","rt":$n[1].GameObject,"p":[$n[1].GameObject,$n[1].Transform,$n[1].Vector3,$n[1].Quaternion]}]}; }, $n);
    /*ObjectPoolExtensions end.*/

    /*ShuffleExtension start.*/
    $m("ShuffleExtension", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"Shuffle","is":true,"t":8,"pi":[{"n":"list","pt":$n[2].List$1(System.Object),"ps":0},{"n":"shuffleAccuracy","pt":$n[0].Int32,"ps":1}],"tpc":1,"tprm":["T"],"sn":"Shuffle$1","rt":$n[0].Void,"p":[$n[2].List$1(System.Object),$n[0].Int32]},{"a":2,"n":"Shuffle","is":true,"t":8,"pi":[{"n":"array","pt":System.Array.type(System.Object),"ps":0},{"n":"shuffleAccuracy","pt":$n[0].Int32,"ps":1}],"tpc":1,"tprm":["T"],"sn":"Shuffle","rt":$n[0].Void,"p":[System.Array.type(System.Object),$n[0].Int32]}]}; }, $n);
    /*ShuffleExtension end.*/

    /*Singleton$1 start.*/
    $m("Singleton$1", function (T) { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"v":true,"a":2,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"Instance","is":true,"t":16,"rt":T,"g":{"a":2,"n":"get_Instance","t":8,"rt":T,"fg":"Instance","is":true},"fn":"Instance"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"canDestroyOnLoad","t":4,"rt":$n[0].Boolean,"sn":"canDestroyOnLoad","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"instance","is":true,"t":4,"rt":T,"sn":"instance"}]}; }, $n);
    /*Singleton$1 end.*/

    /*Vibration start.*/
    $m("Vibration", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"Cancel","is":true,"t":8,"sn":"Cancel","rt":$n[0].Void},{"a":2,"n":"HasVibrator","is":true,"t":8,"sn":"HasVibrator","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"Vibrate","is":true,"t":8,"sn":"Vibrate","rt":$n[0].Void},{"a":2,"n":"Vibrate","is":true,"t":8,"pi":[{"n":"milliseconds","pt":$n[0].Int64,"ps":0}],"sn":"Vibrate$1","rt":$n[0].Void,"p":[$n[0].Int64]},{"a":2,"n":"Vibrate","is":true,"t":8,"pi":[{"n":"pattern","pt":$n[0].Array.type(System.Int64),"ps":0},{"n":"repeat","pt":$n[0].Int32,"ps":1}],"sn":"Vibrate$2","rt":$n[0].Void,"p":[$n[0].Array.type(System.Int64),$n[0].Int32]},{"a":1,"n":"isAndroid","is":true,"t":8,"sn":"isAndroid","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"currentActivity","is":true,"t":4,"rt":( pc.stubProxy.generateConstructorFor( 'UnityEngine.AndroidJavaObject' ) ),"sn":"currentActivity"},{"a":1,"n":"currentStrengthVibrate","is":true,"t":4,"rt":$n[0].Int64,"sn":"currentStrengthVibrate"},{"a":1,"n":"timeVibrate","is":true,"t":4,"rt":$n[0].Single,"sn":"timeVibrate","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"unityPlayer","is":true,"t":4,"rt":( pc.stubProxy.generateConstructorFor( 'UnityEngine.AndroidJavaClass' ) ),"sn":"unityPlayer"},{"a":2,"n":"vibrator","is":true,"t":4,"rt":( pc.stubProxy.generateConstructorFor( 'UnityEngine.AndroidJavaObject' ) ),"sn":"vibrator"}]}; }, $n);
    /*Vibration end.*/

    /*UIFollowObject start.*/
    $m("UIFollowObject", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":2,"n":"target","t":4,"rt":$n[1].GameObject,"sn":"target"}]}; }, $n);
    /*UIFollowObject end.*/

    /*wall start.*/
    $m("wall", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"OnTriggerEnter2D","t":8,"pi":[{"n":"other","pt":$n[1].Collider2D,"ps":0}],"sn":"OnTriggerEnter2D","rt":$n[0].Void,"p":[$n[1].Collider2D]},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"exploreParticle","t":4,"rt":$n[1].ParticleSystem,"sn":"exploreParticle"}]}; }, $n);
    /*wall end.*/

    /*IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty start.*/
    $m("IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty end.*/

    /*SharpJson.Lexer start.*/
    $m("SharpJson.Lexer", function () { return {"nested":[$n[7].Lexer.Token],"att":1048576,"a":4,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"text","pt":$n[0].String,"ps":0}],"sn":"ctor"},{"a":1,"n":"GetLastIndexOfNumber","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0}],"sn":"GetLastIndexOfNumber","rt":$n[0].Int32,"p":[$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"GetNumberString","t":8,"sn":"GetNumberString","rt":$n[0].String},{"a":2,"n":"LookAhead","t":8,"sn":"LookAhead","rt":$n[7].Lexer.Token,"box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}},{"a":2,"n":"NextToken","t":8,"sn":"NextToken","rt":$n[7].Lexer.Token,"box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}},{"a":1,"n":"NextToken","is":true,"t":8,"pi":[{"n":"json","pt":$n[0].Array.type(System.Char),"ps":0},{"n":"index","ref":true,"pt":$n[0].Int32,"ps":1}],"sn":"NextToken","rt":$n[7].Lexer.Token,"p":[$n[0].Array.type(System.Char),$n[0].Int32],"box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}},{"a":2,"n":"ParseDoubleNumber","t":8,"sn":"ParseDoubleNumber","rt":$n[0].Double,"box":function ($v) { return Bridge.box($v, System.Double, System.Double.format, System.Double.getHashCode);}},{"a":2,"n":"ParseFloatNumber","t":8,"sn":"ParseFloatNumber","rt":$n[0].Single,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"ParseString","t":8,"sn":"ParseString","rt":$n[0].String},{"a":2,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"a":1,"n":"SkipWhiteSpaces","t":8,"sn":"SkipWhiteSpaces","rt":$n[0].Void},{"a":2,"n":"hasError","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_hasError","t":8,"rt":$n[0].Boolean,"fg":"hasError","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"hasError"},{"a":2,"n":"lineNumber","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_lineNumber","t":8,"rt":$n[0].Int32,"fg":"lineNumber","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":1,"n":"set_lineNumber","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"lineNumber"},"fn":"lineNumber"},{"a":2,"n":"parseNumbersAsFloat","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_parseNumbersAsFloat","t":8,"rt":$n[0].Boolean,"fg":"parseNumbersAsFloat","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_parseNumbersAsFloat","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"parseNumbersAsFloat"},"fn":"parseNumbersAsFloat"},{"a":1,"n":"index","t":4,"rt":$n[0].Int32,"sn":"index","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"json","t":4,"rt":$n[0].Array.type(System.Char),"sn":"json"},{"a":1,"n":"stringBuffer","t":4,"rt":$n[0].Array.type(System.Char),"sn":"stringBuffer"},{"a":1,"n":"success","t":4,"rt":$n[0].Boolean,"sn":"success","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"backing":true,"n":"<lineNumber>k__BackingField","t":4,"rt":$n[0].Int32,"sn":"lineNumber","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"backing":true,"n":"<parseNumbersAsFloat>k__BackingField","t":4,"rt":$n[0].Boolean,"sn":"parseNumbersAsFloat","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*SharpJson.Lexer end.*/

    /*SharpJson.Lexer+Token start.*/
    $m("SharpJson.Lexer.Token", function () { return {"td":$n[7].Lexer,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Colon","is":true,"t":4,"rt":$n[7].Lexer.Token,"sn":"Colon","box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}},{"a":2,"n":"Comma","is":true,"t":4,"rt":$n[7].Lexer.Token,"sn":"Comma","box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}},{"a":2,"n":"CurlyClose","is":true,"t":4,"rt":$n[7].Lexer.Token,"sn":"CurlyClose","box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}},{"a":2,"n":"CurlyOpen","is":true,"t":4,"rt":$n[7].Lexer.Token,"sn":"CurlyOpen","box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}},{"a":2,"n":"False","is":true,"t":4,"rt":$n[7].Lexer.Token,"sn":"False","box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}},{"a":2,"n":"None","is":true,"t":4,"rt":$n[7].Lexer.Token,"sn":"None","box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}},{"a":2,"n":"Null","is":true,"t":4,"rt":$n[7].Lexer.Token,"sn":"Null","box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}},{"a":2,"n":"Number","is":true,"t":4,"rt":$n[7].Lexer.Token,"sn":"Number","box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}},{"a":2,"n":"SquaredClose","is":true,"t":4,"rt":$n[7].Lexer.Token,"sn":"SquaredClose","box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}},{"a":2,"n":"SquaredOpen","is":true,"t":4,"rt":$n[7].Lexer.Token,"sn":"SquaredOpen","box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}},{"a":2,"n":"String","is":true,"t":4,"rt":$n[7].Lexer.Token,"sn":"String","box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}},{"a":2,"n":"True","is":true,"t":4,"rt":$n[7].Lexer.Token,"sn":"True","box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}}]}; }, $n);
    /*SharpJson.Lexer+Token end.*/

    /*SharpJson.JsonDecoder start.*/
    $m("SharpJson.JsonDecoder", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Decode","t":8,"pi":[{"n":"text","pt":$n[0].String,"ps":0}],"sn":"Decode","rt":$n[0].Object,"p":[$n[0].String]},{"a":2,"n":"DecodeText","is":true,"t":8,"pi":[{"n":"text","pt":$n[0].String,"ps":0}],"sn":"DecodeText","rt":$n[0].Object,"p":[$n[0].String]},{"a":1,"n":"EvalLexer","t":8,"pi":[{"n":"value","pt":System.Object,"ps":0}],"tpc":1,"tprm":["T"],"sn":"EvalLexer","rt":System.Object,"p":[System.Object]},{"a":1,"n":"ParseArray","t":8,"sn":"ParseArray","rt":$n[2].IList$1(System.Object)},{"a":1,"n":"ParseObject","t":8,"sn":"ParseObject","rt":$n[2].IDictionary$2(System.String,System.Object)},{"a":1,"n":"ParseValue","t":8,"sn":"ParseValue","rt":$n[0].Object},{"a":1,"n":"TriggerError","t":8,"pi":[{"n":"message","pt":$n[0].String,"ps":0}],"sn":"TriggerError","rt":$n[0].Void,"p":[$n[0].String]},{"a":2,"n":"errorMessage","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_errorMessage","t":8,"rt":$n[0].String,"fg":"errorMessage"},"s":{"a":1,"n":"set_errorMessage","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"errorMessage"},"fn":"errorMessage"},{"a":2,"n":"parseNumbersAsFloat","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_parseNumbersAsFloat","t":8,"rt":$n[0].Boolean,"fg":"parseNumbersAsFloat","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_parseNumbersAsFloat","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"parseNumbersAsFloat"},"fn":"parseNumbersAsFloat"},{"a":1,"n":"lexer","t":4,"rt":$n[7].Lexer,"sn":"lexer"},{"a":1,"backing":true,"n":"<errorMessage>k__BackingField","t":4,"rt":$n[0].String,"sn":"errorMessage"},{"a":1,"backing":true,"n":"<parseNumbersAsFloat>k__BackingField","t":4,"rt":$n[0].Boolean,"sn":"parseNumbersAsFloat","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*SharpJson.JsonDecoder end.*/

    /*Spine.Animation start.*/
    $m("Spine.Animation", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[8].ExposedList$1(Spine.Timeline),$n[0].Single],"pi":[{"n":"name","pt":$n[0].String,"ps":0},{"n":"timelines","pt":$n[8].ExposedList$1(Spine.Timeline),"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"ctor"},{"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"loop","pt":$n[0].Boolean,"ps":3},{"n":"events","pt":$n[8].ExposedList$1(Spine.Event),"ps":4},{"n":"alpha","pt":$n[0].Single,"ps":5},{"n":"blend","pt":$n[8].MixBlend,"ps":6},{"n":"direction","pt":$n[8].MixDirection,"ps":7}],"sn":"Apply","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[0].Single,$n[0].Single,$n[0].Boolean,$n[8].ExposedList$1(Spine.Event),$n[0].Single,$n[8].MixBlend,$n[8].MixDirection]},{"a":2,"n":"HasTimeline","t":8,"pi":[{"n":"propertyIds","pt":$n[0].Array.type(System.String),"ps":0}],"sn":"HasTimeline","rt":$n[0].Boolean,"p":[$n[0].Array.type(System.String)],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"SetTimelines","t":8,"pi":[{"n":"timelines","pt":$n[8].ExposedList$1(Spine.Timeline),"ps":0}],"sn":"SetTimelines","rt":$n[0].Void,"p":[$n[8].ExposedList$1(Spine.Timeline)]},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"Duration","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Duration","t":8,"rt":$n[0].Single,"fg":"Duration","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Duration","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Duration"},"fn":"Duration"},{"a":2,"n":"Name","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_Name","t":8,"rt":$n[0].String,"fg":"Name"},"fn":"Name"},{"a":2,"n":"Timelines","t":16,"rt":$n[8].ExposedList$1(Spine.Timeline),"g":{"a":2,"n":"get_Timelines","t":8,"rt":$n[8].ExposedList$1(Spine.Timeline),"fg":"Timelines"},"s":{"a":2,"n":"set_Timelines","t":8,"p":[$n[8].ExposedList$1(Spine.Timeline)],"rt":$n[0].Void,"fs":"Timelines"},"fn":"Timelines"},{"a":4,"n":"duration","t":4,"rt":$n[0].Single,"sn":"duration","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"name","t":4,"rt":$n[0].String,"sn":"name"},{"a":4,"n":"timelineIds","t":4,"rt":$n[2].HashSet$1(System.String),"sn":"timelineIds"},{"a":4,"n":"timelines","t":4,"rt":$n[8].ExposedList$1(Spine.Timeline),"sn":"timelines"}]}; }, $n);
    /*Spine.Animation end.*/

    /*Spine.MixBlend start.*/
    $m("Spine.MixBlend", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Add","is":true,"t":4,"rt":$n[8].MixBlend,"sn":"Add","box":function ($v) { return Bridge.box($v, Spine.MixBlend, System.Enum.toStringFn(Spine.MixBlend));}},{"a":2,"n":"First","is":true,"t":4,"rt":$n[8].MixBlend,"sn":"First","box":function ($v) { return Bridge.box($v, Spine.MixBlend, System.Enum.toStringFn(Spine.MixBlend));}},{"a":2,"n":"Replace","is":true,"t":4,"rt":$n[8].MixBlend,"sn":"Replace","box":function ($v) { return Bridge.box($v, Spine.MixBlend, System.Enum.toStringFn(Spine.MixBlend));}},{"a":2,"n":"Setup","is":true,"t":4,"rt":$n[8].MixBlend,"sn":"Setup","box":function ($v) { return Bridge.box($v, Spine.MixBlend, System.Enum.toStringFn(Spine.MixBlend));}}]}; }, $n);
    /*Spine.MixBlend end.*/

    /*Spine.MixDirection start.*/
    $m("Spine.MixDirection", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"In","is":true,"t":4,"rt":$n[8].MixDirection,"sn":"In","box":function ($v) { return Bridge.box($v, Spine.MixDirection, System.Enum.toStringFn(Spine.MixDirection));}},{"a":2,"n":"Out","is":true,"t":4,"rt":$n[8].MixDirection,"sn":"Out","box":function ($v) { return Bridge.box($v, Spine.MixDirection, System.Enum.toStringFn(Spine.MixDirection));}}]}; }, $n);
    /*Spine.MixDirection end.*/

    /*Spine.Property start.*/
    $m("Spine.Property", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Alpha","is":true,"t":4,"rt":$n[8].Property,"sn":"Alpha","box":function ($v) { return Bridge.box($v, Spine.Property, System.Enum.toStringFn(Spine.Property));}},{"a":2,"n":"Attachment","is":true,"t":4,"rt":$n[8].Property,"sn":"Attachment","box":function ($v) { return Bridge.box($v, Spine.Property, System.Enum.toStringFn(Spine.Property));}},{"a":2,"n":"Deform","is":true,"t":4,"rt":$n[8].Property,"sn":"Deform","box":function ($v) { return Bridge.box($v, Spine.Property, System.Enum.toStringFn(Spine.Property));}},{"a":2,"n":"DrawOrder","is":true,"t":4,"rt":$n[8].Property,"sn":"DrawOrder","box":function ($v) { return Bridge.box($v, Spine.Property, System.Enum.toStringFn(Spine.Property));}},{"a":2,"n":"Event","is":true,"t":4,"rt":$n[8].Property,"sn":"Event","box":function ($v) { return Bridge.box($v, Spine.Property, System.Enum.toStringFn(Spine.Property));}},{"a":2,"n":"IkConstraint","is":true,"t":4,"rt":$n[8].Property,"sn":"IkConstraint","box":function ($v) { return Bridge.box($v, Spine.Property, System.Enum.toStringFn(Spine.Property));}},{"a":2,"n":"Inherit","is":true,"t":4,"rt":$n[8].Property,"sn":"Inherit","box":function ($v) { return Bridge.box($v, Spine.Property, System.Enum.toStringFn(Spine.Property));}},{"a":2,"n":"PathConstraintMix","is":true,"t":4,"rt":$n[8].Property,"sn":"PathConstraintMix","box":function ($v) { return Bridge.box($v, Spine.Property, System.Enum.toStringFn(Spine.Property));}},{"a":2,"n":"PathConstraintPosition","is":true,"t":4,"rt":$n[8].Property,"sn":"PathConstraintPosition","box":function ($v) { return Bridge.box($v, Spine.Property, System.Enum.toStringFn(Spine.Property));}},{"a":2,"n":"PathConstraintSpacing","is":true,"t":4,"rt":$n[8].Property,"sn":"PathConstraintSpacing","box":function ($v) { return Bridge.box($v, Spine.Property, System.Enum.toStringFn(Spine.Property));}},{"a":2,"n":"PhysicsConstraintDamping","is":true,"t":4,"rt":$n[8].Property,"sn":"PhysicsConstraintDamping","box":function ($v) { return Bridge.box($v, Spine.Property, System.Enum.toStringFn(Spine.Property));}},{"a":2,"n":"PhysicsConstraintGravity","is":true,"t":4,"rt":$n[8].Property,"sn":"PhysicsConstraintGravity","box":function ($v) { return Bridge.box($v, Spine.Property, System.Enum.toStringFn(Spine.Property));}},{"a":2,"n":"PhysicsConstraintInertia","is":true,"t":4,"rt":$n[8].Property,"sn":"PhysicsConstraintInertia","box":function ($v) { return Bridge.box($v, Spine.Property, System.Enum.toStringFn(Spine.Property));}},{"a":2,"n":"PhysicsConstraintMass","is":true,"t":4,"rt":$n[8].Property,"sn":"PhysicsConstraintMass","box":function ($v) { return Bridge.box($v, Spine.Property, System.Enum.toStringFn(Spine.Property));}},{"a":2,"n":"PhysicsConstraintMix","is":true,"t":4,"rt":$n[8].Property,"sn":"PhysicsConstraintMix","box":function ($v) { return Bridge.box($v, Spine.Property, System.Enum.toStringFn(Spine.Property));}},{"a":2,"n":"PhysicsConstraintReset","is":true,"t":4,"rt":$n[8].Property,"sn":"PhysicsConstraintReset","box":function ($v) { return Bridge.box($v, Spine.Property, System.Enum.toStringFn(Spine.Property));}},{"a":2,"n":"PhysicsConstraintStrength","is":true,"t":4,"rt":$n[8].Property,"sn":"PhysicsConstraintStrength","box":function ($v) { return Bridge.box($v, Spine.Property, System.Enum.toStringFn(Spine.Property));}},{"a":2,"n":"PhysicsConstraintWind","is":true,"t":4,"rt":$n[8].Property,"sn":"PhysicsConstraintWind","box":function ($v) { return Bridge.box($v, Spine.Property, System.Enum.toStringFn(Spine.Property));}},{"a":2,"n":"RGB","is":true,"t":4,"rt":$n[8].Property,"sn":"RGB","box":function ($v) { return Bridge.box($v, Spine.Property, System.Enum.toStringFn(Spine.Property));}},{"a":2,"n":"RGB2","is":true,"t":4,"rt":$n[8].Property,"sn":"RGB2","box":function ($v) { return Bridge.box($v, Spine.Property, System.Enum.toStringFn(Spine.Property));}},{"a":2,"n":"Rotate","is":true,"t":4,"rt":$n[8].Property,"sn":"Rotate","box":function ($v) { return Bridge.box($v, Spine.Property, System.Enum.toStringFn(Spine.Property));}},{"a":2,"n":"ScaleX","is":true,"t":4,"rt":$n[8].Property,"sn":"ScaleX","box":function ($v) { return Bridge.box($v, Spine.Property, System.Enum.toStringFn(Spine.Property));}},{"a":2,"n":"ScaleY","is":true,"t":4,"rt":$n[8].Property,"sn":"ScaleY","box":function ($v) { return Bridge.box($v, Spine.Property, System.Enum.toStringFn(Spine.Property));}},{"a":2,"n":"Sequence","is":true,"t":4,"rt":$n[8].Property,"sn":"Sequence","box":function ($v) { return Bridge.box($v, Spine.Property, System.Enum.toStringFn(Spine.Property));}},{"a":2,"n":"ShearX","is":true,"t":4,"rt":$n[8].Property,"sn":"ShearX","box":function ($v) { return Bridge.box($v, Spine.Property, System.Enum.toStringFn(Spine.Property));}},{"a":2,"n":"ShearY","is":true,"t":4,"rt":$n[8].Property,"sn":"ShearY","box":function ($v) { return Bridge.box($v, Spine.Property, System.Enum.toStringFn(Spine.Property));}},{"a":2,"n":"TransformConstraint","is":true,"t":4,"rt":$n[8].Property,"sn":"TransformConstraint","box":function ($v) { return Bridge.box($v, Spine.Property, System.Enum.toStringFn(Spine.Property));}},{"a":2,"n":"X","is":true,"t":4,"rt":$n[8].Property,"sn":"X","box":function ($v) { return Bridge.box($v, Spine.Property, System.Enum.toStringFn(Spine.Property));}},{"a":2,"n":"Y","is":true,"t":4,"rt":$n[8].Property,"sn":"Y","box":function ($v) { return Bridge.box($v, Spine.Property, System.Enum.toStringFn(Spine.Property));}}]}; }, $n);
    /*Spine.Property end.*/

    /*Spine.Timeline start.*/
    $m("Spine.Timeline", function () { return {"att":1048705,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Array.type(System.String)],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"propertyIds","ip":true,"pt":$n[0].Array.type(System.String),"ps":1}],"sn":"ctor"},{"ab":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"events","pt":$n[8].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[8].MixBlend,"ps":5},{"n":"direction","pt":$n[8].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[0].Single,$n[0].Single,$n[8].ExposedList$1(Spine.Event),$n[0].Single,$n[8].MixBlend,$n[8].MixDirection]},{"a":4,"n":"Search","is":true,"t":8,"pi":[{"n":"frames","pt":$n[0].Array.type(System.Single),"ps":0},{"n":"time","pt":$n[0].Single,"ps":1}],"sn":"Search","rt":$n[0].Int32,"p":[$n[0].Array.type(System.Single),$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"Search","is":true,"t":8,"pi":[{"n":"frames","pt":$n[0].Array.type(System.Single),"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"step","pt":$n[0].Int32,"ps":2}],"sn":"Search$1","rt":$n[0].Int32,"p":[$n[0].Array.type(System.Single),$n[0].Single,$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"Duration","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Duration","t":8,"rt":$n[0].Single,"fg":"Duration","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"Duration"},{"v":true,"a":2,"n":"FrameCount","t":16,"rt":$n[0].Int32,"g":{"v":true,"a":2,"n":"get_FrameCount","t":8,"rt":$n[0].Int32,"fg":"FrameCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"FrameCount"},{"v":true,"a":2,"n":"FrameEntries","t":16,"rt":$n[0].Int32,"g":{"v":true,"a":2,"n":"get_FrameEntries","t":8,"rt":$n[0].Int32,"fg":"FrameEntries","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"FrameEntries"},{"a":2,"n":"Frames","t":16,"rt":$n[0].Array.type(System.Single),"g":{"a":2,"n":"get_Frames","t":8,"rt":$n[0].Array.type(System.Single),"fg":"Frames"},"fn":"Frames"},{"a":2,"n":"PropertyIds","t":16,"rt":$n[0].Array.type(System.String),"g":{"a":2,"n":"get_PropertyIds","t":8,"rt":$n[0].Array.type(System.String),"fg":"PropertyIds"},"fn":"PropertyIds"},{"a":4,"n":"frames","t":4,"rt":$n[0].Array.type(System.Single),"sn":"frames","ro":true},{"a":1,"n":"propertyIds","t":4,"rt":$n[0].Array.type(System.String),"sn":"propertyIds","ro":true}]}; }, $n);
    /*Spine.Timeline end.*/

    /*Spine.IBoneTimeline start.*/
    $m("Spine.IBoneTimeline", function () { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"BoneIndex","t":16,"rt":$n[0].Int32,"g":{"ab":true,"a":2,"n":"get_BoneIndex","t":8,"rt":$n[0].Int32,"fg":"Spine$IBoneTimeline$BoneIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"Spine$IBoneTimeline$BoneIndex"},{"a":1,"backing":true,"n":"<BoneIndex>k__BackingField","t":4,"rt":$n[0].Int32,"sn":"Spine$IBoneTimeline$BoneIndex","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.IBoneTimeline end.*/

    /*Spine.ISlotTimeline start.*/
    $m("Spine.ISlotTimeline", function () { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"SlotIndex","t":16,"rt":$n[0].Int32,"g":{"ab":true,"a":2,"n":"get_SlotIndex","t":8,"rt":$n[0].Int32,"fg":"Spine$ISlotTimeline$SlotIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"Spine$ISlotTimeline$SlotIndex"},{"a":1,"backing":true,"n":"<SlotIndex>k__BackingField","t":4,"rt":$n[0].Int32,"sn":"Spine$ISlotTimeline$SlotIndex","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.ISlotTimeline end.*/

    /*Spine.CurveTimeline start.*/
    $m("Spine.CurveTimeline", function () { return {"att":1048705,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[0].Array.type(System.String)],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"bezierCount","pt":$n[0].Int32,"ps":1},{"n":"propertyIds","ip":true,"pt":$n[0].Array.type(System.String),"ps":2}],"sn":"ctor"},{"a":2,"n":"GetBezierValue","t":8,"pi":[{"n":"time","pt":$n[0].Single,"ps":0},{"n":"frameIndex","pt":$n[0].Int32,"ps":1},{"n":"valueOffset","pt":$n[0].Int32,"ps":2},{"n":"i","pt":$n[0].Int32,"ps":3}],"sn":"GetBezierValue","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Int32,$n[0].Int32,$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"GetCurveType","t":8,"pi":[{"n":"frame","pt":$n[0].Int32,"ps":0}],"sn":"GetCurveType","rt":$n[0].Single,"p":[$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"SetBezier","t":8,"pi":[{"n":"bezier","pt":$n[0].Int32,"ps":0},{"n":"frame","pt":$n[0].Int32,"ps":1},{"n":"value","pt":$n[0].Int32,"ps":2},{"n":"time1","pt":$n[0].Single,"ps":3},{"n":"value1","pt":$n[0].Single,"ps":4},{"n":"cx1","pt":$n[0].Single,"ps":5},{"n":"cy1","pt":$n[0].Single,"ps":6},{"n":"cx2","pt":$n[0].Single,"ps":7},{"n":"cy2","pt":$n[0].Single,"ps":8},{"n":"time2","pt":$n[0].Single,"ps":9},{"n":"value2","pt":$n[0].Single,"ps":10}],"sn":"SetBezier","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Int32,$n[0].Int32,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single]},{"a":2,"n":"SetLinear","t":8,"pi":[{"n":"frame","pt":$n[0].Int32,"ps":0}],"sn":"SetLinear","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"SetStepped","t":8,"pi":[{"n":"frame","pt":$n[0].Int32,"ps":0}],"sn":"SetStepped","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"Shrink","t":8,"pi":[{"n":"bezierCount","pt":$n[0].Int32,"ps":0}],"sn":"Shrink","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"BEZIER","is":true,"t":4,"rt":$n[0].Int32,"sn":"BEZIER","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"BEZIER_SIZE","is":true,"t":4,"rt":$n[0].Int32,"sn":"BEZIER_SIZE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"LINEAR","is":true,"t":4,"rt":$n[0].Int32,"sn":"LINEAR","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"STEPPED","is":true,"t":4,"rt":$n[0].Int32,"sn":"STEPPED","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"curves","t":4,"rt":$n[0].Array.type(System.Single),"sn":"curves"}]}; }, $n);
    /*Spine.CurveTimeline end.*/

    /*Spine.CurveTimeline1 start.*/
    $m("Spine.CurveTimeline1", function () { return {"att":1048705,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[0].String],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"bezierCount","pt":$n[0].Int32,"ps":1},{"n":"propertyId","pt":$n[0].String,"ps":2}],"sn":"ctor"},{"a":2,"n":"GetAbsoluteValue","t":8,"pi":[{"n":"time","pt":$n[0].Single,"ps":0},{"n":"alpha","pt":$n[0].Single,"ps":1},{"n":"blend","pt":$n[8].MixBlend,"ps":2},{"n":"current","pt":$n[0].Single,"ps":3},{"n":"setup","pt":$n[0].Single,"ps":4}],"sn":"GetAbsoluteValue","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single,$n[8].MixBlend,$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"GetAbsoluteValue","t":8,"pi":[{"n":"time","pt":$n[0].Single,"ps":0},{"n":"alpha","pt":$n[0].Single,"ps":1},{"n":"blend","pt":$n[8].MixBlend,"ps":2},{"n":"current","pt":$n[0].Single,"ps":3},{"n":"setup","pt":$n[0].Single,"ps":4},{"n":"value","pt":$n[0].Single,"ps":5}],"sn":"GetAbsoluteValue$1","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single,$n[8].MixBlend,$n[0].Single,$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"GetCurveValue","t":8,"pi":[{"n":"time","pt":$n[0].Single,"ps":0}],"sn":"GetCurveValue","rt":$n[0].Single,"p":[$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"GetRelativeValue","t":8,"pi":[{"n":"time","pt":$n[0].Single,"ps":0},{"n":"alpha","pt":$n[0].Single,"ps":1},{"n":"blend","pt":$n[8].MixBlend,"ps":2},{"n":"current","pt":$n[0].Single,"ps":3},{"n":"setup","pt":$n[0].Single,"ps":4}],"sn":"GetRelativeValue","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single,$n[8].MixBlend,$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"GetScaleValue","t":8,"pi":[{"n":"time","pt":$n[0].Single,"ps":0},{"n":"alpha","pt":$n[0].Single,"ps":1},{"n":"blend","pt":$n[8].MixBlend,"ps":2},{"n":"direction","pt":$n[8].MixDirection,"ps":3},{"n":"current","pt":$n[0].Single,"ps":4},{"n":"setup","pt":$n[0].Single,"ps":5}],"sn":"GetScaleValue","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single,$n[8].MixBlend,$n[8].MixDirection,$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"SetFrame","t":8,"pi":[{"n":"frame","pt":$n[0].Int32,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"value","pt":$n[0].Single,"ps":2}],"sn":"SetFrame","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Single,$n[0].Single]},{"ov":true,"a":2,"n":"FrameEntries","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_FrameEntries","t":8,"rt":$n[0].Int32,"fg":"FrameEntries","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"FrameEntries"},{"a":2,"n":"ENTRIES","is":true,"t":4,"rt":$n[0].Int32,"sn":"ENTRIES","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"VALUE","is":true,"t":4,"rt":$n[0].Int32,"sn":"VALUE","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.CurveTimeline1 end.*/

    /*Spine.CurveTimeline2 start.*/
    $m("Spine.CurveTimeline2", function () { return {"att":1048705,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[0].String,$n[0].String],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"bezierCount","pt":$n[0].Int32,"ps":1},{"n":"propertyId1","pt":$n[0].String,"ps":2},{"n":"propertyId2","pt":$n[0].String,"ps":3}],"sn":"ctor"},{"a":2,"n":"SetFrame","t":8,"pi":[{"n":"frame","pt":$n[0].Int32,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"value1","pt":$n[0].Single,"ps":2},{"n":"value2","pt":$n[0].Single,"ps":3}],"sn":"SetFrame","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Single,$n[0].Single,$n[0].Single]},{"ov":true,"a":2,"n":"FrameEntries","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_FrameEntries","t":8,"rt":$n[0].Int32,"fg":"FrameEntries","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"FrameEntries"},{"a":2,"n":"ENTRIES","is":true,"t":4,"rt":$n[0].Int32,"sn":"ENTRIES","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"VALUE1","is":true,"t":4,"rt":$n[0].Int32,"sn":"VALUE1","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"VALUE2","is":true,"t":4,"rt":$n[0].Int32,"sn":"VALUE2","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.CurveTimeline2 end.*/

    /*Spine.RotateTimeline start.*/
    $m("Spine.RotateTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"bezierCount","pt":$n[0].Int32,"ps":1},{"n":"boneIndex","pt":$n[0].Int32,"ps":2}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[8].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[8].MixBlend,"ps":5},{"n":"direction","pt":$n[8].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[0].Single,$n[0].Single,$n[8].ExposedList$1(Spine.Event),$n[0].Single,$n[8].MixBlend,$n[8].MixDirection]},{"a":2,"n":"BoneIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_BoneIndex","t":8,"rt":$n[0].Int32,"fg":"BoneIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"BoneIndex"},{"a":1,"n":"boneIndex","t":4,"rt":$n[0].Int32,"sn":"boneIndex","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.RotateTimeline end.*/

    /*Spine.TranslateTimeline start.*/
    $m("Spine.TranslateTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"bezierCount","pt":$n[0].Int32,"ps":1},{"n":"boneIndex","pt":$n[0].Int32,"ps":2}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[8].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[8].MixBlend,"ps":5},{"n":"direction","pt":$n[8].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[0].Single,$n[0].Single,$n[8].ExposedList$1(Spine.Event),$n[0].Single,$n[8].MixBlend,$n[8].MixDirection]},{"a":2,"n":"GetCurveValue","t":8,"pi":[{"n":"x","out":true,"pt":$n[0].Single,"ps":0},{"n":"y","out":true,"pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2}],"sn":"GetCurveValue","rt":$n[0].Void,"p":[$n[0].Single,$n[0].Single,$n[0].Single]},{"a":2,"n":"BoneIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_BoneIndex","t":8,"rt":$n[0].Int32,"fg":"BoneIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"BoneIndex"},{"a":1,"n":"boneIndex","t":4,"rt":$n[0].Int32,"sn":"boneIndex","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.TranslateTimeline end.*/

    /*Spine.TranslateXTimeline start.*/
    $m("Spine.TranslateXTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"bezierCount","pt":$n[0].Int32,"ps":1},{"n":"boneIndex","pt":$n[0].Int32,"ps":2}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[8].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[8].MixBlend,"ps":5},{"n":"direction","pt":$n[8].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[0].Single,$n[0].Single,$n[8].ExposedList$1(Spine.Event),$n[0].Single,$n[8].MixBlend,$n[8].MixDirection]},{"a":2,"n":"BoneIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_BoneIndex","t":8,"rt":$n[0].Int32,"fg":"BoneIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"BoneIndex"},{"a":1,"n":"boneIndex","t":4,"rt":$n[0].Int32,"sn":"boneIndex","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.TranslateXTimeline end.*/

    /*Spine.TranslateYTimeline start.*/
    $m("Spine.TranslateYTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"bezierCount","pt":$n[0].Int32,"ps":1},{"n":"boneIndex","pt":$n[0].Int32,"ps":2}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[8].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[8].MixBlend,"ps":5},{"n":"direction","pt":$n[8].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[0].Single,$n[0].Single,$n[8].ExposedList$1(Spine.Event),$n[0].Single,$n[8].MixBlend,$n[8].MixDirection]},{"a":2,"n":"BoneIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_BoneIndex","t":8,"rt":$n[0].Int32,"fg":"BoneIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"BoneIndex"},{"a":1,"n":"boneIndex","t":4,"rt":$n[0].Int32,"sn":"boneIndex","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.TranslateYTimeline end.*/

    /*Spine.ScaleTimeline start.*/
    $m("Spine.ScaleTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"bezierCount","pt":$n[0].Int32,"ps":1},{"n":"boneIndex","pt":$n[0].Int32,"ps":2}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[8].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[8].MixBlend,"ps":5},{"n":"direction","pt":$n[8].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[0].Single,$n[0].Single,$n[8].ExposedList$1(Spine.Event),$n[0].Single,$n[8].MixBlend,$n[8].MixDirection]},{"a":2,"n":"BoneIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_BoneIndex","t":8,"rt":$n[0].Int32,"fg":"BoneIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"BoneIndex"},{"a":1,"n":"boneIndex","t":4,"rt":$n[0].Int32,"sn":"boneIndex","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.ScaleTimeline end.*/

    /*Spine.ScaleXTimeline start.*/
    $m("Spine.ScaleXTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"bezierCount","pt":$n[0].Int32,"ps":1},{"n":"boneIndex","pt":$n[0].Int32,"ps":2}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[8].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[8].MixBlend,"ps":5},{"n":"direction","pt":$n[8].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[0].Single,$n[0].Single,$n[8].ExposedList$1(Spine.Event),$n[0].Single,$n[8].MixBlend,$n[8].MixDirection]},{"a":2,"n":"BoneIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_BoneIndex","t":8,"rt":$n[0].Int32,"fg":"BoneIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"BoneIndex"},{"a":1,"n":"boneIndex","t":4,"rt":$n[0].Int32,"sn":"boneIndex","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.ScaleXTimeline end.*/

    /*Spine.ScaleYTimeline start.*/
    $m("Spine.ScaleYTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"bezierCount","pt":$n[0].Int32,"ps":1},{"n":"boneIndex","pt":$n[0].Int32,"ps":2}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[8].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[8].MixBlend,"ps":5},{"n":"direction","pt":$n[8].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[0].Single,$n[0].Single,$n[8].ExposedList$1(Spine.Event),$n[0].Single,$n[8].MixBlend,$n[8].MixDirection]},{"a":2,"n":"BoneIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_BoneIndex","t":8,"rt":$n[0].Int32,"fg":"BoneIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"BoneIndex"},{"a":1,"n":"boneIndex","t":4,"rt":$n[0].Int32,"sn":"boneIndex","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.ScaleYTimeline end.*/

    /*Spine.ShearTimeline start.*/
    $m("Spine.ShearTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"bezierCount","pt":$n[0].Int32,"ps":1},{"n":"boneIndex","pt":$n[0].Int32,"ps":2}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[8].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[8].MixBlend,"ps":5},{"n":"direction","pt":$n[8].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[0].Single,$n[0].Single,$n[8].ExposedList$1(Spine.Event),$n[0].Single,$n[8].MixBlend,$n[8].MixDirection]},{"a":2,"n":"BoneIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_BoneIndex","t":8,"rt":$n[0].Int32,"fg":"BoneIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"BoneIndex"},{"a":1,"n":"boneIndex","t":4,"rt":$n[0].Int32,"sn":"boneIndex","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.ShearTimeline end.*/

    /*Spine.ShearXTimeline start.*/
    $m("Spine.ShearXTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"bezierCount","pt":$n[0].Int32,"ps":1},{"n":"boneIndex","pt":$n[0].Int32,"ps":2}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[8].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[8].MixBlend,"ps":5},{"n":"direction","pt":$n[8].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[0].Single,$n[0].Single,$n[8].ExposedList$1(Spine.Event),$n[0].Single,$n[8].MixBlend,$n[8].MixDirection]},{"a":2,"n":"BoneIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_BoneIndex","t":8,"rt":$n[0].Int32,"fg":"BoneIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"BoneIndex"},{"a":1,"n":"boneIndex","t":4,"rt":$n[0].Int32,"sn":"boneIndex","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.ShearXTimeline end.*/

    /*Spine.ShearYTimeline start.*/
    $m("Spine.ShearYTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"bezierCount","pt":$n[0].Int32,"ps":1},{"n":"boneIndex","pt":$n[0].Int32,"ps":2}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[8].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[8].MixBlend,"ps":5},{"n":"direction","pt":$n[8].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[0].Single,$n[0].Single,$n[8].ExposedList$1(Spine.Event),$n[0].Single,$n[8].MixBlend,$n[8].MixDirection]},{"a":2,"n":"BoneIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_BoneIndex","t":8,"rt":$n[0].Int32,"fg":"BoneIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"BoneIndex"},{"a":1,"n":"boneIndex","t":4,"rt":$n[0].Int32,"sn":"boneIndex","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.ShearYTimeline end.*/

    /*Spine.InheritTimeline start.*/
    $m("Spine.InheritTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"boneIndex","pt":$n[0].Int32,"ps":1}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[8].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[8].MixBlend,"ps":5},{"n":"direction","pt":$n[8].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[0].Single,$n[0].Single,$n[8].ExposedList$1(Spine.Event),$n[0].Single,$n[8].MixBlend,$n[8].MixDirection]},{"a":2,"n":"SetFrame","t":8,"pi":[{"n":"frame","pt":$n[0].Int32,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"inherit","pt":$n[8].Inherit,"ps":2}],"sn":"SetFrame","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Single,$n[8].Inherit]},{"a":2,"n":"BoneIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_BoneIndex","t":8,"rt":$n[0].Int32,"fg":"BoneIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"BoneIndex"},{"ov":true,"a":2,"n":"FrameEntries","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_FrameEntries","t":8,"rt":$n[0].Int32,"fg":"FrameEntries","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"FrameEntries"},{"a":2,"n":"ENTRIES","is":true,"t":4,"rt":$n[0].Int32,"sn":"ENTRIES","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"INHERIT","is":true,"t":4,"rt":$n[0].Int32,"sn":"INHERIT","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"boneIndex","t":4,"rt":$n[0].Int32,"sn":"boneIndex","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.InheritTimeline end.*/

    /*Spine.RGBATimeline start.*/
    $m("Spine.RGBATimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"bezierCount","pt":$n[0].Int32,"ps":1},{"n":"slotIndex","pt":$n[0].Int32,"ps":2}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[8].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[8].MixBlend,"ps":5},{"n":"direction","pt":$n[8].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[0].Single,$n[0].Single,$n[8].ExposedList$1(Spine.Event),$n[0].Single,$n[8].MixBlend,$n[8].MixDirection]},{"a":2,"n":"SetFrame","t":8,"pi":[{"n":"frame","pt":$n[0].Int32,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"r","pt":$n[0].Single,"ps":2},{"n":"g","pt":$n[0].Single,"ps":3},{"n":"b","pt":$n[0].Single,"ps":4},{"n":"a","pt":$n[0].Single,"ps":5}],"sn":"SetFrame","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single]},{"ov":true,"a":2,"n":"FrameEntries","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_FrameEntries","t":8,"rt":$n[0].Int32,"fg":"FrameEntries","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"FrameEntries"},{"a":2,"n":"SlotIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_SlotIndex","t":8,"rt":$n[0].Int32,"fg":"SlotIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"SlotIndex"},{"a":3,"n":"A","is":true,"t":4,"rt":$n[0].Int32,"sn":"A","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"B","is":true,"t":4,"rt":$n[0].Int32,"sn":"B","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"ENTRIES","is":true,"t":4,"rt":$n[0].Int32,"sn":"ENTRIES","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"G","is":true,"t":4,"rt":$n[0].Int32,"sn":"G","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"R","is":true,"t":4,"rt":$n[0].Int32,"sn":"R","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"slotIndex","t":4,"rt":$n[0].Int32,"sn":"slotIndex","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.RGBATimeline end.*/

    /*Spine.RGBTimeline start.*/
    $m("Spine.RGBTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"bezierCount","pt":$n[0].Int32,"ps":1},{"n":"slotIndex","pt":$n[0].Int32,"ps":2}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[8].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[8].MixBlend,"ps":5},{"n":"direction","pt":$n[8].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[0].Single,$n[0].Single,$n[8].ExposedList$1(Spine.Event),$n[0].Single,$n[8].MixBlend,$n[8].MixDirection]},{"a":2,"n":"SetFrame","t":8,"pi":[{"n":"frame","pt":$n[0].Int32,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"r","pt":$n[0].Single,"ps":2},{"n":"g","pt":$n[0].Single,"ps":3},{"n":"b","pt":$n[0].Single,"ps":4}],"sn":"SetFrame","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single]},{"ov":true,"a":2,"n":"FrameEntries","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_FrameEntries","t":8,"rt":$n[0].Int32,"fg":"FrameEntries","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"FrameEntries"},{"a":2,"n":"SlotIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_SlotIndex","t":8,"rt":$n[0].Int32,"fg":"SlotIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"SlotIndex"},{"a":3,"n":"B","is":true,"t":4,"rt":$n[0].Int32,"sn":"B","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"ENTRIES","is":true,"t":4,"rt":$n[0].Int32,"sn":"ENTRIES","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"G","is":true,"t":4,"rt":$n[0].Int32,"sn":"G","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"R","is":true,"t":4,"rt":$n[0].Int32,"sn":"R","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"slotIndex","t":4,"rt":$n[0].Int32,"sn":"slotIndex","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.RGBTimeline end.*/

    /*Spine.AlphaTimeline start.*/
    $m("Spine.AlphaTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"bezierCount","pt":$n[0].Int32,"ps":1},{"n":"slotIndex","pt":$n[0].Int32,"ps":2}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[8].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[8].MixBlend,"ps":5},{"n":"direction","pt":$n[8].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[0].Single,$n[0].Single,$n[8].ExposedList$1(Spine.Event),$n[0].Single,$n[8].MixBlend,$n[8].MixDirection]},{"a":2,"n":"SlotIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_SlotIndex","t":8,"rt":$n[0].Int32,"fg":"SlotIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"SlotIndex"},{"a":1,"n":"slotIndex","t":4,"rt":$n[0].Int32,"sn":"slotIndex","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.AlphaTimeline end.*/

    /*Spine.RGBA2Timeline start.*/
    $m("Spine.RGBA2Timeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"bezierCount","pt":$n[0].Int32,"ps":1},{"n":"slotIndex","pt":$n[0].Int32,"ps":2}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[8].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[8].MixBlend,"ps":5},{"n":"direction","pt":$n[8].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[0].Single,$n[0].Single,$n[8].ExposedList$1(Spine.Event),$n[0].Single,$n[8].MixBlend,$n[8].MixDirection]},{"a":2,"n":"SetFrame","t":8,"pi":[{"n":"frame","pt":$n[0].Int32,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"r","pt":$n[0].Single,"ps":2},{"n":"g","pt":$n[0].Single,"ps":3},{"n":"b","pt":$n[0].Single,"ps":4},{"n":"a","pt":$n[0].Single,"ps":5},{"n":"r2","pt":$n[0].Single,"ps":6},{"n":"g2","pt":$n[0].Single,"ps":7},{"n":"b2","pt":$n[0].Single,"ps":8}],"sn":"SetFrame","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single]},{"ov":true,"a":2,"n":"FrameEntries","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_FrameEntries","t":8,"rt":$n[0].Int32,"fg":"FrameEntries","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"FrameEntries"},{"a":2,"n":"SlotIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_SlotIndex","t":8,"rt":$n[0].Int32,"fg":"SlotIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"SlotIndex"},{"a":3,"n":"A","is":true,"t":4,"rt":$n[0].Int32,"sn":"A","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"B","is":true,"t":4,"rt":$n[0].Int32,"sn":"B","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"B2","is":true,"t":4,"rt":$n[0].Int32,"sn":"B2","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"ENTRIES","is":true,"t":4,"rt":$n[0].Int32,"sn":"ENTRIES","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"G","is":true,"t":4,"rt":$n[0].Int32,"sn":"G","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"G2","is":true,"t":4,"rt":$n[0].Int32,"sn":"G2","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"R","is":true,"t":4,"rt":$n[0].Int32,"sn":"R","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"R2","is":true,"t":4,"rt":$n[0].Int32,"sn":"R2","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"slotIndex","t":4,"rt":$n[0].Int32,"sn":"slotIndex","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.RGBA2Timeline end.*/

    /*Spine.RGB2Timeline start.*/
    $m("Spine.RGB2Timeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"bezierCount","pt":$n[0].Int32,"ps":1},{"n":"slotIndex","pt":$n[0].Int32,"ps":2}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[8].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[8].MixBlend,"ps":5},{"n":"direction","pt":$n[8].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[0].Single,$n[0].Single,$n[8].ExposedList$1(Spine.Event),$n[0].Single,$n[8].MixBlend,$n[8].MixDirection]},{"a":2,"n":"SetFrame","t":8,"pi":[{"n":"frame","pt":$n[0].Int32,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"r","pt":$n[0].Single,"ps":2},{"n":"g","pt":$n[0].Single,"ps":3},{"n":"b","pt":$n[0].Single,"ps":4},{"n":"r2","pt":$n[0].Single,"ps":5},{"n":"g2","pt":$n[0].Single,"ps":6},{"n":"b2","pt":$n[0].Single,"ps":7}],"sn":"SetFrame","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single]},{"ov":true,"a":2,"n":"FrameEntries","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_FrameEntries","t":8,"rt":$n[0].Int32,"fg":"FrameEntries","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"FrameEntries"},{"a":2,"n":"SlotIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_SlotIndex","t":8,"rt":$n[0].Int32,"fg":"SlotIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"SlotIndex"},{"a":3,"n":"B","is":true,"t":4,"rt":$n[0].Int32,"sn":"B","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"B2","is":true,"t":4,"rt":$n[0].Int32,"sn":"B2","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"ENTRIES","is":true,"t":4,"rt":$n[0].Int32,"sn":"ENTRIES","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"G","is":true,"t":4,"rt":$n[0].Int32,"sn":"G","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"G2","is":true,"t":4,"rt":$n[0].Int32,"sn":"G2","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"R","is":true,"t":4,"rt":$n[0].Int32,"sn":"R","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"R2","is":true,"t":4,"rt":$n[0].Int32,"sn":"R2","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"slotIndex","t":4,"rt":$n[0].Int32,"sn":"slotIndex","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.RGB2Timeline end.*/

    /*Spine.AttachmentTimeline start.*/
    $m("Spine.AttachmentTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"slotIndex","pt":$n[0].Int32,"ps":1}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[8].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[8].MixBlend,"ps":5},{"n":"direction","pt":$n[8].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[0].Single,$n[0].Single,$n[8].ExposedList$1(Spine.Event),$n[0].Single,$n[8].MixBlend,$n[8].MixDirection]},{"a":1,"n":"SetAttachment","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"slot","pt":$n[8].Slot,"ps":1},{"n":"attachmentName","pt":$n[0].String,"ps":2}],"sn":"SetAttachment","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[8].Slot,$n[0].String]},{"a":2,"n":"SetFrame","t":8,"pi":[{"n":"frame","pt":$n[0].Int32,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"attachmentName","pt":$n[0].String,"ps":2}],"sn":"SetFrame","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Single,$n[0].String]},{"a":2,"n":"AttachmentNames","t":16,"rt":$n[0].Array.type(System.String),"g":{"a":2,"n":"get_AttachmentNames","t":8,"rt":$n[0].Array.type(System.String),"fg":"AttachmentNames"},"fn":"AttachmentNames"},{"a":2,"n":"SlotIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_SlotIndex","t":8,"rt":$n[0].Int32,"fg":"SlotIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"SlotIndex"},{"a":1,"n":"attachmentNames","t":4,"rt":$n[0].Array.type(System.String),"sn":"attachmentNames","ro":true},{"a":1,"n":"slotIndex","t":4,"rt":$n[0].Int32,"sn":"slotIndex","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.AttachmentTimeline end.*/

    /*Spine.DeformTimeline start.*/
    $m("Spine.DeformTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[0].Int32,$n[8].VertexAttachment],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"bezierCount","pt":$n[0].Int32,"ps":1},{"n":"slotIndex","pt":$n[0].Int32,"ps":2},{"n":"attachment","pt":$n[8].VertexAttachment,"ps":3}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[8].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[8].MixBlend,"ps":5},{"n":"direction","pt":$n[8].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[0].Single,$n[0].Single,$n[8].ExposedList$1(Spine.Event),$n[0].Single,$n[8].MixBlend,$n[8].MixDirection]},{"a":1,"n":"GetCurvePercent","t":8,"pi":[{"n":"time","pt":$n[0].Single,"ps":0},{"n":"frame","pt":$n[0].Int32,"ps":1}],"sn":"GetCurvePercent","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"SetFrame","t":8,"pi":[{"n":"frame","pt":$n[0].Int32,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"vertices","pt":$n[0].Array.type(System.Single),"ps":2}],"sn":"SetFrame","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Single,$n[0].Array.type(System.Single)]},{"a":2,"n":"setBezier","t":8,"pi":[{"n":"bezier","pt":$n[0].Int32,"ps":0},{"n":"frame","pt":$n[0].Int32,"ps":1},{"n":"value","pt":$n[0].Int32,"ps":2},{"n":"time1","pt":$n[0].Single,"ps":3},{"n":"value1","pt":$n[0].Single,"ps":4},{"n":"cx1","pt":$n[0].Single,"ps":5},{"n":"cy1","pt":$n[0].Single,"ps":6},{"n":"cx2","pt":$n[0].Single,"ps":7},{"n":"cy2","pt":$n[0].Single,"ps":8},{"n":"time2","pt":$n[0].Single,"ps":9},{"n":"value2","pt":$n[0].Single,"ps":10}],"sn":"setBezier","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Int32,$n[0].Int32,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single]},{"a":2,"n":"Attachment","t":16,"rt":$n[8].VertexAttachment,"g":{"a":2,"n":"get_Attachment","t":8,"rt":$n[8].VertexAttachment,"fg":"Attachment"},"fn":"Attachment"},{"a":2,"n":"SlotIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_SlotIndex","t":8,"rt":$n[0].Int32,"fg":"SlotIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"SlotIndex"},{"a":2,"n":"Vertices","t":16,"rt":$n[0].Array.type(System.Array.type(System.Single)),"g":{"a":2,"n":"get_Vertices","t":8,"rt":$n[0].Array.type(System.Array.type(System.Single)),"fg":"Vertices"},"fn":"Vertices"},{"a":1,"n":"attachment","t":4,"rt":$n[8].VertexAttachment,"sn":"attachment","ro":true},{"a":1,"n":"slotIndex","t":4,"rt":$n[0].Int32,"sn":"slotIndex","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"vertices","t":4,"rt":$n[0].Array.type(System.Array.type(System.Single)),"sn":"vertices"}]}; }, $n);
    /*Spine.DeformTimeline end.*/

    /*Spine.EventTimeline start.*/
    $m("Spine.EventTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[8].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[8].MixBlend,"ps":5},{"n":"direction","pt":$n[8].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[0].Single,$n[0].Single,$n[8].ExposedList$1(Spine.Event),$n[0].Single,$n[8].MixBlend,$n[8].MixDirection]},{"a":2,"n":"SetFrame","t":8,"pi":[{"n":"frame","pt":$n[0].Int32,"ps":0},{"n":"e","pt":$n[8].Event,"ps":1}],"sn":"SetFrame","rt":$n[0].Void,"p":[$n[0].Int32,$n[8].Event]},{"a":2,"n":"Events","t":16,"rt":System.Array.type(Spine.Event),"g":{"a":2,"n":"get_Events","t":8,"rt":System.Array.type(Spine.Event),"fg":"Events"},"fn":"Events"},{"a":1,"n":"events","t":4,"rt":System.Array.type(Spine.Event),"sn":"events","ro":true},{"a":1,"n":"propertyIds","is":true,"t":4,"rt":$n[0].Array.type(System.String),"sn":"propertyIds","ro":true}]}; }, $n);
    /*Spine.EventTimeline end.*/

    /*Spine.DrawOrderTimeline start.*/
    $m("Spine.DrawOrderTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[8].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[8].MixBlend,"ps":5},{"n":"direction","pt":$n[8].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[0].Single,$n[0].Single,$n[8].ExposedList$1(Spine.Event),$n[0].Single,$n[8].MixBlend,$n[8].MixDirection]},{"a":2,"n":"SetFrame","t":8,"pi":[{"n":"frame","pt":$n[0].Int32,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"drawOrder","pt":$n[0].Array.type(System.Int32),"ps":2}],"sn":"SetFrame","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Single,$n[0].Array.type(System.Int32)]},{"a":2,"n":"DrawOrders","t":16,"rt":$n[0].Array.type(System.Array.type(System.Int32)),"g":{"a":2,"n":"get_DrawOrders","t":8,"rt":$n[0].Array.type(System.Array.type(System.Int32)),"fg":"DrawOrders"},"fn":"DrawOrders"},{"a":1,"n":"drawOrders","t":4,"rt":$n[0].Array.type(System.Array.type(System.Int32)),"sn":"drawOrders","ro":true},{"a":1,"n":"propertyIds","is":true,"t":4,"rt":$n[0].Array.type(System.String),"sn":"propertyIds","ro":true}]}; }, $n);
    /*Spine.DrawOrderTimeline end.*/

    /*Spine.IkConstraintTimeline start.*/
    $m("Spine.IkConstraintTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"bezierCount","pt":$n[0].Int32,"ps":1},{"n":"ikConstraintIndex","pt":$n[0].Int32,"ps":2}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[8].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[8].MixBlend,"ps":5},{"n":"direction","pt":$n[8].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[0].Single,$n[0].Single,$n[8].ExposedList$1(Spine.Event),$n[0].Single,$n[8].MixBlend,$n[8].MixDirection]},{"a":2,"n":"SetFrame","t":8,"pi":[{"n":"frame","pt":$n[0].Int32,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"mix","pt":$n[0].Single,"ps":2},{"n":"softness","pt":$n[0].Single,"ps":3},{"n":"bendDirection","pt":$n[0].Int32,"ps":4},{"n":"compress","pt":$n[0].Boolean,"ps":5},{"n":"stretch","pt":$n[0].Boolean,"ps":6}],"sn":"SetFrame","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Int32,$n[0].Boolean,$n[0].Boolean]},{"ov":true,"a":2,"n":"FrameEntries","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_FrameEntries","t":8,"rt":$n[0].Int32,"fg":"FrameEntries","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"FrameEntries"},{"a":2,"n":"IkConstraintIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_IkConstraintIndex","t":8,"rt":$n[0].Int32,"fg":"IkConstraintIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"IkConstraintIndex"},{"a":1,"n":"BEND_DIRECTION","is":true,"t":4,"rt":$n[0].Int32,"sn":"BEND_DIRECTION","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"COMPRESS","is":true,"t":4,"rt":$n[0].Int32,"sn":"COMPRESS","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"ENTRIES","is":true,"t":4,"rt":$n[0].Int32,"sn":"ENTRIES","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"MIX","is":true,"t":4,"rt":$n[0].Int32,"sn":"MIX","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"SOFTNESS","is":true,"t":4,"rt":$n[0].Int32,"sn":"SOFTNESS","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"STRETCH","is":true,"t":4,"rt":$n[0].Int32,"sn":"STRETCH","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"constraintIndex","t":4,"rt":$n[0].Int32,"sn":"constraintIndex","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.IkConstraintTimeline end.*/

    /*Spine.TransformConstraintTimeline start.*/
    $m("Spine.TransformConstraintTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"bezierCount","pt":$n[0].Int32,"ps":1},{"n":"transformConstraintIndex","pt":$n[0].Int32,"ps":2}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[8].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[8].MixBlend,"ps":5},{"n":"direction","pt":$n[8].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[0].Single,$n[0].Single,$n[8].ExposedList$1(Spine.Event),$n[0].Single,$n[8].MixBlend,$n[8].MixDirection]},{"a":2,"n":"GetCurveValue","t":8,"pi":[{"n":"rotate","out":true,"pt":$n[0].Single,"ps":0},{"n":"x","out":true,"pt":$n[0].Single,"ps":1},{"n":"y","out":true,"pt":$n[0].Single,"ps":2},{"n":"scaleX","out":true,"pt":$n[0].Single,"ps":3},{"n":"scaleY","out":true,"pt":$n[0].Single,"ps":4},{"n":"shearY","out":true,"pt":$n[0].Single,"ps":5},{"n":"time","pt":$n[0].Single,"ps":6}],"sn":"GetCurveValue","rt":$n[0].Void,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single]},{"a":2,"n":"SetFrame","t":8,"pi":[{"n":"frame","pt":$n[0].Int32,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"mixRotate","pt":$n[0].Single,"ps":2},{"n":"mixX","pt":$n[0].Single,"ps":3},{"n":"mixY","pt":$n[0].Single,"ps":4},{"n":"mixScaleX","pt":$n[0].Single,"ps":5},{"n":"mixScaleY","pt":$n[0].Single,"ps":6},{"n":"mixShearY","pt":$n[0].Single,"ps":7}],"sn":"SetFrame","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single]},{"ov":true,"a":2,"n":"FrameEntries","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_FrameEntries","t":8,"rt":$n[0].Int32,"fg":"FrameEntries","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"FrameEntries"},{"a":2,"n":"TransformConstraintIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_TransformConstraintIndex","t":8,"rt":$n[0].Int32,"fg":"TransformConstraintIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"TransformConstraintIndex"},{"a":2,"n":"ENTRIES","is":true,"t":4,"rt":$n[0].Int32,"sn":"ENTRIES","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"ROTATE","is":true,"t":4,"rt":$n[0].Int32,"sn":"ROTATE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"SCALEX","is":true,"t":4,"rt":$n[0].Int32,"sn":"SCALEX","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"SCALEY","is":true,"t":4,"rt":$n[0].Int32,"sn":"SCALEY","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"SHEARY","is":true,"t":4,"rt":$n[0].Int32,"sn":"SHEARY","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"X","is":true,"t":4,"rt":$n[0].Int32,"sn":"X","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"Y","is":true,"t":4,"rt":$n[0].Int32,"sn":"Y","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"constraintIndex","t":4,"rt":$n[0].Int32,"sn":"constraintIndex","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.TransformConstraintTimeline end.*/

    /*Spine.PathConstraintPositionTimeline start.*/
    $m("Spine.PathConstraintPositionTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"bezierCount","pt":$n[0].Int32,"ps":1},{"n":"pathConstraintIndex","pt":$n[0].Int32,"ps":2}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[8].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[8].MixBlend,"ps":5},{"n":"direction","pt":$n[8].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[0].Single,$n[0].Single,$n[8].ExposedList$1(Spine.Event),$n[0].Single,$n[8].MixBlend,$n[8].MixDirection]},{"a":2,"n":"PathConstraintIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_PathConstraintIndex","t":8,"rt":$n[0].Int32,"fg":"PathConstraintIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"PathConstraintIndex"},{"a":1,"n":"constraintIndex","t":4,"rt":$n[0].Int32,"sn":"constraintIndex","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.PathConstraintPositionTimeline end.*/

    /*Spine.PathConstraintSpacingTimeline start.*/
    $m("Spine.PathConstraintSpacingTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"bezierCount","pt":$n[0].Int32,"ps":1},{"n":"pathConstraintIndex","pt":$n[0].Int32,"ps":2}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"events","pt":$n[8].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[8].MixBlend,"ps":5},{"n":"direction","pt":$n[8].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[0].Single,$n[0].Single,$n[8].ExposedList$1(Spine.Event),$n[0].Single,$n[8].MixBlend,$n[8].MixDirection]},{"a":2,"n":"PathConstraintIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_PathConstraintIndex","t":8,"rt":$n[0].Int32,"fg":"PathConstraintIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"PathConstraintIndex"},{"a":1,"n":"constraintIndex","t":4,"rt":$n[0].Int32,"sn":"constraintIndex","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.PathConstraintSpacingTimeline end.*/

    /*Spine.PathConstraintMixTimeline start.*/
    $m("Spine.PathConstraintMixTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"bezierCount","pt":$n[0].Int32,"ps":1},{"n":"pathConstraintIndex","pt":$n[0].Int32,"ps":2}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[8].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[8].MixBlend,"ps":5},{"n":"direction","pt":$n[8].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[0].Single,$n[0].Single,$n[8].ExposedList$1(Spine.Event),$n[0].Single,$n[8].MixBlend,$n[8].MixDirection]},{"a":2,"n":"SetFrame","t":8,"pi":[{"n":"frame","pt":$n[0].Int32,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"mixRotate","pt":$n[0].Single,"ps":2},{"n":"mixX","pt":$n[0].Single,"ps":3},{"n":"mixY","pt":$n[0].Single,"ps":4}],"sn":"SetFrame","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single]},{"ov":true,"a":2,"n":"FrameEntries","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_FrameEntries","t":8,"rt":$n[0].Int32,"fg":"FrameEntries","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"FrameEntries"},{"a":2,"n":"PathConstraintIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_PathConstraintIndex","t":8,"rt":$n[0].Int32,"fg":"PathConstraintIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"PathConstraintIndex"},{"a":2,"n":"ENTRIES","is":true,"t":4,"rt":$n[0].Int32,"sn":"ENTRIES","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"ROTATE","is":true,"t":4,"rt":$n[0].Int32,"sn":"ROTATE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"X","is":true,"t":4,"rt":$n[0].Int32,"sn":"X","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"Y","is":true,"t":4,"rt":$n[0].Int32,"sn":"Y","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"constraintIndex","t":4,"rt":$n[0].Int32,"sn":"constraintIndex","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.PathConstraintMixTimeline end.*/

    /*Spine.PhysicsConstraintTimeline start.*/
    $m("Spine.PhysicsConstraintTimeline", function () { return {"att":1048705,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[0].Int32,$n[8].Property],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"bezierCount","pt":$n[0].Int32,"ps":1},{"n":"physicsConstraintIndex","pt":$n[0].Int32,"ps":2},{"n":"property","pt":$n[8].Property,"ps":3}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[8].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[8].MixBlend,"ps":5},{"n":"direction","pt":$n[8].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[0].Single,$n[0].Single,$n[8].ExposedList$1(Spine.Event),$n[0].Single,$n[8].MixBlend,$n[8].MixDirection]},{"ab":true,"a":3,"n":"Get","t":8,"pi":[{"n":"constraint","pt":$n[8].PhysicsConstraint,"ps":0}],"sn":"Get","rt":$n[0].Single,"p":[$n[8].PhysicsConstraint],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"ab":true,"a":3,"n":"Global","t":8,"pi":[{"n":"constraint","pt":$n[8].PhysicsConstraintData,"ps":0}],"sn":"Global","rt":$n[0].Boolean,"p":[$n[8].PhysicsConstraintData],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"ab":true,"a":3,"n":"Set","t":8,"pi":[{"n":"constraint","pt":$n[8].PhysicsConstraint,"ps":0},{"n":"value","pt":$n[0].Single,"ps":1}],"sn":"Set","rt":$n[0].Void,"p":[$n[8].PhysicsConstraint,$n[0].Single]},{"ab":true,"a":3,"n":"Setup","t":8,"pi":[{"n":"constraint","pt":$n[8].PhysicsConstraint,"ps":0}],"sn":"Setup","rt":$n[0].Single,"p":[$n[8].PhysicsConstraint],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"PhysicsConstraintIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_PhysicsConstraintIndex","t":8,"rt":$n[0].Int32,"fg":"PhysicsConstraintIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"PhysicsConstraintIndex"},{"a":1,"n":"constraintIndex","t":4,"rt":$n[0].Int32,"sn":"constraintIndex","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.PhysicsConstraintTimeline end.*/

    /*Spine.PhysicsConstraintInertiaTimeline start.*/
    $m("Spine.PhysicsConstraintInertiaTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"bezierCount","pt":$n[0].Int32,"ps":1},{"n":"physicsConstraintIndex","pt":$n[0].Int32,"ps":2}],"sn":"ctor"},{"ov":true,"a":3,"n":"Get","t":8,"pi":[{"n":"constraint","pt":$n[8].PhysicsConstraint,"ps":0}],"sn":"Get","rt":$n[0].Single,"p":[$n[8].PhysicsConstraint],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"ov":true,"a":3,"n":"Global","t":8,"pi":[{"n":"constraint","pt":$n[8].PhysicsConstraintData,"ps":0}],"sn":"Global","rt":$n[0].Boolean,"p":[$n[8].PhysicsConstraintData],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"ov":true,"a":3,"n":"Set","t":8,"pi":[{"n":"constraint","pt":$n[8].PhysicsConstraint,"ps":0},{"n":"value","pt":$n[0].Single,"ps":1}],"sn":"Set","rt":$n[0].Void,"p":[$n[8].PhysicsConstraint,$n[0].Single]},{"ov":true,"a":3,"n":"Setup","t":8,"pi":[{"n":"constraint","pt":$n[8].PhysicsConstraint,"ps":0}],"sn":"Setup","rt":$n[0].Single,"p":[$n[8].PhysicsConstraint],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.PhysicsConstraintInertiaTimeline end.*/

    /*Spine.PhysicsConstraintStrengthTimeline start.*/
    $m("Spine.PhysicsConstraintStrengthTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"bezierCount","pt":$n[0].Int32,"ps":1},{"n":"physicsConstraintIndex","pt":$n[0].Int32,"ps":2}],"sn":"ctor"},{"ov":true,"a":3,"n":"Get","t":8,"pi":[{"n":"constraint","pt":$n[8].PhysicsConstraint,"ps":0}],"sn":"Get","rt":$n[0].Single,"p":[$n[8].PhysicsConstraint],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"ov":true,"a":3,"n":"Global","t":8,"pi":[{"n":"constraint","pt":$n[8].PhysicsConstraintData,"ps":0}],"sn":"Global","rt":$n[0].Boolean,"p":[$n[8].PhysicsConstraintData],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"ov":true,"a":3,"n":"Set","t":8,"pi":[{"n":"constraint","pt":$n[8].PhysicsConstraint,"ps":0},{"n":"value","pt":$n[0].Single,"ps":1}],"sn":"Set","rt":$n[0].Void,"p":[$n[8].PhysicsConstraint,$n[0].Single]},{"ov":true,"a":3,"n":"Setup","t":8,"pi":[{"n":"constraint","pt":$n[8].PhysicsConstraint,"ps":0}],"sn":"Setup","rt":$n[0].Single,"p":[$n[8].PhysicsConstraint],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.PhysicsConstraintStrengthTimeline end.*/

    /*Spine.PhysicsConstraintDampingTimeline start.*/
    $m("Spine.PhysicsConstraintDampingTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"bezierCount","pt":$n[0].Int32,"ps":1},{"n":"physicsConstraintIndex","pt":$n[0].Int32,"ps":2}],"sn":"ctor"},{"ov":true,"a":3,"n":"Get","t":8,"pi":[{"n":"constraint","pt":$n[8].PhysicsConstraint,"ps":0}],"sn":"Get","rt":$n[0].Single,"p":[$n[8].PhysicsConstraint],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"ov":true,"a":3,"n":"Global","t":8,"pi":[{"n":"constraint","pt":$n[8].PhysicsConstraintData,"ps":0}],"sn":"Global","rt":$n[0].Boolean,"p":[$n[8].PhysicsConstraintData],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"ov":true,"a":3,"n":"Set","t":8,"pi":[{"n":"constraint","pt":$n[8].PhysicsConstraint,"ps":0},{"n":"value","pt":$n[0].Single,"ps":1}],"sn":"Set","rt":$n[0].Void,"p":[$n[8].PhysicsConstraint,$n[0].Single]},{"ov":true,"a":3,"n":"Setup","t":8,"pi":[{"n":"constraint","pt":$n[8].PhysicsConstraint,"ps":0}],"sn":"Setup","rt":$n[0].Single,"p":[$n[8].PhysicsConstraint],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.PhysicsConstraintDampingTimeline end.*/

    /*Spine.PhysicsConstraintMassTimeline start.*/
    $m("Spine.PhysicsConstraintMassTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"bezierCount","pt":$n[0].Int32,"ps":1},{"n":"physicsConstraintIndex","pt":$n[0].Int32,"ps":2}],"sn":"ctor"},{"ov":true,"a":3,"n":"Get","t":8,"pi":[{"n":"constraint","pt":$n[8].PhysicsConstraint,"ps":0}],"sn":"Get","rt":$n[0].Single,"p":[$n[8].PhysicsConstraint],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"ov":true,"a":3,"n":"Global","t":8,"pi":[{"n":"constraint","pt":$n[8].PhysicsConstraintData,"ps":0}],"sn":"Global","rt":$n[0].Boolean,"p":[$n[8].PhysicsConstraintData],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"ov":true,"a":3,"n":"Set","t":8,"pi":[{"n":"constraint","pt":$n[8].PhysicsConstraint,"ps":0},{"n":"value","pt":$n[0].Single,"ps":1}],"sn":"Set","rt":$n[0].Void,"p":[$n[8].PhysicsConstraint,$n[0].Single]},{"ov":true,"a":3,"n":"Setup","t":8,"pi":[{"n":"constraint","pt":$n[8].PhysicsConstraint,"ps":0}],"sn":"Setup","rt":$n[0].Single,"p":[$n[8].PhysicsConstraint],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.PhysicsConstraintMassTimeline end.*/

    /*Spine.PhysicsConstraintWindTimeline start.*/
    $m("Spine.PhysicsConstraintWindTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"bezierCount","pt":$n[0].Int32,"ps":1},{"n":"physicsConstraintIndex","pt":$n[0].Int32,"ps":2}],"sn":"ctor"},{"ov":true,"a":3,"n":"Get","t":8,"pi":[{"n":"constraint","pt":$n[8].PhysicsConstraint,"ps":0}],"sn":"Get","rt":$n[0].Single,"p":[$n[8].PhysicsConstraint],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"ov":true,"a":3,"n":"Global","t":8,"pi":[{"n":"constraint","pt":$n[8].PhysicsConstraintData,"ps":0}],"sn":"Global","rt":$n[0].Boolean,"p":[$n[8].PhysicsConstraintData],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"ov":true,"a":3,"n":"Set","t":8,"pi":[{"n":"constraint","pt":$n[8].PhysicsConstraint,"ps":0},{"n":"value","pt":$n[0].Single,"ps":1}],"sn":"Set","rt":$n[0].Void,"p":[$n[8].PhysicsConstraint,$n[0].Single]},{"ov":true,"a":3,"n":"Setup","t":8,"pi":[{"n":"constraint","pt":$n[8].PhysicsConstraint,"ps":0}],"sn":"Setup","rt":$n[0].Single,"p":[$n[8].PhysicsConstraint],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.PhysicsConstraintWindTimeline end.*/

    /*Spine.PhysicsConstraintGravityTimeline start.*/
    $m("Spine.PhysicsConstraintGravityTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"bezierCount","pt":$n[0].Int32,"ps":1},{"n":"physicsConstraintIndex","pt":$n[0].Int32,"ps":2}],"sn":"ctor"},{"ov":true,"a":3,"n":"Get","t":8,"pi":[{"n":"constraint","pt":$n[8].PhysicsConstraint,"ps":0}],"sn":"Get","rt":$n[0].Single,"p":[$n[8].PhysicsConstraint],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"ov":true,"a":3,"n":"Global","t":8,"pi":[{"n":"constraint","pt":$n[8].PhysicsConstraintData,"ps":0}],"sn":"Global","rt":$n[0].Boolean,"p":[$n[8].PhysicsConstraintData],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"ov":true,"a":3,"n":"Set","t":8,"pi":[{"n":"constraint","pt":$n[8].PhysicsConstraint,"ps":0},{"n":"value","pt":$n[0].Single,"ps":1}],"sn":"Set","rt":$n[0].Void,"p":[$n[8].PhysicsConstraint,$n[0].Single]},{"ov":true,"a":3,"n":"Setup","t":8,"pi":[{"n":"constraint","pt":$n[8].PhysicsConstraint,"ps":0}],"sn":"Setup","rt":$n[0].Single,"p":[$n[8].PhysicsConstraint],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.PhysicsConstraintGravityTimeline end.*/

    /*Spine.PhysicsConstraintMixTimeline start.*/
    $m("Spine.PhysicsConstraintMixTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"bezierCount","pt":$n[0].Int32,"ps":1},{"n":"physicsConstraintIndex","pt":$n[0].Int32,"ps":2}],"sn":"ctor"},{"ov":true,"a":3,"n":"Get","t":8,"pi":[{"n":"constraint","pt":$n[8].PhysicsConstraint,"ps":0}],"sn":"Get","rt":$n[0].Single,"p":[$n[8].PhysicsConstraint],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"ov":true,"a":3,"n":"Global","t":8,"pi":[{"n":"constraint","pt":$n[8].PhysicsConstraintData,"ps":0}],"sn":"Global","rt":$n[0].Boolean,"p":[$n[8].PhysicsConstraintData],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"ov":true,"a":3,"n":"Set","t":8,"pi":[{"n":"constraint","pt":$n[8].PhysicsConstraint,"ps":0},{"n":"value","pt":$n[0].Single,"ps":1}],"sn":"Set","rt":$n[0].Void,"p":[$n[8].PhysicsConstraint,$n[0].Single]},{"ov":true,"a":3,"n":"Setup","t":8,"pi":[{"n":"constraint","pt":$n[8].PhysicsConstraint,"ps":0}],"sn":"Setup","rt":$n[0].Single,"p":[$n[8].PhysicsConstraint],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.PhysicsConstraintMixTimeline end.*/

    /*Spine.PhysicsConstraintResetTimeline start.*/
    $m("Spine.PhysicsConstraintResetTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"physicsConstraintIndex","pt":$n[0].Int32,"ps":1}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[8].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[8].MixBlend,"ps":5},{"n":"direction","pt":$n[8].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[0].Single,$n[0].Single,$n[8].ExposedList$1(Spine.Event),$n[0].Single,$n[8].MixBlend,$n[8].MixDirection]},{"a":2,"n":"SetFrame","t":8,"pi":[{"n":"frame","pt":$n[0].Int32,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1}],"sn":"SetFrame","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Single]},{"ov":true,"a":2,"n":"FrameCount","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_FrameCount","t":8,"rt":$n[0].Int32,"fg":"FrameCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"FrameCount"},{"a":2,"n":"PhysicsConstraintIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_PhysicsConstraintIndex","t":8,"rt":$n[0].Int32,"fg":"PhysicsConstraintIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"PhysicsConstraintIndex"},{"a":1,"n":"constraintIndex","t":4,"rt":$n[0].Int32,"sn":"constraintIndex","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"propertyIds","is":true,"t":4,"rt":$n[0].Array.type(System.String),"sn":"propertyIds","ro":true}]}; }, $n);
    /*Spine.PhysicsConstraintResetTimeline end.*/

    /*Spine.SequenceTimeline start.*/
    $m("Spine.SequenceTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[8].Attachment],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"slotIndex","pt":$n[0].Int32,"ps":1},{"n":"attachment","pt":$n[8].Attachment,"ps":2}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[8].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[8].MixBlend,"ps":5},{"n":"direction","pt":$n[8].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[0].Single,$n[0].Single,$n[8].ExposedList$1(Spine.Event),$n[0].Single,$n[8].MixBlend,$n[8].MixDirection]},{"a":2,"n":"SetFrame","t":8,"pi":[{"n":"frame","pt":$n[0].Int32,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"mode","pt":$n[8].SequenceMode,"ps":2},{"n":"index","pt":$n[0].Int32,"ps":3},{"n":"delay","pt":$n[0].Single,"ps":4}],"sn":"SetFrame","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Single,$n[8].SequenceMode,$n[0].Int32,$n[0].Single]},{"a":2,"n":"Attachment","t":16,"rt":$n[8].Attachment,"g":{"a":2,"n":"get_Attachment","t":8,"rt":$n[8].Attachment,"fg":"Attachment"},"fn":"Attachment"},{"ov":true,"a":2,"n":"FrameEntries","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_FrameEntries","t":8,"rt":$n[0].Int32,"fg":"FrameEntries","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"FrameEntries"},{"a":2,"n":"SlotIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_SlotIndex","t":8,"rt":$n[0].Int32,"fg":"SlotIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"SlotIndex"},{"a":1,"n":"DELAY","is":true,"t":4,"rt":$n[0].Int32,"sn":"DELAY","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"ENTRIES","is":true,"t":4,"rt":$n[0].Int32,"sn":"ENTRIES","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"MODE","is":true,"t":4,"rt":$n[0].Int32,"sn":"MODE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"attachment","t":4,"rt":$n[8].IHasTextureRegion,"sn":"attachment","ro":true},{"a":1,"n":"slotIndex","t":4,"rt":$n[0].Int32,"sn":"slotIndex","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.SequenceTimeline end.*/

    /*Spine.AnimationState start.*/
    $m("Spine.AnimationState", function () { return {"nested":[Function,Function],"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[8].AnimationStateData],"pi":[{"n":"data","pt":$n[8].AnimationStateData,"ps":0}],"sn":"ctor"},{"a":2,"n":"AddAnimation","t":8,"pi":[{"n":"trackIndex","pt":$n[0].Int32,"ps":0},{"n":"animation","pt":$n[8].Animation,"ps":1},{"n":"loop","pt":$n[0].Boolean,"ps":2},{"n":"delay","pt":$n[0].Single,"ps":3}],"sn":"AddAnimation","rt":$n[8].TrackEntry,"p":[$n[0].Int32,$n[8].Animation,$n[0].Boolean,$n[0].Single]},{"a":2,"n":"AddAnimation","t":8,"pi":[{"n":"trackIndex","pt":$n[0].Int32,"ps":0},{"n":"animationName","pt":$n[0].String,"ps":1},{"n":"loop","pt":$n[0].Boolean,"ps":2},{"n":"delay","pt":$n[0].Single,"ps":3}],"sn":"AddAnimation$1","rt":$n[8].TrackEntry,"p":[$n[0].Int32,$n[0].String,$n[0].Boolean,$n[0].Single]},{"a":2,"n":"AddEmptyAnimation","t":8,"pi":[{"n":"trackIndex","pt":$n[0].Int32,"ps":0},{"n":"mixDuration","pt":$n[0].Single,"ps":1},{"n":"delay","pt":$n[0].Single,"ps":2}],"sn":"AddEmptyAnimation","rt":$n[8].TrackEntry,"p":[$n[0].Int32,$n[0].Single,$n[0].Single]},{"a":2,"n":"AddEventSubscribersFrom","t":8,"pi":[{"n":"src","pt":$n[8].AnimationState,"ps":0}],"sn":"AddEventSubscribersFrom","rt":$n[0].Void,"p":[$n[8].AnimationState]},{"a":1,"n":"AnimationsChanged","t":8,"sn":"AnimationsChanged","rt":$n[0].Void},{"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0}],"sn":"Apply","rt":$n[0].Boolean,"p":[$n[8].Skeleton],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"ApplyAttachmentTimeline","t":8,"pi":[{"n":"timeline","pt":$n[8].AttachmentTimeline,"ps":0},{"n":"skeleton","pt":$n[8].Skeleton,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"blend","pt":$n[8].MixBlend,"ps":3},{"n":"attachments","pt":$n[0].Boolean,"ps":4}],"sn":"ApplyAttachmentTimeline","rt":$n[0].Void,"p":[$n[8].AttachmentTimeline,$n[8].Skeleton,$n[0].Single,$n[8].MixBlend,$n[0].Boolean]},{"a":2,"n":"ApplyEventTimelinesOnly","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"issueEvents","dv":true,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"ApplyEventTimelinesOnly","rt":$n[0].Boolean,"p":[$n[8].Skeleton,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"ApplyMixingFrom","t":8,"pi":[{"n":"to","pt":$n[8].TrackEntry,"ps":0},{"n":"skeleton","pt":$n[8].Skeleton,"ps":1},{"n":"blend","pt":$n[8].MixBlend,"ps":2}],"sn":"ApplyMixingFrom","rt":$n[0].Single,"p":[$n[8].TrackEntry,$n[8].Skeleton,$n[8].MixBlend],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"ApplyMixingFromEventTimelinesOnly","t":8,"pi":[{"n":"to","pt":$n[8].TrackEntry,"ps":0},{"n":"skeleton","pt":$n[8].Skeleton,"ps":1},{"n":"issueEvents","pt":$n[0].Boolean,"ps":2}],"sn":"ApplyMixingFromEventTimelinesOnly","rt":$n[0].Single,"p":[$n[8].TrackEntry,$n[8].Skeleton,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"ApplyRotateTimeline","is":true,"t":8,"pi":[{"n":"timeline","pt":$n[8].RotateTimeline,"ps":0},{"n":"skeleton","pt":$n[8].Skeleton,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"alpha","pt":$n[0].Single,"ps":3},{"n":"blend","pt":$n[8].MixBlend,"ps":4},{"n":"timelinesRotation","pt":$n[0].Array.type(System.Single),"ps":5},{"n":"i","pt":$n[0].Int32,"ps":6},{"n":"firstFrame","pt":$n[0].Boolean,"ps":7}],"sn":"ApplyRotateTimeline","rt":$n[0].Void,"p":[$n[8].RotateTimeline,$n[8].Skeleton,$n[0].Single,$n[0].Single,$n[8].MixBlend,$n[0].Array.type(System.Single),$n[0].Int32,$n[0].Boolean]},{"a":2,"n":"AssignEventSubscribersFrom","t":8,"pi":[{"n":"src","pt":$n[8].AnimationState,"ps":0}],"sn":"AssignEventSubscribersFrom","rt":$n[0].Void,"p":[$n[8].AnimationState]},{"a":2,"n":"ClearListenerNotifications","t":8,"sn":"ClearListenerNotifications","rt":$n[0].Void},{"a":2,"n":"ClearNext","t":8,"pi":[{"n":"entry","pt":$n[8].TrackEntry,"ps":0}],"sn":"ClearNext","rt":$n[0].Void,"p":[$n[8].TrackEntry]},{"a":2,"n":"ClearTrack","t":8,"pi":[{"n":"trackIndex","pt":$n[0].Int32,"ps":0}],"sn":"ClearTrack","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"ClearTracks","t":8,"sn":"ClearTracks","rt":$n[0].Void},{"a":1,"n":"ComputeHold","t":8,"pi":[{"n":"entry","pt":$n[8].TrackEntry,"ps":0}],"sn":"ComputeHold","rt":$n[0].Void,"p":[$n[8].TrackEntry]},{"a":1,"n":"ExpandToIndex","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0}],"sn":"ExpandToIndex","rt":$n[8].TrackEntry,"p":[$n[0].Int32]},{"a":2,"n":"GetCurrent","t":8,"pi":[{"n":"trackIndex","pt":$n[0].Int32,"ps":0}],"sn":"GetCurrent","rt":$n[8].TrackEntry,"p":[$n[0].Int32]},{"a":1,"n":"NewTrackEntry","t":8,"pi":[{"n":"trackIndex","pt":$n[0].Int32,"ps":0},{"n":"animation","pt":$n[8].Animation,"ps":1},{"n":"loop","pt":$n[0].Boolean,"ps":2},{"n":"last","pt":$n[8].TrackEntry,"ps":3}],"sn":"NewTrackEntry","rt":$n[8].TrackEntry,"p":[$n[0].Int32,$n[8].Animation,$n[0].Boolean,$n[8].TrackEntry]},{"a":4,"n":"OnComplete","t":8,"pi":[{"n":"entry","pt":$n[8].TrackEntry,"ps":0}],"sn":"OnComplete","rt":$n[0].Void,"p":[$n[8].TrackEntry]},{"a":4,"n":"OnDispose","t":8,"pi":[{"n":"entry","pt":$n[8].TrackEntry,"ps":0}],"sn":"OnDispose","rt":$n[0].Void,"p":[$n[8].TrackEntry]},{"a":4,"n":"OnEnd","t":8,"pi":[{"n":"entry","pt":$n[8].TrackEntry,"ps":0}],"sn":"OnEnd","rt":$n[0].Void,"p":[$n[8].TrackEntry]},{"a":4,"n":"OnEvent","t":8,"pi":[{"n":"entry","pt":$n[8].TrackEntry,"ps":0},{"n":"e","pt":$n[8].Event,"ps":1}],"sn":"OnEvent","rt":$n[0].Void,"p":[$n[8].TrackEntry,$n[8].Event]},{"a":4,"n":"OnInterrupt","t":8,"pi":[{"n":"entry","pt":$n[8].TrackEntry,"ps":0}],"sn":"OnInterrupt","rt":$n[0].Void,"p":[$n[8].TrackEntry]},{"a":4,"n":"OnStart","t":8,"pi":[{"n":"entry","pt":$n[8].TrackEntry,"ps":0}],"sn":"OnStart","rt":$n[0].Void,"p":[$n[8].TrackEntry]},{"a":1,"n":"QueueEvents","t":8,"pi":[{"n":"entry","pt":$n[8].TrackEntry,"ps":0},{"n":"animationTime","pt":$n[0].Single,"ps":1}],"sn":"QueueEvents","rt":$n[0].Void,"p":[$n[8].TrackEntry,$n[0].Single]},{"a":2,"n":"SetAnimation","t":8,"pi":[{"n":"trackIndex","pt":$n[0].Int32,"ps":0},{"n":"animation","pt":$n[8].Animation,"ps":1},{"n":"loop","pt":$n[0].Boolean,"ps":2}],"sn":"SetAnimation","rt":$n[8].TrackEntry,"p":[$n[0].Int32,$n[8].Animation,$n[0].Boolean]},{"a":2,"n":"SetAnimation","t":8,"pi":[{"n":"trackIndex","pt":$n[0].Int32,"ps":0},{"n":"animationName","pt":$n[0].String,"ps":1},{"n":"loop","pt":$n[0].Boolean,"ps":2}],"sn":"SetAnimation$1","rt":$n[8].TrackEntry,"p":[$n[0].Int32,$n[0].String,$n[0].Boolean]},{"a":1,"n":"SetAttachment","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"slot","pt":$n[8].Slot,"ps":1},{"n":"attachmentName","pt":$n[0].String,"ps":2},{"n":"attachments","pt":$n[0].Boolean,"ps":3}],"sn":"SetAttachment","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[8].Slot,$n[0].String,$n[0].Boolean]},{"a":1,"n":"SetCurrent","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"current","pt":$n[8].TrackEntry,"ps":1},{"n":"interrupt","pt":$n[0].Boolean,"ps":2}],"sn":"SetCurrent","rt":$n[0].Void,"p":[$n[0].Int32,$n[8].TrackEntry,$n[0].Boolean]},{"a":2,"n":"SetEmptyAnimation","t":8,"pi":[{"n":"trackIndex","pt":$n[0].Int32,"ps":0},{"n":"mixDuration","pt":$n[0].Single,"ps":1}],"sn":"SetEmptyAnimation","rt":$n[8].TrackEntry,"p":[$n[0].Int32,$n[0].Single]},{"a":2,"n":"SetEmptyAnimations","t":8,"pi":[{"n":"mixDuration","pt":$n[0].Single,"ps":0}],"sn":"SetEmptyAnimations","rt":$n[0].Void,"p":[$n[0].Single]},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"Update","t":8,"pi":[{"n":"delta","pt":$n[0].Single,"ps":0}],"sn":"Update","rt":$n[0].Void,"p":[$n[0].Single]},{"a":1,"n":"UpdateMixingFrom","t":8,"pi":[{"n":"to","pt":$n[8].TrackEntry,"ps":0},{"n":"delta","pt":$n[0].Single,"ps":1}],"sn":"UpdateMixingFrom","rt":$n[0].Boolean,"p":[$n[8].TrackEntry,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"Data","t":16,"rt":$n[8].AnimationStateData,"g":{"a":2,"n":"get_Data","t":8,"rt":$n[8].AnimationStateData,"fg":"Data"},"s":{"a":2,"n":"set_Data","t":8,"p":[$n[8].AnimationStateData],"rt":$n[0].Void,"fs":"Data"},"fn":"Data"},{"a":2,"n":"TimeScale","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_TimeScale","t":8,"rt":$n[0].Single,"fg":"TimeScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_TimeScale","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"TimeScale"},"fn":"TimeScale"},{"a":2,"n":"Tracks","t":16,"rt":$n[8].ExposedList$1(Spine.TrackEntry),"g":{"a":2,"n":"get_Tracks","t":8,"rt":$n[8].ExposedList$1(Spine.TrackEntry),"fg":"Tracks"},"fn":"Tracks"},{"a":4,"n":"Current","is":true,"t":4,"rt":$n[0].Int32,"sn":"Current","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"EmptyAnimation","is":true,"t":4,"rt":$n[8].Animation,"sn":"EmptyAnimation","ro":true},{"a":4,"n":"First","is":true,"t":4,"rt":$n[0].Int32,"sn":"First","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"HoldFirst","is":true,"t":4,"rt":$n[0].Int32,"sn":"HoldFirst","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"HoldMix","is":true,"t":4,"rt":$n[0].Int32,"sn":"HoldMix","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"HoldSubsequent","is":true,"t":4,"rt":$n[0].Int32,"sn":"HoldSubsequent","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"Setup","is":true,"t":4,"rt":$n[0].Int32,"sn":"Setup","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"Subsequent","is":true,"t":4,"rt":$n[0].Int32,"sn":"Subsequent","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"animationsChanged","t":4,"rt":$n[0].Boolean,"sn":"animationsChanged","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"data","t":4,"rt":$n[8].AnimationStateData,"sn":"data"},{"a":1,"n":"events","t":4,"rt":$n[8].ExposedList$1(Spine.Event),"sn":"events","ro":true},{"a":1,"n":"propertyIds","t":4,"rt":$n[2].HashSet$1(System.String),"sn":"propertyIds","ro":true},{"a":1,"n":"queue","t":4,"rt":$n[8].EventQueue,"sn":"queue","ro":true},{"a":1,"n":"timeScale","t":4,"rt":$n[0].Single,"sn":"timeScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"trackEntryPool","t":4,"rt":$n[8].Pool$1(Spine.TrackEntry),"sn":"trackEntryPool","ro":true},{"a":1,"n":"tracks","t":4,"rt":$n[8].ExposedList$1(Spine.TrackEntry),"sn":"tracks","ro":true},{"a":1,"n":"unkeyedState","t":4,"rt":$n[0].Int32,"sn":"unkeyedState","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"Complete","t":2,"ad":{"a":2,"n":"add_Complete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addComplete","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_Complete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeComplete","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"Dispose","t":2,"ad":{"a":2,"n":"add_Dispose","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addDispose","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_Dispose","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeDispose","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"End","t":2,"ad":{"a":2,"n":"add_End","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addEnd","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_End","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeEnd","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"Event","t":2,"ad":{"a":2,"n":"add_Event","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addEvent","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_Event","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeEvent","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"Interrupt","t":2,"ad":{"a":2,"n":"add_Interrupt","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addInterrupt","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_Interrupt","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeInterrupt","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"Start","t":2,"ad":{"a":2,"n":"add_Start","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addStart","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_Start","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeStart","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.AnimationState end.*/

    /*Spine.TrackEntry start.*/
    $m("Spine.TrackEntry", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AllowImmediateQueue","t":8,"sn":"AllowImmediateQueue","rt":$n[0].Void},{"a":4,"n":"OnComplete","t":8,"sn":"OnComplete","rt":$n[0].Void},{"a":4,"n":"OnDispose","t":8,"sn":"OnDispose","rt":$n[0].Void},{"a":4,"n":"OnEnd","t":8,"sn":"OnEnd","rt":$n[0].Void},{"a":4,"n":"OnEvent","t":8,"pi":[{"n":"e","pt":$n[8].Event,"ps":0}],"sn":"OnEvent","rt":$n[0].Void,"p":[$n[8].Event]},{"a":4,"n":"OnInterrupt","t":8,"sn":"OnInterrupt","rt":$n[0].Void},{"a":4,"n":"OnStart","t":8,"sn":"OnStart","rt":$n[0].Void},{"a":2,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"a":2,"n":"ResetRotationDirections","t":8,"sn":"ResetRotationDirections","rt":$n[0].Void},{"a":2,"n":"SetMixDuration","t":8,"pi":[{"n":"mixDuration","pt":$n[0].Single,"ps":0},{"n":"delay","pt":$n[0].Single,"ps":1}],"sn":"SetMixDuration","rt":$n[0].Void,"p":[$n[0].Single,$n[0].Single]},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"Alpha","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Alpha","t":8,"rt":$n[0].Single,"fg":"Alpha","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Alpha","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Alpha"},"fn":"Alpha"},{"a":2,"n":"AlphaAttachmentThreshold","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_AlphaAttachmentThreshold","t":8,"rt":$n[0].Single,"fg":"AlphaAttachmentThreshold","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_AlphaAttachmentThreshold","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"AlphaAttachmentThreshold"},"fn":"AlphaAttachmentThreshold"},{"a":2,"n":"Animation","t":16,"rt":$n[8].Animation,"g":{"a":2,"n":"get_Animation","t":8,"rt":$n[8].Animation,"fg":"Animation"},"fn":"Animation"},{"a":2,"n":"AnimationEnd","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_AnimationEnd","t":8,"rt":$n[0].Single,"fg":"AnimationEnd","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_AnimationEnd","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"AnimationEnd"},"fn":"AnimationEnd"},{"a":2,"n":"AnimationLast","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_AnimationLast","t":8,"rt":$n[0].Single,"fg":"AnimationLast","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_AnimationLast","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"AnimationLast"},"fn":"AnimationLast"},{"a":2,"n":"AnimationStart","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_AnimationStart","t":8,"rt":$n[0].Single,"fg":"AnimationStart","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_AnimationStart","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"AnimationStart"},"fn":"AnimationStart"},{"a":2,"n":"AnimationTime","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_AnimationTime","t":8,"rt":$n[0].Single,"fg":"AnimationTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"AnimationTime"},{"a":2,"n":"Delay","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Delay","t":8,"rt":$n[0].Single,"fg":"Delay","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Delay","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Delay"},"fn":"Delay"},{"a":2,"n":"EventThreshold","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_EventThreshold","t":8,"rt":$n[0].Single,"fg":"EventThreshold","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_EventThreshold","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"EventThreshold"},"fn":"EventThreshold"},{"a":2,"n":"HoldPrevious","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_HoldPrevious","t":8,"rt":$n[0].Boolean,"fg":"HoldPrevious","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_HoldPrevious","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"HoldPrevious"},"fn":"HoldPrevious"},{"a":2,"n":"InterruptAlpha","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_InterruptAlpha","t":8,"rt":$n[0].Single,"fg":"InterruptAlpha","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"InterruptAlpha"},{"a":2,"n":"IsComplete","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsComplete","t":8,"rt":$n[0].Boolean,"fg":"IsComplete","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsComplete"},{"a":2,"n":"IsEmptyAnimation","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsEmptyAnimation","t":8,"rt":$n[0].Boolean,"fg":"IsEmptyAnimation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsEmptyAnimation"},{"a":2,"n":"IsNextReady","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsNextReady","t":8,"rt":$n[0].Boolean,"fg":"IsNextReady","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsNextReady"},{"a":2,"n":"Loop","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Loop","t":8,"rt":$n[0].Boolean,"fg":"Loop","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_Loop","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"Loop"},"fn":"Loop"},{"a":2,"n":"MixAttachmentThreshold","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MixAttachmentThreshold","t":8,"rt":$n[0].Single,"fg":"MixAttachmentThreshold","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MixAttachmentThreshold","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MixAttachmentThreshold"},"fn":"MixAttachmentThreshold"},{"a":2,"n":"MixBlend","t":16,"rt":$n[8].MixBlend,"g":{"a":2,"n":"get_MixBlend","t":8,"rt":$n[8].MixBlend,"fg":"MixBlend","box":function ($v) { return Bridge.box($v, Spine.MixBlend, System.Enum.toStringFn(Spine.MixBlend));}},"s":{"a":2,"n":"set_MixBlend","t":8,"p":[$n[8].MixBlend],"rt":$n[0].Void,"fs":"MixBlend"},"fn":"MixBlend"},{"a":2,"n":"MixDrawOrderThreshold","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MixDrawOrderThreshold","t":8,"rt":$n[0].Single,"fg":"MixDrawOrderThreshold","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MixDrawOrderThreshold","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MixDrawOrderThreshold"},"fn":"MixDrawOrderThreshold"},{"a":2,"n":"MixDuration","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MixDuration","t":8,"rt":$n[0].Single,"fg":"MixDuration","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MixDuration","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MixDuration"},"fn":"MixDuration"},{"a":2,"n":"MixTime","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MixTime","t":8,"rt":$n[0].Single,"fg":"MixTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MixTime","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MixTime"},"fn":"MixTime"},{"a":2,"n":"MixingFrom","t":16,"rt":$n[8].TrackEntry,"g":{"a":2,"n":"get_MixingFrom","t":8,"rt":$n[8].TrackEntry,"fg":"MixingFrom"},"fn":"MixingFrom"},{"a":2,"n":"MixingTo","t":16,"rt":$n[8].TrackEntry,"g":{"a":2,"n":"get_MixingTo","t":8,"rt":$n[8].TrackEntry,"fg":"MixingTo"},"fn":"MixingTo"},{"a":2,"n":"Next","t":16,"rt":$n[8].TrackEntry,"g":{"a":2,"n":"get_Next","t":8,"rt":$n[8].TrackEntry,"fg":"Next"},"fn":"Next"},{"a":2,"n":"Previous","t":16,"rt":$n[8].TrackEntry,"g":{"a":2,"n":"get_Previous","t":8,"rt":$n[8].TrackEntry,"fg":"Previous"},"fn":"Previous"},{"a":2,"n":"Reverse","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Reverse","t":8,"rt":$n[0].Boolean,"fg":"Reverse","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_Reverse","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"Reverse"},"fn":"Reverse"},{"a":2,"n":"ShortestRotation","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_ShortestRotation","t":8,"rt":$n[0].Boolean,"fg":"ShortestRotation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_ShortestRotation","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"ShortestRotation"},"fn":"ShortestRotation"},{"a":2,"n":"TimeScale","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_TimeScale","t":8,"rt":$n[0].Single,"fg":"TimeScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_TimeScale","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"TimeScale"},"fn":"TimeScale"},{"a":2,"n":"TrackComplete","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_TrackComplete","t":8,"rt":$n[0].Single,"fg":"TrackComplete","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"TrackComplete"},{"a":2,"n":"TrackEnd","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_TrackEnd","t":8,"rt":$n[0].Single,"fg":"TrackEnd","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_TrackEnd","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"TrackEnd"},"fn":"TrackEnd"},{"a":2,"n":"TrackIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_TrackIndex","t":8,"rt":$n[0].Int32,"fg":"TrackIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"TrackIndex"},{"a":2,"n":"TrackTime","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_TrackTime","t":8,"rt":$n[0].Single,"fg":"TrackTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_TrackTime","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"TrackTime"},"fn":"TrackTime"},{"a":2,"n":"WasApplied","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_WasApplied","t":8,"rt":$n[0].Boolean,"fg":"WasApplied","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"WasApplied"},{"a":4,"n":"alpha","t":4,"rt":$n[0].Single,"sn":"alpha","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"alphaAttachmentThreshold","t":4,"rt":$n[0].Single,"sn":"alphaAttachmentThreshold","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"animation","t":4,"rt":$n[8].Animation,"sn":"animation"},{"a":4,"n":"animationEnd","t":4,"rt":$n[0].Single,"sn":"animationEnd","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"animationLast","t":4,"rt":$n[0].Single,"sn":"animationLast","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"animationStart","t":4,"rt":$n[0].Single,"sn":"animationStart","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"delay","t":4,"rt":$n[0].Single,"sn":"delay","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"eventThreshold","t":4,"rt":$n[0].Single,"sn":"eventThreshold","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"holdPrevious","t":4,"rt":$n[0].Boolean,"sn":"holdPrevious","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"interruptAlpha","t":4,"rt":$n[0].Single,"sn":"interruptAlpha","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"loop","t":4,"rt":$n[0].Boolean,"sn":"loop","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"mixAttachmentThreshold","t":4,"rt":$n[0].Single,"sn":"mixAttachmentThreshold","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"mixBlend","t":4,"rt":$n[8].MixBlend,"sn":"mixBlend","box":function ($v) { return Bridge.box($v, Spine.MixBlend, System.Enum.toStringFn(Spine.MixBlend));}},{"a":4,"n":"mixDrawOrderThreshold","t":4,"rt":$n[0].Single,"sn":"mixDrawOrderThreshold","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"mixDuration","t":4,"rt":$n[0].Single,"sn":"mixDuration","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"mixTime","t":4,"rt":$n[0].Single,"sn":"mixTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"mixingFrom","t":4,"rt":$n[8].TrackEntry,"sn":"mixingFrom"},{"a":4,"n":"mixingTo","t":4,"rt":$n[8].TrackEntry,"sn":"mixingTo"},{"a":4,"n":"next","t":4,"rt":$n[8].TrackEntry,"sn":"next"},{"a":4,"n":"nextAnimationLast","t":4,"rt":$n[0].Single,"sn":"nextAnimationLast","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"nextTrackLast","t":4,"rt":$n[0].Single,"sn":"nextTrackLast","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"previous","t":4,"rt":$n[8].TrackEntry,"sn":"previous"},{"a":4,"n":"reverse","t":4,"rt":$n[0].Boolean,"sn":"reverse","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"shortestRotation","t":4,"rt":$n[0].Boolean,"sn":"shortestRotation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"timeScale","t":4,"rt":$n[0].Single,"sn":"timeScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"timelineHoldMix","t":4,"rt":$n[8].ExposedList$1(Spine.TrackEntry),"sn":"timelineHoldMix","ro":true},{"a":4,"n":"timelineMode","t":4,"rt":$n[8].ExposedList$1(System.Int32),"sn":"timelineMode","ro":true},{"a":4,"n":"timelinesRotation","t":4,"rt":$n[8].ExposedList$1(System.Single),"sn":"timelinesRotation","ro":true},{"a":4,"n":"totalAlpha","t":4,"rt":$n[0].Single,"sn":"totalAlpha","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"trackEnd","t":4,"rt":$n[0].Single,"sn":"trackEnd","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"trackIndex","t":4,"rt":$n[0].Int32,"sn":"trackIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"trackLast","t":4,"rt":$n[0].Single,"sn":"trackLast","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"trackTime","t":4,"rt":$n[0].Single,"sn":"trackTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Complete","t":2,"ad":{"a":2,"n":"add_Complete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addComplete","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_Complete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeComplete","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"Dispose","t":2,"ad":{"a":2,"n":"add_Dispose","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addDispose","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_Dispose","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeDispose","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"End","t":2,"ad":{"a":2,"n":"add_End","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addEnd","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_End","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeEnd","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"Event","t":2,"ad":{"a":2,"n":"add_Event","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addEvent","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_Event","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeEvent","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"Interrupt","t":2,"ad":{"a":2,"n":"add_Interrupt","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addInterrupt","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_Interrupt","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeInterrupt","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"Start","t":2,"ad":{"a":2,"n":"add_Start","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addStart","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_Start","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeStart","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.TrackEntry end.*/

    /*Spine.EventQueue start.*/
    $m("Spine.EventQueue", function () { return {"nested":[$n[8].EventQueue.EventQueueEntry,$n[8].EventQueue.EventType],"att":1048576,"a":4,"m":[{"a":4,"n":".ctor","t":1,"p":[$n[8].AnimationState,Function,$n[8].Pool$1(Spine.TrackEntry)],"pi":[{"n":"state","pt":$n[8].AnimationState,"ps":0},{"n":"HandleAnimationsChanged","pt":Function,"ps":1},{"n":"trackEntryPool","pt":$n[8].Pool$1(Spine.TrackEntry),"ps":2}],"sn":"ctor"},{"a":4,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":4,"n":"Complete","t":8,"pi":[{"n":"entry","pt":$n[8].TrackEntry,"ps":0}],"sn":"Complete","rt":$n[0].Void,"p":[$n[8].TrackEntry]},{"a":4,"n":"Dispose","t":8,"pi":[{"n":"entry","pt":$n[8].TrackEntry,"ps":0}],"sn":"Dispose","rt":$n[0].Void,"p":[$n[8].TrackEntry]},{"a":4,"n":"Drain","t":8,"sn":"Drain","rt":$n[0].Void},{"a":4,"n":"End","t":8,"pi":[{"n":"entry","pt":$n[8].TrackEntry,"ps":0}],"sn":"End","rt":$n[0].Void,"p":[$n[8].TrackEntry]},{"a":4,"n":"Event","t":8,"pi":[{"n":"entry","pt":$n[8].TrackEntry,"ps":0},{"n":"e","pt":$n[8].Event,"ps":1}],"sn":"Event","rt":$n[0].Void,"p":[$n[8].TrackEntry,$n[8].Event]},{"a":4,"n":"Interrupt","t":8,"pi":[{"n":"entry","pt":$n[8].TrackEntry,"ps":0}],"sn":"Interrupt","rt":$n[0].Void,"p":[$n[8].TrackEntry]},{"a":4,"n":"Start","t":8,"pi":[{"n":"entry","pt":$n[8].TrackEntry,"ps":0}],"sn":"Start","rt":$n[0].Void,"p":[$n[8].TrackEntry]},{"a":4,"n":"drainDisabled","t":4,"rt":$n[0].Boolean,"sn":"drainDisabled","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"eventQueueEntries","t":4,"rt":$n[2].List$1(Spine.EventQueue.EventQueueEntry),"sn":"eventQueueEntries","ro":true},{"a":1,"n":"state","t":4,"rt":$n[8].AnimationState,"sn":"state","ro":true},{"a":1,"n":"trackEntryPool","t":4,"rt":$n[8].Pool$1(Spine.TrackEntry),"sn":"trackEntryPool","ro":true},{"a":4,"n":"AnimationsChanged","t":2,"ad":{"a":4,"n":"add_AnimationsChanged","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addAnimationsChanged","rt":$n[0].Void,"p":[Function]},"r":{"a":4,"n":"remove_AnimationsChanged","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeAnimationsChanged","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.EventQueue end.*/

    /*Spine.EventQueue+EventQueueEntry start.*/
    $m("Spine.EventQueue.EventQueueEntry", function () { return {"td":$n[8].EventQueue,"att":1048843,"a":1,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[8].EventQueue.EventType,$n[8].TrackEntry,$n[8].Event],"pi":[{"n":"eventType","pt":$n[8].EventQueue.EventType,"ps":0},{"n":"trackEntry","pt":$n[8].TrackEntry,"ps":1},{"n":"e","dv":null,"o":true,"pt":$n[8].Event,"ps":2}],"sn":"$ctor1"},{"a":2,"n":"e","t":4,"rt":$n[8].Event,"sn":"e"},{"a":2,"n":"entry","t":4,"rt":$n[8].TrackEntry,"sn":"entry"},{"a":2,"n":"type","t":4,"rt":$n[8].EventQueue.EventType,"sn":"type","box":function ($v) { return Bridge.box($v, Spine.EventQueue.EventType, System.Enum.toStringFn(Spine.EventQueue.EventType));}}]}; }, $n);
    /*Spine.EventQueue+EventQueueEntry end.*/

    /*Spine.EventQueue+EventType start.*/
    $m("Spine.EventQueue.EventType", function () { return {"td":$n[8].EventQueue,"att":259,"a":1,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Complete","is":true,"t":4,"rt":$n[8].EventQueue.EventType,"sn":"Complete","box":function ($v) { return Bridge.box($v, Spine.EventQueue.EventType, System.Enum.toStringFn(Spine.EventQueue.EventType));}},{"a":2,"n":"Dispose","is":true,"t":4,"rt":$n[8].EventQueue.EventType,"sn":"Dispose","box":function ($v) { return Bridge.box($v, Spine.EventQueue.EventType, System.Enum.toStringFn(Spine.EventQueue.EventType));}},{"a":2,"n":"End","is":true,"t":4,"rt":$n[8].EventQueue.EventType,"sn":"End","box":function ($v) { return Bridge.box($v, Spine.EventQueue.EventType, System.Enum.toStringFn(Spine.EventQueue.EventType));}},{"a":2,"n":"Event","is":true,"t":4,"rt":$n[8].EventQueue.EventType,"sn":"Event","box":function ($v) { return Bridge.box($v, Spine.EventQueue.EventType, System.Enum.toStringFn(Spine.EventQueue.EventType));}},{"a":2,"n":"Interrupt","is":true,"t":4,"rt":$n[8].EventQueue.EventType,"sn":"Interrupt","box":function ($v) { return Bridge.box($v, Spine.EventQueue.EventType, System.Enum.toStringFn(Spine.EventQueue.EventType));}},{"a":2,"n":"Start","is":true,"t":4,"rt":$n[8].EventQueue.EventType,"sn":"Start","box":function ($v) { return Bridge.box($v, Spine.EventQueue.EventType, System.Enum.toStringFn(Spine.EventQueue.EventType));}}]}; }, $n);
    /*Spine.EventQueue+EventType end.*/

    /*Spine.Pool$1 start.*/
    $m("Spine.Pool$1", function (T) { return {"nested":[$n[8].Pool$1.IPoolable],"att":1048576,"a":4,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32],"pi":[{"n":"initialCapacity","dv":16,"o":true,"pt":$n[0].Int32,"ps":0},{"n":"max","dv":2147483647,"o":true,"pt":$n[0].Int32,"ps":1}],"sn":"ctor"},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"Free","t":8,"pi":[{"n":"obj","pt":T,"ps":0}],"sn":"Free","rt":$n[0].Void,"p":[T]},{"a":2,"n":"Obtain","t":8,"sn":"Obtain","rt":T},{"a":3,"n":"Reset","t":8,"pi":[{"n":"obj","pt":T,"ps":0}],"sn":"Reset","rt":$n[0].Void,"p":[T]},{"a":2,"n":"Count","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Count","t":8,"rt":$n[0].Int32,"fg":"Count","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"Count"},{"a":2,"n":"Peak","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Peak","t":8,"rt":$n[0].Int32,"fg":"Peak","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":1,"n":"set_Peak","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"Peak"},"fn":"Peak"},{"a":1,"n":"freeObjects","t":4,"rt":$n[2].Stack$1(T),"sn":"freeObjects","ro":true},{"a":2,"n":"max","t":4,"rt":$n[0].Int32,"sn":"max","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"backing":true,"n":"<Peak>k__BackingField","t":4,"rt":$n[0].Int32,"sn":"Peak","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.Pool$1 end.*/

    /*Spine.Pool$1+IPoolable start.*/
    $m("Spine.Pool$1.IPoolable", function (T) { return {"td":$n[8].Pool$1(T),"att":1048738,"a":2,"m":[{"ab":true,"a":2,"n":"Reset","t":8,"sn":"Spine$Pool$1$IPoolable$" + Bridge.getTypeAlias(T) + "$Reset","rt":$n[0].Void}]}; }, $n);
    /*Spine.Pool$1+IPoolable end.*/

    /*Spine.HashSetExtensions start.*/
    $m("Spine.HashSetExtensions", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"AddAll","is":true,"t":8,"pi":[{"n":"set","pt":$n[2].HashSet$1(System.Object),"ps":0},{"n":"addSet","pt":System.Array.type(System.Object),"ps":1}],"tpc":1,"tprm":["T"],"sn":"AddAll","rt":$n[0].Boolean,"p":[$n[2].HashSet$1(System.Object),System.Array.type(System.Object)],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.HashSetExtensions end.*/

    /*Spine.AnimationStateData start.*/
    $m("Spine.AnimationStateData", function () { return {"nested":[$n[8].AnimationStateData.AnimationPair,$n[8].AnimationStateData.AnimationPairComparer],"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[8].SkeletonData],"pi":[{"n":"skeletonData","pt":$n[8].SkeletonData,"ps":0}],"sn":"ctor"},{"a":2,"n":"GetMix","t":8,"pi":[{"n":"from","pt":$n[8].Animation,"ps":0},{"n":"to","pt":$n[8].Animation,"ps":1}],"sn":"GetMix","rt":$n[0].Single,"p":[$n[8].Animation,$n[8].Animation],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"SetMix","t":8,"pi":[{"n":"from","pt":$n[8].Animation,"ps":0},{"n":"to","pt":$n[8].Animation,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"SetMix","rt":$n[0].Void,"p":[$n[8].Animation,$n[8].Animation,$n[0].Single]},{"a":2,"n":"SetMix","t":8,"pi":[{"n":"fromName","pt":$n[0].String,"ps":0},{"n":"toName","pt":$n[0].String,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"SetMix$1","rt":$n[0].Void,"p":[$n[0].String,$n[0].String,$n[0].Single]},{"a":2,"n":"DefaultMix","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_DefaultMix","t":8,"rt":$n[0].Single,"fg":"DefaultMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_DefaultMix","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"DefaultMix"},"fn":"DefaultMix"},{"a":2,"n":"SkeletonData","t":16,"rt":$n[8].SkeletonData,"g":{"a":2,"n":"get_SkeletonData","t":8,"rt":$n[8].SkeletonData,"fg":"SkeletonData"},"fn":"SkeletonData"},{"a":1,"n":"animationToMixTime","t":4,"rt":$n[2].Dictionary$2(Spine.AnimationStateData.AnimationPair,System.Single),"sn":"animationToMixTime","ro":true},{"a":4,"n":"defaultMix","t":4,"rt":$n[0].Single,"sn":"defaultMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"skeletonData","t":4,"rt":$n[8].SkeletonData,"sn":"skeletonData"}]}; }, $n);
    /*Spine.AnimationStateData end.*/

    /*Spine.AnimationStateData+AnimationPair start.*/
    $m("Spine.AnimationStateData.AnimationPair", function () { return {"td":$n[8].AnimationStateData,"att":1048842,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[8].Animation,$n[8].Animation],"pi":[{"n":"a1","pt":$n[8].Animation,"ps":0},{"n":"a2","pt":$n[8].Animation,"ps":1}],"sn":"$ctor1"},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"a1","t":4,"rt":$n[8].Animation,"sn":"a1","ro":true},{"a":2,"n":"a2","t":4,"rt":$n[8].Animation,"sn":"a2","ro":true}]}; }, $n);
    /*Spine.AnimationStateData+AnimationPair end.*/

    /*Spine.AnimationStateData+AnimationPairComparer start.*/
    $m("Spine.AnimationStateData.AnimationPairComparer", function () { return {"td":$n[8].AnimationStateData,"att":1048578,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Instance","is":true,"t":4,"rt":$n[8].AnimationStateData.AnimationPairComparer,"sn":"Instance","ro":true}]}; }, $n);
    /*Spine.AnimationStateData+AnimationPairComparer end.*/

    /*Spine.Atlas start.*/
    $m("Spine.Atlas", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[2].List$1(Spine.AtlasPage),$n[2].List$1(Spine.AtlasRegion)],"pi":[{"n":"pages","pt":$n[2].List$1(Spine.AtlasPage),"ps":0},{"n":"regions","pt":$n[2].List$1(Spine.AtlasRegion),"ps":1}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[9].TextReader,$n[0].String,$n[8].TextureLoader],"pi":[{"n":"reader","pt":$n[9].TextReader,"ps":0},{"n":"imagesDir","pt":$n[0].String,"ps":1},{"n":"textureLoader","pt":$n[8].TextureLoader,"ps":2}],"sn":"$ctor1"},{"a":2,"n":"Dispose","t":8,"sn":"Dispose","rt":$n[0].Void},{"a":2,"n":"FindRegion","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"FindRegion","rt":$n[8].AtlasRegion,"p":[$n[0].String]},{"a":2,"n":"FlipV","t":8,"sn":"FlipV","rt":$n[0].Void},{"a":2,"n":"GetEnumerator","t":8,"sn":"GetEnumerator","rt":$n[2].IEnumerator$1(Spine.AtlasRegion)},{"a":1,"n":"ReadEntry","is":true,"t":8,"pi":[{"n":"entry","pt":$n[0].Array.type(System.String),"ps":0},{"n":"line","pt":$n[0].String,"ps":1}],"sn":"ReadEntry","rt":$n[0].Int32,"p":[$n[0].Array.type(System.String),$n[0].String],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"Pages","t":16,"rt":$n[2].List$1(Spine.AtlasPage),"g":{"a":2,"n":"get_Pages","t":8,"rt":$n[2].List$1(Spine.AtlasPage),"fg":"Pages"},"fn":"Pages"},{"a":2,"n":"Regions","t":16,"rt":$n[2].List$1(Spine.AtlasRegion),"g":{"a":2,"n":"get_Regions","t":8,"rt":$n[2].List$1(Spine.AtlasRegion),"fg":"Regions"},"fn":"Regions"},{"a":1,"n":"pages","t":4,"rt":$n[2].List$1(Spine.AtlasPage),"sn":"pages","ro":true},{"a":1,"n":"regions","t":4,"rt":$n[2].List$1(Spine.AtlasRegion),"sn":"regions"},{"a":1,"n":"textureLoader","t":4,"rt":$n[8].TextureLoader,"sn":"textureLoader"}]}; }, $n);
    /*Spine.Atlas end.*/

    /*Spine.Format start.*/
    $m("Spine.Format", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Alpha","is":true,"t":4,"rt":$n[8].Format,"sn":"Alpha","box":function ($v) { return Bridge.box($v, Spine.Format, System.Enum.toStringFn(Spine.Format));}},{"a":2,"n":"Intensity","is":true,"t":4,"rt":$n[8].Format,"sn":"Intensity","box":function ($v) { return Bridge.box($v, Spine.Format, System.Enum.toStringFn(Spine.Format));}},{"a":2,"n":"LuminanceAlpha","is":true,"t":4,"rt":$n[8].Format,"sn":"LuminanceAlpha","box":function ($v) { return Bridge.box($v, Spine.Format, System.Enum.toStringFn(Spine.Format));}},{"a":2,"n":"RGB565","is":true,"t":4,"rt":$n[8].Format,"sn":"RGB565","box":function ($v) { return Bridge.box($v, Spine.Format, System.Enum.toStringFn(Spine.Format));}},{"a":2,"n":"RGB888","is":true,"t":4,"rt":$n[8].Format,"sn":"RGB888","box":function ($v) { return Bridge.box($v, Spine.Format, System.Enum.toStringFn(Spine.Format));}},{"a":2,"n":"RGBA4444","is":true,"t":4,"rt":$n[8].Format,"sn":"RGBA4444","box":function ($v) { return Bridge.box($v, Spine.Format, System.Enum.toStringFn(Spine.Format));}},{"a":2,"n":"RGBA8888","is":true,"t":4,"rt":$n[8].Format,"sn":"RGBA8888","box":function ($v) { return Bridge.box($v, Spine.Format, System.Enum.toStringFn(Spine.Format));}}]}; }, $n);
    /*Spine.Format end.*/

    /*Spine.TextureFilter start.*/
    $m("Spine.TextureFilter", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Linear","is":true,"t":4,"rt":$n[8].TextureFilter,"sn":"Linear","box":function ($v) { return Bridge.box($v, Spine.TextureFilter, System.Enum.toStringFn(Spine.TextureFilter));}},{"a":2,"n":"MipMap","is":true,"t":4,"rt":$n[8].TextureFilter,"sn":"MipMap","box":function ($v) { return Bridge.box($v, Spine.TextureFilter, System.Enum.toStringFn(Spine.TextureFilter));}},{"a":2,"n":"MipMapLinearLinear","is":true,"t":4,"rt":$n[8].TextureFilter,"sn":"MipMapLinearLinear","box":function ($v) { return Bridge.box($v, Spine.TextureFilter, System.Enum.toStringFn(Spine.TextureFilter));}},{"a":2,"n":"MipMapLinearNearest","is":true,"t":4,"rt":$n[8].TextureFilter,"sn":"MipMapLinearNearest","box":function ($v) { return Bridge.box($v, Spine.TextureFilter, System.Enum.toStringFn(Spine.TextureFilter));}},{"a":2,"n":"MipMapNearestLinear","is":true,"t":4,"rt":$n[8].TextureFilter,"sn":"MipMapNearestLinear","box":function ($v) { return Bridge.box($v, Spine.TextureFilter, System.Enum.toStringFn(Spine.TextureFilter));}},{"a":2,"n":"MipMapNearestNearest","is":true,"t":4,"rt":$n[8].TextureFilter,"sn":"MipMapNearestNearest","box":function ($v) { return Bridge.box($v, Spine.TextureFilter, System.Enum.toStringFn(Spine.TextureFilter));}},{"a":2,"n":"Nearest","is":true,"t":4,"rt":$n[8].TextureFilter,"sn":"Nearest","box":function ($v) { return Bridge.box($v, Spine.TextureFilter, System.Enum.toStringFn(Spine.TextureFilter));}}]}; }, $n);
    /*Spine.TextureFilter end.*/

    /*Spine.TextureWrap start.*/
    $m("Spine.TextureWrap", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"ClampToEdge","is":true,"t":4,"rt":$n[8].TextureWrap,"sn":"ClampToEdge","box":function ($v) { return Bridge.box($v, Spine.TextureWrap, System.Enum.toStringFn(Spine.TextureWrap));}},{"a":2,"n":"MirroredRepeat","is":true,"t":4,"rt":$n[8].TextureWrap,"sn":"MirroredRepeat","box":function ($v) { return Bridge.box($v, Spine.TextureWrap, System.Enum.toStringFn(Spine.TextureWrap));}},{"a":2,"n":"Repeat","is":true,"t":4,"rt":$n[8].TextureWrap,"sn":"Repeat","box":function ($v) { return Bridge.box($v, Spine.TextureWrap, System.Enum.toStringFn(Spine.TextureWrap));}}]}; }, $n);
    /*Spine.TextureWrap end.*/

    /*Spine.AtlasPage start.*/
    $m("Spine.AtlasPage", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Clone","t":8,"sn":"Clone","rt":$n[8].AtlasPage},{"a":2,"n":"format","t":4,"rt":$n[8].Format,"sn":"format","box":function ($v) { return Bridge.box($v, Spine.Format, System.Enum.toStringFn(Spine.Format));}},{"a":2,"n":"height","t":4,"rt":$n[0].Int32,"sn":"height","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"magFilter","t":4,"rt":$n[8].TextureFilter,"sn":"magFilter","box":function ($v) { return Bridge.box($v, Spine.TextureFilter, System.Enum.toStringFn(Spine.TextureFilter));}},{"a":2,"n":"minFilter","t":4,"rt":$n[8].TextureFilter,"sn":"minFilter","box":function ($v) { return Bridge.box($v, Spine.TextureFilter, System.Enum.toStringFn(Spine.TextureFilter));}},{"a":2,"n":"name","t":4,"rt":$n[0].String,"sn":"name"},{"a":2,"n":"pma","t":4,"rt":$n[0].Boolean,"sn":"pma","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"rendererObject","t":4,"rt":$n[0].Object,"sn":"rendererObject"},{"a":2,"n":"uWrap","t":4,"rt":$n[8].TextureWrap,"sn":"uWrap","box":function ($v) { return Bridge.box($v, Spine.TextureWrap, System.Enum.toStringFn(Spine.TextureWrap));}},{"a":2,"n":"vWrap","t":4,"rt":$n[8].TextureWrap,"sn":"vWrap","box":function ($v) { return Bridge.box($v, Spine.TextureWrap, System.Enum.toStringFn(Spine.TextureWrap));}},{"a":2,"n":"width","t":4,"rt":$n[0].Int32,"sn":"width","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.AtlasPage end.*/

    /*Spine.AtlasRegion start.*/
    $m("Spine.AtlasRegion", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Clone","t":8,"sn":"Clone","rt":$n[8].AtlasRegion},{"ov":true,"a":2,"n":"OriginalHeight","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_OriginalHeight","t":8,"rt":$n[0].Int32,"fg":"OriginalHeight","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"OriginalHeight"},{"ov":true,"a":2,"n":"OriginalWidth","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_OriginalWidth","t":8,"rt":$n[0].Int32,"fg":"OriginalWidth","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"OriginalWidth"},{"a":2,"n":"packedHeight","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_packedHeight","t":8,"rt":$n[0].Int32,"fg":"packedHeight","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_packedHeight","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"packedHeight"},"fn":"packedHeight"},{"a":2,"n":"packedWidth","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_packedWidth","t":8,"rt":$n[0].Int32,"fg":"packedWidth","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_packedWidth","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"packedWidth"},"fn":"packedWidth"},{"a":2,"n":"degrees","t":4,"rt":$n[0].Int32,"sn":"degrees","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"index","t":4,"rt":$n[0].Int32,"sn":"index","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"name","t":4,"rt":$n[0].String,"sn":"name"},{"a":2,"n":"names","t":4,"rt":$n[0].Array.type(System.String),"sn":"names"},{"a":2,"n":"offsetX","t":4,"rt":$n[0].Single,"sn":"offsetX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"offsetY","t":4,"rt":$n[0].Single,"sn":"offsetY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"originalHeight","t":4,"rt":$n[0].Int32,"sn":"originalHeight","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"originalWidth","t":4,"rt":$n[0].Int32,"sn":"originalWidth","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"page","t":4,"rt":$n[8].AtlasPage,"sn":"page"},{"a":2,"n":"rotate","t":4,"rt":$n[0].Boolean,"sn":"rotate","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"values","t":4,"rt":$n[0].Array.type(System.Array.type(System.Int32)),"sn":"values"},{"a":2,"n":"x","t":4,"rt":$n[0].Int32,"sn":"x","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"y","t":4,"rt":$n[0].Int32,"sn":"y","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.AtlasRegion end.*/

    /*Spine.TextureLoader start.*/
    $m("Spine.TextureLoader", function () { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"Load","t":8,"pi":[{"n":"page","pt":$n[8].AtlasPage,"ps":0},{"n":"path","pt":$n[0].String,"ps":1}],"sn":"Spine$TextureLoader$Load","rt":$n[0].Void,"p":[$n[8].AtlasPage,$n[0].String]},{"ab":true,"a":2,"n":"Unload","t":8,"pi":[{"n":"texture","pt":$n[0].Object,"ps":0}],"sn":"Spine$TextureLoader$Unload","rt":$n[0].Void,"p":[$n[0].Object]}]}; }, $n);
    /*Spine.TextureLoader end.*/

    /*Spine.AtlasAttachmentLoader start.*/
    $m("Spine.AtlasAttachmentLoader", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[System.Array.type(Spine.Atlas)],"pi":[{"n":"atlasArray","ip":true,"pt":System.Array.type(Spine.Atlas),"ps":0}],"sn":"ctor"},{"a":2,"n":"FindRegion","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"FindRegion","rt":$n[8].AtlasRegion,"p":[$n[0].String]},{"a":1,"n":"LoadSequence","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0},{"n":"basePath","pt":$n[0].String,"ps":1},{"n":"sequence","pt":$n[8].Sequence,"ps":2}],"sn":"LoadSequence","rt":$n[0].Void,"p":[$n[0].String,$n[0].String,$n[8].Sequence]},{"a":2,"n":"NewBoundingBoxAttachment","t":8,"pi":[{"n":"skin","pt":$n[8].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"NewBoundingBoxAttachment","rt":$n[8].BoundingBoxAttachment,"p":[$n[8].Skin,$n[0].String]},{"a":2,"n":"NewClippingAttachment","t":8,"pi":[{"n":"skin","pt":$n[8].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"NewClippingAttachment","rt":$n[8].ClippingAttachment,"p":[$n[8].Skin,$n[0].String]},{"a":2,"n":"NewMeshAttachment","t":8,"pi":[{"n":"skin","pt":$n[8].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"path","pt":$n[0].String,"ps":2},{"n":"sequence","pt":$n[8].Sequence,"ps":3}],"sn":"NewMeshAttachment","rt":$n[8].MeshAttachment,"p":[$n[8].Skin,$n[0].String,$n[0].String,$n[8].Sequence]},{"a":2,"n":"NewPathAttachment","t":8,"pi":[{"n":"skin","pt":$n[8].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"NewPathAttachment","rt":$n[8].PathAttachment,"p":[$n[8].Skin,$n[0].String]},{"a":2,"n":"NewPointAttachment","t":8,"pi":[{"n":"skin","pt":$n[8].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"NewPointAttachment","rt":$n[8].PointAttachment,"p":[$n[8].Skin,$n[0].String]},{"a":2,"n":"NewRegionAttachment","t":8,"pi":[{"n":"skin","pt":$n[8].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"path","pt":$n[0].String,"ps":2},{"n":"sequence","pt":$n[8].Sequence,"ps":3}],"sn":"NewRegionAttachment","rt":$n[8].RegionAttachment,"p":[$n[8].Skin,$n[0].String,$n[0].String,$n[8].Sequence]},{"a":1,"n":"atlasArray","t":4,"rt":System.Array.type(Spine.Atlas),"sn":"atlasArray"}]}; }, $n);
    /*Spine.AtlasAttachmentLoader end.*/

    /*Spine.Attachment start.*/
    $m("Spine.Attachment", function () { return {"att":1048705,"a":2,"m":[{"a":3,"n":".ctor","t":1,"p":[$n[8].Attachment],"pi":[{"n":"other","pt":$n[8].Attachment,"ps":0}],"sn":"ctor"},{"a":3,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"$ctor1"},{"ab":true,"a":2,"n":"Copy","t":8,"sn":"Copy","rt":$n[8].Attachment},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"Name","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_Name","t":8,"rt":$n[0].String,"fg":"Name"},"fn":"Name"},{"a":1,"backing":true,"n":"<Name>k__BackingField","t":4,"rt":$n[0].String,"sn":"Name"}]}; }, $n);
    /*Spine.Attachment end.*/

    /*Spine.AttachmentLoader start.*/
    $m("Spine.AttachmentLoader", function () { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"NewBoundingBoxAttachment","t":8,"pi":[{"n":"skin","pt":$n[8].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"Spine$AttachmentLoader$NewBoundingBoxAttachment","rt":$n[8].BoundingBoxAttachment,"p":[$n[8].Skin,$n[0].String]},{"ab":true,"a":2,"n":"NewClippingAttachment","t":8,"pi":[{"n":"skin","pt":$n[8].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"Spine$AttachmentLoader$NewClippingAttachment","rt":$n[8].ClippingAttachment,"p":[$n[8].Skin,$n[0].String]},{"ab":true,"a":2,"n":"NewMeshAttachment","t":8,"pi":[{"n":"skin","pt":$n[8].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"path","pt":$n[0].String,"ps":2},{"n":"sequence","pt":$n[8].Sequence,"ps":3}],"sn":"Spine$AttachmentLoader$NewMeshAttachment","rt":$n[8].MeshAttachment,"p":[$n[8].Skin,$n[0].String,$n[0].String,$n[8].Sequence]},{"ab":true,"a":2,"n":"NewPathAttachment","t":8,"pi":[{"n":"skin","pt":$n[8].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"Spine$AttachmentLoader$NewPathAttachment","rt":$n[8].PathAttachment,"p":[$n[8].Skin,$n[0].String]},{"ab":true,"a":2,"n":"NewPointAttachment","t":8,"pi":[{"n":"skin","pt":$n[8].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"Spine$AttachmentLoader$NewPointAttachment","rt":$n[8].PointAttachment,"p":[$n[8].Skin,$n[0].String]},{"ab":true,"a":2,"n":"NewRegionAttachment","t":8,"pi":[{"n":"skin","pt":$n[8].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"path","pt":$n[0].String,"ps":2},{"n":"sequence","pt":$n[8].Sequence,"ps":3}],"sn":"Spine$AttachmentLoader$NewRegionAttachment","rt":$n[8].RegionAttachment,"p":[$n[8].Skin,$n[0].String,$n[0].String,$n[8].Sequence]}]}; }, $n);
    /*Spine.AttachmentLoader end.*/

    /*Spine.AttachmentType start.*/
    $m("Spine.AttachmentType", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Boundingbox","is":true,"t":4,"rt":$n[8].AttachmentType,"sn":"Boundingbox","box":function ($v) { return Bridge.box($v, Spine.AttachmentType, System.Enum.toStringFn(Spine.AttachmentType));}},{"a":2,"n":"Clipping","is":true,"t":4,"rt":$n[8].AttachmentType,"sn":"Clipping","box":function ($v) { return Bridge.box($v, Spine.AttachmentType, System.Enum.toStringFn(Spine.AttachmentType));}},{"a":2,"n":"Linkedmesh","is":true,"t":4,"rt":$n[8].AttachmentType,"sn":"Linkedmesh","box":function ($v) { return Bridge.box($v, Spine.AttachmentType, System.Enum.toStringFn(Spine.AttachmentType));}},{"a":2,"n":"Mesh","is":true,"t":4,"rt":$n[8].AttachmentType,"sn":"Mesh","box":function ($v) { return Bridge.box($v, Spine.AttachmentType, System.Enum.toStringFn(Spine.AttachmentType));}},{"a":2,"n":"Path","is":true,"t":4,"rt":$n[8].AttachmentType,"sn":"Path","box":function ($v) { return Bridge.box($v, Spine.AttachmentType, System.Enum.toStringFn(Spine.AttachmentType));}},{"a":2,"n":"Point","is":true,"t":4,"rt":$n[8].AttachmentType,"sn":"Point","box":function ($v) { return Bridge.box($v, Spine.AttachmentType, System.Enum.toStringFn(Spine.AttachmentType));}},{"a":2,"n":"Region","is":true,"t":4,"rt":$n[8].AttachmentType,"sn":"Region","box":function ($v) { return Bridge.box($v, Spine.AttachmentType, System.Enum.toStringFn(Spine.AttachmentType));}},{"a":2,"n":"Sequence","is":true,"t":4,"rt":$n[8].AttachmentType,"sn":"Sequence","box":function ($v) { return Bridge.box($v, Spine.AttachmentType, System.Enum.toStringFn(Spine.AttachmentType));}}]}; }, $n);
    /*Spine.AttachmentType end.*/

    /*Spine.BoundingBoxAttachment start.*/
    $m("Spine.BoundingBoxAttachment", function () { return {"att":1048577,"a":2,"m":[{"a":3,"n":".ctor","t":1,"p":[$n[8].BoundingBoxAttachment],"pi":[{"n":"other","pt":$n[8].BoundingBoxAttachment,"ps":0}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"$ctor1"},{"ov":true,"a":2,"n":"Copy","t":8,"sn":"Copy","rt":$n[8].Attachment}]}; }, $n);
    /*Spine.BoundingBoxAttachment end.*/

    /*Spine.ClippingAttachment start.*/
    $m("Spine.ClippingAttachment", function () { return {"att":1048577,"a":2,"m":[{"a":3,"n":".ctor","t":1,"p":[$n[8].ClippingAttachment],"pi":[{"n":"other","pt":$n[8].ClippingAttachment,"ps":0}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"$ctor1"},{"ov":true,"a":2,"n":"Copy","t":8,"sn":"Copy","rt":$n[8].Attachment},{"a":2,"n":"EndSlot","t":16,"rt":$n[8].SlotData,"g":{"a":2,"n":"get_EndSlot","t":8,"rt":$n[8].SlotData,"fg":"EndSlot"},"s":{"a":2,"n":"set_EndSlot","t":8,"p":[$n[8].SlotData],"rt":$n[0].Void,"fs":"EndSlot"},"fn":"EndSlot"},{"a":4,"n":"endSlot","t":4,"rt":$n[8].SlotData,"sn":"endSlot"}]}; }, $n);
    /*Spine.ClippingAttachment end.*/

    /*Spine.IHasTextureRegion start.*/
    $m("Spine.IHasTextureRegion", function () { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"UpdateRegion","t":8,"sn":"Spine$IHasTextureRegion$UpdateRegion","rt":$n[0].Void},{"ab":true,"a":2,"n":"A","t":16,"rt":$n[0].Single,"g":{"ab":true,"a":2,"n":"get_A","t":8,"rt":$n[0].Single,"fg":"Spine$IHasTextureRegion$A","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"ab":true,"a":2,"n":"set_A","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Spine$IHasTextureRegion$A"},"fn":"Spine$IHasTextureRegion$A"},{"ab":true,"a":2,"n":"B","t":16,"rt":$n[0].Single,"g":{"ab":true,"a":2,"n":"get_B","t":8,"rt":$n[0].Single,"fg":"Spine$IHasTextureRegion$B","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"ab":true,"a":2,"n":"set_B","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Spine$IHasTextureRegion$B"},"fn":"Spine$IHasTextureRegion$B"},{"ab":true,"a":2,"n":"G","t":16,"rt":$n[0].Single,"g":{"ab":true,"a":2,"n":"get_G","t":8,"rt":$n[0].Single,"fg":"Spine$IHasTextureRegion$G","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"ab":true,"a":2,"n":"set_G","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Spine$IHasTextureRegion$G"},"fn":"Spine$IHasTextureRegion$G"},{"ab":true,"a":2,"n":"Path","t":16,"rt":$n[0].String,"g":{"ab":true,"a":2,"n":"get_Path","t":8,"rt":$n[0].String,"fg":"Spine$IHasTextureRegion$Path"},"s":{"ab":true,"a":2,"n":"set_Path","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"Spine$IHasTextureRegion$Path"},"fn":"Spine$IHasTextureRegion$Path"},{"ab":true,"a":2,"n":"R","t":16,"rt":$n[0].Single,"g":{"ab":true,"a":2,"n":"get_R","t":8,"rt":$n[0].Single,"fg":"Spine$IHasTextureRegion$R","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"ab":true,"a":2,"n":"set_R","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Spine$IHasTextureRegion$R"},"fn":"Spine$IHasTextureRegion$R"},{"ab":true,"a":2,"n":"Region","t":16,"rt":$n[8].TextureRegion,"g":{"ab":true,"a":2,"n":"get_Region","t":8,"rt":$n[8].TextureRegion,"fg":"Spine$IHasTextureRegion$Region"},"s":{"ab":true,"a":2,"n":"set_Region","t":8,"p":[$n[8].TextureRegion],"rt":$n[0].Void,"fs":"Spine$IHasTextureRegion$Region"},"fn":"Spine$IHasTextureRegion$Region"},{"ab":true,"a":2,"n":"Sequence","t":16,"rt":$n[8].Sequence,"g":{"ab":true,"a":2,"n":"get_Sequence","t":8,"rt":$n[8].Sequence,"fg":"Spine$IHasTextureRegion$Sequence"},"s":{"ab":true,"a":2,"n":"set_Sequence","t":8,"p":[$n[8].Sequence],"rt":$n[0].Void,"fs":"Spine$IHasTextureRegion$Sequence"},"fn":"Spine$IHasTextureRegion$Sequence"},{"a":1,"backing":true,"n":"<A>k__BackingField","t":4,"rt":$n[0].Single,"sn":"Spine$IHasTextureRegion$A","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"backing":true,"n":"<B>k__BackingField","t":4,"rt":$n[0].Single,"sn":"Spine$IHasTextureRegion$B","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"backing":true,"n":"<G>k__BackingField","t":4,"rt":$n[0].Single,"sn":"Spine$IHasTextureRegion$G","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"backing":true,"n":"<Path>k__BackingField","t":4,"rt":$n[0].String,"sn":"Spine$IHasTextureRegion$Path"},{"a":1,"backing":true,"n":"<R>k__BackingField","t":4,"rt":$n[0].Single,"sn":"Spine$IHasTextureRegion$R","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"backing":true,"n":"<Region>k__BackingField","t":4,"rt":$n[8].TextureRegion,"sn":"Spine$IHasTextureRegion$Region"},{"a":1,"backing":true,"n":"<Sequence>k__BackingField","t":4,"rt":$n[8].Sequence,"sn":"Spine$IHasTextureRegion$Sequence"}]}; }, $n);
    /*Spine.IHasTextureRegion end.*/

    /*Spine.MeshAttachment start.*/
    $m("Spine.MeshAttachment", function () { return {"att":1048577,"a":2,"m":[{"a":3,"n":".ctor","t":1,"p":[$n[8].MeshAttachment],"pi":[{"n":"other","pt":$n[8].MeshAttachment,"ps":0}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"$ctor1"},{"ov":true,"a":2,"n":"ComputeWorldVertices","t":8,"pi":[{"n":"slot","pt":$n[8].Slot,"ps":0},{"n":"start","pt":$n[0].Int32,"ps":1},{"n":"count","pt":$n[0].Int32,"ps":2},{"n":"worldVertices","pt":$n[0].Array.type(System.Single),"ps":3},{"n":"offset","pt":$n[0].Int32,"ps":4},{"n":"stride","dv":2,"o":true,"pt":$n[0].Int32,"ps":5}],"sn":"ComputeWorldVertices","rt":$n[0].Void,"p":[$n[8].Slot,$n[0].Int32,$n[0].Int32,$n[0].Array.type(System.Single),$n[0].Int32,$n[0].Int32]},{"ov":true,"a":2,"n":"Copy","t":8,"sn":"Copy","rt":$n[8].Attachment},{"a":2,"n":"NewLinkedMesh","t":8,"sn":"NewLinkedMesh","rt":$n[8].MeshAttachment},{"a":2,"n":"UpdateRegion","t":8,"sn":"UpdateRegion","rt":$n[0].Void},{"a":2,"n":"A","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_A","t":8,"rt":$n[0].Single,"fg":"A","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_A","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"A"},"fn":"A"},{"a":2,"n":"B","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_B","t":8,"rt":$n[0].Single,"fg":"B","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_B","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"B"},"fn":"B"},{"a":2,"n":"Edges","t":16,"rt":$n[0].Array.type(System.Int32),"g":{"a":2,"n":"get_Edges","t":8,"rt":$n[0].Array.type(System.Int32),"fg":"Edges"},"s":{"a":2,"n":"set_Edges","t":8,"p":[$n[0].Array.type(System.Int32)],"rt":$n[0].Void,"fs":"Edges"},"fn":"Edges"},{"a":2,"n":"G","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_G","t":8,"rt":$n[0].Single,"fg":"G","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_G","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"G"},"fn":"G"},{"a":2,"n":"Height","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Height","t":8,"rt":$n[0].Single,"fg":"Height","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Height","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Height"},"fn":"Height"},{"a":2,"n":"HullLength","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_HullLength","t":8,"rt":$n[0].Int32,"fg":"HullLength","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_HullLength","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"HullLength"},"fn":"HullLength"},{"a":2,"n":"ParentMesh","t":16,"rt":$n[8].MeshAttachment,"g":{"a":2,"n":"get_ParentMesh","t":8,"rt":$n[8].MeshAttachment,"fg":"ParentMesh"},"s":{"a":2,"n":"set_ParentMesh","t":8,"p":[$n[8].MeshAttachment],"rt":$n[0].Void,"fs":"ParentMesh"},"fn":"ParentMesh"},{"a":2,"n":"Path","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_Path","t":8,"rt":$n[0].String,"fg":"Path"},"s":{"a":2,"n":"set_Path","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"Path"},"fn":"Path"},{"a":2,"n":"R","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_R","t":8,"rt":$n[0].Single,"fg":"R","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_R","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"R"},"fn":"R"},{"a":2,"n":"Region","t":16,"rt":$n[8].TextureRegion,"g":{"a":2,"n":"get_Region","t":8,"rt":$n[8].TextureRegion,"fg":"Region"},"s":{"a":2,"n":"set_Region","t":8,"p":[$n[8].TextureRegion],"rt":$n[0].Void,"fs":"Region"},"fn":"Region"},{"a":2,"n":"RegionUVs","t":16,"rt":$n[0].Array.type(System.Single),"g":{"a":2,"n":"get_RegionUVs","t":8,"rt":$n[0].Array.type(System.Single),"fg":"RegionUVs"},"s":{"a":2,"n":"set_RegionUVs","t":8,"p":[$n[0].Array.type(System.Single)],"rt":$n[0].Void,"fs":"RegionUVs"},"fn":"RegionUVs"},{"a":2,"n":"Sequence","t":16,"rt":$n[8].Sequence,"g":{"a":2,"n":"get_Sequence","t":8,"rt":$n[8].Sequence,"fg":"Sequence"},"s":{"a":2,"n":"set_Sequence","t":8,"p":[$n[8].Sequence],"rt":$n[0].Void,"fs":"Sequence"},"fn":"Sequence"},{"a":2,"n":"Triangles","t":16,"rt":$n[0].Array.type(System.Int32),"g":{"a":2,"n":"get_Triangles","t":8,"rt":$n[0].Array.type(System.Int32),"fg":"Triangles"},"s":{"a":2,"n":"set_Triangles","t":8,"p":[$n[0].Array.type(System.Int32)],"rt":$n[0].Void,"fs":"Triangles"},"fn":"Triangles"},{"a":2,"n":"UVs","t":16,"rt":$n[0].Array.type(System.Single),"g":{"a":2,"n":"get_UVs","t":8,"rt":$n[0].Array.type(System.Single),"fg":"UVs"},"s":{"a":2,"n":"set_UVs","t":8,"p":[$n[0].Array.type(System.Single)],"rt":$n[0].Void,"fs":"UVs"},"fn":"UVs"},{"a":2,"n":"Width","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Width","t":8,"rt":$n[0].Single,"fg":"Width","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Width","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Width"},"fn":"Width"},{"a":4,"n":"a","t":4,"rt":$n[0].Single,"sn":"a","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"b","t":4,"rt":$n[0].Single,"sn":"b","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"g","t":4,"rt":$n[0].Single,"sn":"g","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"hullLength","t":4,"rt":$n[0].Int32,"sn":"hullLength","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"parentMesh","t":4,"rt":$n[8].MeshAttachment,"sn":"parentMesh"},{"a":4,"n":"path","t":4,"rt":$n[0].String,"sn":"path"},{"a":4,"n":"r","t":4,"rt":$n[0].Single,"sn":"r","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"region","t":4,"rt":$n[8].TextureRegion,"sn":"region"},{"a":4,"n":"regionUVs","t":4,"rt":$n[0].Array.type(System.Single),"sn":"regionUVs"},{"a":1,"n":"sequence","t":4,"rt":$n[8].Sequence,"sn":"sequence"},{"a":4,"n":"triangles","t":4,"rt":$n[0].Array.type(System.Int32),"sn":"triangles"},{"a":4,"n":"uvs","t":4,"rt":$n[0].Array.type(System.Single),"sn":"uvs"},{"a":1,"backing":true,"n":"<Edges>k__BackingField","t":4,"rt":$n[0].Array.type(System.Int32),"sn":"Edges"},{"a":1,"backing":true,"n":"<Height>k__BackingField","t":4,"rt":$n[0].Single,"sn":"Height","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"backing":true,"n":"<Width>k__BackingField","t":4,"rt":$n[0].Single,"sn":"Width","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.MeshAttachment end.*/

    /*Spine.PathAttachment start.*/
    $m("Spine.PathAttachment", function () { return {"att":1048577,"a":2,"m":[{"a":3,"n":".ctor","t":1,"p":[$n[8].PathAttachment],"pi":[{"n":"other","pt":$n[8].PathAttachment,"ps":0}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"$ctor1"},{"ov":true,"a":2,"n":"Copy","t":8,"sn":"Copy","rt":$n[8].Attachment},{"a":2,"n":"Closed","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Closed","t":8,"rt":$n[0].Boolean,"fg":"Closed","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_Closed","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"Closed"},"fn":"Closed"},{"a":2,"n":"ConstantSpeed","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_ConstantSpeed","t":8,"rt":$n[0].Boolean,"fg":"ConstantSpeed","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_ConstantSpeed","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"ConstantSpeed"},"fn":"ConstantSpeed"},{"a":2,"n":"Lengths","t":16,"rt":$n[0].Array.type(System.Single),"g":{"a":2,"n":"get_Lengths","t":8,"rt":$n[0].Array.type(System.Single),"fg":"Lengths"},"s":{"a":2,"n":"set_Lengths","t":8,"p":[$n[0].Array.type(System.Single)],"rt":$n[0].Void,"fs":"Lengths"},"fn":"Lengths"},{"a":4,"n":"closed","t":4,"rt":$n[0].Boolean,"sn":"closed","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"constantSpeed","t":4,"rt":$n[0].Boolean,"sn":"constantSpeed","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"lengths","t":4,"rt":$n[0].Array.type(System.Single),"sn":"lengths"}]}; }, $n);
    /*Spine.PathAttachment end.*/

    /*Spine.PointAttachment start.*/
    $m("Spine.PointAttachment", function () { return {"att":1048577,"a":2,"m":[{"a":3,"n":".ctor","t":1,"p":[$n[8].PointAttachment],"pi":[{"n":"other","pt":$n[8].PointAttachment,"ps":0}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"$ctor1"},{"a":2,"n":"ComputeWorldPosition","t":8,"pi":[{"n":"bone","pt":$n[8].Bone,"ps":0},{"n":"ox","out":true,"pt":$n[0].Single,"ps":1},{"n":"oy","out":true,"pt":$n[0].Single,"ps":2}],"sn":"ComputeWorldPosition","rt":$n[0].Void,"p":[$n[8].Bone,$n[0].Single,$n[0].Single]},{"a":2,"n":"ComputeWorldRotation","t":8,"pi":[{"n":"bone","pt":$n[8].Bone,"ps":0}],"sn":"ComputeWorldRotation","rt":$n[0].Single,"p":[$n[8].Bone],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"ov":true,"a":2,"n":"Copy","t":8,"sn":"Copy","rt":$n[8].Attachment},{"a":2,"n":"Rotation","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Rotation","t":8,"rt":$n[0].Single,"fg":"Rotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Rotation","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Rotation"},"fn":"Rotation"},{"a":2,"n":"X","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_X","t":8,"rt":$n[0].Single,"fg":"X","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_X","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"X"},"fn":"X"},{"a":2,"n":"Y","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Y","t":8,"rt":$n[0].Single,"fg":"Y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Y","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Y"},"fn":"Y"},{"a":4,"n":"rotation","t":4,"rt":$n[0].Single,"sn":"rotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"x","t":4,"rt":$n[0].Single,"sn":"x","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"y","t":4,"rt":$n[0].Single,"sn":"y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.PointAttachment end.*/

    /*Spine.RegionAttachment start.*/
    $m("Spine.RegionAttachment", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[8].RegionAttachment],"pi":[{"n":"other","pt":$n[8].RegionAttachment,"ps":0}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"$ctor1"},{"a":2,"n":"ComputeWorldVertices","t":8,"pi":[{"n":"slot","pt":$n[8].Slot,"ps":0},{"n":"worldVertices","pt":$n[0].Array.type(System.Single),"ps":1},{"n":"offset","pt":$n[0].Int32,"ps":2},{"n":"stride","dv":2,"o":true,"pt":$n[0].Int32,"ps":3}],"sn":"ComputeWorldVertices","rt":$n[0].Void,"p":[$n[8].Slot,$n[0].Array.type(System.Single),$n[0].Int32,$n[0].Int32]},{"ov":true,"a":2,"n":"Copy","t":8,"sn":"Copy","rt":$n[8].Attachment},{"a":2,"n":"UpdateRegion","t":8,"sn":"UpdateRegion","rt":$n[0].Void},{"a":2,"n":"A","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_A","t":8,"rt":$n[0].Single,"fg":"A","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_A","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"A"},"fn":"A"},{"a":2,"n":"B","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_B","t":8,"rt":$n[0].Single,"fg":"B","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_B","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"B"},"fn":"B"},{"a":2,"n":"G","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_G","t":8,"rt":$n[0].Single,"fg":"G","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_G","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"G"},"fn":"G"},{"a":2,"n":"Height","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Height","t":8,"rt":$n[0].Single,"fg":"Height","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Height","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Height"},"fn":"Height"},{"a":2,"n":"Offset","t":16,"rt":$n[0].Array.type(System.Single),"g":{"a":2,"n":"get_Offset","t":8,"rt":$n[0].Array.type(System.Single),"fg":"Offset"},"fn":"Offset"},{"a":2,"n":"Path","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_Path","t":8,"rt":$n[0].String,"fg":"Path"},"s":{"a":2,"n":"set_Path","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"Path"},"fn":"Path"},{"a":2,"n":"R","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_R","t":8,"rt":$n[0].Single,"fg":"R","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_R","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"R"},"fn":"R"},{"a":2,"n":"Region","t":16,"rt":$n[8].TextureRegion,"g":{"a":2,"n":"get_Region","t":8,"rt":$n[8].TextureRegion,"fg":"Region"},"s":{"a":2,"n":"set_Region","t":8,"p":[$n[8].TextureRegion],"rt":$n[0].Void,"fs":"Region"},"fn":"Region"},{"a":2,"n":"Rotation","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Rotation","t":8,"rt":$n[0].Single,"fg":"Rotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Rotation","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Rotation"},"fn":"Rotation"},{"a":2,"n":"ScaleX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ScaleX","t":8,"rt":$n[0].Single,"fg":"ScaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ScaleX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ScaleX"},"fn":"ScaleX"},{"a":2,"n":"ScaleY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ScaleY","t":8,"rt":$n[0].Single,"fg":"ScaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ScaleY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ScaleY"},"fn":"ScaleY"},{"a":2,"n":"Sequence","t":16,"rt":$n[8].Sequence,"g":{"a":2,"n":"get_Sequence","t":8,"rt":$n[8].Sequence,"fg":"Sequence"},"s":{"a":2,"n":"set_Sequence","t":8,"p":[$n[8].Sequence],"rt":$n[0].Void,"fs":"Sequence"},"fn":"Sequence"},{"a":2,"n":"UVs","t":16,"rt":$n[0].Array.type(System.Single),"g":{"a":2,"n":"get_UVs","t":8,"rt":$n[0].Array.type(System.Single),"fg":"UVs"},"fn":"UVs"},{"a":2,"n":"Width","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Width","t":8,"rt":$n[0].Single,"fg":"Width","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Width","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Width"},"fn":"Width"},{"a":2,"n":"X","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_X","t":8,"rt":$n[0].Single,"fg":"X","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_X","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"X"},"fn":"X"},{"a":2,"n":"Y","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Y","t":8,"rt":$n[0].Single,"fg":"Y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Y","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Y"},"fn":"Y"},{"a":2,"n":"BLX","is":true,"t":4,"rt":$n[0].Int32,"sn":"BLX","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"BLY","is":true,"t":4,"rt":$n[0].Int32,"sn":"BLY","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"BRX","is":true,"t":4,"rt":$n[0].Int32,"sn":"BRX","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"BRY","is":true,"t":4,"rt":$n[0].Int32,"sn":"BRY","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"ULX","is":true,"t":4,"rt":$n[0].Int32,"sn":"ULX","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"ULY","is":true,"t":4,"rt":$n[0].Int32,"sn":"ULY","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"URX","is":true,"t":4,"rt":$n[0].Int32,"sn":"URX","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"URY","is":true,"t":4,"rt":$n[0].Int32,"sn":"URY","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"a","t":4,"rt":$n[0].Single,"sn":"a","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"b","t":4,"rt":$n[0].Single,"sn":"b","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"g","t":4,"rt":$n[0].Single,"sn":"g","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"height","t":4,"rt":$n[0].Single,"sn":"height","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"offset","t":4,"rt":$n[0].Array.type(System.Single),"sn":"offset"},{"a":4,"n":"r","t":4,"rt":$n[0].Single,"sn":"r","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"region","t":4,"rt":$n[8].TextureRegion,"sn":"region"},{"a":4,"n":"rotation","t":4,"rt":$n[0].Single,"sn":"rotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"scaleX","t":4,"rt":$n[0].Single,"sn":"scaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"scaleY","t":4,"rt":$n[0].Single,"sn":"scaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"sequence","t":4,"rt":$n[8].Sequence,"sn":"sequence"},{"a":4,"n":"uvs","t":4,"rt":$n[0].Array.type(System.Single),"sn":"uvs"},{"a":4,"n":"width","t":4,"rt":$n[0].Single,"sn":"width","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"x","t":4,"rt":$n[0].Single,"sn":"x","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"y","t":4,"rt":$n[0].Single,"sn":"y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"backing":true,"n":"<Path>k__BackingField","t":4,"rt":$n[0].String,"sn":"Path"}]}; }, $n);
    /*Spine.RegionAttachment end.*/

    /*Spine.Sequence start.*/
    $m("Spine.Sequence", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[8].Sequence],"pi":[{"n":"other","pt":$n[8].Sequence,"ps":0}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32],"pi":[{"n":"count","pt":$n[0].Int32,"ps":0}],"sn":"$ctor1"},{"a":2,"n":"Apply","t":8,"pi":[{"n":"slot","pt":$n[8].Slot,"ps":0},{"n":"attachment","pt":$n[8].IHasTextureRegion,"ps":1}],"sn":"Apply","rt":$n[0].Void,"p":[$n[8].Slot,$n[8].IHasTextureRegion]},{"a":2,"n":"GetPath","t":8,"pi":[{"n":"basePath","pt":$n[0].String,"ps":0},{"n":"index","pt":$n[0].Int32,"ps":1}],"sn":"GetPath","rt":$n[0].String,"p":[$n[0].String,$n[0].Int32]},{"a":2,"n":"Digits","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Digits","t":8,"rt":$n[0].Int32,"fg":"Digits","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_Digits","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"Digits"},"fn":"Digits"},{"a":2,"n":"Id","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Id","t":8,"rt":$n[0].Int32,"fg":"Id","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"Id"},{"a":2,"n":"Regions","t":16,"rt":System.Array.type(Spine.TextureRegion),"g":{"a":2,"n":"get_Regions","t":8,"rt":System.Array.type(Spine.TextureRegion),"fg":"Regions"},"fn":"Regions"},{"a":2,"n":"SetupIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_SetupIndex","t":8,"rt":$n[0].Int32,"fg":"SetupIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_SetupIndex","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"SetupIndex"},"fn":"SetupIndex"},{"a":2,"n":"Start","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Start","t":8,"rt":$n[0].Int32,"fg":"Start","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_Start","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"Start"},"fn":"Start"},{"a":4,"n":"digits","t":4,"rt":$n[0].Int32,"sn":"digits","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"id","t":4,"rt":$n[0].Int32,"sn":"id","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"nextID","is":true,"t":4,"rt":$n[0].Int32,"sn":"nextID","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"nextIdLock","is":true,"t":4,"rt":$n[0].Object,"sn":"nextIdLock","ro":true},{"a":4,"n":"regions","t":4,"rt":System.Array.type(Spine.TextureRegion),"sn":"regions","ro":true},{"a":4,"n":"setupIndex","t":4,"rt":$n[0].Int32,"sn":"setupIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"start","t":4,"rt":$n[0].Int32,"sn":"start","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.Sequence end.*/

    /*Spine.SequenceMode start.*/
    $m("Spine.SequenceMode", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Hold","is":true,"t":4,"rt":$n[8].SequenceMode,"sn":"Hold","box":function ($v) { return Bridge.box($v, Spine.SequenceMode, System.Enum.toStringFn(Spine.SequenceMode));}},{"a":2,"n":"Loop","is":true,"t":4,"rt":$n[8].SequenceMode,"sn":"Loop","box":function ($v) { return Bridge.box($v, Spine.SequenceMode, System.Enum.toStringFn(Spine.SequenceMode));}},{"a":2,"n":"LoopReverse","is":true,"t":4,"rt":$n[8].SequenceMode,"sn":"LoopReverse","box":function ($v) { return Bridge.box($v, Spine.SequenceMode, System.Enum.toStringFn(Spine.SequenceMode));}},{"a":2,"n":"Once","is":true,"t":4,"rt":$n[8].SequenceMode,"sn":"Once","box":function ($v) { return Bridge.box($v, Spine.SequenceMode, System.Enum.toStringFn(Spine.SequenceMode));}},{"a":2,"n":"OnceReverse","is":true,"t":4,"rt":$n[8].SequenceMode,"sn":"OnceReverse","box":function ($v) { return Bridge.box($v, Spine.SequenceMode, System.Enum.toStringFn(Spine.SequenceMode));}},{"a":2,"n":"Pingpong","is":true,"t":4,"rt":$n[8].SequenceMode,"sn":"Pingpong","box":function ($v) { return Bridge.box($v, Spine.SequenceMode, System.Enum.toStringFn(Spine.SequenceMode));}},{"a":2,"n":"PingpongReverse","is":true,"t":4,"rt":$n[8].SequenceMode,"sn":"PingpongReverse","box":function ($v) { return Bridge.box($v, Spine.SequenceMode, System.Enum.toStringFn(Spine.SequenceMode));}}]}; }, $n);
    /*Spine.SequenceMode end.*/

    /*Spine.VertexAttachment start.*/
    $m("Spine.VertexAttachment", function () { return {"att":1048705,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[8].VertexAttachment],"pi":[{"n":"other","pt":$n[8].VertexAttachment,"ps":0}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"$ctor1"},{"a":2,"n":"ComputeWorldVertices","t":8,"pi":[{"n":"slot","pt":$n[8].Slot,"ps":0},{"n":"worldVertices","pt":$n[0].Array.type(System.Single),"ps":1}],"sn":"ComputeWorldVertices$1","rt":$n[0].Void,"p":[$n[8].Slot,$n[0].Array.type(System.Single)]},{"v":true,"a":2,"n":"ComputeWorldVertices","t":8,"pi":[{"n":"slot","pt":$n[8].Slot,"ps":0},{"n":"start","pt":$n[0].Int32,"ps":1},{"n":"count","pt":$n[0].Int32,"ps":2},{"n":"worldVertices","pt":$n[0].Array.type(System.Single),"ps":3},{"n":"offset","pt":$n[0].Int32,"ps":4},{"n":"stride","dv":2,"o":true,"pt":$n[0].Int32,"ps":5}],"sn":"ComputeWorldVertices","rt":$n[0].Void,"p":[$n[8].Slot,$n[0].Int32,$n[0].Int32,$n[0].Array.type(System.Single),$n[0].Int32,$n[0].Int32]},{"a":2,"n":"Bones","t":16,"rt":$n[0].Array.type(System.Int32),"g":{"a":2,"n":"get_Bones","t":8,"rt":$n[0].Array.type(System.Int32),"fg":"Bones"},"s":{"a":2,"n":"set_Bones","t":8,"p":[$n[0].Array.type(System.Int32)],"rt":$n[0].Void,"fs":"Bones"},"fn":"Bones"},{"a":2,"n":"Id","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Id","t":8,"rt":$n[0].Int32,"fg":"Id","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"Id"},{"a":2,"n":"TimelineAttachment","t":16,"rt":$n[8].VertexAttachment,"g":{"a":2,"n":"get_TimelineAttachment","t":8,"rt":$n[8].VertexAttachment,"fg":"TimelineAttachment"},"s":{"a":2,"n":"set_TimelineAttachment","t":8,"p":[$n[8].VertexAttachment],"rt":$n[0].Void,"fs":"TimelineAttachment"},"fn":"TimelineAttachment"},{"a":2,"n":"Vertices","t":16,"rt":$n[0].Array.type(System.Single),"g":{"a":2,"n":"get_Vertices","t":8,"rt":$n[0].Array.type(System.Single),"fg":"Vertices"},"s":{"a":2,"n":"set_Vertices","t":8,"p":[$n[0].Array.type(System.Single)],"rt":$n[0].Void,"fs":"Vertices"},"fn":"Vertices"},{"a":2,"n":"WorldVerticesLength","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_WorldVerticesLength","t":8,"rt":$n[0].Int32,"fg":"WorldVerticesLength","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_WorldVerticesLength","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"WorldVerticesLength"},"fn":"WorldVerticesLength"},{"a":4,"n":"bones","t":4,"rt":$n[0].Array.type(System.Int32),"sn":"bones"},{"a":4,"n":"id","t":4,"rt":$n[0].Int32,"sn":"id","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"nextID","is":true,"t":4,"rt":$n[0].Int32,"sn":"nextID","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"nextIdLock","is":true,"t":4,"rt":$n[0].Object,"sn":"nextIdLock","ro":true},{"a":4,"n":"timelineAttachment","t":4,"rt":$n[8].VertexAttachment,"sn":"timelineAttachment"},{"a":4,"n":"vertices","t":4,"rt":$n[0].Array.type(System.Single),"sn":"vertices"},{"a":4,"n":"worldVerticesLength","t":4,"rt":$n[0].Int32,"sn":"worldVerticesLength","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.VertexAttachment end.*/

    /*Spine.BlendMode start.*/
    $m("Spine.BlendMode", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Additive","is":true,"t":4,"rt":$n[8].BlendMode,"sn":"Additive","box":function ($v) { return Bridge.box($v, Spine.BlendMode, System.Enum.toStringFn(Spine.BlendMode));}},{"a":2,"n":"Multiply","is":true,"t":4,"rt":$n[8].BlendMode,"sn":"Multiply","box":function ($v) { return Bridge.box($v, Spine.BlendMode, System.Enum.toStringFn(Spine.BlendMode));}},{"a":2,"n":"Normal","is":true,"t":4,"rt":$n[8].BlendMode,"sn":"Normal","box":function ($v) { return Bridge.box($v, Spine.BlendMode, System.Enum.toStringFn(Spine.BlendMode));}},{"a":2,"n":"Screen","is":true,"t":4,"rt":$n[8].BlendMode,"sn":"Screen","box":function ($v) { return Bridge.box($v, Spine.BlendMode, System.Enum.toStringFn(Spine.BlendMode));}}]}; }, $n);
    /*Spine.BlendMode end.*/

    /*Spine.Bone start.*/
    $m("Spine.Bone", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[8].Bone,$n[8].Skeleton,$n[8].Bone],"pi":[{"n":"bone","pt":$n[8].Bone,"ps":0},{"n":"skeleton","pt":$n[8].Skeleton,"ps":1},{"n":"parent","pt":$n[8].Bone,"ps":2}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[8].BoneData,$n[8].Skeleton,$n[8].Bone],"pi":[{"n":"data","pt":$n[8].BoneData,"ps":0},{"n":"skeleton","pt":$n[8].Skeleton,"ps":1},{"n":"parent","pt":$n[8].Bone,"ps":2}],"sn":"$ctor1"},{"a":2,"n":"LocalToWorld","t":8,"pi":[{"n":"localX","pt":$n[0].Single,"ps":0},{"n":"localY","pt":$n[0].Single,"ps":1},{"n":"worldX","out":true,"pt":$n[0].Single,"ps":2},{"n":"worldY","out":true,"pt":$n[0].Single,"ps":3}],"sn":"LocalToWorld","rt":$n[0].Void,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single]},{"a":2,"n":"LocalToWorldRotation","t":8,"pi":[{"n":"localRotation","pt":$n[0].Single,"ps":0}],"sn":"LocalToWorldRotation","rt":$n[0].Single,"p":[$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"ParentToWorld","t":8,"pi":[{"n":"parentX","pt":$n[0].Single,"ps":0},{"n":"parentY","pt":$n[0].Single,"ps":1},{"n":"worldX","out":true,"pt":$n[0].Single,"ps":2},{"n":"worldY","out":true,"pt":$n[0].Single,"ps":3}],"sn":"ParentToWorld","rt":$n[0].Void,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single]},{"a":2,"n":"RotateWorld","t":8,"pi":[{"n":"degrees","pt":$n[0].Single,"ps":0}],"sn":"RotateWorld","rt":$n[0].Void,"p":[$n[0].Single]},{"a":2,"n":"SetToSetupPose","t":8,"sn":"SetToSetupPose","rt":$n[0].Void},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"Update","t":8,"pi":[{"n":"physics","pt":$n[8].Skeleton.Physics,"ps":0}],"sn":"Update","rt":$n[0].Void,"p":[$n[8].Skeleton.Physics]},{"a":2,"n":"UpdateAppliedTransform","t":8,"sn":"UpdateAppliedTransform","rt":$n[0].Void},{"a":2,"n":"UpdateWorldTransform","t":8,"sn":"UpdateWorldTransform","rt":$n[0].Void},{"a":2,"n":"UpdateWorldTransform","t":8,"pi":[{"n":"x","pt":$n[0].Single,"ps":0},{"n":"y","pt":$n[0].Single,"ps":1},{"n":"rotation","pt":$n[0].Single,"ps":2},{"n":"scaleX","pt":$n[0].Single,"ps":3},{"n":"scaleY","pt":$n[0].Single,"ps":4},{"n":"shearX","pt":$n[0].Single,"ps":5},{"n":"shearY","pt":$n[0].Single,"ps":6}],"sn":"UpdateWorldTransform$1","rt":$n[0].Void,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single]},{"a":2,"n":"WorldToLocal","t":8,"pi":[{"n":"worldX","pt":$n[0].Single,"ps":0},{"n":"worldY","pt":$n[0].Single,"ps":1},{"n":"localX","out":true,"pt":$n[0].Single,"ps":2},{"n":"localY","out":true,"pt":$n[0].Single,"ps":3}],"sn":"WorldToLocal","rt":$n[0].Void,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single]},{"a":2,"n":"WorldToLocalRotation","t":8,"pi":[{"n":"worldRotation","pt":$n[0].Single,"ps":0}],"sn":"WorldToLocalRotation","rt":$n[0].Single,"p":[$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"WorldToParent","t":8,"pi":[{"n":"worldX","pt":$n[0].Single,"ps":0},{"n":"worldY","pt":$n[0].Single,"ps":1},{"n":"parentX","out":true,"pt":$n[0].Single,"ps":2},{"n":"parentY","out":true,"pt":$n[0].Single,"ps":3}],"sn":"WorldToParent","rt":$n[0].Void,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single]},{"a":2,"n":"A","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_A","t":8,"rt":$n[0].Single,"fg":"A","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_A","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"A"},"fn":"A"},{"a":2,"n":"AScaleX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_AScaleX","t":8,"rt":$n[0].Single,"fg":"AScaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_AScaleX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"AScaleX"},"fn":"AScaleX"},{"a":2,"n":"AScaleY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_AScaleY","t":8,"rt":$n[0].Single,"fg":"AScaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_AScaleY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"AScaleY"},"fn":"AScaleY"},{"a":2,"n":"AShearX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_AShearX","t":8,"rt":$n[0].Single,"fg":"AShearX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_AShearX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"AShearX"},"fn":"AShearX"},{"a":2,"n":"AShearY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_AShearY","t":8,"rt":$n[0].Single,"fg":"AShearY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_AShearY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"AShearY"},"fn":"AShearY"},{"a":2,"n":"AX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_AX","t":8,"rt":$n[0].Single,"fg":"AX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_AX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"AX"},"fn":"AX"},{"a":2,"n":"AY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_AY","t":8,"rt":$n[0].Single,"fg":"AY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_AY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"AY"},"fn":"AY"},{"a":2,"n":"Active","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Active","t":8,"rt":$n[0].Boolean,"fg":"Active","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"Active"},{"a":2,"n":"AppliedRotation","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_AppliedRotation","t":8,"rt":$n[0].Single,"fg":"AppliedRotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_AppliedRotation","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"AppliedRotation"},"fn":"AppliedRotation"},{"a":2,"n":"B","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_B","t":8,"rt":$n[0].Single,"fg":"B","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_B","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"B"},"fn":"B"},{"a":2,"n":"C","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_C","t":8,"rt":$n[0].Single,"fg":"C","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_C","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"C"},"fn":"C"},{"a":2,"n":"Children","t":16,"rt":$n[8].ExposedList$1(Spine.Bone),"g":{"a":2,"n":"get_Children","t":8,"rt":$n[8].ExposedList$1(Spine.Bone),"fg":"Children"},"fn":"Children"},{"a":2,"n":"D","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_D","t":8,"rt":$n[0].Single,"fg":"D","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_D","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"D"},"fn":"D"},{"a":2,"n":"Data","t":16,"rt":$n[8].BoneData,"g":{"a":2,"n":"get_Data","t":8,"rt":$n[8].BoneData,"fg":"Data"},"fn":"Data"},{"a":2,"n":"Inherit","t":16,"rt":$n[8].Inherit,"g":{"a":2,"n":"get_Inherit","t":8,"rt":$n[8].Inherit,"fg":"Inherit","box":function ($v) { return Bridge.box($v, Spine.Inherit, System.Enum.toStringFn(Spine.Inherit));}},"s":{"a":2,"n":"set_Inherit","t":8,"p":[$n[8].Inherit],"rt":$n[0].Void,"fs":"Inherit"},"fn":"Inherit"},{"a":2,"n":"Parent","t":16,"rt":$n[8].Bone,"g":{"a":2,"n":"get_Parent","t":8,"rt":$n[8].Bone,"fg":"Parent"},"fn":"Parent"},{"a":2,"n":"Rotation","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Rotation","t":8,"rt":$n[0].Single,"fg":"Rotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Rotation","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Rotation"},"fn":"Rotation"},{"a":2,"n":"ScaleX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ScaleX","t":8,"rt":$n[0].Single,"fg":"ScaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ScaleX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ScaleX"},"fn":"ScaleX"},{"a":2,"n":"ScaleY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ScaleY","t":8,"rt":$n[0].Single,"fg":"ScaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ScaleY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ScaleY"},"fn":"ScaleY"},{"a":2,"n":"ShearX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ShearX","t":8,"rt":$n[0].Single,"fg":"ShearX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ShearX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ShearX"},"fn":"ShearX"},{"a":2,"n":"ShearY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ShearY","t":8,"rt":$n[0].Single,"fg":"ShearY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ShearY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ShearY"},"fn":"ShearY"},{"a":2,"n":"Skeleton","t":16,"rt":$n[8].Skeleton,"g":{"a":2,"n":"get_Skeleton","t":8,"rt":$n[8].Skeleton,"fg":"Skeleton"},"fn":"Skeleton"},{"a":2,"n":"WorldRotationX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_WorldRotationX","t":8,"rt":$n[0].Single,"fg":"WorldRotationX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"WorldRotationX"},{"a":2,"n":"WorldRotationY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_WorldRotationY","t":8,"rt":$n[0].Single,"fg":"WorldRotationY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"WorldRotationY"},{"a":2,"n":"WorldScaleX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_WorldScaleX","t":8,"rt":$n[0].Single,"fg":"WorldScaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"WorldScaleX"},{"a":2,"n":"WorldScaleY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_WorldScaleY","t":8,"rt":$n[0].Single,"fg":"WorldScaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"WorldScaleY"},{"a":2,"n":"WorldX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_WorldX","t":8,"rt":$n[0].Single,"fg":"WorldX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_WorldX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"WorldX"},"fn":"WorldX"},{"a":2,"n":"WorldY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_WorldY","t":8,"rt":$n[0].Single,"fg":"WorldY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_WorldY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"WorldY"},"fn":"WorldY"},{"a":2,"n":"X","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_X","t":8,"rt":$n[0].Single,"fg":"X","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_X","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"X"},"fn":"X"},{"a":2,"n":"Y","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Y","t":8,"rt":$n[0].Single,"fg":"Y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Y","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Y"},"fn":"Y"},{"a":4,"n":"a","t":4,"rt":$n[0].Single,"sn":"a","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"active","t":4,"rt":$n[0].Boolean,"sn":"active","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"arotation","t":4,"rt":$n[0].Single,"sn":"arotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"ascaleX","t":4,"rt":$n[0].Single,"sn":"ascaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"ascaleY","t":4,"rt":$n[0].Single,"sn":"ascaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"ashearX","t":4,"rt":$n[0].Single,"sn":"ashearX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"ashearY","t":4,"rt":$n[0].Single,"sn":"ashearY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"ax","t":4,"rt":$n[0].Single,"sn":"ax","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"ay","t":4,"rt":$n[0].Single,"sn":"ay","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"b","t":4,"rt":$n[0].Single,"sn":"b","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"c","t":4,"rt":$n[0].Single,"sn":"c","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"children","t":4,"rt":$n[8].ExposedList$1(Spine.Bone),"sn":"children"},{"a":4,"n":"d","t":4,"rt":$n[0].Single,"sn":"d","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"data","t":4,"rt":$n[8].BoneData,"sn":"data"},{"a":4,"n":"inherit","t":4,"rt":$n[8].Inherit,"sn":"inherit","box":function ($v) { return Bridge.box($v, Spine.Inherit, System.Enum.toStringFn(Spine.Inherit));}},{"a":4,"n":"parent","t":4,"rt":$n[8].Bone,"sn":"parent"},{"a":4,"n":"rotation","t":4,"rt":$n[0].Single,"sn":"rotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"scaleX","t":4,"rt":$n[0].Single,"sn":"scaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"scaleY","t":4,"rt":$n[0].Single,"sn":"scaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"shearX","t":4,"rt":$n[0].Single,"sn":"shearX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"shearY","t":4,"rt":$n[0].Single,"sn":"shearY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"skeleton","t":4,"rt":$n[8].Skeleton,"sn":"skeleton"},{"a":4,"n":"sorted","t":4,"rt":$n[0].Boolean,"sn":"sorted","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"worldX","t":4,"rt":$n[0].Single,"sn":"worldX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"worldY","t":4,"rt":$n[0].Single,"sn":"worldY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"x","t":4,"rt":$n[0].Single,"sn":"x","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"y","t":4,"rt":$n[0].Single,"sn":"y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"yDown","is":true,"t":4,"rt":$n[0].Boolean,"sn":"yDown","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Bone end.*/

    /*Spine.BoneData start.*/
    $m("Spine.BoneData", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].String,$n[8].BoneData],"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"parent","pt":$n[8].BoneData,"ps":2}],"sn":"ctor"},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"Index","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Index","t":8,"rt":$n[0].Int32,"fg":"Index","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"Index"},{"a":2,"n":"Inherit","t":16,"rt":$n[8].Inherit,"g":{"a":2,"n":"get_Inherit","t":8,"rt":$n[8].Inherit,"fg":"Inherit","box":function ($v) { return Bridge.box($v, Spine.Inherit, System.Enum.toStringFn(Spine.Inherit));}},"s":{"a":2,"n":"set_Inherit","t":8,"p":[$n[8].Inherit],"rt":$n[0].Void,"fs":"Inherit"},"fn":"Inherit"},{"a":2,"n":"Length","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Length","t":8,"rt":$n[0].Single,"fg":"Length","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Length","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Length"},"fn":"Length"},{"a":2,"n":"Name","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_Name","t":8,"rt":$n[0].String,"fg":"Name"},"fn":"Name"},{"a":2,"n":"Parent","t":16,"rt":$n[8].BoneData,"g":{"a":2,"n":"get_Parent","t":8,"rt":$n[8].BoneData,"fg":"Parent"},"fn":"Parent"},{"a":2,"n":"Rotation","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Rotation","t":8,"rt":$n[0].Single,"fg":"Rotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Rotation","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Rotation"},"fn":"Rotation"},{"a":2,"n":"ScaleX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ScaleX","t":8,"rt":$n[0].Single,"fg":"ScaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ScaleX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ScaleX"},"fn":"ScaleX"},{"a":2,"n":"ScaleY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ScaleY","t":8,"rt":$n[0].Single,"fg":"ScaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ScaleY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ScaleY"},"fn":"ScaleY"},{"a":2,"n":"ShearX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ShearX","t":8,"rt":$n[0].Single,"fg":"ShearX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ShearX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ShearX"},"fn":"ShearX"},{"a":2,"n":"ShearY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ShearY","t":8,"rt":$n[0].Single,"fg":"ShearY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ShearY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ShearY"},"fn":"ShearY"},{"a":2,"n":"SkinRequired","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_SkinRequired","t":8,"rt":$n[0].Boolean,"fg":"SkinRequired","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_SkinRequired","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"SkinRequired"},"fn":"SkinRequired"},{"a":2,"n":"X","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_X","t":8,"rt":$n[0].Single,"fg":"X","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_X","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"X"},"fn":"X"},{"a":2,"n":"Y","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Y","t":8,"rt":$n[0].Single,"fg":"Y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Y","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Y"},"fn":"Y"},{"a":4,"n":"index","t":4,"rt":$n[0].Int32,"sn":"index","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"inherit","t":4,"rt":$n[8].Inherit,"sn":"inherit","box":function ($v) { return Bridge.box($v, Spine.Inherit, System.Enum.toStringFn(Spine.Inherit));}},{"a":4,"n":"length","t":4,"rt":$n[0].Single,"sn":"length","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"name","t":4,"rt":$n[0].String,"sn":"name"},{"a":4,"n":"parent","t":4,"rt":$n[8].BoneData,"sn":"parent"},{"a":4,"n":"rotation","t":4,"rt":$n[0].Single,"sn":"rotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"scaleX","t":4,"rt":$n[0].Single,"sn":"scaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"scaleY","t":4,"rt":$n[0].Single,"sn":"scaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"shearX","t":4,"rt":$n[0].Single,"sn":"shearX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"shearY","t":4,"rt":$n[0].Single,"sn":"shearY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"skinRequired","t":4,"rt":$n[0].Boolean,"sn":"skinRequired","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"x","t":4,"rt":$n[0].Single,"sn":"x","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"y","t":4,"rt":$n[0].Single,"sn":"y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.BoneData end.*/

    /*Spine.Inherit start.*/
    $m("Spine.Inherit", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"NoRotationOrReflection","is":true,"t":4,"rt":$n[8].Inherit,"sn":"NoRotationOrReflection","box":function ($v) { return Bridge.box($v, Spine.Inherit, System.Enum.toStringFn(Spine.Inherit));}},{"a":2,"n":"NoScale","is":true,"t":4,"rt":$n[8].Inherit,"sn":"NoScale","box":function ($v) { return Bridge.box($v, Spine.Inherit, System.Enum.toStringFn(Spine.Inherit));}},{"a":2,"n":"NoScaleOrReflection","is":true,"t":4,"rt":$n[8].Inherit,"sn":"NoScaleOrReflection","box":function ($v) { return Bridge.box($v, Spine.Inherit, System.Enum.toStringFn(Spine.Inherit));}},{"a":2,"n":"Normal","is":true,"t":4,"rt":$n[8].Inherit,"sn":"Normal","box":function ($v) { return Bridge.box($v, Spine.Inherit, System.Enum.toStringFn(Spine.Inherit));}},{"a":2,"n":"OnlyTranslation","is":true,"t":4,"rt":$n[8].Inherit,"sn":"OnlyTranslation","box":function ($v) { return Bridge.box($v, Spine.Inherit, System.Enum.toStringFn(Spine.Inherit));}}]}; }, $n);
    /*Spine.Inherit end.*/

    /*Spine.InheritEnum start.*/
    $m("Spine.InheritEnum", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Values","is":true,"t":4,"rt":System.Array.type(Spine.Inherit),"sn":"Values","ro":true}]}; }, $n);
    /*Spine.InheritEnum end.*/

    /*Spine.ConstraintData start.*/
    $m("Spine.ConstraintData", function () { return {"att":1048705,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"Name","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_Name","t":8,"rt":$n[0].String,"fg":"Name"},"fn":"Name"},{"a":2,"n":"Order","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Order","t":8,"rt":$n[0].Int32,"fg":"Order","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_Order","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"Order"},"fn":"Order"},{"a":2,"n":"SkinRequired","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_SkinRequired","t":8,"rt":$n[0].Boolean,"fg":"SkinRequired","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_SkinRequired","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"SkinRequired"},"fn":"SkinRequired"},{"a":4,"n":"name","t":4,"rt":$n[0].String,"sn":"name","ro":true},{"a":4,"n":"order","t":4,"rt":$n[0].Int32,"sn":"order","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"skinRequired","t":4,"rt":$n[0].Boolean,"sn":"skinRequired","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.ConstraintData end.*/

    /*Spine.Event start.*/
    $m("Spine.Event", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Single,$n[8].EventData],"pi":[{"n":"time","pt":$n[0].Single,"ps":0},{"n":"data","pt":$n[8].EventData,"ps":1}],"sn":"ctor"},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"Balance","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Balance","t":8,"rt":$n[0].Single,"fg":"Balance","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Balance","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Balance"},"fn":"Balance"},{"a":2,"n":"Data","t":16,"rt":$n[8].EventData,"g":{"a":2,"n":"get_Data","t":8,"rt":$n[8].EventData,"fg":"Data"},"fn":"Data"},{"a":2,"n":"Float","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Float","t":8,"rt":$n[0].Single,"fg":"Float","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Float","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Float"},"fn":"Float"},{"a":2,"n":"Int","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Int","t":8,"rt":$n[0].Int32,"fg":"Int","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_Int","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"Int"},"fn":"Int"},{"a":2,"n":"String","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_String","t":8,"rt":$n[0].String,"fg":"String"},"s":{"a":2,"n":"set_String","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"String"},"fn":"String"},{"a":2,"n":"Time","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Time","t":8,"rt":$n[0].Single,"fg":"Time","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"Time"},{"a":2,"n":"Volume","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Volume","t":8,"rt":$n[0].Single,"fg":"Volume","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Volume","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Volume"},"fn":"Volume"},{"a":4,"n":"balance","t":4,"rt":$n[0].Single,"sn":"balance","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"data","t":4,"rt":$n[8].EventData,"sn":"data","ro":true},{"a":4,"n":"floatValue","t":4,"rt":$n[0].Single,"sn":"floatValue","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"intValue","t":4,"rt":$n[0].Int32,"sn":"intValue","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"stringValue","t":4,"rt":$n[0].String,"sn":"stringValue"},{"a":4,"n":"time","t":4,"rt":$n[0].Single,"sn":"time","ro":true,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"volume","t":4,"rt":$n[0].Single,"sn":"volume","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.Event end.*/

    /*Spine.EventData start.*/
    $m("Spine.EventData", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"AudioPath","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_AudioPath","t":8,"rt":$n[0].String,"fg":"AudioPath"},"s":{"a":2,"n":"set_AudioPath","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"AudioPath"},"fn":"AudioPath"},{"a":2,"n":"Balance","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Balance","t":8,"rt":$n[0].Single,"fg":"Balance","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Balance","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Balance"},"fn":"Balance"},{"a":2,"n":"Float","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Float","t":8,"rt":$n[0].Single,"fg":"Float","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Float","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Float"},"fn":"Float"},{"a":2,"n":"Int","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Int","t":8,"rt":$n[0].Int32,"fg":"Int","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_Int","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"Int"},"fn":"Int"},{"a":2,"n":"Name","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_Name","t":8,"rt":$n[0].String,"fg":"Name"},"fn":"Name"},{"a":2,"n":"String","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_String","t":8,"rt":$n[0].String,"fg":"String"},"s":{"a":2,"n":"set_String","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"String"},"fn":"String"},{"a":2,"n":"Volume","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Volume","t":8,"rt":$n[0].Single,"fg":"Volume","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Volume","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Volume"},"fn":"Volume"},{"a":4,"n":"name","t":4,"rt":$n[0].String,"sn":"name"},{"a":1,"backing":true,"n":"<AudioPath>k__BackingField","t":4,"rt":$n[0].String,"sn":"AudioPath"},{"a":1,"backing":true,"n":"<Balance>k__BackingField","t":4,"rt":$n[0].Single,"sn":"Balance","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"backing":true,"n":"<Float>k__BackingField","t":4,"rt":$n[0].Single,"sn":"Float","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"backing":true,"n":"<Int>k__BackingField","t":4,"rt":$n[0].Int32,"sn":"Int","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"backing":true,"n":"<String>k__BackingField","t":4,"rt":$n[0].String,"sn":"String"},{"a":1,"backing":true,"n":"<Volume>k__BackingField","t":4,"rt":$n[0].Single,"sn":"Volume","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.EventData end.*/

    /*Spine.ExposedList$1 start.*/
    $m("Spine.ExposedList$1", function (T) { return {"nested":[$n[8].ExposedList$1.Enumerator],"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[2].IEnumerable$1(T)],"pi":[{"n":"collection","pt":$n[2].IEnumerable$1(T),"ps":0}],"sn":"$ctor2"},{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32],"pi":[{"n":"capacity","pt":$n[0].Int32,"ps":0}],"sn":"$ctor3"},{"a":4,"n":".ctor","t":1,"p":[System.Array.type(T),$n[0].Int32],"pi":[{"n":"data","pt":System.Array.type(T),"ps":0},{"n":"size","pt":$n[0].Int32,"ps":1}],"sn":"$ctor1"},{"a":2,"n":"Add","t":8,"pi":[{"n":"item","pt":T,"ps":0}],"sn":"Add","rt":$n[0].Void,"p":[T]},{"a":1,"n":"AddCollection","t":8,"pi":[{"n":"collection","pt":$n[2].ICollection$1(T),"ps":0}],"sn":"AddCollection","rt":$n[0].Void,"p":[$n[2].ICollection$1(T)]},{"a":1,"n":"AddEnumerable","t":8,"pi":[{"n":"enumerable","pt":$n[2].IEnumerable$1(T),"ps":0}],"sn":"AddEnumerable","rt":$n[0].Void,"p":[$n[2].IEnumerable$1(T)]},{"a":2,"n":"AddRange","t":8,"pi":[{"n":"list","pt":$n[8].ExposedList$1(T),"ps":0}],"sn":"AddRange","rt":$n[0].Void,"p":[$n[8].ExposedList$1(T)]},{"a":2,"n":"AddRange","t":8,"pi":[{"n":"collection","pt":$n[2].IEnumerable$1(T),"ps":0}],"sn":"AddRange$1","rt":$n[0].Void,"p":[$n[2].IEnumerable$1(T)]},{"a":2,"n":"BinarySearch","t":8,"pi":[{"n":"item","pt":T,"ps":0}],"sn":"BinarySearch","rt":$n[0].Int32,"p":[T],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"BinarySearch","t":8,"pi":[{"n":"item","pt":T,"ps":0},{"n":"comparer","pt":$n[2].IComparer$1(T),"ps":1}],"sn":"BinarySearch$1","rt":$n[0].Int32,"p":[T,$n[2].IComparer$1(T)],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"BinarySearch","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"count","pt":$n[0].Int32,"ps":1},{"n":"item","pt":T,"ps":2},{"n":"comparer","pt":$n[2].IComparer$1(T),"ps":3}],"sn":"BinarySearch$2","rt":$n[0].Int32,"p":[$n[0].Int32,$n[0].Int32,T,$n[2].IComparer$1(T)],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"CheckCollection","t":8,"pi":[{"n":"collection","pt":$n[2].IEnumerable$1(T),"ps":0}],"sn":"CheckCollection","rt":$n[0].Void,"p":[$n[2].IEnumerable$1(T)]},{"a":1,"n":"CheckIndex","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0}],"sn":"CheckIndex","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":1,"n":"CheckMatch","is":true,"t":8,"pi":[{"n":"match","pt":Function,"ps":0}],"sn":"CheckMatch","rt":$n[0].Void,"p":[Function]},{"a":1,"n":"CheckRange","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"count","pt":$n[0].Int32,"ps":1}],"sn":"CheckRange","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Int32]},{"a":2,"n":"Clear","t":8,"pi":[{"n":"clearArray","dv":true,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"Clear","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":2,"n":"Contains","t":8,"pi":[{"n":"item","pt":T,"ps":0}],"sn":"Contains","rt":$n[0].Boolean,"p":[T],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"ConvertAll","t":8,"pi":[{"n":"converter","pt":Function,"ps":0}],"tpc":1,"tprm":["TOutput"],"sn":"ConvertAll","rt":$n[8].ExposedList$1(System.Object),"p":[Function]},{"a":2,"n":"CopyTo","t":8,"pi":[{"n":"array","pt":System.Array.type(T),"ps":0}],"sn":"CopyTo","rt":$n[0].Void,"p":[System.Array.type(T)]},{"a":2,"n":"CopyTo","t":8,"pi":[{"n":"array","pt":System.Array.type(T),"ps":0},{"n":"arrayIndex","pt":$n[0].Int32,"ps":1}],"sn":"CopyTo$1","rt":$n[0].Void,"p":[System.Array.type(T),$n[0].Int32]},{"a":2,"n":"CopyTo","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"array","pt":System.Array.type(T),"ps":1},{"n":"arrayIndex","pt":$n[0].Int32,"ps":2},{"n":"count","pt":$n[0].Int32,"ps":3}],"sn":"CopyTo$2","rt":$n[0].Void,"p":[$n[0].Int32,System.Array.type(T),$n[0].Int32,$n[0].Int32]},{"a":2,"n":"EnsureCapacity","t":8,"pi":[{"n":"min","pt":$n[0].Int32,"ps":0}],"sn":"EnsureCapacity","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"Exists","t":8,"pi":[{"n":"match","pt":Function,"ps":0}],"sn":"Exists","rt":$n[0].Boolean,"p":[Function],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"Find","t":8,"pi":[{"n":"match","pt":Function,"ps":0}],"sn":"Find","rt":T,"p":[Function]},{"a":2,"n":"FindAll","t":8,"pi":[{"n":"match","pt":Function,"ps":0}],"sn":"FindAll","rt":$n[8].ExposedList$1(T),"p":[Function]},{"a":1,"n":"FindAllList","t":8,"pi":[{"n":"match","pt":Function,"ps":0}],"sn":"FindAllList","rt":$n[8].ExposedList$1(T),"p":[Function]},{"a":2,"n":"FindIndex","t":8,"pi":[{"n":"match","pt":Function,"ps":0}],"sn":"FindIndex$2","rt":$n[0].Int32,"p":[Function],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"FindIndex","t":8,"pi":[{"n":"startIndex","pt":$n[0].Int32,"ps":0},{"n":"match","pt":Function,"ps":1}],"sn":"FindIndex$1","rt":$n[0].Int32,"p":[$n[0].Int32,Function],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"FindIndex","t":8,"pi":[{"n":"startIndex","pt":$n[0].Int32,"ps":0},{"n":"count","pt":$n[0].Int32,"ps":1},{"n":"match","pt":Function,"ps":2}],"sn":"FindIndex","rt":$n[0].Int32,"p":[$n[0].Int32,$n[0].Int32,Function],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"FindLast","t":8,"pi":[{"n":"match","pt":Function,"ps":0}],"sn":"FindLast","rt":T,"p":[Function]},{"a":2,"n":"FindLastIndex","t":8,"pi":[{"n":"match","pt":Function,"ps":0}],"sn":"FindLastIndex$2","rt":$n[0].Int32,"p":[Function],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"FindLastIndex","t":8,"pi":[{"n":"startIndex","pt":$n[0].Int32,"ps":0},{"n":"match","pt":Function,"ps":1}],"sn":"FindLastIndex$1","rt":$n[0].Int32,"p":[$n[0].Int32,Function],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"FindLastIndex","t":8,"pi":[{"n":"startIndex","pt":$n[0].Int32,"ps":0},{"n":"count","pt":$n[0].Int32,"ps":1},{"n":"match","pt":Function,"ps":2}],"sn":"FindLastIndex","rt":$n[0].Int32,"p":[$n[0].Int32,$n[0].Int32,Function],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"ForEach","t":8,"pi":[{"n":"action","pt":Function,"ps":0}],"sn":"ForEach","rt":$n[0].Void,"p":[Function]},{"a":2,"n":"GetEnumerator","t":8,"sn":"GetEnumerator","rt":$n[8].ExposedList$1.Enumerator(T)},{"a":1,"n":"GetIndex","t":8,"pi":[{"n":"startIndex","pt":$n[0].Int32,"ps":0},{"n":"count","pt":$n[0].Int32,"ps":1},{"n":"match","pt":Function,"ps":2}],"sn":"GetIndex","rt":$n[0].Int32,"p":[$n[0].Int32,$n[0].Int32,Function],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"GetLastIndex","t":8,"pi":[{"n":"startIndex","pt":$n[0].Int32,"ps":0},{"n":"count","pt":$n[0].Int32,"ps":1},{"n":"match","pt":Function,"ps":2}],"sn":"GetLastIndex","rt":$n[0].Int32,"p":[$n[0].Int32,$n[0].Int32,Function],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"GetRange","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"count","pt":$n[0].Int32,"ps":1}],"sn":"GetRange","rt":$n[8].ExposedList$1(T),"p":[$n[0].Int32,$n[0].Int32]},{"a":2,"n":"GrowIfNeeded","t":8,"pi":[{"n":"addedCount","pt":$n[0].Int32,"ps":0}],"sn":"GrowIfNeeded","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"IndexOf","t":8,"pi":[{"n":"item","pt":T,"ps":0}],"sn":"IndexOf","rt":$n[0].Int32,"p":[T],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"IndexOf","t":8,"pi":[{"n":"item","pt":T,"ps":0},{"n":"index","pt":$n[0].Int32,"ps":1}],"sn":"IndexOf$1","rt":$n[0].Int32,"p":[T,$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"IndexOf","t":8,"pi":[{"n":"item","pt":T,"ps":0},{"n":"index","pt":$n[0].Int32,"ps":1},{"n":"count","pt":$n[0].Int32,"ps":2}],"sn":"IndexOf$2","rt":$n[0].Int32,"p":[T,$n[0].Int32,$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"Insert","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"item","pt":T,"ps":1}],"sn":"Insert","rt":$n[0].Void,"p":[$n[0].Int32,T]},{"a":1,"n":"InsertCollection","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"collection","pt":$n[2].ICollection$1(T),"ps":1}],"sn":"InsertCollection","rt":$n[0].Void,"p":[$n[0].Int32,$n[2].ICollection$1(T)]},{"a":1,"n":"InsertEnumeration","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"enumerable","pt":$n[2].IEnumerable$1(T),"ps":1}],"sn":"InsertEnumeration","rt":$n[0].Void,"p":[$n[0].Int32,$n[2].IEnumerable$1(T)]},{"a":2,"n":"InsertRange","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"collection","pt":$n[2].IEnumerable$1(T),"ps":1}],"sn":"InsertRange","rt":$n[0].Void,"p":[$n[0].Int32,$n[2].IEnumerable$1(T)]},{"a":2,"n":"LastIndexOf","t":8,"pi":[{"n":"item","pt":T,"ps":0}],"sn":"LastIndexOf","rt":$n[0].Int32,"p":[T],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"LastIndexOf","t":8,"pi":[{"n":"item","pt":T,"ps":0},{"n":"index","pt":$n[0].Int32,"ps":1}],"sn":"LastIndexOf$1","rt":$n[0].Int32,"p":[T,$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"LastIndexOf","t":8,"pi":[{"n":"item","pt":T,"ps":0},{"n":"index","pt":$n[0].Int32,"ps":1},{"n":"count","pt":$n[0].Int32,"ps":2}],"sn":"LastIndexOf$2","rt":$n[0].Int32,"p":[T,$n[0].Int32,$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"Pop","t":8,"sn":"Pop","rt":T},{"a":2,"n":"Remove","t":8,"pi":[{"n":"item","pt":T,"ps":0}],"sn":"Remove","rt":$n[0].Boolean,"p":[T],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"RemoveAll","t":8,"pi":[{"n":"match","pt":Function,"ps":0}],"sn":"RemoveAll","rt":$n[0].Int32,"p":[Function],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"RemoveAt","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0}],"sn":"RemoveAt","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"RemoveRange","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"count","pt":$n[0].Int32,"ps":1}],"sn":"RemoveRange","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Int32]},{"a":2,"n":"Resize","t":8,"pi":[{"n":"newSize","pt":$n[0].Int32,"ps":0}],"sn":"Resize","rt":$n[8].ExposedList$1(T),"p":[$n[0].Int32]},{"a":2,"n":"Reverse","t":8,"sn":"Reverse","rt":$n[0].Void},{"a":2,"n":"Reverse","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"count","pt":$n[0].Int32,"ps":1}],"sn":"Reverse$1","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Int32]},{"a":1,"n":"Shift","t":8,"pi":[{"n":"start","pt":$n[0].Int32,"ps":0},{"n":"delta","pt":$n[0].Int32,"ps":1}],"sn":"Shift","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Int32]},{"a":2,"n":"Sort","t":8,"sn":"Sort","rt":$n[0].Void},{"a":2,"n":"Sort","t":8,"pi":[{"n":"comparer","pt":$n[2].IComparer$1(T),"ps":0}],"sn":"Sort$1","rt":$n[0].Void,"p":[$n[2].IComparer$1(T)]},{"a":2,"n":"Sort","t":8,"pi":[{"n":"comparison","pt":Function,"ps":0}],"sn":"Sort$2","rt":$n[0].Void,"p":[Function]},{"a":2,"n":"Sort","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"count","pt":$n[0].Int32,"ps":1},{"n":"comparer","pt":$n[2].IComparer$1(T),"ps":2}],"sn":"Sort$3","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Int32,$n[2].IComparer$1(T)]},{"a":2,"n":"ToArray","t":8,"sn":"ToArray","rt":System.Array.type(T)},{"a":2,"n":"TrimExcess","t":8,"sn":"TrimExcess","rt":$n[0].Void},{"a":2,"n":"TrueForAll","t":8,"pi":[{"n":"match","pt":Function,"ps":0}],"sn":"TrueForAll","rt":$n[0].Boolean,"p":[Function],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"Capacity","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Capacity","t":8,"rt":$n[0].Int32,"fg":"Capacity","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_Capacity","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"Capacity"},"fn":"Capacity"},{"a":2,"n":"Count","t":4,"rt":$n[0].Int32,"sn":"Count","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"DefaultCapacity","is":true,"t":4,"rt":$n[0].Int32,"sn":"DefaultCapacity","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"EmptyArray","is":true,"t":4,"rt":System.Array.type(T),"sn":"EmptyArray","ro":true},{"a":2,"n":"Items","t":4,"rt":System.Array.type(T),"sn":"Items"},{"a":1,"n":"version","t":4,"rt":$n[0].Int32,"sn":"version","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.ExposedList$1 end.*/

    /*Spine.ExposedList$1+Enumerator start.*/
    $m("Spine.ExposedList$1.Enumerator", function (T) { return {"td":$n[8].ExposedList$1(T),"att":1048842,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":4,"n":".ctor","t":1,"p":[$n[8].ExposedList$1(T)],"pi":[{"n":"l","pt":$n[8].ExposedList$1(T),"ps":0}],"sn":"$ctor1"},{"a":2,"n":"Dispose","t":8,"sn":"Dispose","rt":$n[0].Void},{"a":2,"n":"MoveNext","t":8,"sn":"moveNext","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"VerifyState","t":8,"sn":"VerifyState","rt":$n[0].Void},{"a":2,"n":"Current","t":16,"rt":T,"g":{"a":2,"n":"get_Current","t":8,"rt":T,"fg":"Current"},"fn":"Current"},{"a":1,"n":"current","t":4,"rt":T,"sn":"current"},{"a":1,"n":"l","t":4,"rt":$n[8].ExposedList$1(T),"sn":"l"},{"a":1,"n":"next","t":4,"rt":$n[0].Int32,"sn":"next","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"ver","t":4,"rt":$n[0].Int32,"sn":"ver","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.ExposedList$1+Enumerator end.*/

    /*Spine.IkConstraint start.*/
    $m("Spine.IkConstraint", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[8].IkConstraint,$n[8].Skeleton],"pi":[{"n":"constraint","pt":$n[8].IkConstraint,"ps":0},{"n":"skeleton","pt":$n[8].Skeleton,"ps":1}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[8].IkConstraintData,$n[8].Skeleton],"pi":[{"n":"data","pt":$n[8].IkConstraintData,"ps":0},{"n":"skeleton","pt":$n[8].Skeleton,"ps":1}],"sn":"$ctor1"},{"a":2,"n":"Apply","is":true,"t":8,"pi":[{"n":"bone","pt":$n[8].Bone,"ps":0},{"n":"targetX","pt":$n[0].Single,"ps":1},{"n":"targetY","pt":$n[0].Single,"ps":2},{"n":"compress","pt":$n[0].Boolean,"ps":3},{"n":"stretch","pt":$n[0].Boolean,"ps":4},{"n":"uniform","pt":$n[0].Boolean,"ps":5},{"n":"alpha","pt":$n[0].Single,"ps":6}],"sn":"Apply$1","rt":$n[0].Void,"p":[$n[8].Bone,$n[0].Single,$n[0].Single,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean,$n[0].Single]},{"a":2,"n":"Apply","is":true,"t":8,"pi":[{"n":"parent","pt":$n[8].Bone,"ps":0},{"n":"child","pt":$n[8].Bone,"ps":1},{"n":"targetX","pt":$n[0].Single,"ps":2},{"n":"targetY","pt":$n[0].Single,"ps":3},{"n":"bendDir","pt":$n[0].Int32,"ps":4},{"n":"stretch","pt":$n[0].Boolean,"ps":5},{"n":"uniform","pt":$n[0].Boolean,"ps":6},{"n":"softness","pt":$n[0].Single,"ps":7},{"n":"alpha","pt":$n[0].Single,"ps":8}],"sn":"Apply","rt":$n[0].Void,"p":[$n[8].Bone,$n[8].Bone,$n[0].Single,$n[0].Single,$n[0].Int32,$n[0].Boolean,$n[0].Boolean,$n[0].Single,$n[0].Single]},{"a":2,"n":"SetToSetupPose","t":8,"sn":"SetToSetupPose","rt":$n[0].Void},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"Update","t":8,"pi":[{"n":"physics","pt":$n[8].Skeleton.Physics,"ps":0}],"sn":"Update","rt":$n[0].Void,"p":[$n[8].Skeleton.Physics]},{"a":2,"n":"Active","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Active","t":8,"rt":$n[0].Boolean,"fg":"Active","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"Active"},{"a":2,"n":"BendDirection","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_BendDirection","t":8,"rt":$n[0].Int32,"fg":"BendDirection","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_BendDirection","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"BendDirection"},"fn":"BendDirection"},{"a":2,"n":"Bones","t":16,"rt":$n[8].ExposedList$1(Spine.Bone),"g":{"a":2,"n":"get_Bones","t":8,"rt":$n[8].ExposedList$1(Spine.Bone),"fg":"Bones"},"fn":"Bones"},{"a":2,"n":"Compress","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Compress","t":8,"rt":$n[0].Boolean,"fg":"Compress","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_Compress","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"Compress"},"fn":"Compress"},{"a":2,"n":"Data","t":16,"rt":$n[8].IkConstraintData,"g":{"a":2,"n":"get_Data","t":8,"rt":$n[8].IkConstraintData,"fg":"Data"},"fn":"Data"},{"a":2,"n":"Mix","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Mix","t":8,"rt":$n[0].Single,"fg":"Mix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Mix","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Mix"},"fn":"Mix"},{"a":2,"n":"Softness","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Softness","t":8,"rt":$n[0].Single,"fg":"Softness","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Softness","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Softness"},"fn":"Softness"},{"a":2,"n":"Stretch","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Stretch","t":8,"rt":$n[0].Boolean,"fg":"Stretch","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_Stretch","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"Stretch"},"fn":"Stretch"},{"a":2,"n":"Target","t":16,"rt":$n[8].Bone,"g":{"a":2,"n":"get_Target","t":8,"rt":$n[8].Bone,"fg":"Target"},"s":{"a":2,"n":"set_Target","t":8,"p":[$n[8].Bone],"rt":$n[0].Void,"fs":"Target"},"fn":"Target"},{"a":4,"n":"active","t":4,"rt":$n[0].Boolean,"sn":"active","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"bendDirection","t":4,"rt":$n[0].Int32,"sn":"bendDirection","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"bones","t":4,"rt":$n[8].ExposedList$1(Spine.Bone),"sn":"bones","ro":true},{"a":4,"n":"compress","t":4,"rt":$n[0].Boolean,"sn":"compress","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"data","t":4,"rt":$n[8].IkConstraintData,"sn":"data","ro":true},{"a":4,"n":"mix","t":4,"rt":$n[0].Single,"sn":"mix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"softness","t":4,"rt":$n[0].Single,"sn":"softness","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"stretch","t":4,"rt":$n[0].Boolean,"sn":"stretch","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"target","t":4,"rt":$n[8].Bone,"sn":"target"}]}; }, $n);
    /*Spine.IkConstraint end.*/

    /*Spine.IkConstraintData start.*/
    $m("Spine.IkConstraintData", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"ctor"},{"a":2,"n":"BendDirection","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_BendDirection","t":8,"rt":$n[0].Int32,"fg":"BendDirection","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_BendDirection","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"BendDirection"},"fn":"BendDirection"},{"a":2,"n":"Bones","t":16,"rt":$n[8].ExposedList$1(Spine.BoneData),"g":{"a":2,"n":"get_Bones","t":8,"rt":$n[8].ExposedList$1(Spine.BoneData),"fg":"Bones"},"fn":"Bones"},{"a":2,"n":"Compress","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Compress","t":8,"rt":$n[0].Boolean,"fg":"Compress","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_Compress","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"Compress"},"fn":"Compress"},{"a":2,"n":"Mix","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Mix","t":8,"rt":$n[0].Single,"fg":"Mix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Mix","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Mix"},"fn":"Mix"},{"a":2,"n":"Softness","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Softness","t":8,"rt":$n[0].Single,"fg":"Softness","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Softness","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Softness"},"fn":"Softness"},{"a":2,"n":"Stretch","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Stretch","t":8,"rt":$n[0].Boolean,"fg":"Stretch","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_Stretch","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"Stretch"},"fn":"Stretch"},{"a":2,"n":"Target","t":16,"rt":$n[8].BoneData,"g":{"a":2,"n":"get_Target","t":8,"rt":$n[8].BoneData,"fg":"Target"},"s":{"a":2,"n":"set_Target","t":8,"p":[$n[8].BoneData],"rt":$n[0].Void,"fs":"Target"},"fn":"Target"},{"a":2,"n":"Uniform","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Uniform","t":8,"rt":$n[0].Boolean,"fg":"Uniform","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_Uniform","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"Uniform"},"fn":"Uniform"},{"a":4,"n":"bendDirection","t":4,"rt":$n[0].Int32,"sn":"bendDirection","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"bones","t":4,"rt":$n[8].ExposedList$1(Spine.BoneData),"sn":"bones"},{"a":4,"n":"compress","t":4,"rt":$n[0].Boolean,"sn":"compress","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"mix","t":4,"rt":$n[0].Single,"sn":"mix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"softness","t":4,"rt":$n[0].Single,"sn":"softness","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"stretch","t":4,"rt":$n[0].Boolean,"sn":"stretch","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"target","t":4,"rt":$n[8].BoneData,"sn":"target"},{"a":4,"n":"uniform","t":4,"rt":$n[0].Boolean,"sn":"uniform","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.IkConstraintData end.*/

    /*Spine.IUpdatable start.*/
    $m("Spine.IUpdatable", function () { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"Update","t":8,"pi":[{"n":"physics","pt":$n[8].Skeleton.Physics,"ps":0}],"sn":"Spine$IUpdatable$Update","rt":$n[0].Void,"p":[$n[8].Skeleton.Physics]},{"ab":true,"a":2,"n":"Active","t":16,"rt":$n[0].Boolean,"g":{"ab":true,"a":2,"n":"get_Active","t":8,"rt":$n[0].Boolean,"fg":"Spine$IUpdatable$Active","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"Spine$IUpdatable$Active"},{"a":1,"backing":true,"n":"<Active>k__BackingField","t":4,"rt":$n[0].Boolean,"sn":"Spine$IUpdatable$Active","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.IUpdatable end.*/

    /*Spine.Json start.*/
    $m("Spine.Json", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"Deserialize","is":true,"t":8,"pi":[{"n":"text","pt":$n[9].TextReader,"ps":0}],"sn":"Deserialize","rt":$n[0].Object,"p":[$n[9].TextReader]}]}; }, $n);
    /*Spine.Json end.*/

    /*Spine.MathUtils start.*/
    $m("Spine.MathUtils", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"Atan2","is":true,"t":8,"pi":[{"n":"y","pt":$n[0].Single,"ps":0},{"n":"x","pt":$n[0].Single,"ps":1}],"sn":"Atan2","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Atan2Deg","is":true,"t":8,"pi":[{"n":"y","pt":$n[0].Single,"ps":0},{"n":"x","pt":$n[0].Single,"ps":1}],"sn":"Atan2Deg","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Clamp","is":true,"t":8,"pi":[{"n":"value","pt":$n[0].Single,"ps":0},{"n":"min","pt":$n[0].Single,"ps":1},{"n":"max","pt":$n[0].Single,"ps":2}],"sn":"Clamp","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Cos","is":true,"t":8,"pi":[{"n":"radians","pt":$n[0].Single,"ps":0}],"sn":"Cos","rt":$n[0].Single,"p":[$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"CosDeg","is":true,"t":8,"pi":[{"n":"degrees","pt":$n[0].Single,"ps":0}],"sn":"CosDeg","rt":$n[0].Single,"p":[$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"RandomTriangle","is":true,"t":8,"pi":[{"n":"min","pt":$n[0].Single,"ps":0},{"n":"max","pt":$n[0].Single,"ps":1}],"sn":"RandomTriangle","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"RandomTriangle","is":true,"t":8,"pi":[{"n":"min","pt":$n[0].Single,"ps":0},{"n":"max","pt":$n[0].Single,"ps":1},{"n":"mode","pt":$n[0].Single,"ps":2}],"sn":"RandomTriangle$1","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Sin","is":true,"t":8,"pi":[{"n":"radians","pt":$n[0].Single,"ps":0}],"sn":"Sin","rt":$n[0].Single,"p":[$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"SinDeg","is":true,"t":8,"pi":[{"n":"degrees","pt":$n[0].Single,"ps":0}],"sn":"SinDeg","rt":$n[0].Single,"p":[$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"DegRad","is":true,"t":4,"rt":$n[0].Single,"sn":"DegRad","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"InvPI2","is":true,"t":4,"rt":$n[0].Single,"sn":"InvPI2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"PI","is":true,"t":4,"rt":$n[0].Single,"sn":"PI","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"PI2","is":true,"t":4,"rt":$n[0].Single,"sn":"PI2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"RadDeg","is":true,"t":4,"rt":$n[0].Single,"sn":"RadDeg","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"random","is":true,"t":4,"rt":$n[0].Random,"sn":"random"}]}; }, $n);
    /*Spine.MathUtils end.*/

    /*Spine.IInterpolation start.*/
    $m("Spine.IInterpolation", function () { return {"att":1048705,"a":2,"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ab":true,"a":3,"n":"Apply","t":8,"pi":[{"n":"a","pt":$n[0].Single,"ps":0}],"sn":"Apply$1","rt":$n[0].Single,"p":[$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Apply","t":8,"pi":[{"n":"start","pt":$n[0].Single,"ps":0},{"n":"end","pt":$n[0].Single,"ps":1},{"n":"a","pt":$n[0].Single,"ps":2}],"sn":"Apply","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Pow2","is":true,"t":4,"rt":$n[8].IInterpolation,"sn":"Pow2"},{"a":2,"n":"Pow2Out","is":true,"t":4,"rt":$n[8].IInterpolation,"sn":"Pow2Out"}]}; }, $n);
    /*Spine.IInterpolation end.*/

    /*Spine.Pow start.*/
    $m("Spine.Pow", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Single],"pi":[{"n":"power","pt":$n[0].Single,"ps":0}],"sn":"ctor"},{"ov":true,"a":3,"n":"Apply","t":8,"pi":[{"n":"a","pt":$n[0].Single,"ps":0}],"sn":"Apply$1","rt":$n[0].Single,"p":[$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Power","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Power","t":8,"rt":$n[0].Single,"fg":"Power","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Power","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Power"},"fn":"Power"},{"a":1,"backing":true,"n":"<Power>k__BackingField","t":4,"rt":$n[0].Single,"sn":"Power","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.Pow end.*/

    /*Spine.PowOut start.*/
    $m("Spine.PowOut", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Single],"pi":[{"n":"power","pt":$n[0].Single,"ps":0}],"sn":"ctor"},{"ov":true,"a":3,"n":"Apply","t":8,"pi":[{"n":"a","pt":$n[0].Single,"ps":0}],"sn":"Apply$1","rt":$n[0].Single,"p":[$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.PowOut end.*/

    /*Spine.PathConstraint start.*/
    $m("Spine.PathConstraint", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[8].PathConstraint,$n[8].Skeleton],"pi":[{"n":"constraint","pt":$n[8].PathConstraint,"ps":0},{"n":"skeleton","pt":$n[8].Skeleton,"ps":1}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[8].PathConstraintData,$n[8].Skeleton],"pi":[{"n":"data","pt":$n[8].PathConstraintData,"ps":0},{"n":"skeleton","pt":$n[8].Skeleton,"ps":1}],"sn":"$ctor1"},{"a":1,"n":"AddAfterPosition","is":true,"t":8,"pi":[{"n":"p","pt":$n[0].Single,"ps":0},{"n":"temp","pt":$n[0].Array.type(System.Single),"ps":1},{"n":"i","pt":$n[0].Int32,"ps":2},{"n":"output","pt":$n[0].Array.type(System.Single),"ps":3},{"n":"o","pt":$n[0].Int32,"ps":4}],"sn":"AddAfterPosition","rt":$n[0].Void,"p":[$n[0].Single,$n[0].Array.type(System.Single),$n[0].Int32,$n[0].Array.type(System.Single),$n[0].Int32]},{"a":1,"n":"AddBeforePosition","is":true,"t":8,"pi":[{"n":"p","pt":$n[0].Single,"ps":0},{"n":"temp","pt":$n[0].Array.type(System.Single),"ps":1},{"n":"i","pt":$n[0].Int32,"ps":2},{"n":"output","pt":$n[0].Array.type(System.Single),"ps":3},{"n":"o","pt":$n[0].Int32,"ps":4}],"sn":"AddBeforePosition","rt":$n[0].Void,"p":[$n[0].Single,$n[0].Array.type(System.Single),$n[0].Int32,$n[0].Array.type(System.Single),$n[0].Int32]},{"a":1,"n":"AddCurvePosition","is":true,"t":8,"pi":[{"n":"p","pt":$n[0].Single,"ps":0},{"n":"x1","pt":$n[0].Single,"ps":1},{"n":"y1","pt":$n[0].Single,"ps":2},{"n":"cx1","pt":$n[0].Single,"ps":3},{"n":"cy1","pt":$n[0].Single,"ps":4},{"n":"cx2","pt":$n[0].Single,"ps":5},{"n":"cy2","pt":$n[0].Single,"ps":6},{"n":"x2","pt":$n[0].Single,"ps":7},{"n":"y2","pt":$n[0].Single,"ps":8},{"n":"output","pt":$n[0].Array.type(System.Single),"ps":9},{"n":"o","pt":$n[0].Int32,"ps":10},{"n":"tangents","pt":$n[0].Boolean,"ps":11}],"sn":"AddCurvePosition","rt":$n[0].Void,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Array.type(System.Single),$n[0].Int32,$n[0].Boolean]},{"a":2,"n":"ArraysFill","is":true,"t":8,"pi":[{"n":"a","pt":$n[0].Array.type(System.Single),"ps":0},{"n":"fromIndex","pt":$n[0].Int32,"ps":1},{"n":"toIndex","pt":$n[0].Int32,"ps":2},{"n":"val","pt":$n[0].Single,"ps":3}],"sn":"ArraysFill","rt":$n[0].Void,"p":[$n[0].Array.type(System.Single),$n[0].Int32,$n[0].Int32,$n[0].Single]},{"a":1,"n":"ComputeWorldPositions","t":8,"pi":[{"n":"path","pt":$n[8].PathAttachment,"ps":0},{"n":"spacesCount","pt":$n[0].Int32,"ps":1},{"n":"tangents","pt":$n[0].Boolean,"ps":2}],"sn":"ComputeWorldPositions","rt":$n[0].Array.type(System.Single),"p":[$n[8].PathAttachment,$n[0].Int32,$n[0].Boolean]},{"a":2,"n":"SetToSetupPose","t":8,"sn":"SetToSetupPose","rt":$n[0].Void},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"Update","t":8,"pi":[{"n":"physics","pt":$n[8].Skeleton.Physics,"ps":0}],"sn":"Update","rt":$n[0].Void,"p":[$n[8].Skeleton.Physics]},{"a":2,"n":"Active","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Active","t":8,"rt":$n[0].Boolean,"fg":"Active","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"Active"},{"a":2,"n":"Bones","t":16,"rt":$n[8].ExposedList$1(Spine.Bone),"g":{"a":2,"n":"get_Bones","t":8,"rt":$n[8].ExposedList$1(Spine.Bone),"fg":"Bones"},"fn":"Bones"},{"a":2,"n":"Data","t":16,"rt":$n[8].PathConstraintData,"g":{"a":2,"n":"get_Data","t":8,"rt":$n[8].PathConstraintData,"fg":"Data"},"fn":"Data"},{"a":2,"n":"MixRotate","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MixRotate","t":8,"rt":$n[0].Single,"fg":"MixRotate","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MixRotate","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MixRotate"},"fn":"MixRotate"},{"a":2,"n":"MixX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MixX","t":8,"rt":$n[0].Single,"fg":"MixX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MixX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MixX"},"fn":"MixX"},{"a":2,"n":"MixY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MixY","t":8,"rt":$n[0].Single,"fg":"MixY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MixY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MixY"},"fn":"MixY"},{"a":2,"n":"Position","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Position","t":8,"rt":$n[0].Single,"fg":"Position","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Position","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Position"},"fn":"Position"},{"a":2,"n":"Spacing","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Spacing","t":8,"rt":$n[0].Single,"fg":"Spacing","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Spacing","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Spacing"},"fn":"Spacing"},{"a":2,"n":"Target","t":16,"rt":$n[8].Slot,"g":{"a":2,"n":"get_Target","t":8,"rt":$n[8].Slot,"fg":"Target"},"s":{"a":2,"n":"set_Target","t":8,"p":[$n[8].Slot],"rt":$n[0].Void,"fs":"Target"},"fn":"Target"},{"a":1,"n":"AFTER","is":true,"t":4,"rt":$n[0].Int32,"sn":"AFTER","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"BEFORE","is":true,"t":4,"rt":$n[0].Int32,"sn":"BEFORE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"Epsilon","is":true,"t":4,"rt":$n[0].Single,"sn":"Epsilon","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"NONE","is":true,"t":4,"rt":$n[0].Int32,"sn":"NONE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"active","t":4,"rt":$n[0].Boolean,"sn":"active","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"bones","t":4,"rt":$n[8].ExposedList$1(Spine.Bone),"sn":"bones","ro":true},{"a":4,"n":"curves","t":4,"rt":$n[8].ExposedList$1(System.Single),"sn":"curves","ro":true},{"a":4,"n":"data","t":4,"rt":$n[8].PathConstraintData,"sn":"data","ro":true},{"a":4,"n":"lengths","t":4,"rt":$n[8].ExposedList$1(System.Single),"sn":"lengths","ro":true},{"a":4,"n":"mixRotate","t":4,"rt":$n[0].Single,"sn":"mixRotate","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"mixX","t":4,"rt":$n[0].Single,"sn":"mixX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"mixY","t":4,"rt":$n[0].Single,"sn":"mixY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"position","t":4,"rt":$n[0].Single,"sn":"position","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"positions","t":4,"rt":$n[8].ExposedList$1(System.Single),"sn":"positions","ro":true},{"a":4,"n":"segments","t":4,"rt":$n[0].Array.type(System.Single),"sn":"segments","ro":true},{"a":4,"n":"spaces","t":4,"rt":$n[8].ExposedList$1(System.Single),"sn":"spaces","ro":true},{"a":4,"n":"spacing","t":4,"rt":$n[0].Single,"sn":"spacing","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"target","t":4,"rt":$n[8].Slot,"sn":"target"},{"a":4,"n":"world","t":4,"rt":$n[8].ExposedList$1(System.Single),"sn":"world","ro":true}]}; }, $n);
    /*Spine.PathConstraint end.*/

    /*Spine.PathConstraintData start.*/
    $m("Spine.PathConstraintData", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"ctor"},{"a":2,"n":"Bones","t":16,"rt":$n[8].ExposedList$1(Spine.BoneData),"g":{"a":2,"n":"get_Bones","t":8,"rt":$n[8].ExposedList$1(Spine.BoneData),"fg":"Bones"},"fn":"Bones"},{"a":2,"n":"MixX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MixX","t":8,"rt":$n[0].Single,"fg":"MixX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MixX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MixX"},"fn":"MixX"},{"a":2,"n":"MixY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MixY","t":8,"rt":$n[0].Single,"fg":"MixY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MixY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MixY"},"fn":"MixY"},{"a":2,"n":"OffsetRotation","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_OffsetRotation","t":8,"rt":$n[0].Single,"fg":"OffsetRotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_OffsetRotation","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"OffsetRotation"},"fn":"OffsetRotation"},{"a":2,"n":"Position","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Position","t":8,"rt":$n[0].Single,"fg":"Position","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Position","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Position"},"fn":"Position"},{"a":2,"n":"PositionMode","t":16,"rt":$n[8].PositionMode,"g":{"a":2,"n":"get_PositionMode","t":8,"rt":$n[8].PositionMode,"fg":"PositionMode","box":function ($v) { return Bridge.box($v, Spine.PositionMode, System.Enum.toStringFn(Spine.PositionMode));}},"s":{"a":2,"n":"set_PositionMode","t":8,"p":[$n[8].PositionMode],"rt":$n[0].Void,"fs":"PositionMode"},"fn":"PositionMode"},{"a":2,"n":"RotateMix","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_RotateMix","t":8,"rt":$n[0].Single,"fg":"RotateMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_RotateMix","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"RotateMix"},"fn":"RotateMix"},{"a":2,"n":"RotateMode","t":16,"rt":$n[8].RotateMode,"g":{"a":2,"n":"get_RotateMode","t":8,"rt":$n[8].RotateMode,"fg":"RotateMode","box":function ($v) { return Bridge.box($v, Spine.RotateMode, System.Enum.toStringFn(Spine.RotateMode));}},"s":{"a":2,"n":"set_RotateMode","t":8,"p":[$n[8].RotateMode],"rt":$n[0].Void,"fs":"RotateMode"},"fn":"RotateMode"},{"a":2,"n":"Spacing","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Spacing","t":8,"rt":$n[0].Single,"fg":"Spacing","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Spacing","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Spacing"},"fn":"Spacing"},{"a":2,"n":"SpacingMode","t":16,"rt":$n[8].SpacingMode,"g":{"a":2,"n":"get_SpacingMode","t":8,"rt":$n[8].SpacingMode,"fg":"SpacingMode","box":function ($v) { return Bridge.box($v, Spine.SpacingMode, System.Enum.toStringFn(Spine.SpacingMode));}},"s":{"a":2,"n":"set_SpacingMode","t":8,"p":[$n[8].SpacingMode],"rt":$n[0].Void,"fs":"SpacingMode"},"fn":"SpacingMode"},{"a":2,"n":"Target","t":16,"rt":$n[8].SlotData,"g":{"a":2,"n":"get_Target","t":8,"rt":$n[8].SlotData,"fg":"Target"},"s":{"a":2,"n":"set_Target","t":8,"p":[$n[8].SlotData],"rt":$n[0].Void,"fs":"Target"},"fn":"Target"},{"a":4,"n":"bones","t":4,"rt":$n[8].ExposedList$1(Spine.BoneData),"sn":"bones"},{"a":4,"n":"mixRotate","t":4,"rt":$n[0].Single,"sn":"mixRotate","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"mixX","t":4,"rt":$n[0].Single,"sn":"mixX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"mixY","t":4,"rt":$n[0].Single,"sn":"mixY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"offsetRotation","t":4,"rt":$n[0].Single,"sn":"offsetRotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"position","t":4,"rt":$n[0].Single,"sn":"position","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"positionMode","t":4,"rt":$n[8].PositionMode,"sn":"positionMode","box":function ($v) { return Bridge.box($v, Spine.PositionMode, System.Enum.toStringFn(Spine.PositionMode));}},{"a":4,"n":"rotateMode","t":4,"rt":$n[8].RotateMode,"sn":"rotateMode","box":function ($v) { return Bridge.box($v, Spine.RotateMode, System.Enum.toStringFn(Spine.RotateMode));}},{"a":4,"n":"spacing","t":4,"rt":$n[0].Single,"sn":"spacing","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"spacingMode","t":4,"rt":$n[8].SpacingMode,"sn":"spacingMode","box":function ($v) { return Bridge.box($v, Spine.SpacingMode, System.Enum.toStringFn(Spine.SpacingMode));}},{"a":4,"n":"target","t":4,"rt":$n[8].SlotData,"sn":"target"}]}; }, $n);
    /*Spine.PathConstraintData end.*/

    /*Spine.PositionMode start.*/
    $m("Spine.PositionMode", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Fixed","is":true,"t":4,"rt":$n[8].PositionMode,"sn":"Fixed","box":function ($v) { return Bridge.box($v, Spine.PositionMode, System.Enum.toStringFn(Spine.PositionMode));}},{"a":2,"n":"Percent","is":true,"t":4,"rt":$n[8].PositionMode,"sn":"Percent","box":function ($v) { return Bridge.box($v, Spine.PositionMode, System.Enum.toStringFn(Spine.PositionMode));}}]}; }, $n);
    /*Spine.PositionMode end.*/

    /*Spine.SpacingMode start.*/
    $m("Spine.SpacingMode", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Fixed","is":true,"t":4,"rt":$n[8].SpacingMode,"sn":"Fixed","box":function ($v) { return Bridge.box($v, Spine.SpacingMode, System.Enum.toStringFn(Spine.SpacingMode));}},{"a":2,"n":"Length","is":true,"t":4,"rt":$n[8].SpacingMode,"sn":"Length","box":function ($v) { return Bridge.box($v, Spine.SpacingMode, System.Enum.toStringFn(Spine.SpacingMode));}},{"a":2,"n":"Percent","is":true,"t":4,"rt":$n[8].SpacingMode,"sn":"Percent","box":function ($v) { return Bridge.box($v, Spine.SpacingMode, System.Enum.toStringFn(Spine.SpacingMode));}},{"a":2,"n":"Proportional","is":true,"t":4,"rt":$n[8].SpacingMode,"sn":"Proportional","box":function ($v) { return Bridge.box($v, Spine.SpacingMode, System.Enum.toStringFn(Spine.SpacingMode));}}]}; }, $n);
    /*Spine.SpacingMode end.*/

    /*Spine.RotateMode start.*/
    $m("Spine.RotateMode", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Chain","is":true,"t":4,"rt":$n[8].RotateMode,"sn":"Chain","box":function ($v) { return Bridge.box($v, Spine.RotateMode, System.Enum.toStringFn(Spine.RotateMode));}},{"a":2,"n":"ChainScale","is":true,"t":4,"rt":$n[8].RotateMode,"sn":"ChainScale","box":function ($v) { return Bridge.box($v, Spine.RotateMode, System.Enum.toStringFn(Spine.RotateMode));}},{"a":2,"n":"Tangent","is":true,"t":4,"rt":$n[8].RotateMode,"sn":"Tangent","box":function ($v) { return Bridge.box($v, Spine.RotateMode, System.Enum.toStringFn(Spine.RotateMode));}}]}; }, $n);
    /*Spine.RotateMode end.*/

    /*Spine.PhysicsConstraint start.*/
    $m("Spine.PhysicsConstraint", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[8].PhysicsConstraint,$n[8].Skeleton],"pi":[{"n":"constraint","pt":$n[8].PhysicsConstraint,"ps":0},{"n":"skeleton","pt":$n[8].Skeleton,"ps":1}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[8].PhysicsConstraintData,$n[8].Skeleton],"pi":[{"n":"data","pt":$n[8].PhysicsConstraintData,"ps":0},{"n":"skeleton","pt":$n[8].Skeleton,"ps":1}],"sn":"$ctor1"},{"a":2,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"a":2,"n":"Rotate","t":8,"pi":[{"n":"x","pt":$n[0].Single,"ps":0},{"n":"y","pt":$n[0].Single,"ps":1},{"n":"degrees","pt":$n[0].Single,"ps":2}],"sn":"Rotate","rt":$n[0].Void,"p":[$n[0].Single,$n[0].Single,$n[0].Single]},{"a":2,"n":"SetToSetupPose","t":8,"sn":"SetToSetupPose","rt":$n[0].Void},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"Translate","t":8,"pi":[{"n":"x","pt":$n[0].Single,"ps":0},{"n":"y","pt":$n[0].Single,"ps":1}],"sn":"Translate","rt":$n[0].Void,"p":[$n[0].Single,$n[0].Single]},{"a":2,"n":"Update","t":8,"pi":[{"n":"physics","pt":$n[8].Skeleton.Physics,"ps":0}],"sn":"Update","rt":$n[0].Void,"p":[$n[8].Skeleton.Physics]},{"a":2,"n":"getData","t":8,"sn":"getData","rt":$n[8].PhysicsConstraintData},{"a":2,"n":"Active","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Active","t":8,"rt":$n[0].Boolean,"fg":"Active","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"Active"},{"a":2,"n":"Bone","t":16,"rt":$n[8].Bone,"g":{"a":2,"n":"get_Bone","t":8,"rt":$n[8].Bone,"fg":"Bone"},"s":{"a":2,"n":"set_Bone","t":8,"p":[$n[8].Bone],"rt":$n[0].Void,"fs":"Bone"},"fn":"Bone"},{"a":2,"n":"Damping","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Damping","t":8,"rt":$n[0].Single,"fg":"Damping","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Damping","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Damping"},"fn":"Damping"},{"a":2,"n":"Data","t":16,"rt":$n[8].PhysicsConstraintData,"g":{"a":2,"n":"get_Data","t":8,"rt":$n[8].PhysicsConstraintData,"fg":"Data"},"fn":"Data"},{"a":2,"n":"Gravity","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Gravity","t":8,"rt":$n[0].Single,"fg":"Gravity","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Gravity","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Gravity"},"fn":"Gravity"},{"a":2,"n":"Inertia","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Inertia","t":8,"rt":$n[0].Single,"fg":"Inertia","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Inertia","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Inertia"},"fn":"Inertia"},{"a":2,"n":"MassInverse","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MassInverse","t":8,"rt":$n[0].Single,"fg":"MassInverse","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MassInverse","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MassInverse"},"fn":"MassInverse"},{"a":2,"n":"Mix","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Mix","t":8,"rt":$n[0].Single,"fg":"Mix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Mix","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Mix"},"fn":"Mix"},{"a":2,"n":"Strength","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Strength","t":8,"rt":$n[0].Single,"fg":"Strength","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Strength","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Strength"},"fn":"Strength"},{"a":2,"n":"Wind","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Wind","t":8,"rt":$n[0].Single,"fg":"Wind","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Wind","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Wind"},"fn":"Wind"},{"a":4,"n":"active","t":4,"rt":$n[0].Boolean,"sn":"active","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"bone","t":4,"rt":$n[8].Bone,"sn":"bone"},{"a":1,"n":"cx","t":4,"rt":$n[0].Single,"sn":"cx","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"cy","t":4,"rt":$n[0].Single,"sn":"cy","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"damping","t":4,"rt":$n[0].Single,"sn":"damping","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"data","t":4,"rt":$n[8].PhysicsConstraintData,"sn":"data","ro":true},{"a":4,"n":"gravity","t":4,"rt":$n[0].Single,"sn":"gravity","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"inertia","t":4,"rt":$n[0].Single,"sn":"inertia","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"lastTime","t":4,"rt":$n[0].Single,"sn":"lastTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"massInverse","t":4,"rt":$n[0].Single,"sn":"massInverse","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"mix","t":4,"rt":$n[0].Single,"sn":"mix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"remaining","t":4,"rt":$n[0].Single,"sn":"remaining","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"reset","t":4,"rt":$n[0].Boolean,"sn":"reset","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"rotateOffset","t":4,"rt":$n[0].Single,"sn":"rotateOffset","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"rotateVelocity","t":4,"rt":$n[0].Single,"sn":"rotateVelocity","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"scaleOffset","t":4,"rt":$n[0].Single,"sn":"scaleOffset","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"scaleVelocity","t":4,"rt":$n[0].Single,"sn":"scaleVelocity","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"skeleton","t":4,"rt":$n[8].Skeleton,"sn":"skeleton","ro":true},{"a":4,"n":"strength","t":4,"rt":$n[0].Single,"sn":"strength","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"tx","t":4,"rt":$n[0].Single,"sn":"tx","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"ty","t":4,"rt":$n[0].Single,"sn":"ty","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"ux","t":4,"rt":$n[0].Single,"sn":"ux","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"uy","t":4,"rt":$n[0].Single,"sn":"uy","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"wind","t":4,"rt":$n[0].Single,"sn":"wind","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"xOffset","t":4,"rt":$n[0].Single,"sn":"xOffset","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"xVelocity","t":4,"rt":$n[0].Single,"sn":"xVelocity","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"yOffset","t":4,"rt":$n[0].Single,"sn":"yOffset","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"yVelocity","t":4,"rt":$n[0].Single,"sn":"yVelocity","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.PhysicsConstraint end.*/

    /*Spine.PhysicsConstraintData start.*/
    $m("Spine.PhysicsConstraintData", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"ctor"},{"a":2,"n":"Bone","t":16,"rt":$n[8].BoneData,"g":{"a":2,"n":"get_Bone","t":8,"rt":$n[8].BoneData,"fg":"Bone"},"fn":"Bone"},{"a":2,"n":"Damping","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Damping","t":8,"rt":$n[0].Single,"fg":"Damping","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Damping","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Damping"},"fn":"Damping"},{"a":2,"n":"DampingGlobal","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_DampingGlobal","t":8,"rt":$n[0].Boolean,"fg":"DampingGlobal","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_DampingGlobal","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"DampingGlobal"},"fn":"DampingGlobal"},{"a":2,"n":"Gravity","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Gravity","t":8,"rt":$n[0].Single,"fg":"Gravity","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Gravity","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Gravity"},"fn":"Gravity"},{"a":2,"n":"GravityGlobal","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_GravityGlobal","t":8,"rt":$n[0].Boolean,"fg":"GravityGlobal","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_GravityGlobal","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"GravityGlobal"},"fn":"GravityGlobal"},{"a":2,"n":"Inertia","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Inertia","t":8,"rt":$n[0].Single,"fg":"Inertia","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Inertia","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Inertia"},"fn":"Inertia"},{"a":2,"n":"InertiaGlobal","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_InertiaGlobal","t":8,"rt":$n[0].Boolean,"fg":"InertiaGlobal","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_InertiaGlobal","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"InertiaGlobal"},"fn":"InertiaGlobal"},{"a":2,"n":"Limit","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Limit","t":8,"rt":$n[0].Single,"fg":"Limit","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Limit","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Limit"},"fn":"Limit"},{"a":2,"n":"MassGlobal","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_MassGlobal","t":8,"rt":$n[0].Boolean,"fg":"MassGlobal","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_MassGlobal","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"MassGlobal"},"fn":"MassGlobal"},{"a":2,"n":"MassInverse","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MassInverse","t":8,"rt":$n[0].Single,"fg":"MassInverse","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MassInverse","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MassInverse"},"fn":"MassInverse"},{"a":2,"n":"Mix","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Mix","t":8,"rt":$n[0].Single,"fg":"Mix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Mix","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Mix"},"fn":"Mix"},{"a":2,"n":"MixGlobal","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_MixGlobal","t":8,"rt":$n[0].Boolean,"fg":"MixGlobal","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_MixGlobal","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"MixGlobal"},"fn":"MixGlobal"},{"a":2,"n":"Rotate","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Rotate","t":8,"rt":$n[0].Single,"fg":"Rotate","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Rotate","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Rotate"},"fn":"Rotate"},{"a":2,"n":"ScaleX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ScaleX","t":8,"rt":$n[0].Single,"fg":"ScaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ScaleX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ScaleX"},"fn":"ScaleX"},{"a":2,"n":"ShearX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ShearX","t":8,"rt":$n[0].Single,"fg":"ShearX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ShearX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ShearX"},"fn":"ShearX"},{"a":2,"n":"Step","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Step","t":8,"rt":$n[0].Single,"fg":"Step","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Step","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Step"},"fn":"Step"},{"a":2,"n":"Strength","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Strength","t":8,"rt":$n[0].Single,"fg":"Strength","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Strength","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Strength"},"fn":"Strength"},{"a":2,"n":"StrengthGlobal","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_StrengthGlobal","t":8,"rt":$n[0].Boolean,"fg":"StrengthGlobal","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_StrengthGlobal","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"StrengthGlobal"},"fn":"StrengthGlobal"},{"a":2,"n":"Wind","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Wind","t":8,"rt":$n[0].Single,"fg":"Wind","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Wind","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Wind"},"fn":"Wind"},{"a":2,"n":"WindGlobal","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_WindGlobal","t":8,"rt":$n[0].Boolean,"fg":"WindGlobal","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_WindGlobal","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"WindGlobal"},"fn":"WindGlobal"},{"a":2,"n":"X","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_X","t":8,"rt":$n[0].Single,"fg":"X","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_X","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"X"},"fn":"X"},{"a":2,"n":"Y","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Y","t":8,"rt":$n[0].Single,"fg":"Y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Y","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Y"},"fn":"Y"},{"a":4,"n":"bone","t":4,"rt":$n[8].BoneData,"sn":"bone"},{"a":4,"n":"damping","t":4,"rt":$n[0].Single,"sn":"damping","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"dampingGlobal","t":4,"rt":$n[0].Boolean,"sn":"dampingGlobal","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"gravity","t":4,"rt":$n[0].Single,"sn":"gravity","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"gravityGlobal","t":4,"rt":$n[0].Boolean,"sn":"gravityGlobal","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"inertia","t":4,"rt":$n[0].Single,"sn":"inertia","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"inertiaGlobal","t":4,"rt":$n[0].Boolean,"sn":"inertiaGlobal","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"limit","t":4,"rt":$n[0].Single,"sn":"limit","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"massGlobal","t":4,"rt":$n[0].Boolean,"sn":"massGlobal","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"massInverse","t":4,"rt":$n[0].Single,"sn":"massInverse","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"mix","t":4,"rt":$n[0].Single,"sn":"mix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"mixGlobal","t":4,"rt":$n[0].Boolean,"sn":"mixGlobal","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"rotate","t":4,"rt":$n[0].Single,"sn":"rotate","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"scaleX","t":4,"rt":$n[0].Single,"sn":"scaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"shearX","t":4,"rt":$n[0].Single,"sn":"shearX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"step","t":4,"rt":$n[0].Single,"sn":"step","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"strength","t":4,"rt":$n[0].Single,"sn":"strength","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"strengthGlobal","t":4,"rt":$n[0].Boolean,"sn":"strengthGlobal","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"wind","t":4,"rt":$n[0].Single,"sn":"wind","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"windGlobal","t":4,"rt":$n[0].Boolean,"sn":"windGlobal","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"x","t":4,"rt":$n[0].Single,"sn":"x","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"y","t":4,"rt":$n[0].Single,"sn":"y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.PhysicsConstraintData end.*/

    /*Spine.Skeleton start.*/
    $m("Spine.Skeleton", function () { return {"nested":[$n[8].Skeleton.Physics],"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[8].Skeleton],"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[8].SkeletonData],"pi":[{"n":"data","pt":$n[8].SkeletonData,"ps":0}],"sn":"$ctor1"},{"a":2,"n":"FindBone","t":8,"pi":[{"n":"boneName","pt":$n[0].String,"ps":0}],"sn":"FindBone","rt":$n[8].Bone,"p":[$n[0].String]},{"a":2,"n":"FindIkConstraint","t":8,"pi":[{"n":"constraintName","pt":$n[0].String,"ps":0}],"sn":"FindIkConstraint","rt":$n[8].IkConstraint,"p":[$n[0].String]},{"a":2,"n":"FindPathConstraint","t":8,"pi":[{"n":"constraintName","pt":$n[0].String,"ps":0}],"sn":"FindPathConstraint","rt":$n[8].PathConstraint,"p":[$n[0].String]},{"a":2,"n":"FindPhysicsConstraint","t":8,"pi":[{"n":"constraintName","pt":$n[0].String,"ps":0}],"sn":"FindPhysicsConstraint","rt":$n[8].PhysicsConstraint,"p":[$n[0].String]},{"a":2,"n":"FindSlot","t":8,"pi":[{"n":"slotName","pt":$n[0].String,"ps":0}],"sn":"FindSlot","rt":$n[8].Slot,"p":[$n[0].String]},{"a":2,"n":"FindTransformConstraint","t":8,"pi":[{"n":"constraintName","pt":$n[0].String,"ps":0}],"sn":"FindTransformConstraint","rt":$n[8].TransformConstraint,"p":[$n[0].String]},{"a":2,"n":"GetAttachment","t":8,"pi":[{"n":"slotIndex","pt":$n[0].Int32,"ps":0},{"n":"attachmentName","pt":$n[0].String,"ps":1}],"sn":"GetAttachment","rt":$n[8].Attachment,"p":[$n[0].Int32,$n[0].String]},{"a":2,"n":"GetAttachment","t":8,"pi":[{"n":"slotName","pt":$n[0].String,"ps":0},{"n":"attachmentName","pt":$n[0].String,"ps":1}],"sn":"GetAttachment$1","rt":$n[8].Attachment,"p":[$n[0].String,$n[0].String]},{"a":2,"n":"GetBounds","t":8,"pi":[{"n":"x","out":true,"pt":$n[0].Single,"ps":0},{"n":"y","out":true,"pt":$n[0].Single,"ps":1},{"n":"width","out":true,"pt":$n[0].Single,"ps":2},{"n":"height","out":true,"pt":$n[0].Single,"ps":3},{"n":"vertexBuffer","ref":true,"pt":$n[0].Array.type(System.Single),"ps":4},{"n":"clipper","dv":null,"o":true,"pt":$n[8].SkeletonClipping,"ps":5}],"sn":"GetBounds","rt":$n[0].Void,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Array.type(System.Single),$n[8].SkeletonClipping]},{"a":2,"n":"PhysicsRotate","t":8,"pi":[{"n":"x","pt":$n[0].Single,"ps":0},{"n":"y","pt":$n[0].Single,"ps":1},{"n":"degrees","pt":$n[0].Single,"ps":2}],"sn":"PhysicsRotate","rt":$n[0].Void,"p":[$n[0].Single,$n[0].Single,$n[0].Single]},{"a":2,"n":"PhysicsTranslate","t":8,"pi":[{"n":"x","pt":$n[0].Single,"ps":0},{"n":"y","pt":$n[0].Single,"ps":1}],"sn":"PhysicsTranslate","rt":$n[0].Void,"p":[$n[0].Single,$n[0].Single]},{"a":2,"n":"SetAttachment","t":8,"pi":[{"n":"slotName","pt":$n[0].String,"ps":0},{"n":"attachmentName","pt":$n[0].String,"ps":1}],"sn":"SetAttachment","rt":$n[0].Void,"p":[$n[0].String,$n[0].String]},{"a":2,"n":"SetBonesToSetupPose","t":8,"sn":"SetBonesToSetupPose","rt":$n[0].Void},{"a":2,"n":"SetSkin","t":8,"pi":[{"n":"newSkin","pt":$n[8].Skin,"ps":0}],"sn":"SetSkin","rt":$n[0].Void,"p":[$n[8].Skin]},{"a":2,"n":"SetSkin","t":8,"pi":[{"n":"skinName","pt":$n[0].String,"ps":0}],"sn":"SetSkin$1","rt":$n[0].Void,"p":[$n[0].String]},{"a":2,"n":"SetSlotsToSetupPose","t":8,"sn":"SetSlotsToSetupPose","rt":$n[0].Void},{"a":2,"n":"SetToSetupPose","t":8,"sn":"SetToSetupPose","rt":$n[0].Void},{"a":1,"n":"SortBone","t":8,"pi":[{"n":"bone","pt":$n[8].Bone,"ps":0}],"sn":"SortBone","rt":$n[0].Void,"p":[$n[8].Bone]},{"a":1,"n":"SortIkConstraint","t":8,"pi":[{"n":"constraint","pt":$n[8].IkConstraint,"ps":0}],"sn":"SortIkConstraint","rt":$n[0].Void,"p":[$n[8].IkConstraint]},{"a":1,"n":"SortPathConstraint","t":8,"pi":[{"n":"constraint","pt":$n[8].PathConstraint,"ps":0}],"sn":"SortPathConstraint","rt":$n[0].Void,"p":[$n[8].PathConstraint]},{"a":1,"n":"SortPathConstraintAttachment","t":8,"pi":[{"n":"attachment","pt":$n[8].Attachment,"ps":0},{"n":"slotBone","pt":$n[8].Bone,"ps":1}],"sn":"SortPathConstraintAttachment","rt":$n[0].Void,"p":[$n[8].Attachment,$n[8].Bone]},{"a":1,"n":"SortPathConstraintAttachment","t":8,"pi":[{"n":"skin","pt":$n[8].Skin,"ps":0},{"n":"slotIndex","pt":$n[0].Int32,"ps":1},{"n":"slotBone","pt":$n[8].Bone,"ps":2}],"sn":"SortPathConstraintAttachment$1","rt":$n[0].Void,"p":[$n[8].Skin,$n[0].Int32,$n[8].Bone]},{"a":1,"n":"SortPhysicsConstraint","t":8,"pi":[{"n":"constraint","pt":$n[8].PhysicsConstraint,"ps":0}],"sn":"SortPhysicsConstraint","rt":$n[0].Void,"p":[$n[8].PhysicsConstraint]},{"a":1,"n":"SortReset","is":true,"t":8,"pi":[{"n":"bones","pt":$n[8].ExposedList$1(Spine.Bone),"ps":0}],"sn":"SortReset","rt":$n[0].Void,"p":[$n[8].ExposedList$1(Spine.Bone)]},{"a":1,"n":"SortTransformConstraint","t":8,"pi":[{"n":"constraint","pt":$n[8].TransformConstraint,"ps":0}],"sn":"SortTransformConstraint","rt":$n[0].Void,"p":[$n[8].TransformConstraint]},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"Update","t":8,"pi":[{"n":"delta","pt":$n[0].Single,"ps":0}],"sn":"Update","rt":$n[0].Void,"p":[$n[0].Single]},{"a":2,"n":"UpdateCache","t":8,"sn":"UpdateCache","rt":$n[0].Void},{"a":2,"n":"UpdateWorldTransform","t":8,"pi":[{"n":"physics","pt":$n[8].Skeleton.Physics,"ps":0}],"sn":"UpdateWorldTransform","rt":$n[0].Void,"p":[$n[8].Skeleton.Physics]},{"a":2,"n":"UpdateWorldTransform","t":8,"pi":[{"n":"physics","pt":$n[8].Skeleton.Physics,"ps":0},{"n":"parent","pt":$n[8].Bone,"ps":1}],"sn":"UpdateWorldTransform$1","rt":$n[0].Void,"p":[$n[8].Skeleton.Physics,$n[8].Bone]},{"a":2,"n":"A","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_A","t":8,"rt":$n[0].Single,"fg":"A","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_A","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"A"},"fn":"A"},{"a":2,"n":"B","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_B","t":8,"rt":$n[0].Single,"fg":"B","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_B","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"B"},"fn":"B"},{"a":2,"n":"Bones","t":16,"rt":$n[8].ExposedList$1(Spine.Bone),"g":{"a":2,"n":"get_Bones","t":8,"rt":$n[8].ExposedList$1(Spine.Bone),"fg":"Bones"},"fn":"Bones"},{"a":2,"n":"Data","t":16,"rt":$n[8].SkeletonData,"g":{"a":2,"n":"get_Data","t":8,"rt":$n[8].SkeletonData,"fg":"Data"},"fn":"Data"},{"a":2,"n":"DrawOrder","t":16,"rt":$n[8].ExposedList$1(Spine.Slot),"g":{"a":2,"n":"get_DrawOrder","t":8,"rt":$n[8].ExposedList$1(Spine.Slot),"fg":"DrawOrder"},"fn":"DrawOrder"},{"a":2,"n":"FlipX","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_FlipX","t":8,"rt":$n[0].Boolean,"fg":"FlipX","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_FlipX","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"FlipX"},"fn":"FlipX"},{"a":2,"n":"FlipY","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_FlipY","t":8,"rt":$n[0].Boolean,"fg":"FlipY","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_FlipY","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"FlipY"},"fn":"FlipY"},{"a":2,"n":"G","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_G","t":8,"rt":$n[0].Single,"fg":"G","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_G","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"G"},"fn":"G"},{"a":2,"n":"IkConstraints","t":16,"rt":$n[8].ExposedList$1(Spine.IkConstraint),"g":{"a":2,"n":"get_IkConstraints","t":8,"rt":$n[8].ExposedList$1(Spine.IkConstraint),"fg":"IkConstraints"},"fn":"IkConstraints"},{"a":2,"n":"PathConstraints","t":16,"rt":$n[8].ExposedList$1(Spine.PathConstraint),"g":{"a":2,"n":"get_PathConstraints","t":8,"rt":$n[8].ExposedList$1(Spine.PathConstraint),"fg":"PathConstraints"},"fn":"PathConstraints"},{"a":2,"n":"PhysicsConstraints","t":16,"rt":$n[8].ExposedList$1(Spine.PhysicsConstraint),"g":{"a":2,"n":"get_PhysicsConstraints","t":8,"rt":$n[8].ExposedList$1(Spine.PhysicsConstraint),"fg":"PhysicsConstraints"},"fn":"PhysicsConstraints"},{"a":2,"n":"R","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_R","t":8,"rt":$n[0].Single,"fg":"R","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_R","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"R"},"fn":"R"},{"a":2,"n":"RootBone","t":16,"rt":$n[8].Bone,"g":{"a":2,"n":"get_RootBone","t":8,"rt":$n[8].Bone,"fg":"RootBone"},"fn":"RootBone"},{"a":2,"n":"ScaleX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ScaleX","t":8,"rt":$n[0].Single,"fg":"ScaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ScaleX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ScaleX"},"fn":"ScaleX"},{"a":2,"n":"ScaleY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ScaleY","t":8,"rt":$n[0].Single,"fg":"ScaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ScaleY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ScaleY"},"fn":"ScaleY"},{"a":2,"n":"Skin","t":16,"rt":$n[8].Skin,"g":{"a":2,"n":"get_Skin","t":8,"rt":$n[8].Skin,"fg":"Skin"},"s":{"a":2,"n":"set_Skin","t":8,"p":[$n[8].Skin],"rt":$n[0].Void,"fs":"Skin"},"fn":"Skin"},{"a":2,"n":"Slots","t":16,"rt":$n[8].ExposedList$1(Spine.Slot),"g":{"a":2,"n":"get_Slots","t":8,"rt":$n[8].ExposedList$1(Spine.Slot),"fg":"Slots"},"fn":"Slots"},{"a":2,"n":"Time","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Time","t":8,"rt":$n[0].Single,"fg":"Time","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Time","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Time"},"fn":"Time"},{"a":2,"n":"TransformConstraints","t":16,"rt":$n[8].ExposedList$1(Spine.TransformConstraint),"g":{"a":2,"n":"get_TransformConstraints","t":8,"rt":$n[8].ExposedList$1(Spine.TransformConstraint),"fg":"TransformConstraints"},"fn":"TransformConstraints"},{"a":2,"n":"UpdateCacheList","t":16,"rt":$n[8].ExposedList$1(Spine.IUpdatable),"g":{"a":2,"n":"get_UpdateCacheList","t":8,"rt":$n[8].ExposedList$1(Spine.IUpdatable),"fg":"UpdateCacheList"},"fn":"UpdateCacheList"},{"a":2,"n":"X","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_X","t":8,"rt":$n[0].Single,"fg":"X","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_X","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"X"},"fn":"X"},{"a":2,"n":"Y","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Y","t":8,"rt":$n[0].Single,"fg":"Y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Y","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Y"},"fn":"Y"},{"a":4,"n":"a","t":4,"rt":$n[0].Single,"sn":"a","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"b","t":4,"rt":$n[0].Single,"sn":"b","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"bones","t":4,"rt":$n[8].ExposedList$1(Spine.Bone),"sn":"bones"},{"a":4,"n":"data","t":4,"rt":$n[8].SkeletonData,"sn":"data"},{"a":4,"n":"drawOrder","t":4,"rt":$n[8].ExposedList$1(Spine.Slot),"sn":"drawOrder"},{"a":4,"n":"g","t":4,"rt":$n[0].Single,"sn":"g","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"ikConstraints","t":4,"rt":$n[8].ExposedList$1(Spine.IkConstraint),"sn":"ikConstraints"},{"a":4,"n":"pathConstraints","t":4,"rt":$n[8].ExposedList$1(Spine.PathConstraint),"sn":"pathConstraints"},{"a":4,"n":"physicsConstraints","t":4,"rt":$n[8].ExposedList$1(Spine.PhysicsConstraint),"sn":"physicsConstraints"},{"a":1,"n":"quadTriangles","is":true,"t":4,"rt":$n[0].Array.type(System.Int32),"sn":"quadTriangles","ro":true},{"a":4,"n":"r","t":4,"rt":$n[0].Single,"sn":"r","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"scaleX","t":4,"rt":$n[0].Single,"sn":"scaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"scaleY","t":4,"rt":$n[0].Single,"sn":"scaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"skin","t":4,"rt":$n[8].Skin,"sn":"skin"},{"a":4,"n":"slots","t":4,"rt":$n[8].ExposedList$1(Spine.Slot),"sn":"slots"},{"a":4,"n":"time","t":4,"rt":$n[0].Single,"sn":"time","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"transformConstraints","t":4,"rt":$n[8].ExposedList$1(Spine.TransformConstraint),"sn":"transformConstraints"},{"a":4,"n":"updateCache","t":4,"rt":$n[8].ExposedList$1(Spine.IUpdatable),"sn":"updateCache"},{"a":4,"n":"x","t":4,"rt":$n[0].Single,"sn":"x","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"y","t":4,"rt":$n[0].Single,"sn":"y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.Skeleton end.*/

    /*Spine.Skeleton+Physics start.*/
    $m("Spine.Skeleton.Physics", function () { return {"td":$n[8].Skeleton,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"None","is":true,"t":4,"rt":$n[8].Skeleton.Physics,"sn":"None","box":function ($v) { return Bridge.box($v, Spine.Skeleton.Physics, System.Enum.toStringFn(Spine.Skeleton.Physics));}},{"a":2,"n":"Pose","is":true,"t":4,"rt":$n[8].Skeleton.Physics,"sn":"Pose","box":function ($v) { return Bridge.box($v, Spine.Skeleton.Physics, System.Enum.toStringFn(Spine.Skeleton.Physics));}},{"a":2,"n":"Reset","is":true,"t":4,"rt":$n[8].Skeleton.Physics,"sn":"Reset","box":function ($v) { return Bridge.box($v, Spine.Skeleton.Physics, System.Enum.toStringFn(Spine.Skeleton.Physics));}},{"a":2,"n":"Update","is":true,"t":4,"rt":$n[8].Skeleton.Physics,"sn":"Update","box":function ($v) { return Bridge.box($v, Spine.Skeleton.Physics, System.Enum.toStringFn(Spine.Skeleton.Physics));}}]}; }, $n);
    /*Spine.Skeleton+Physics end.*/

    /*Spine.SkeletonBinary start.*/
    $m("Spine.SkeletonBinary", function () { return {"nested":[$n[8].SkeletonBinary.Vertices,$n[8].SkeletonBinary.SkeletonInput,$n[8].SkeletonBinary.LinkedMesh],"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[System.Array.type(Spine.Atlas)],"pi":[{"n":"atlasArray","ip":true,"pt":System.Array.type(Spine.Atlas),"ps":0}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[8].AttachmentLoader],"pi":[{"n":"attachmentLoader","pt":$n[8].AttachmentLoader,"ps":0}],"sn":"$ctor1"},{"a":2,"n":"GetVersionString","is":true,"t":8,"pi":[{"n":"file","pt":$n[9].Stream,"ps":0}],"sn":"GetVersionString","rt":$n[0].String,"p":[$n[9].Stream]},{"a":1,"n":"ReadAnimation","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0},{"n":"input","pt":$n[8].SkeletonBinary.SkeletonInput,"ps":1},{"n":"skeletonData","pt":$n[8].SkeletonData,"ps":2}],"sn":"ReadAnimation","rt":$n[8].Animation,"p":[$n[0].String,$n[8].SkeletonBinary.SkeletonInput,$n[8].SkeletonData]},{"a":1,"n":"ReadAttachment","t":8,"pi":[{"n":"input","pt":$n[8].SkeletonBinary.SkeletonInput,"ps":0},{"n":"skeletonData","pt":$n[8].SkeletonData,"ps":1},{"n":"skin","pt":$n[8].Skin,"ps":2},{"n":"slotIndex","pt":$n[0].Int32,"ps":3},{"n":"attachmentName","pt":$n[0].String,"ps":4},{"n":"nonessential","pt":$n[0].Boolean,"ps":5}],"sn":"ReadAttachment","rt":$n[8].Attachment,"p":[$n[8].SkeletonBinary.SkeletonInput,$n[8].SkeletonData,$n[8].Skin,$n[0].Int32,$n[0].String,$n[0].Boolean]},{"a":1,"n":"ReadFloatArray","t":8,"pi":[{"n":"input","pt":$n[8].SkeletonBinary.SkeletonInput,"ps":0},{"n":"n","pt":$n[0].Int32,"ps":1},{"n":"scale","pt":$n[0].Single,"ps":2}],"sn":"ReadFloatArray","rt":$n[0].Array.type(System.Single),"p":[$n[8].SkeletonBinary.SkeletonInput,$n[0].Int32,$n[0].Single]},{"a":1,"n":"ReadSequence","t":8,"pi":[{"n":"input","pt":$n[8].SkeletonBinary.SkeletonInput,"ps":0}],"sn":"ReadSequence","rt":$n[8].Sequence,"p":[$n[8].SkeletonBinary.SkeletonInput]},{"a":1,"n":"ReadShortArray","t":8,"pi":[{"n":"input","pt":$n[8].SkeletonBinary.SkeletonInput,"ps":0},{"n":"n","pt":$n[0].Int32,"ps":1}],"sn":"ReadShortArray","rt":$n[0].Array.type(System.Int32),"p":[$n[8].SkeletonBinary.SkeletonInput,$n[0].Int32]},{"a":2,"n":"ReadSkeletonData","t":8,"pi":[{"n":"file","pt":$n[9].Stream,"ps":0}],"sn":"ReadSkeletonData$1","rt":$n[8].SkeletonData,"p":[$n[9].Stream]},{"ov":true,"a":2,"n":"ReadSkeletonData","t":8,"pi":[{"n":"path","pt":$n[0].String,"ps":0}],"sn":"ReadSkeletonData","rt":$n[8].SkeletonData,"p":[$n[0].String]},{"a":1,"n":"ReadSkin","t":8,"pi":[{"n":"input","pt":$n[8].SkeletonBinary.SkeletonInput,"ps":0},{"n":"skeletonData","pt":$n[8].SkeletonData,"ps":1},{"n":"defaultSkin","pt":$n[0].Boolean,"ps":2},{"n":"nonessential","pt":$n[0].Boolean,"ps":3}],"sn":"ReadSkin","rt":$n[8].Skin,"p":[$n[8].SkeletonBinary.SkeletonInput,$n[8].SkeletonData,$n[0].Boolean,$n[0].Boolean]},{"a":1,"n":"ReadTimeline","t":8,"pi":[{"n":"input","pt":$n[8].SkeletonBinary.SkeletonInput,"ps":0},{"n":"timelines","pt":$n[8].ExposedList$1(Spine.Timeline),"ps":1},{"n":"timeline","pt":$n[8].CurveTimeline1,"ps":2},{"n":"scale","pt":$n[0].Single,"ps":3}],"sn":"ReadTimeline","rt":$n[0].Void,"p":[$n[8].SkeletonBinary.SkeletonInput,$n[8].ExposedList$1(Spine.Timeline),$n[8].CurveTimeline1,$n[0].Single]},{"a":1,"n":"ReadTimeline","t":8,"pi":[{"n":"input","pt":$n[8].SkeletonBinary.SkeletonInput,"ps":0},{"n":"timelines","pt":$n[8].ExposedList$1(Spine.Timeline),"ps":1},{"n":"timeline","pt":$n[8].CurveTimeline2,"ps":2},{"n":"scale","pt":$n[0].Single,"ps":3}],"sn":"ReadTimeline$1","rt":$n[0].Void,"p":[$n[8].SkeletonBinary.SkeletonInput,$n[8].ExposedList$1(Spine.Timeline),$n[8].CurveTimeline2,$n[0].Single]},{"a":1,"n":"ReadVertices","t":8,"pi":[{"n":"input","pt":$n[8].SkeletonBinary.SkeletonInput,"ps":0},{"n":"weighted","pt":$n[0].Boolean,"ps":1}],"sn":"ReadVertices","rt":$n[8].SkeletonBinary.Vertices,"p":[$n[8].SkeletonBinary.SkeletonInput,$n[0].Boolean]},{"a":1,"n":"SetBezier","t":8,"pi":[{"n":"input","pt":$n[8].SkeletonBinary.SkeletonInput,"ps":0},{"n":"timeline","pt":$n[8].CurveTimeline,"ps":1},{"n":"bezier","pt":$n[0].Int32,"ps":2},{"n":"frame","pt":$n[0].Int32,"ps":3},{"n":"value","pt":$n[0].Int32,"ps":4},{"n":"time1","pt":$n[0].Single,"ps":5},{"n":"time2","pt":$n[0].Single,"ps":6},{"n":"value1","pt":$n[0].Single,"ps":7},{"n":"value2","pt":$n[0].Single,"ps":8},{"n":"scale","pt":$n[0].Single,"ps":9}],"sn":"SetBezier","rt":$n[0].Void,"p":[$n[8].SkeletonBinary.SkeletonInput,$n[8].CurveTimeline,$n[0].Int32,$n[0].Int32,$n[0].Int32,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single]},{"a":2,"n":"ATTACHMENT_DEFORM","is":true,"t":4,"rt":$n[0].Int32,"sn":"ATTACHMENT_DEFORM","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"ATTACHMENT_SEQUENCE","is":true,"t":4,"rt":$n[0].Int32,"sn":"ATTACHMENT_SEQUENCE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"BONE_INHERIT","is":true,"t":4,"rt":$n[0].Int32,"sn":"BONE_INHERIT","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"BONE_ROTATE","is":true,"t":4,"rt":$n[0].Int32,"sn":"BONE_ROTATE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"BONE_SCALE","is":true,"t":4,"rt":$n[0].Int32,"sn":"BONE_SCALE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"BONE_SCALEX","is":true,"t":4,"rt":$n[0].Int32,"sn":"BONE_SCALEX","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"BONE_SCALEY","is":true,"t":4,"rt":$n[0].Int32,"sn":"BONE_SCALEY","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"BONE_SHEAR","is":true,"t":4,"rt":$n[0].Int32,"sn":"BONE_SHEAR","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"BONE_SHEARX","is":true,"t":4,"rt":$n[0].Int32,"sn":"BONE_SHEARX","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"BONE_SHEARY","is":true,"t":4,"rt":$n[0].Int32,"sn":"BONE_SHEARY","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"BONE_TRANSLATE","is":true,"t":4,"rt":$n[0].Int32,"sn":"BONE_TRANSLATE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"BONE_TRANSLATEX","is":true,"t":4,"rt":$n[0].Int32,"sn":"BONE_TRANSLATEX","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"BONE_TRANSLATEY","is":true,"t":4,"rt":$n[0].Int32,"sn":"BONE_TRANSLATEY","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"CURVE_BEZIER","is":true,"t":4,"rt":$n[0].Int32,"sn":"CURVE_BEZIER","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"CURVE_LINEAR","is":true,"t":4,"rt":$n[0].Int32,"sn":"CURVE_LINEAR","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"CURVE_STEPPED","is":true,"t":4,"rt":$n[0].Int32,"sn":"CURVE_STEPPED","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"PATH_MIX","is":true,"t":4,"rt":$n[0].Int32,"sn":"PATH_MIX","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"PATH_POSITION","is":true,"t":4,"rt":$n[0].Int32,"sn":"PATH_POSITION","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"PATH_SPACING","is":true,"t":4,"rt":$n[0].Int32,"sn":"PATH_SPACING","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"PHYSICS_DAMPING","is":true,"t":4,"rt":$n[0].Int32,"sn":"PHYSICS_DAMPING","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"PHYSICS_GRAVITY","is":true,"t":4,"rt":$n[0].Int32,"sn":"PHYSICS_GRAVITY","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"PHYSICS_INERTIA","is":true,"t":4,"rt":$n[0].Int32,"sn":"PHYSICS_INERTIA","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"PHYSICS_MASS","is":true,"t":4,"rt":$n[0].Int32,"sn":"PHYSICS_MASS","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"PHYSICS_MIX","is":true,"t":4,"rt":$n[0].Int32,"sn":"PHYSICS_MIX","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"PHYSICS_RESET","is":true,"t":4,"rt":$n[0].Int32,"sn":"PHYSICS_RESET","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"PHYSICS_STRENGTH","is":true,"t":4,"rt":$n[0].Int32,"sn":"PHYSICS_STRENGTH","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"PHYSICS_WIND","is":true,"t":4,"rt":$n[0].Int32,"sn":"PHYSICS_WIND","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"SLOT_ALPHA","is":true,"t":4,"rt":$n[0].Int32,"sn":"SLOT_ALPHA","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"SLOT_ATTACHMENT","is":true,"t":4,"rt":$n[0].Int32,"sn":"SLOT_ATTACHMENT","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"SLOT_RGB","is":true,"t":4,"rt":$n[0].Int32,"sn":"SLOT_RGB","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"SLOT_RGB2","is":true,"t":4,"rt":$n[0].Int32,"sn":"SLOT_RGB2","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"SLOT_RGBA","is":true,"t":4,"rt":$n[0].Int32,"sn":"SLOT_RGBA","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"SLOT_RGBA2","is":true,"t":4,"rt":$n[0].Int32,"sn":"SLOT_RGBA2","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"linkedMeshes","t":4,"rt":$n[2].List$1(Spine.SkeletonBinary.LinkedMesh),"sn":"linkedMeshes","ro":true}]}; }, $n);
    /*Spine.SkeletonBinary end.*/

    /*Spine.SkeletonBinary+Vertices start.*/
    $m("Spine.SkeletonBinary.Vertices", function () { return {"td":$n[8].SkeletonBinary,"att":1048581,"a":4,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"bones","t":4,"rt":$n[0].Array.type(System.Int32),"sn":"bones"},{"a":2,"n":"length","t":4,"rt":$n[0].Int32,"sn":"length","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"vertices","t":4,"rt":$n[0].Array.type(System.Single),"sn":"vertices"}]}; }, $n);
    /*Spine.SkeletonBinary+Vertices end.*/

    /*Spine.SkeletonBinary+SkeletonInput start.*/
    $m("Spine.SkeletonBinary.SkeletonInput", function () { return {"td":$n[8].SkeletonBinary,"att":1048581,"a":4,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[9].Stream],"pi":[{"n":"input","pt":$n[9].Stream,"ps":0}],"sn":"ctor"},{"a":2,"n":"GetVersionString","t":8,"sn":"GetVersionString","rt":$n[0].String},{"a":2,"n":"GetVersionStringOld3X","t":8,"sn":"GetVersionStringOld3X","rt":$n[0].String},{"a":2,"n":"Read","t":8,"sn":"Read","rt":$n[0].Int32,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"ReadBoolean","t":8,"sn":"ReadBoolean","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"ReadFloat","t":8,"sn":"ReadFloat","rt":$n[0].Single,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"ReadFully","t":8,"pi":[{"n":"buffer","pt":$n[0].Array.type(System.Byte),"ps":0},{"n":"offset","pt":$n[0].Int32,"ps":1},{"n":"length","pt":$n[0].Int32,"ps":2}],"sn":"ReadFully","rt":$n[0].Void,"p":[$n[0].Array.type(System.Byte),$n[0].Int32,$n[0].Int32]},{"a":2,"n":"ReadInt","t":8,"sn":"ReadInt","rt":$n[0].Int32,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"ReadInt","t":8,"pi":[{"n":"optimizePositive","pt":$n[0].Boolean,"ps":0}],"sn":"ReadInt$1","rt":$n[0].Int32,"p":[$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"ReadLong","t":8,"sn":"ReadLong","rt":$n[0].Int64},{"a":2,"n":"ReadSByte","t":8,"sn":"ReadSByte","rt":$n[0].SByte,"box":function ($v) { return Bridge.box($v, System.SByte);}},{"a":2,"n":"ReadString","t":8,"sn":"ReadString","rt":$n[0].String},{"a":2,"n":"ReadStringRef","t":8,"sn":"ReadStringRef","rt":$n[0].String},{"a":2,"n":"ReadUByte","t":8,"sn":"ReadUByte","rt":$n[0].Byte,"box":function ($v) { return Bridge.box($v, System.Byte);}},{"a":1,"n":"bytesBigEndian","t":4,"rt":$n[0].Array.type(System.Byte),"sn":"bytesBigEndian"},{"a":1,"n":"chars","t":4,"rt":$n[0].Array.type(System.Byte),"sn":"chars"},{"a":1,"n":"input","t":4,"rt":$n[9].Stream,"sn":"input"},{"a":4,"n":"strings","t":4,"rt":$n[0].Array.type(System.String),"sn":"strings"}]}; }, $n);
    /*Spine.SkeletonBinary+SkeletonInput end.*/

    /*Spine.SkeletonBinary+LinkedMesh start.*/
    $m("Spine.SkeletonBinary.LinkedMesh", function () { return {"td":$n[8].SkeletonBinary,"att":1048579,"a":1,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[8].MeshAttachment,$n[0].Int32,$n[0].Int32,$n[0].String,$n[0].Boolean],"pi":[{"n":"mesh","pt":$n[8].MeshAttachment,"ps":0},{"n":"skinIndex","pt":$n[0].Int32,"ps":1},{"n":"slotIndex","pt":$n[0].Int32,"ps":2},{"n":"parent","pt":$n[0].String,"ps":3},{"n":"inheritTimelines","pt":$n[0].Boolean,"ps":4}],"sn":"ctor"},{"a":4,"n":"inheritTimelines","t":4,"rt":$n[0].Boolean,"sn":"inheritTimelines","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"mesh","t":4,"rt":$n[8].MeshAttachment,"sn":"mesh"},{"a":4,"n":"parent","t":4,"rt":$n[0].String,"sn":"parent"},{"a":4,"n":"skinIndex","t":4,"rt":$n[0].Int32,"sn":"skinIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"slotIndex","t":4,"rt":$n[0].Int32,"sn":"slotIndex","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.SkeletonBinary+LinkedMesh end.*/

    /*Spine.SkeletonBounds start.*/
    $m("Spine.SkeletonBounds", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"AabbCompute","t":8,"sn":"AabbCompute","rt":$n[0].Void},{"a":2,"n":"AabbContainsPoint","t":8,"pi":[{"n":"x","pt":$n[0].Single,"ps":0},{"n":"y","pt":$n[0].Single,"ps":1}],"sn":"AabbContainsPoint","rt":$n[0].Boolean,"p":[$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"AabbIntersectsSegment","t":8,"pi":[{"n":"x1","pt":$n[0].Single,"ps":0},{"n":"y1","pt":$n[0].Single,"ps":1},{"n":"x2","pt":$n[0].Single,"ps":2},{"n":"y2","pt":$n[0].Single,"ps":3}],"sn":"AabbIntersectsSegment","rt":$n[0].Boolean,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"AabbIntersectsSkeleton","t":8,"pi":[{"n":"bounds","pt":$n[8].SkeletonBounds,"ps":0}],"sn":"AabbIntersectsSkeleton","rt":$n[0].Boolean,"p":[$n[8].SkeletonBounds],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"ContainsPoint","t":8,"pi":[{"n":"x","pt":$n[0].Single,"ps":0},{"n":"y","pt":$n[0].Single,"ps":1}],"sn":"ContainsPoint","rt":$n[8].BoundingBoxAttachment,"p":[$n[0].Single,$n[0].Single]},{"a":2,"n":"ContainsPoint","t":8,"pi":[{"n":"polygon","pt":$n[8].Polygon,"ps":0},{"n":"x","pt":$n[0].Single,"ps":1},{"n":"y","pt":$n[0].Single,"ps":2}],"sn":"ContainsPoint$1","rt":$n[0].Boolean,"p":[$n[8].Polygon,$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"GetPolygon","t":8,"pi":[{"n":"attachment","pt":$n[8].BoundingBoxAttachment,"ps":0}],"sn":"GetPolygon","rt":$n[8].Polygon,"p":[$n[8].BoundingBoxAttachment]},{"a":2,"n":"IntersectsSegment","t":8,"pi":[{"n":"x1","pt":$n[0].Single,"ps":0},{"n":"y1","pt":$n[0].Single,"ps":1},{"n":"x2","pt":$n[0].Single,"ps":2},{"n":"y2","pt":$n[0].Single,"ps":3}],"sn":"IntersectsSegment","rt":$n[8].BoundingBoxAttachment,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single]},{"a":2,"n":"IntersectsSegment","t":8,"pi":[{"n":"polygon","pt":$n[8].Polygon,"ps":0},{"n":"x1","pt":$n[0].Single,"ps":1},{"n":"y1","pt":$n[0].Single,"ps":2},{"n":"x2","pt":$n[0].Single,"ps":3},{"n":"y2","pt":$n[0].Single,"ps":4}],"sn":"IntersectsSegment$1","rt":$n[0].Boolean,"p":[$n[8].Polygon,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"Update","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"updateAabb","pt":$n[0].Boolean,"ps":1}],"sn":"Update","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[0].Boolean]},{"a":2,"n":"BoundingBoxes","t":16,"rt":$n[8].ExposedList$1(Spine.BoundingBoxAttachment),"g":{"a":2,"n":"get_BoundingBoxes","t":8,"rt":$n[8].ExposedList$1(Spine.BoundingBoxAttachment),"fg":"BoundingBoxes"},"s":{"a":1,"n":"set_BoundingBoxes","t":8,"p":[$n[8].ExposedList$1(Spine.BoundingBoxAttachment)],"rt":$n[0].Void,"fs":"BoundingBoxes"},"fn":"BoundingBoxes"},{"a":2,"n":"Height","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Height","t":8,"rt":$n[0].Single,"fg":"Height","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"Height"},{"a":2,"n":"MaxX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MaxX","t":8,"rt":$n[0].Single,"fg":"MaxX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MaxX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MaxX"},"fn":"MaxX"},{"a":2,"n":"MaxY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MaxY","t":8,"rt":$n[0].Single,"fg":"MaxY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MaxY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MaxY"},"fn":"MaxY"},{"a":2,"n":"MinX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MinX","t":8,"rt":$n[0].Single,"fg":"MinX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MinX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MinX"},"fn":"MinX"},{"a":2,"n":"MinY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MinY","t":8,"rt":$n[0].Single,"fg":"MinY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MinY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MinY"},"fn":"MinY"},{"a":2,"n":"Polygons","t":16,"rt":$n[8].ExposedList$1(Spine.Polygon),"g":{"a":2,"n":"get_Polygons","t":8,"rt":$n[8].ExposedList$1(Spine.Polygon),"fg":"Polygons"},"s":{"a":1,"n":"set_Polygons","t":8,"p":[$n[8].ExposedList$1(Spine.Polygon)],"rt":$n[0].Void,"fs":"Polygons"},"fn":"Polygons"},{"a":2,"n":"Width","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Width","t":8,"rt":$n[0].Single,"fg":"Width","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"Width"},{"a":1,"n":"maxX","t":4,"rt":$n[0].Single,"sn":"maxX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"maxY","t":4,"rt":$n[0].Single,"sn":"maxY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"minX","t":4,"rt":$n[0].Single,"sn":"minX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"minY","t":4,"rt":$n[0].Single,"sn":"minY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"polygonPool","t":4,"rt":$n[8].ExposedList$1(Spine.Polygon),"sn":"polygonPool"},{"a":1,"backing":true,"n":"<BoundingBoxes>k__BackingField","t":4,"rt":$n[8].ExposedList$1(Spine.BoundingBoxAttachment),"sn":"BoundingBoxes"},{"a":1,"backing":true,"n":"<Polygons>k__BackingField","t":4,"rt":$n[8].ExposedList$1(Spine.Polygon),"sn":"Polygons"}]}; }, $n);
    /*Spine.SkeletonBounds end.*/

    /*Spine.Polygon start.*/
    $m("Spine.Polygon", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Count","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Count","t":8,"rt":$n[0].Int32,"fg":"Count","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_Count","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"Count"},"fn":"Count"},{"a":2,"n":"Vertices","t":16,"rt":$n[0].Array.type(System.Single),"g":{"a":2,"n":"get_Vertices","t":8,"rt":$n[0].Array.type(System.Single),"fg":"Vertices"},"s":{"a":2,"n":"set_Vertices","t":8,"p":[$n[0].Array.type(System.Single)],"rt":$n[0].Void,"fs":"Vertices"},"fn":"Vertices"},{"a":1,"backing":true,"n":"<Count>k__BackingField","t":4,"rt":$n[0].Int32,"sn":"Count","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"backing":true,"n":"<Vertices>k__BackingField","t":4,"rt":$n[0].Array.type(System.Single),"sn":"Vertices"}]}; }, $n);
    /*Spine.Polygon end.*/

    /*Spine.SkeletonClipping start.*/
    $m("Spine.SkeletonClipping", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":4,"n":"Clip","t":8,"pi":[{"n":"x1","pt":$n[0].Single,"ps":0},{"n":"y1","pt":$n[0].Single,"ps":1},{"n":"x2","pt":$n[0].Single,"ps":2},{"n":"y2","pt":$n[0].Single,"ps":3},{"n":"x3","pt":$n[0].Single,"ps":4},{"n":"y3","pt":$n[0].Single,"ps":5},{"n":"clippingArea","pt":$n[8].ExposedList$1(System.Single),"ps":6},{"n":"output","pt":$n[8].ExposedList$1(System.Single),"ps":7}],"sn":"Clip","rt":$n[0].Boolean,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[8].ExposedList$1(System.Single),$n[8].ExposedList$1(System.Single)],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"ClipEnd","t":8,"sn":"ClipEnd","rt":$n[0].Void},{"a":2,"n":"ClipEnd","t":8,"pi":[{"n":"slot","pt":$n[8].Slot,"ps":0}],"sn":"ClipEnd$1","rt":$n[0].Void,"p":[$n[8].Slot]},{"a":2,"n":"ClipStart","t":8,"pi":[{"n":"slot","pt":$n[8].Slot,"ps":0},{"n":"clip","pt":$n[8].ClippingAttachment,"ps":1}],"sn":"ClipStart","rt":$n[0].Int32,"p":[$n[8].Slot,$n[8].ClippingAttachment],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"ClipTriangles","t":8,"pi":[{"n":"vertices","pt":$n[0].Array.type(System.Single),"ps":0},{"n":"triangles","pt":$n[0].Array.type(System.Int32),"ps":1},{"n":"trianglesLength","pt":$n[0].Int32,"ps":2}],"sn":"ClipTriangles","rt":$n[0].Void,"p":[$n[0].Array.type(System.Single),$n[0].Array.type(System.Int32),$n[0].Int32]},{"a":2,"n":"ClipTriangles","t":8,"pi":[{"n":"vertices","pt":$n[0].Array.type(System.Single),"ps":0},{"n":"triangles","pt":$n[0].Array.type(System.Int32),"ps":1},{"n":"trianglesLength","pt":$n[0].Int32,"ps":2},{"n":"uvs","pt":$n[0].Array.type(System.Single),"ps":3}],"sn":"ClipTriangles$1","rt":$n[0].Void,"p":[$n[0].Array.type(System.Single),$n[0].Array.type(System.Int32),$n[0].Int32,$n[0].Array.type(System.Single)]},{"a":2,"n":"MakeClockwise","is":true,"t":8,"pi":[{"n":"polygon","pt":$n[8].ExposedList$1(System.Single),"ps":0}],"sn":"MakeClockwise","rt":$n[0].Void,"p":[$n[8].ExposedList$1(System.Single)]},{"a":2,"n":"ClippedTriangles","t":16,"rt":$n[8].ExposedList$1(System.Int32),"g":{"a":2,"n":"get_ClippedTriangles","t":8,"rt":$n[8].ExposedList$1(System.Int32),"fg":"ClippedTriangles"},"fn":"ClippedTriangles"},{"a":2,"n":"ClippedUVs","t":16,"rt":$n[8].ExposedList$1(System.Single),"g":{"a":2,"n":"get_ClippedUVs","t":8,"rt":$n[8].ExposedList$1(System.Single),"fg":"ClippedUVs"},"fn":"ClippedUVs"},{"a":2,"n":"ClippedVertices","t":16,"rt":$n[8].ExposedList$1(System.Single),"g":{"a":2,"n":"get_ClippedVertices","t":8,"rt":$n[8].ExposedList$1(System.Single),"fg":"ClippedVertices"},"fn":"ClippedVertices"},{"a":2,"n":"IsClipping","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsClipping","t":8,"rt":$n[0].Boolean,"fg":"IsClipping","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsClipping"},{"a":4,"n":"clipAttachment","t":4,"rt":$n[8].ClippingAttachment,"sn":"clipAttachment"},{"a":4,"n":"clipOutput","t":4,"rt":$n[8].ExposedList$1(System.Single),"sn":"clipOutput","ro":true},{"a":4,"n":"clippedTriangles","t":4,"rt":$n[8].ExposedList$1(System.Int32),"sn":"clippedTriangles","ro":true},{"a":4,"n":"clippedUVs","t":4,"rt":$n[8].ExposedList$1(System.Single),"sn":"clippedUVs","ro":true},{"a":4,"n":"clippedVertices","t":4,"rt":$n[8].ExposedList$1(System.Single),"sn":"clippedVertices","ro":true},{"a":4,"n":"clippingPolygon","t":4,"rt":$n[8].ExposedList$1(System.Single),"sn":"clippingPolygon","ro":true},{"a":4,"n":"clippingPolygons","t":4,"rt":$n[8].ExposedList$1(Spine.ExposedList$1(System.Single)),"sn":"clippingPolygons"},{"a":4,"n":"scratch","t":4,"rt":$n[8].ExposedList$1(System.Single),"sn":"scratch","ro":true},{"a":4,"n":"triangulator","t":4,"rt":$n[8].Triangulator,"sn":"triangulator","ro":true}]}; }, $n);
    /*Spine.SkeletonClipping end.*/

    /*Spine.SkeletonData start.*/
    $m("Spine.SkeletonData", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"FindAnimation","t":8,"pi":[{"n":"animationName","pt":$n[0].String,"ps":0}],"sn":"FindAnimation","rt":$n[8].Animation,"p":[$n[0].String]},{"a":2,"n":"FindBone","t":8,"pi":[{"n":"boneName","pt":$n[0].String,"ps":0}],"sn":"FindBone","rt":$n[8].BoneData,"p":[$n[0].String]},{"a":2,"n":"FindEvent","t":8,"pi":[{"n":"eventDataName","pt":$n[0].String,"ps":0}],"sn":"FindEvent","rt":$n[8].EventData,"p":[$n[0].String]},{"a":2,"n":"FindIkConstraint","t":8,"pi":[{"n":"constraintName","pt":$n[0].String,"ps":0}],"sn":"FindIkConstraint","rt":$n[8].IkConstraintData,"p":[$n[0].String]},{"a":2,"n":"FindPathConstraint","t":8,"pi":[{"n":"constraintName","pt":$n[0].String,"ps":0}],"sn":"FindPathConstraint","rt":$n[8].PathConstraintData,"p":[$n[0].String]},{"a":2,"n":"FindPhysicsConstraint","t":8,"pi":[{"n":"constraintName","pt":$n[0].String,"ps":0}],"sn":"FindPhysicsConstraint","rt":$n[8].PhysicsConstraintData,"p":[$n[0].String]},{"a":2,"n":"FindSkin","t":8,"pi":[{"n":"skinName","pt":$n[0].String,"ps":0}],"sn":"FindSkin","rt":$n[8].Skin,"p":[$n[0].String]},{"a":2,"n":"FindSlot","t":8,"pi":[{"n":"slotName","pt":$n[0].String,"ps":0}],"sn":"FindSlot","rt":$n[8].SlotData,"p":[$n[0].String]},{"a":2,"n":"FindTransformConstraint","t":8,"pi":[{"n":"constraintName","pt":$n[0].String,"ps":0}],"sn":"FindTransformConstraint","rt":$n[8].TransformConstraintData,"p":[$n[0].String]},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"Animations","t":16,"rt":$n[8].ExposedList$1(Spine.Animation),"g":{"a":2,"n":"get_Animations","t":8,"rt":$n[8].ExposedList$1(Spine.Animation),"fg":"Animations"},"s":{"a":2,"n":"set_Animations","t":8,"p":[$n[8].ExposedList$1(Spine.Animation)],"rt":$n[0].Void,"fs":"Animations"},"fn":"Animations"},{"a":2,"n":"AudioPath","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_AudioPath","t":8,"rt":$n[0].String,"fg":"AudioPath"},"s":{"a":2,"n":"set_AudioPath","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"AudioPath"},"fn":"AudioPath"},{"a":2,"n":"Bones","t":16,"rt":$n[8].ExposedList$1(Spine.BoneData),"g":{"a":2,"n":"get_Bones","t":8,"rt":$n[8].ExposedList$1(Spine.BoneData),"fg":"Bones"},"fn":"Bones"},{"a":2,"n":"DefaultSkin","t":16,"rt":$n[8].Skin,"g":{"a":2,"n":"get_DefaultSkin","t":8,"rt":$n[8].Skin,"fg":"DefaultSkin"},"s":{"a":2,"n":"set_DefaultSkin","t":8,"p":[$n[8].Skin],"rt":$n[0].Void,"fs":"DefaultSkin"},"fn":"DefaultSkin"},{"a":2,"n":"Events","t":16,"rt":$n[8].ExposedList$1(Spine.EventData),"g":{"a":2,"n":"get_Events","t":8,"rt":$n[8].ExposedList$1(Spine.EventData),"fg":"Events"},"s":{"a":2,"n":"set_Events","t":8,"p":[$n[8].ExposedList$1(Spine.EventData)],"rt":$n[0].Void,"fs":"Events"},"fn":"Events"},{"a":2,"n":"Fps","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Fps","t":8,"rt":$n[0].Single,"fg":"Fps","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Fps","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Fps"},"fn":"Fps"},{"a":2,"n":"Hash","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_Hash","t":8,"rt":$n[0].String,"fg":"Hash"},"s":{"a":2,"n":"set_Hash","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"Hash"},"fn":"Hash"},{"a":2,"n":"Height","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Height","t":8,"rt":$n[0].Single,"fg":"Height","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Height","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Height"},"fn":"Height"},{"a":2,"n":"IkConstraints","t":16,"rt":$n[8].ExposedList$1(Spine.IkConstraintData),"g":{"a":2,"n":"get_IkConstraints","t":8,"rt":$n[8].ExposedList$1(Spine.IkConstraintData),"fg":"IkConstraints"},"s":{"a":2,"n":"set_IkConstraints","t":8,"p":[$n[8].ExposedList$1(Spine.IkConstraintData)],"rt":$n[0].Void,"fs":"IkConstraints"},"fn":"IkConstraints"},{"a":2,"n":"ImagesPath","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_ImagesPath","t":8,"rt":$n[0].String,"fg":"ImagesPath"},"s":{"a":2,"n":"set_ImagesPath","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"ImagesPath"},"fn":"ImagesPath"},{"a":2,"n":"Name","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_Name","t":8,"rt":$n[0].String,"fg":"Name"},"s":{"a":2,"n":"set_Name","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"Name"},"fn":"Name"},{"a":2,"n":"PathConstraints","t":16,"rt":$n[8].ExposedList$1(Spine.PathConstraintData),"g":{"a":2,"n":"get_PathConstraints","t":8,"rt":$n[8].ExposedList$1(Spine.PathConstraintData),"fg":"PathConstraints"},"s":{"a":2,"n":"set_PathConstraints","t":8,"p":[$n[8].ExposedList$1(Spine.PathConstraintData)],"rt":$n[0].Void,"fs":"PathConstraints"},"fn":"PathConstraints"},{"a":2,"n":"PhysicsConstraints","t":16,"rt":$n[8].ExposedList$1(Spine.PhysicsConstraintData),"g":{"a":2,"n":"get_PhysicsConstraints","t":8,"rt":$n[8].ExposedList$1(Spine.PhysicsConstraintData),"fg":"PhysicsConstraints"},"s":{"a":2,"n":"set_PhysicsConstraints","t":8,"p":[$n[8].ExposedList$1(Spine.PhysicsConstraintData)],"rt":$n[0].Void,"fs":"PhysicsConstraints"},"fn":"PhysicsConstraints"},{"a":2,"n":"ReferenceScale","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ReferenceScale","t":8,"rt":$n[0].Single,"fg":"ReferenceScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ReferenceScale","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ReferenceScale"},"fn":"ReferenceScale"},{"a":2,"n":"Skins","t":16,"rt":$n[8].ExposedList$1(Spine.Skin),"g":{"a":2,"n":"get_Skins","t":8,"rt":$n[8].ExposedList$1(Spine.Skin),"fg":"Skins"},"s":{"a":2,"n":"set_Skins","t":8,"p":[$n[8].ExposedList$1(Spine.Skin)],"rt":$n[0].Void,"fs":"Skins"},"fn":"Skins"},{"a":2,"n":"Slots","t":16,"rt":$n[8].ExposedList$1(Spine.SlotData),"g":{"a":2,"n":"get_Slots","t":8,"rt":$n[8].ExposedList$1(Spine.SlotData),"fg":"Slots"},"fn":"Slots"},{"a":2,"n":"TransformConstraints","t":16,"rt":$n[8].ExposedList$1(Spine.TransformConstraintData),"g":{"a":2,"n":"get_TransformConstraints","t":8,"rt":$n[8].ExposedList$1(Spine.TransformConstraintData),"fg":"TransformConstraints"},"s":{"a":2,"n":"set_TransformConstraints","t":8,"p":[$n[8].ExposedList$1(Spine.TransformConstraintData)],"rt":$n[0].Void,"fs":"TransformConstraints"},"fn":"TransformConstraints"},{"a":2,"n":"Version","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_Version","t":8,"rt":$n[0].String,"fg":"Version"},"s":{"a":2,"n":"set_Version","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"Version"},"fn":"Version"},{"a":2,"n":"Width","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Width","t":8,"rt":$n[0].Single,"fg":"Width","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Width","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Width"},"fn":"Width"},{"a":2,"n":"X","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_X","t":8,"rt":$n[0].Single,"fg":"X","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_X","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"X"},"fn":"X"},{"a":2,"n":"Y","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Y","t":8,"rt":$n[0].Single,"fg":"Y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Y","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Y"},"fn":"Y"},{"a":4,"n":"animations","t":4,"rt":$n[8].ExposedList$1(Spine.Animation),"sn":"animations"},{"a":4,"n":"audioPath","t":4,"rt":$n[0].String,"sn":"audioPath"},{"a":4,"n":"bones","t":4,"rt":$n[8].ExposedList$1(Spine.BoneData),"sn":"bones"},{"a":4,"n":"defaultSkin","t":4,"rt":$n[8].Skin,"sn":"defaultSkin"},{"a":4,"n":"events","t":4,"rt":$n[8].ExposedList$1(Spine.EventData),"sn":"events"},{"a":4,"n":"fps","t":4,"rt":$n[0].Single,"sn":"fps","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"hash","t":4,"rt":$n[0].String,"sn":"hash"},{"a":4,"n":"height","t":4,"rt":$n[0].Single,"sn":"height","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"ikConstraints","t":4,"rt":$n[8].ExposedList$1(Spine.IkConstraintData),"sn":"ikConstraints"},{"a":4,"n":"imagesPath","t":4,"rt":$n[0].String,"sn":"imagesPath"},{"a":4,"n":"name","t":4,"rt":$n[0].String,"sn":"name"},{"a":4,"n":"pathConstraints","t":4,"rt":$n[8].ExposedList$1(Spine.PathConstraintData),"sn":"pathConstraints"},{"a":4,"n":"physicsConstraints","t":4,"rt":$n[8].ExposedList$1(Spine.PhysicsConstraintData),"sn":"physicsConstraints"},{"a":4,"n":"referenceScale","t":4,"rt":$n[0].Single,"sn":"referenceScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"skins","t":4,"rt":$n[8].ExposedList$1(Spine.Skin),"sn":"skins"},{"a":4,"n":"slots","t":4,"rt":$n[8].ExposedList$1(Spine.SlotData),"sn":"slots"},{"a":4,"n":"transformConstraints","t":4,"rt":$n[8].ExposedList$1(Spine.TransformConstraintData),"sn":"transformConstraints"},{"a":4,"n":"version","t":4,"rt":$n[0].String,"sn":"version"},{"a":4,"n":"width","t":4,"rt":$n[0].Single,"sn":"width","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"x","t":4,"rt":$n[0].Single,"sn":"x","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"y","t":4,"rt":$n[0].Single,"sn":"y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.SkeletonData end.*/

    /*Spine.SkeletonJson start.*/
    $m("Spine.SkeletonJson", function () { return {"nested":[$n[8].SkeletonJson.LinkedMesh],"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[System.Array.type(Spine.Atlas)],"pi":[{"n":"atlasArray","ip":true,"pt":System.Array.type(Spine.Atlas),"ps":0}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[8].AttachmentLoader],"pi":[{"n":"attachmentLoader","pt":$n[8].AttachmentLoader,"ps":0}],"sn":"$ctor1"},{"a":1,"n":"FindSlotIndex","t":8,"pi":[{"n":"skeletonData","pt":$n[8].SkeletonData,"ps":0},{"n":"slotName","pt":$n[0].String,"ps":1}],"sn":"FindSlotIndex","rt":$n[0].Int32,"p":[$n[8].SkeletonData,$n[0].String],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"GetBoolean","is":true,"t":8,"pi":[{"n":"map","pt":$n[2].Dictionary$2(System.String,System.Object),"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"defaultValue","pt":$n[0].Boolean,"ps":2}],"sn":"GetBoolean","rt":$n[0].Boolean,"p":[$n[2].Dictionary$2(System.String,System.Object),$n[0].String,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"GetFloat","is":true,"t":8,"pi":[{"n":"map","pt":$n[2].Dictionary$2(System.String,System.Object),"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"defaultValue","pt":$n[0].Single,"ps":2}],"sn":"GetFloat","rt":$n[0].Single,"p":[$n[2].Dictionary$2(System.String,System.Object),$n[0].String,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"GetFloatArray","is":true,"t":8,"pi":[{"n":"map","pt":$n[2].Dictionary$2(System.String,System.Object),"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"scale","pt":$n[0].Single,"ps":2}],"sn":"GetFloatArray","rt":$n[0].Array.type(System.Single),"p":[$n[2].Dictionary$2(System.String,System.Object),$n[0].String,$n[0].Single]},{"a":1,"n":"GetInt","is":true,"t":8,"pi":[{"n":"map","pt":$n[2].Dictionary$2(System.String,System.Object),"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"GetInt","rt":$n[0].Int32,"p":[$n[2].Dictionary$2(System.String,System.Object),$n[0].String],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"GetInt","is":true,"t":8,"pi":[{"n":"map","pt":$n[2].Dictionary$2(System.String,System.Object),"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"defaultValue","pt":$n[0].Int32,"ps":2}],"sn":"GetInt$1","rt":$n[0].Int32,"p":[$n[2].Dictionary$2(System.String,System.Object),$n[0].String,$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"GetIntArray","is":true,"t":8,"pi":[{"n":"map","pt":$n[2].Dictionary$2(System.String,System.Object),"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"GetIntArray","rt":$n[0].Array.type(System.Int32),"p":[$n[2].Dictionary$2(System.String,System.Object),$n[0].String]},{"a":1,"n":"GetString","is":true,"t":8,"pi":[{"n":"map","pt":$n[2].Dictionary$2(System.String,System.Object),"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"defaultValue","pt":$n[0].String,"ps":2}],"sn":"GetString","rt":$n[0].String,"p":[$n[2].Dictionary$2(System.String,System.Object),$n[0].String,$n[0].String]},{"a":1,"n":"ReadAnimation","t":8,"pi":[{"n":"map","pt":$n[2].Dictionary$2(System.String,System.Object),"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"skeletonData","pt":$n[8].SkeletonData,"ps":2}],"sn":"ReadAnimation","rt":$n[0].Void,"p":[$n[2].Dictionary$2(System.String,System.Object),$n[0].String,$n[8].SkeletonData]},{"a":1,"n":"ReadAttachment","t":8,"pi":[{"n":"map","pt":$n[2].Dictionary$2(System.String,System.Object),"ps":0},{"n":"skin","pt":$n[8].Skin,"ps":1},{"n":"slotIndex","pt":$n[0].Int32,"ps":2},{"n":"name","pt":$n[0].String,"ps":3},{"n":"skeletonData","pt":$n[8].SkeletonData,"ps":4}],"sn":"ReadAttachment","rt":$n[8].Attachment,"p":[$n[2].Dictionary$2(System.String,System.Object),$n[8].Skin,$n[0].Int32,$n[0].String,$n[8].SkeletonData]},{"a":1,"n":"ReadCurve","is":true,"t":8,"pi":[{"n":"curve","pt":$n[0].Object,"ps":0},{"n":"timeline","pt":$n[8].CurveTimeline,"ps":1},{"n":"bezier","pt":$n[0].Int32,"ps":2},{"n":"frame","pt":$n[0].Int32,"ps":3},{"n":"value","pt":$n[0].Int32,"ps":4},{"n":"time1","pt":$n[0].Single,"ps":5},{"n":"time2","pt":$n[0].Single,"ps":6},{"n":"value1","pt":$n[0].Single,"ps":7},{"n":"value2","pt":$n[0].Single,"ps":8},{"n":"scale","pt":$n[0].Single,"ps":9}],"sn":"ReadCurve","rt":$n[0].Int32,"p":[$n[0].Object,$n[8].CurveTimeline,$n[0].Int32,$n[0].Int32,$n[0].Int32,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"ReadSequence","is":true,"t":8,"pi":[{"n":"sequenceJson","pt":$n[0].Object,"ps":0}],"sn":"ReadSequence","rt":$n[8].Sequence,"p":[$n[0].Object]},{"a":2,"n":"ReadSkeletonData","t":8,"pi":[{"n":"reader","pt":$n[9].TextReader,"ps":0}],"sn":"ReadSkeletonData$1","rt":$n[8].SkeletonData,"p":[$n[9].TextReader]},{"ov":true,"a":2,"n":"ReadSkeletonData","t":8,"pi":[{"n":"path","pt":$n[0].String,"ps":0}],"sn":"ReadSkeletonData","rt":$n[8].SkeletonData,"p":[$n[0].String]},{"a":1,"n":"ReadTimeline","is":true,"t":8,"pi":[{"n":"keyMapEnumerator","ref":true,"pt":$n[2].List$1.Enumerator(System.Object),"ps":0},{"n":"timeline","pt":$n[8].CurveTimeline1,"ps":1},{"n":"defaultValue","pt":$n[0].Single,"ps":2},{"n":"scale","pt":$n[0].Single,"ps":3}],"sn":"ReadTimeline","rt":$n[8].Timeline,"p":[$n[2].List$1.Enumerator(System.Object),$n[8].CurveTimeline1,$n[0].Single,$n[0].Single]},{"a":1,"n":"ReadTimeline","is":true,"t":8,"pi":[{"n":"keyMapEnumerator","ref":true,"pt":$n[2].List$1.Enumerator(System.Object),"ps":0},{"n":"timeline","pt":$n[8].CurveTimeline2,"ps":1},{"n":"name1","pt":$n[0].String,"ps":2},{"n":"name2","pt":$n[0].String,"ps":3},{"n":"defaultValue","pt":$n[0].Single,"ps":4},{"n":"scale","pt":$n[0].Single,"ps":5}],"sn":"ReadTimeline$1","rt":$n[8].Timeline,"p":[$n[2].List$1.Enumerator(System.Object),$n[8].CurveTimeline2,$n[0].String,$n[0].String,$n[0].Single,$n[0].Single]},{"a":1,"n":"ReadVertices","t":8,"pi":[{"n":"map","pt":$n[2].Dictionary$2(System.String,System.Object),"ps":0},{"n":"attachment","pt":$n[8].VertexAttachment,"ps":1},{"n":"verticesLength","pt":$n[0].Int32,"ps":2}],"sn":"ReadVertices","rt":$n[0].Void,"p":[$n[2].Dictionary$2(System.String,System.Object),$n[8].VertexAttachment,$n[0].Int32]},{"a":1,"n":"SetBezier","is":true,"t":8,"pi":[{"n":"timeline","pt":$n[8].CurveTimeline,"ps":0},{"n":"frame","pt":$n[0].Int32,"ps":1},{"n":"value","pt":$n[0].Int32,"ps":2},{"n":"bezier","pt":$n[0].Int32,"ps":3},{"n":"time1","pt":$n[0].Single,"ps":4},{"n":"value1","pt":$n[0].Single,"ps":5},{"n":"cx1","pt":$n[0].Single,"ps":6},{"n":"cy1","pt":$n[0].Single,"ps":7},{"n":"cx2","pt":$n[0].Single,"ps":8},{"n":"cy2","pt":$n[0].Single,"ps":9},{"n":"time2","pt":$n[0].Single,"ps":10},{"n":"value2","pt":$n[0].Single,"ps":11}],"sn":"SetBezier","rt":$n[0].Void,"p":[$n[8].CurveTimeline,$n[0].Int32,$n[0].Int32,$n[0].Int32,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single]},{"a":1,"n":"ToColor","is":true,"t":8,"pi":[{"n":"hexString","pt":$n[0].String,"ps":0},{"n":"colorIndex","pt":$n[0].Int32,"ps":1},{"n":"expectedLength","dv":8,"o":true,"pt":$n[0].Int32,"ps":2}],"sn":"ToColor","rt":$n[0].Single,"p":[$n[0].String,$n[0].Int32,$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"linkedMeshes","t":4,"rt":$n[2].List$1(Spine.SkeletonJson.LinkedMesh),"sn":"linkedMeshes","ro":true}]}; }, $n);
    /*Spine.SkeletonJson end.*/

    /*Spine.SkeletonJson+LinkedMesh start.*/
    $m("Spine.SkeletonJson.LinkedMesh", function () { return {"td":$n[8].SkeletonJson,"att":1048579,"a":1,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[8].MeshAttachment,$n[0].String,$n[0].Int32,$n[0].String,$n[0].Boolean],"pi":[{"n":"mesh","pt":$n[8].MeshAttachment,"ps":0},{"n":"skin","pt":$n[0].String,"ps":1},{"n":"slotIndex","pt":$n[0].Int32,"ps":2},{"n":"parent","pt":$n[0].String,"ps":3},{"n":"inheritTimelines","pt":$n[0].Boolean,"ps":4}],"sn":"ctor"},{"a":4,"n":"inheritTimelines","t":4,"rt":$n[0].Boolean,"sn":"inheritTimelines","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"mesh","t":4,"rt":$n[8].MeshAttachment,"sn":"mesh"},{"a":4,"n":"parent","t":4,"rt":$n[0].String,"sn":"parent"},{"a":4,"n":"skin","t":4,"rt":$n[0].String,"sn":"skin"},{"a":4,"n":"slotIndex","t":4,"rt":$n[0].Int32,"sn":"slotIndex","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.SkeletonJson+LinkedMesh end.*/

    /*Spine.SkeletonLoader start.*/
    $m("Spine.SkeletonLoader", function () { return {"att":1048705,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[System.Array.type(Spine.Atlas)],"pi":[{"n":"atlasArray","ip":true,"pt":System.Array.type(Spine.Atlas),"ps":0}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[8].AttachmentLoader],"pi":[{"n":"attachmentLoader","pt":$n[8].AttachmentLoader,"ps":0}],"sn":"$ctor1"},{"ab":true,"a":2,"n":"ReadSkeletonData","t":8,"pi":[{"n":"path","pt":$n[0].String,"ps":0}],"sn":"ReadSkeletonData","rt":$n[8].SkeletonData,"p":[$n[0].String]},{"a":2,"n":"Scale","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Scale","t":8,"rt":$n[0].Single,"fg":"Scale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Scale","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Scale"},"fn":"Scale"},{"a":3,"n":"attachmentLoader","t":4,"rt":$n[8].AttachmentLoader,"sn":"attachmentLoader","ro":true},{"a":3,"n":"scale","t":4,"rt":$n[0].Single,"sn":"scale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.SkeletonLoader end.*/

    /*Spine.Skin start.*/
    $m("Spine.Skin", function () { return {"nested":[$n[8].Skin.SkinEntry,$n[8].Skin.SkinKey,$n[8].Skin.SkinKeyComparer],"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"ctor"},{"a":2,"n":"AddSkin","t":8,"pi":[{"n":"skin","pt":$n[8].Skin,"ps":0}],"sn":"AddSkin","rt":$n[0].Void,"p":[$n[8].Skin]},{"a":4,"n":"AttachAll","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"oldSkin","pt":$n[8].Skin,"ps":1}],"sn":"AttachAll","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[8].Skin]},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"CopySkin","t":8,"pi":[{"n":"skin","pt":$n[8].Skin,"ps":0}],"sn":"CopySkin","rt":$n[0].Void,"p":[$n[8].Skin]},{"a":2,"n":"GetAttachment","t":8,"pi":[{"n":"slotIndex","pt":$n[0].Int32,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"GetAttachment","rt":$n[8].Attachment,"p":[$n[0].Int32,$n[0].String]},{"a":2,"n":"GetAttachments","t":8,"pi":[{"n":"slotIndex","pt":$n[0].Int32,"ps":0},{"n":"attachments","pt":$n[2].List$1(Spine.Skin.SkinEntry),"ps":1}],"sn":"GetAttachments","rt":$n[0].Void,"p":[$n[0].Int32,$n[2].List$1(Spine.Skin.SkinEntry)]},{"a":2,"n":"RemoveAttachment","t":8,"pi":[{"n":"slotIndex","pt":$n[0].Int32,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"RemoveAttachment","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].String]},{"a":2,"n":"SetAttachment","t":8,"pi":[{"n":"slotIndex","pt":$n[0].Int32,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"attachment","pt":$n[8].Attachment,"ps":2}],"sn":"SetAttachment","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].String,$n[8].Attachment]},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"Attachments","t":16,"rt":$n[2].ICollection$1(Spine.Skin.SkinEntry),"g":{"a":2,"n":"get_Attachments","t":8,"rt":$n[2].ICollection$1(Spine.Skin.SkinEntry),"fg":"Attachments"},"fn":"Attachments"},{"a":2,"n":"Bones","t":16,"rt":$n[8].ExposedList$1(Spine.BoneData),"g":{"a":2,"n":"get_Bones","t":8,"rt":$n[8].ExposedList$1(Spine.BoneData),"fg":"Bones"},"fn":"Bones"},{"a":2,"n":"Constraints","t":16,"rt":$n[8].ExposedList$1(Spine.ConstraintData),"g":{"a":2,"n":"get_Constraints","t":8,"rt":$n[8].ExposedList$1(Spine.ConstraintData),"fg":"Constraints"},"fn":"Constraints"},{"a":2,"n":"Name","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_Name","t":8,"rt":$n[0].String,"fg":"Name"},"fn":"Name"},{"a":1,"n":"attachments","t":4,"rt":$n[2].Dictionary$2(Spine.Skin.SkinKey,Spine.Skin.SkinEntry),"sn":"attachments"},{"a":4,"n":"bones","t":4,"rt":$n[8].ExposedList$1(Spine.BoneData),"sn":"bones","ro":true},{"a":4,"n":"constraints","t":4,"rt":$n[8].ExposedList$1(Spine.ConstraintData),"sn":"constraints","ro":true},{"a":4,"n":"name","t":4,"rt":$n[0].String,"sn":"name"}]}; }, $n);
    /*Spine.Skin end.*/

    /*Spine.Skin+SkinEntry start.*/
    $m("Spine.Skin.SkinEntry", function () { return {"td":$n[8].Skin,"att":1048842,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].String,$n[8].Attachment],"pi":[{"n":"slotIndex","pt":$n[0].Int32,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"attachment","pt":$n[8].Attachment,"ps":2}],"sn":"$ctor1"},{"a":2,"n":"Attachment","t":16,"rt":$n[8].Attachment,"g":{"a":2,"n":"get_Attachment","t":8,"rt":$n[8].Attachment,"fg":"Attachment"},"fn":"Attachment"},{"a":2,"n":"Name","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_Name","t":8,"rt":$n[0].String,"fg":"Name"},"fn":"Name"},{"a":2,"n":"SlotIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_SlotIndex","t":8,"rt":$n[0].Int32,"fg":"SlotIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"SlotIndex"},{"a":4,"n":"attachment","t":4,"rt":$n[8].Attachment,"sn":"attachment","ro":true},{"a":4,"n":"name","t":4,"rt":$n[0].String,"sn":"name","ro":true},{"a":4,"n":"slotIndex","t":4,"rt":$n[0].Int32,"sn":"slotIndex","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.Skin+SkinEntry end.*/

    /*Spine.Skin+SkinKey start.*/
    $m("Spine.Skin.SkinKey", function () { return {"td":$n[8].Skin,"att":1048843,"a":1,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].String],"pi":[{"n":"slotIndex","pt":$n[0].Int32,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"$ctor1"},{"a":4,"n":"hashCode","t":4,"rt":$n[0].Int32,"sn":"hashCode","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"name","t":4,"rt":$n[0].String,"sn":"name","ro":true},{"a":4,"n":"slotIndex","t":4,"rt":$n[0].Int32,"sn":"slotIndex","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.Skin+SkinKey end.*/

    /*Spine.Skin+SkinKeyComparer start.*/
    $m("Spine.Skin.SkinKeyComparer", function () { return {"td":$n[8].Skin,"att":1048579,"a":1,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":4,"n":"Instance","is":true,"t":4,"rt":$n[8].Skin.SkinKeyComparer,"sn":"Instance","ro":true}]}; }, $n);
    /*Spine.Skin+SkinKeyComparer end.*/

    /*Spine.Slot start.*/
    $m("Spine.Slot", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[8].Slot,$n[8].Bone],"pi":[{"n":"slot","pt":$n[8].Slot,"ps":0},{"n":"bone","pt":$n[8].Bone,"ps":1}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[8].SlotData,$n[8].Bone],"pi":[{"n":"data","pt":$n[8].SlotData,"ps":0},{"n":"bone","pt":$n[8].Bone,"ps":1}],"sn":"$ctor1"},{"a":2,"n":"ClampColor","t":8,"sn":"ClampColor","rt":$n[0].Void},{"a":2,"n":"ClampSecondColor","t":8,"sn":"ClampSecondColor","rt":$n[0].Void},{"a":2,"n":"SetToSetupPose","t":8,"sn":"SetToSetupPose","rt":$n[0].Void},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"A","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_A","t":8,"rt":$n[0].Single,"fg":"A","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_A","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"A"},"fn":"A"},{"a":2,"n":"Attachment","t":16,"rt":$n[8].Attachment,"g":{"a":2,"n":"get_Attachment","t":8,"rt":$n[8].Attachment,"fg":"Attachment"},"s":{"a":2,"n":"set_Attachment","t":8,"p":[$n[8].Attachment],"rt":$n[0].Void,"fs":"Attachment"},"fn":"Attachment"},{"a":2,"n":"B","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_B","t":8,"rt":$n[0].Single,"fg":"B","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_B","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"B"},"fn":"B"},{"a":2,"n":"B2","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_B2","t":8,"rt":$n[0].Single,"fg":"B2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_B2","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"B2"},"fn":"B2"},{"a":2,"n":"Bone","t":16,"rt":$n[8].Bone,"g":{"a":2,"n":"get_Bone","t":8,"rt":$n[8].Bone,"fg":"Bone"},"fn":"Bone"},{"a":2,"n":"Data","t":16,"rt":$n[8].SlotData,"g":{"a":2,"n":"get_Data","t":8,"rt":$n[8].SlotData,"fg":"Data"},"fn":"Data"},{"a":2,"n":"Deform","t":16,"rt":$n[8].ExposedList$1(System.Single),"g":{"a":2,"n":"get_Deform","t":8,"rt":$n[8].ExposedList$1(System.Single),"fg":"Deform"},"s":{"a":2,"n":"set_Deform","t":8,"p":[$n[8].ExposedList$1(System.Single)],"rt":$n[0].Void,"fs":"Deform"},"fn":"Deform"},{"a":2,"n":"G","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_G","t":8,"rt":$n[0].Single,"fg":"G","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_G","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"G"},"fn":"G"},{"a":2,"n":"G2","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_G2","t":8,"rt":$n[0].Single,"fg":"G2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_G2","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"G2"},"fn":"G2"},{"a":2,"n":"HasSecondColor","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_HasSecondColor","t":8,"rt":$n[0].Boolean,"fg":"HasSecondColor","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_HasSecondColor","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"HasSecondColor"},"fn":"HasSecondColor"},{"a":2,"n":"R","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_R","t":8,"rt":$n[0].Single,"fg":"R","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_R","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"R"},"fn":"R"},{"a":2,"n":"R2","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_R2","t":8,"rt":$n[0].Single,"fg":"R2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_R2","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"R2"},"fn":"R2"},{"a":2,"n":"SequenceIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_SequenceIndex","t":8,"rt":$n[0].Int32,"fg":"SequenceIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_SequenceIndex","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"SequenceIndex"},"fn":"SequenceIndex"},{"a":2,"n":"Skeleton","t":16,"rt":$n[8].Skeleton,"g":{"a":2,"n":"get_Skeleton","t":8,"rt":$n[8].Skeleton,"fg":"Skeleton"},"fn":"Skeleton"},{"a":4,"n":"a","t":4,"rt":$n[0].Single,"sn":"a","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"attachment","t":4,"rt":$n[8].Attachment,"sn":"attachment"},{"a":4,"n":"attachmentState","t":4,"rt":$n[0].Int32,"sn":"attachmentState","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"b","t":4,"rt":$n[0].Single,"sn":"b","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"b2","t":4,"rt":$n[0].Single,"sn":"b2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"bone","t":4,"rt":$n[8].Bone,"sn":"bone"},{"a":4,"n":"data","t":4,"rt":$n[8].SlotData,"sn":"data"},{"a":4,"n":"deform","t":4,"rt":$n[8].ExposedList$1(System.Single),"sn":"deform"},{"a":4,"n":"g","t":4,"rt":$n[0].Single,"sn":"g","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"g2","t":4,"rt":$n[0].Single,"sn":"g2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"hasSecondColor","t":4,"rt":$n[0].Boolean,"sn":"hasSecondColor","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"r","t":4,"rt":$n[0].Single,"sn":"r","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"r2","t":4,"rt":$n[0].Single,"sn":"r2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"sequenceIndex","t":4,"rt":$n[0].Int32,"sn":"sequenceIndex","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.Slot end.*/

    /*Spine.SlotData start.*/
    $m("Spine.SlotData", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].String,$n[8].BoneData],"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"boneData","pt":$n[8].BoneData,"ps":2}],"sn":"ctor"},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"A","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_A","t":8,"rt":$n[0].Single,"fg":"A","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_A","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"A"},"fn":"A"},{"a":2,"n":"AttachmentName","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_AttachmentName","t":8,"rt":$n[0].String,"fg":"AttachmentName"},"s":{"a":2,"n":"set_AttachmentName","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"AttachmentName"},"fn":"AttachmentName"},{"a":2,"n":"B","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_B","t":8,"rt":$n[0].Single,"fg":"B","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_B","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"B"},"fn":"B"},{"a":2,"n":"B2","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_B2","t":8,"rt":$n[0].Single,"fg":"B2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_B2","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"B2"},"fn":"B2"},{"a":2,"n":"BlendMode","t":16,"rt":$n[8].BlendMode,"g":{"a":2,"n":"get_BlendMode","t":8,"rt":$n[8].BlendMode,"fg":"BlendMode","box":function ($v) { return Bridge.box($v, Spine.BlendMode, System.Enum.toStringFn(Spine.BlendMode));}},"s":{"a":2,"n":"set_BlendMode","t":8,"p":[$n[8].BlendMode],"rt":$n[0].Void,"fs":"BlendMode"},"fn":"BlendMode"},{"a":2,"n":"BoneData","t":16,"rt":$n[8].BoneData,"g":{"a":2,"n":"get_BoneData","t":8,"rt":$n[8].BoneData,"fg":"BoneData"},"fn":"BoneData"},{"a":2,"n":"G","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_G","t":8,"rt":$n[0].Single,"fg":"G","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_G","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"G"},"fn":"G"},{"a":2,"n":"G2","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_G2","t":8,"rt":$n[0].Single,"fg":"G2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_G2","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"G2"},"fn":"G2"},{"a":2,"n":"HasSecondColor","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_HasSecondColor","t":8,"rt":$n[0].Boolean,"fg":"HasSecondColor","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_HasSecondColor","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"HasSecondColor"},"fn":"HasSecondColor"},{"a":2,"n":"Index","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Index","t":8,"rt":$n[0].Int32,"fg":"Index","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"Index"},{"a":2,"n":"Name","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_Name","t":8,"rt":$n[0].String,"fg":"Name"},"fn":"Name"},{"a":2,"n":"R","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_R","t":8,"rt":$n[0].Single,"fg":"R","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_R","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"R"},"fn":"R"},{"a":2,"n":"R2","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_R2","t":8,"rt":$n[0].Single,"fg":"R2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_R2","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"R2"},"fn":"R2"},{"a":4,"n":"a","t":4,"rt":$n[0].Single,"sn":"a","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"attachmentName","t":4,"rt":$n[0].String,"sn":"attachmentName"},{"a":4,"n":"b","t":4,"rt":$n[0].Single,"sn":"b","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"b2","t":4,"rt":$n[0].Single,"sn":"b2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"blendMode","t":4,"rt":$n[8].BlendMode,"sn":"blendMode","box":function ($v) { return Bridge.box($v, Spine.BlendMode, System.Enum.toStringFn(Spine.BlendMode));}},{"a":4,"n":"boneData","t":4,"rt":$n[8].BoneData,"sn":"boneData"},{"a":4,"n":"g","t":4,"rt":$n[0].Single,"sn":"g","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"g2","t":4,"rt":$n[0].Single,"sn":"g2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"hasSecondColor","t":4,"rt":$n[0].Boolean,"sn":"hasSecondColor","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"index","t":4,"rt":$n[0].Int32,"sn":"index","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"name","t":4,"rt":$n[0].String,"sn":"name"},{"a":4,"n":"r","t":4,"rt":$n[0].Single,"sn":"r","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"r2","t":4,"rt":$n[0].Single,"sn":"r2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.SlotData end.*/

    /*Spine.TextureRegion start.*/
    $m("Spine.TextureRegion", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"v":true,"a":2,"n":"OriginalHeight","t":16,"rt":$n[0].Int32,"g":{"v":true,"a":2,"n":"get_OriginalHeight","t":8,"rt":$n[0].Int32,"fg":"OriginalHeight","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"OriginalHeight"},{"v":true,"a":2,"n":"OriginalWidth","t":16,"rt":$n[0].Int32,"g":{"v":true,"a":2,"n":"get_OriginalWidth","t":8,"rt":$n[0].Int32,"fg":"OriginalWidth","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"OriginalWidth"},{"a":2,"n":"height","t":4,"rt":$n[0].Int32,"sn":"height","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"u","t":4,"rt":$n[0].Single,"sn":"u","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"u2","t":4,"rt":$n[0].Single,"sn":"u2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"v","t":4,"rt":$n[0].Single,"sn":"v","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"v2","t":4,"rt":$n[0].Single,"sn":"v2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"width","t":4,"rt":$n[0].Int32,"sn":"width","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.TextureRegion end.*/

    /*Spine.TransformConstraint start.*/
    $m("Spine.TransformConstraint", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[8].TransformConstraint,$n[8].Skeleton],"pi":[{"n":"constraint","pt":$n[8].TransformConstraint,"ps":0},{"n":"skeleton","pt":$n[8].Skeleton,"ps":1}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[8].TransformConstraintData,$n[8].Skeleton],"pi":[{"n":"data","pt":$n[8].TransformConstraintData,"ps":0},{"n":"skeleton","pt":$n[8].Skeleton,"ps":1}],"sn":"$ctor1"},{"a":1,"n":"ApplyAbsoluteLocal","t":8,"sn":"ApplyAbsoluteLocal","rt":$n[0].Void},{"a":1,"n":"ApplyAbsoluteWorld","t":8,"sn":"ApplyAbsoluteWorld","rt":$n[0].Void},{"a":1,"n":"ApplyRelativeLocal","t":8,"sn":"ApplyRelativeLocal","rt":$n[0].Void},{"a":1,"n":"ApplyRelativeWorld","t":8,"sn":"ApplyRelativeWorld","rt":$n[0].Void},{"a":2,"n":"SetToSetupPose","t":8,"sn":"SetToSetupPose","rt":$n[0].Void},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"Update","t":8,"pi":[{"n":"physics","pt":$n[8].Skeleton.Physics,"ps":0}],"sn":"Update","rt":$n[0].Void,"p":[$n[8].Skeleton.Physics]},{"a":2,"n":"Active","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Active","t":8,"rt":$n[0].Boolean,"fg":"Active","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"Active"},{"a":2,"n":"Bones","t":16,"rt":$n[8].ExposedList$1(Spine.Bone),"g":{"a":2,"n":"get_Bones","t":8,"rt":$n[8].ExposedList$1(Spine.Bone),"fg":"Bones"},"fn":"Bones"},{"a":2,"n":"Data","t":16,"rt":$n[8].TransformConstraintData,"g":{"a":2,"n":"get_Data","t":8,"rt":$n[8].TransformConstraintData,"fg":"Data"},"fn":"Data"},{"a":2,"n":"MixRotate","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MixRotate","t":8,"rt":$n[0].Single,"fg":"MixRotate","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MixRotate","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MixRotate"},"fn":"MixRotate"},{"a":2,"n":"MixScaleX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MixScaleX","t":8,"rt":$n[0].Single,"fg":"MixScaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MixScaleX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MixScaleX"},"fn":"MixScaleX"},{"a":2,"n":"MixScaleY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MixScaleY","t":8,"rt":$n[0].Single,"fg":"MixScaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MixScaleY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MixScaleY"},"fn":"MixScaleY"},{"a":2,"n":"MixShearY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MixShearY","t":8,"rt":$n[0].Single,"fg":"MixShearY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MixShearY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MixShearY"},"fn":"MixShearY"},{"a":2,"n":"MixX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MixX","t":8,"rt":$n[0].Single,"fg":"MixX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MixX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MixX"},"fn":"MixX"},{"a":2,"n":"MixY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MixY","t":8,"rt":$n[0].Single,"fg":"MixY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MixY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MixY"},"fn":"MixY"},{"a":2,"n":"Target","t":16,"rt":$n[8].Bone,"g":{"a":2,"n":"get_Target","t":8,"rt":$n[8].Bone,"fg":"Target"},"s":{"a":2,"n":"set_Target","t":8,"p":[$n[8].Bone],"rt":$n[0].Void,"fs":"Target"},"fn":"Target"},{"a":4,"n":"active","t":4,"rt":$n[0].Boolean,"sn":"active","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"bones","t":4,"rt":$n[8].ExposedList$1(Spine.Bone),"sn":"bones","ro":true},{"a":4,"n":"data","t":4,"rt":$n[8].TransformConstraintData,"sn":"data","ro":true},{"a":4,"n":"mixRotate","t":4,"rt":$n[0].Single,"sn":"mixRotate","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"mixScaleX","t":4,"rt":$n[0].Single,"sn":"mixScaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"mixScaleY","t":4,"rt":$n[0].Single,"sn":"mixScaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"mixShearY","t":4,"rt":$n[0].Single,"sn":"mixShearY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"mixX","t":4,"rt":$n[0].Single,"sn":"mixX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"mixY","t":4,"rt":$n[0].Single,"sn":"mixY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"target","t":4,"rt":$n[8].Bone,"sn":"target"}]}; }, $n);
    /*Spine.TransformConstraint end.*/

    /*Spine.TransformConstraintData start.*/
    $m("Spine.TransformConstraintData", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"ctor"},{"a":2,"n":"Bones","t":16,"rt":$n[8].ExposedList$1(Spine.BoneData),"g":{"a":2,"n":"get_Bones","t":8,"rt":$n[8].ExposedList$1(Spine.BoneData),"fg":"Bones"},"fn":"Bones"},{"a":2,"n":"Local","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Local","t":8,"rt":$n[0].Boolean,"fg":"Local","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_Local","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"Local"},"fn":"Local"},{"a":2,"n":"MixRotate","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MixRotate","t":8,"rt":$n[0].Single,"fg":"MixRotate","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MixRotate","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MixRotate"},"fn":"MixRotate"},{"a":2,"n":"MixScaleX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MixScaleX","t":8,"rt":$n[0].Single,"fg":"MixScaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MixScaleX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MixScaleX"},"fn":"MixScaleX"},{"a":2,"n":"MixScaleY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MixScaleY","t":8,"rt":$n[0].Single,"fg":"MixScaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MixScaleY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MixScaleY"},"fn":"MixScaleY"},{"a":2,"n":"MixShearY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MixShearY","t":8,"rt":$n[0].Single,"fg":"MixShearY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MixShearY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MixShearY"},"fn":"MixShearY"},{"a":2,"n":"MixX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MixX","t":8,"rt":$n[0].Single,"fg":"MixX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MixX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MixX"},"fn":"MixX"},{"a":2,"n":"MixY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MixY","t":8,"rt":$n[0].Single,"fg":"MixY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MixY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MixY"},"fn":"MixY"},{"a":2,"n":"OffsetRotation","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_OffsetRotation","t":8,"rt":$n[0].Single,"fg":"OffsetRotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_OffsetRotation","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"OffsetRotation"},"fn":"OffsetRotation"},{"a":2,"n":"OffsetScaleX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_OffsetScaleX","t":8,"rt":$n[0].Single,"fg":"OffsetScaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_OffsetScaleX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"OffsetScaleX"},"fn":"OffsetScaleX"},{"a":2,"n":"OffsetScaleY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_OffsetScaleY","t":8,"rt":$n[0].Single,"fg":"OffsetScaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_OffsetScaleY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"OffsetScaleY"},"fn":"OffsetScaleY"},{"a":2,"n":"OffsetShearY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_OffsetShearY","t":8,"rt":$n[0].Single,"fg":"OffsetShearY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_OffsetShearY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"OffsetShearY"},"fn":"OffsetShearY"},{"a":2,"n":"OffsetX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_OffsetX","t":8,"rt":$n[0].Single,"fg":"OffsetX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_OffsetX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"OffsetX"},"fn":"OffsetX"},{"a":2,"n":"OffsetY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_OffsetY","t":8,"rt":$n[0].Single,"fg":"OffsetY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_OffsetY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"OffsetY"},"fn":"OffsetY"},{"a":2,"n":"Relative","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Relative","t":8,"rt":$n[0].Boolean,"fg":"Relative","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_Relative","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"Relative"},"fn":"Relative"},{"a":2,"n":"Target","t":16,"rt":$n[8].BoneData,"g":{"a":2,"n":"get_Target","t":8,"rt":$n[8].BoneData,"fg":"Target"},"s":{"a":2,"n":"set_Target","t":8,"p":[$n[8].BoneData],"rt":$n[0].Void,"fs":"Target"},"fn":"Target"},{"a":4,"n":"bones","t":4,"rt":$n[8].ExposedList$1(Spine.BoneData),"sn":"bones"},{"a":4,"n":"local","t":4,"rt":$n[0].Boolean,"sn":"local","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"mixRotate","t":4,"rt":$n[0].Single,"sn":"mixRotate","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"mixScaleX","t":4,"rt":$n[0].Single,"sn":"mixScaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"mixScaleY","t":4,"rt":$n[0].Single,"sn":"mixScaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"mixShearY","t":4,"rt":$n[0].Single,"sn":"mixShearY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"mixX","t":4,"rt":$n[0].Single,"sn":"mixX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"mixY","t":4,"rt":$n[0].Single,"sn":"mixY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"offsetRotation","t":4,"rt":$n[0].Single,"sn":"offsetRotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"offsetScaleX","t":4,"rt":$n[0].Single,"sn":"offsetScaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"offsetScaleY","t":4,"rt":$n[0].Single,"sn":"offsetScaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"offsetShearY","t":4,"rt":$n[0].Single,"sn":"offsetShearY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"offsetX","t":4,"rt":$n[0].Single,"sn":"offsetX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"offsetY","t":4,"rt":$n[0].Single,"sn":"offsetY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"relative","t":4,"rt":$n[0].Boolean,"sn":"relative","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"target","t":4,"rt":$n[8].BoneData,"sn":"target"}]}; }, $n);
    /*Spine.TransformConstraintData end.*/

    /*Spine.Triangulator start.*/
    $m("Spine.Triangulator", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Decompose","t":8,"pi":[{"n":"verticesArray","pt":$n[8].ExposedList$1(System.Single),"ps":0},{"n":"triangles","pt":$n[8].ExposedList$1(System.Int32),"ps":1}],"sn":"Decompose","rt":$n[8].ExposedList$1(Spine.ExposedList$1(System.Single)),"p":[$n[8].ExposedList$1(System.Single),$n[8].ExposedList$1(System.Int32)]},{"a":1,"n":"IsConcave","is":true,"t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"vertexCount","pt":$n[0].Int32,"ps":1},{"n":"vertices","pt":$n[0].Array.type(System.Single),"ps":2},{"n":"indices","pt":$n[0].Array.type(System.Int32),"ps":3}],"sn":"IsConcave","rt":$n[0].Boolean,"p":[$n[0].Int32,$n[0].Int32,$n[0].Array.type(System.Single),$n[0].Array.type(System.Int32)],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"PositiveArea","is":true,"t":8,"pi":[{"n":"p1x","pt":$n[0].Single,"ps":0},{"n":"p1y","pt":$n[0].Single,"ps":1},{"n":"p2x","pt":$n[0].Single,"ps":2},{"n":"p2y","pt":$n[0].Single,"ps":3},{"n":"p3x","pt":$n[0].Single,"ps":4},{"n":"p3y","pt":$n[0].Single,"ps":5}],"sn":"PositiveArea","rt":$n[0].Boolean,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"Triangulate","t":8,"pi":[{"n":"verticesArray","pt":$n[8].ExposedList$1(System.Single),"ps":0}],"sn":"Triangulate","rt":$n[8].ExposedList$1(System.Int32),"p":[$n[8].ExposedList$1(System.Single)]},{"a":1,"n":"Winding","is":true,"t":8,"pi":[{"n":"p1x","pt":$n[0].Single,"ps":0},{"n":"p1y","pt":$n[0].Single,"ps":1},{"n":"p2x","pt":$n[0].Single,"ps":2},{"n":"p2y","pt":$n[0].Single,"ps":3},{"n":"p3x","pt":$n[0].Single,"ps":4},{"n":"p3y","pt":$n[0].Single,"ps":5}],"sn":"Winding","rt":$n[0].Int32,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"convexPolygons","t":4,"rt":$n[8].ExposedList$1(Spine.ExposedList$1(System.Single)),"sn":"convexPolygons","ro":true},{"a":1,"n":"convexPolygonsIndices","t":4,"rt":$n[8].ExposedList$1(Spine.ExposedList$1(System.Int32)),"sn":"convexPolygonsIndices","ro":true},{"a":1,"n":"indicesArray","t":4,"rt":$n[8].ExposedList$1(System.Int32),"sn":"indicesArray","ro":true},{"a":1,"n":"isConcaveArray","t":4,"rt":$n[8].ExposedList$1(System.Boolean),"sn":"isConcaveArray","ro":true},{"a":1,"n":"polygonIndicesPool","t":4,"rt":$n[8].Pool$1(Spine.ExposedList$1(System.Int32)),"sn":"polygonIndicesPool","ro":true},{"a":1,"n":"polygonPool","t":4,"rt":$n[8].Pool$1(Spine.ExposedList$1(System.Single)),"sn":"polygonPool","ro":true},{"a":1,"n":"triangles","t":4,"rt":$n[8].ExposedList$1(System.Int32),"sn":"triangles","ro":true}]}; }, $n);
    /*Spine.Triangulator end.*/

    /*Spine.BoneMatrix start.*/
    $m("Spine.BoneMatrix", function () { return {"att":1048841,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[8].Bone],"pi":[{"n":"bone","pt":$n[8].Bone,"ps":0}],"sn":"$ctor1"},{"a":2,"n":".ctor","t":1,"p":[$n[8].BoneData],"pi":[{"n":"boneData","pt":$n[8].BoneData,"ps":0}],"sn":"$ctor2"},{"a":2,"n":"CalculateSetupWorld","is":true,"t":8,"pi":[{"n":"boneData","pt":$n[8].BoneData,"ps":0}],"sn":"CalculateSetupWorld","rt":$n[8].BoneMatrix,"p":[$n[8].BoneData]},{"a":1,"n":"GetInheritedInternal","is":true,"t":8,"pi":[{"n":"boneData","pt":$n[8].BoneData,"ps":0},{"n":"parentMatrix","pt":$n[8].BoneMatrix,"ps":1}],"sn":"GetInheritedInternal","rt":$n[8].BoneMatrix,"p":[$n[8].BoneData,$n[8].BoneMatrix]},{"a":2,"n":"TransformMatrix","t":8,"pi":[{"n":"local","pt":$n[8].BoneMatrix,"ps":0}],"sn":"TransformMatrix","rt":$n[8].BoneMatrix,"p":[$n[8].BoneMatrix]},{"a":2,"n":"a","t":4,"rt":$n[0].Single,"sn":"a","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"b","t":4,"rt":$n[0].Single,"sn":"b","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"c","t":4,"rt":$n[0].Single,"sn":"c","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"d","t":4,"rt":$n[0].Single,"sn":"d","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"x","t":4,"rt":$n[0].Single,"sn":"x","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"y","t":4,"rt":$n[0].Single,"sn":"y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.BoneMatrix end.*/

    /*Spine.SpineSkeletonExtensions start.*/
    $m("Spine.SpineSkeletonExtensions", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"InheritsRotation","is":true,"t":8,"pi":[{"n":"mode","pt":$n[8].Inherit,"ps":0}],"sn":"InheritsRotation","rt":$n[0].Boolean,"p":[$n[8].Inherit],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"InheritsScale","is":true,"t":8,"pi":[{"n":"mode","pt":$n[8].Inherit,"ps":0}],"sn":"InheritsScale","rt":$n[0].Boolean,"p":[$n[8].Inherit],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"IsWeighted","is":true,"t":8,"pi":[{"n":"va","pt":$n[8].VertexAttachment,"ps":0}],"sn":"IsWeighted","rt":$n[0].Boolean,"p":[$n[8].VertexAttachment],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.SpineSkeletonExtensions end.*/

    /*Spine.Unity.AnimationReferenceAsset start.*/
    $m("Spine.Unity.AnimationReferenceAsset", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Spine/Animation Reference Asset", order: 100
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"a":2,"n":"op_Implicit","is":true,"t":8,"pi":[{"n":"asset","pt":$n[5].AnimationReferenceAsset,"ps":0}],"sn":"op_Implicit","rt":$n[8].Animation,"p":[$n[5].AnimationReferenceAsset]},{"a":2,"n":"Animation","t":16,"rt":$n[8].Animation,"g":{"a":2,"n":"get_Animation","t":8,"rt":$n[8].Animation,"fg":"Animation"},"fn":"Animation"},{"a":2,"n":"SkeletonDataAsset","t":16,"rt":$n[5].SkeletonDataAsset,"g":{"a":2,"n":"get_SkeletonDataAsset","t":8,"rt":$n[5].SkeletonDataAsset,"fg":"SkeletonDataAsset"},"fn":"SkeletonDataAsset"},{"a":1,"n":"QuietSkeletonData","is":true,"t":4,"rt":$n[0].Boolean,"sn":"QuietSkeletonData","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"animation","t":4,"rt":$n[8].Animation,"sn":"animation"},{"at":[new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineAnimation("", "", true, false, false)],"a":3,"n":"animationName","t":4,"rt":$n[0].String,"sn":"animationName"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"skeletonDataAsset","t":4,"rt":$n[5].SkeletonDataAsset,"sn":"skeletonDataAsset"}]}; }, $n);
    /*Spine.Unity.AnimationReferenceAsset end.*/

    /*Spine.Unity.AtlasAssetBase start.*/
    $m("Spine.Unity.AtlasAssetBase", function () { return {"nested":[$n[5].AtlasAssetBase.LoadingMode],"att":1048705,"a":2,"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"v":true,"a":2,"n":"BeginCustomTextureLoading","t":8,"sn":"BeginCustomTextureLoading","rt":$n[0].Void},{"ab":true,"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"v":true,"a":2,"n":"EndCustomTextureLoading","t":8,"sn":"EndCustomTextureLoading","rt":$n[0].Void},{"ab":true,"a":2,"n":"GetAtlas","t":8,"pi":[{"n":"onlyMetaData","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"GetAtlas","rt":$n[8].Atlas,"p":[$n[0].Boolean]},{"v":true,"a":2,"n":"RequireTextureLoaded","t":8,"pi":[{"n":"placeholderTexture","pt":$n[1].Texture,"ps":0},{"n":"replacementTexture","ref":true,"pt":$n[1].Texture,"ps":1},{"n":"onTextureLoaded","pt":Function,"ps":2}],"sn":"RequireTextureLoaded","rt":$n[0].Void,"p":[$n[1].Texture,$n[1].Texture,Function]},{"v":true,"a":2,"n":"RequireTexturesLoaded","t":8,"pi":[{"n":"material","pt":$n[1].Material,"ps":0},{"n":"overrideMaterial","ref":true,"pt":$n[1].Material,"ps":1}],"sn":"RequireTexturesLoaded","rt":$n[0].Void,"p":[$n[1].Material,$n[1].Material]},{"ab":true,"a":2,"n":"IsLoaded","t":16,"rt":$n[0].Boolean,"g":{"ab":true,"a":2,"n":"get_IsLoaded","t":8,"rt":$n[0].Boolean,"fg":"IsLoaded","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsLoaded"},{"ab":true,"a":2,"n":"MaterialCount","t":16,"rt":$n[0].Int32,"g":{"ab":true,"a":2,"n":"get_MaterialCount","t":8,"rt":$n[0].Int32,"fg":"MaterialCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"MaterialCount"},{"ab":true,"a":2,"n":"Materials","t":16,"rt":$n[2].IEnumerable$1(UnityEngine.Material),"g":{"ab":true,"a":2,"n":"get_Materials","t":8,"rt":$n[2].IEnumerable$1(UnityEngine.Material),"fg":"Materials"},"fn":"Materials"},{"a":2,"n":"OnDemandTextureLoader","t":16,"rt":$n[5].OnDemandTextureLoader,"g":{"a":2,"n":"get_OnDemandTextureLoader","t":8,"rt":$n[5].OnDemandTextureLoader,"fg":"OnDemandTextureLoader"},"s":{"a":2,"n":"set_OnDemandTextureLoader","t":8,"p":[$n[5].OnDemandTextureLoader],"rt":$n[0].Void,"fs":"OnDemandTextureLoader"},"fn":"OnDemandTextureLoader"},{"ab":true,"a":2,"n":"PrimaryMaterial","t":16,"rt":$n[1].Material,"g":{"ab":true,"a":2,"n":"get_PrimaryMaterial","t":8,"rt":$n[1].Material,"fg":"PrimaryMaterial"},"fn":"PrimaryMaterial"},{"v":true,"a":2,"n":"TextureLoadingMode","t":16,"rt":$n[5].AtlasAssetBase.LoadingMode,"g":{"v":true,"a":2,"n":"get_TextureLoadingMode","t":8,"rt":$n[5].AtlasAssetBase.LoadingMode,"fg":"TextureLoadingMode","box":function ($v) { return Bridge.box($v, Spine.Unity.AtlasAssetBase.LoadingMode, System.Enum.toStringFn(Spine.Unity.AtlasAssetBase.LoadingMode));}},"s":{"v":true,"a":2,"n":"set_TextureLoadingMode","t":8,"p":[$n[5].AtlasAssetBase.LoadingMode],"rt":$n[0].Void,"fs":"TextureLoadingMode"},"fn":"TextureLoadingMode"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"onDemandTextureLoader","t":4,"rt":$n[5].OnDemandTextureLoader,"sn":"onDemandTextureLoader"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"textureLoadingMode","t":4,"rt":$n[5].AtlasAssetBase.LoadingMode,"sn":"textureLoadingMode","box":function ($v) { return Bridge.box($v, Spine.Unity.AtlasAssetBase.LoadingMode, System.Enum.toStringFn(Spine.Unity.AtlasAssetBase.LoadingMode));}},{"a":1,"backing":true,"n":"<IsLoaded>k__BackingField","t":4,"rt":$n[0].Boolean,"sn":"IsLoaded","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"backing":true,"n":"<MaterialCount>k__BackingField","t":4,"rt":$n[0].Int32,"sn":"MaterialCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"backing":true,"n":"<Materials>k__BackingField","t":4,"rt":$n[2].IEnumerable$1(UnityEngine.Material),"sn":"Materials"},{"a":1,"backing":true,"n":"<PrimaryMaterial>k__BackingField","t":4,"rt":$n[1].Material,"sn":"PrimaryMaterial"}]}; }, $n);
    /*Spine.Unity.AtlasAssetBase end.*/

    /*Spine.Unity.AtlasAssetBase+LoadingMode start.*/
    $m("Spine.Unity.AtlasAssetBase.LoadingMode", function () { return {"td":$n[5].AtlasAssetBase,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Normal","is":true,"t":4,"rt":$n[5].AtlasAssetBase.LoadingMode,"sn":"Normal","box":function ($v) { return Bridge.box($v, Spine.Unity.AtlasAssetBase.LoadingMode, System.Enum.toStringFn(Spine.Unity.AtlasAssetBase.LoadingMode));}},{"a":2,"n":"OnDemand","is":true,"t":4,"rt":$n[5].AtlasAssetBase.LoadingMode,"sn":"OnDemand","box":function ($v) { return Bridge.box($v, Spine.Unity.AtlasAssetBase.LoadingMode, System.Enum.toStringFn(Spine.Unity.AtlasAssetBase.LoadingMode));}}]}; }, $n);
    /*Spine.Unity.AtlasAssetBase+LoadingMode end.*/

    /*Spine.Unity.BlendModeMaterials start.*/
    $m("Spine.Unity.BlendModeMaterials", function () { return {"nested":[$n[5].BlendModeMaterials.ReplacementMaterial,$n[5].BlendModeMaterials.TemplateMaterials,Function],"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"ApplyMaterials","t":8,"pi":[{"n":"skeletonData","pt":$n[8].SkeletonData,"ps":0}],"sn":"ApplyMaterials","rt":$n[0].Void,"p":[$n[8].SkeletonData]},{"a":2,"n":"BlendModeForMaterial","t":8,"pi":[{"n":"material","pt":$n[1].Material,"ps":0}],"sn":"BlendModeForMaterial","rt":$n[8].BlendMode,"p":[$n[1].Material],"box":function ($v) { return Bridge.box($v, Spine.BlendMode, System.Enum.toStringFn(Spine.BlendMode));}},{"a":3,"n":"CloneAtlasRegionWithMaterial","t":8,"pi":[{"n":"originalRegion","pt":$n[8].AtlasRegion,"ps":0},{"n":"replacementMaterials","pt":$n[2].List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial),"ps":1}],"sn":"CloneAtlasRegionWithMaterial","rt":$n[8].AtlasRegion,"p":[$n[8].AtlasRegion,$n[2].List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial)]},{"a":2,"n":"CreateAndAssignMaterials","is":true,"t":8,"pi":[{"n":"skeletonDataAsset","pt":$n[5].SkeletonDataAsset,"ps":0},{"n":"templateMaterials","pt":$n[5].BlendModeMaterials.TemplateMaterials,"ps":1},{"n":"anyReplacementMaterialsChanged","ref":true,"pt":$n[0].Boolean,"ps":2}],"sn":"CreateAndAssignMaterials","rt":$n[0].Boolean,"p":[$n[5].SkeletonDataAsset,$n[5].BlendModeMaterials.TemplateMaterials,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"CreateAndAssignMaterials","is":true,"t":8,"pi":[{"n":"skeletonDataAsset","pt":$n[5].SkeletonDataAsset,"ps":0},{"n":"templateMaterials","pt":$n[5].BlendModeMaterials.TemplateMaterials,"ps":1},{"n":"anyReplacementMaterialsChanged","ref":true,"pt":$n[0].Boolean,"ps":2},{"n":"clearSkeletonDataAssetFunc","pt":Function,"ps":3},{"n":"afterAssetModifiedFunc","pt":Function,"ps":4},{"n":"createForRegionFunc","pt":Function,"ps":5}],"sn":"CreateAndAssignMaterials$1","rt":$n[0].Boolean,"p":[$n[5].SkeletonDataAsset,$n[5].BlendModeMaterials.TemplateMaterials,$n[0].Boolean,Function,Function,Function],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"CreateForRegion","is":true,"t":8,"pi":[{"n":"replacementMaterials","ref":true,"pt":$n[2].List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial),"ps":0},{"n":"anyReplacementMaterialsChanged","ref":true,"pt":$n[0].Boolean,"ps":1},{"n":"originalRegion","pt":$n[8].AtlasRegion,"ps":2},{"n":"materialTemplate","pt":$n[1].Material,"ps":3},{"n":"materialSuffix","pt":$n[0].String,"ps":4},{"n":"skeletonDataAsset","pt":$n[5].SkeletonDataAsset,"ps":5}],"sn":"CreateForRegion","rt":$n[0].Boolean,"p":[$n[2].List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial),$n[0].Boolean,$n[8].AtlasRegion,$n[1].Material,$n[0].String,$n[5].SkeletonDataAsset],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"CreateReplacementMaterial","is":true,"t":8,"pi":[{"n":"originalRegion","pt":$n[8].AtlasRegion,"ps":0},{"n":"materialTemplate","pt":$n[1].Material,"ps":1},{"n":"materialSuffix","pt":$n[0].String,"ps":2}],"sn":"CreateReplacementMaterial","rt":$n[5].BlendModeMaterials.ReplacementMaterial,"p":[$n[8].AtlasRegion,$n[1].Material,$n[0].String]},{"a":2,"n":"UpdateBlendmodeMaterialsRequiredState","t":8,"pi":[{"n":"skeletonData","pt":$n[8].SkeletonData,"ps":0}],"sn":"UpdateBlendmodeMaterialsRequiredState","rt":$n[0].Boolean,"p":[$n[8].SkeletonData],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"RequiresBlendModeMaterials","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_RequiresBlendModeMaterials","t":8,"rt":$n[0].Boolean,"fg":"RequiresBlendModeMaterials","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_RequiresBlendModeMaterials","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"RequiresBlendModeMaterials"},"fn":"RequiresBlendModeMaterials"},{"a":2,"n":"MATERIAL_SUFFIX_ADDITIVE","is":true,"t":4,"rt":$n[0].String,"sn":"MATERIAL_SUFFIX_ADDITIVE"},{"a":2,"n":"MATERIAL_SUFFIX_MULTIPLY","is":true,"t":4,"rt":$n[0].String,"sn":"MATERIAL_SUFFIX_MULTIPLY"},{"a":2,"n":"MATERIAL_SUFFIX_SCREEN","is":true,"t":4,"rt":$n[0].String,"sn":"MATERIAL_SUFFIX_SCREEN"},{"a":2,"n":"additiveMaterials","t":4,"rt":$n[2].List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial),"sn":"additiveMaterials"},{"a":2,"n":"applyAdditiveMaterial","t":4,"rt":$n[0].Boolean,"sn":"applyAdditiveMaterial","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"multiplyMaterials","t":4,"rt":$n[2].List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial),"sn":"multiplyMaterials"},{"at":[new UnityEngine.SerializeFieldAttribute(),new UnityEngine.HideInInspector()],"a":3,"n":"requiresBlendModeMaterials","t":4,"rt":$n[0].Boolean,"sn":"requiresBlendModeMaterials","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"screenMaterials","t":4,"rt":$n[2].List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial),"sn":"screenMaterials"}]}; }, $n);
    /*Spine.Unity.BlendModeMaterials end.*/

    /*Spine.Unity.BlendModeMaterials+ReplacementMaterial start.*/
    $m("Spine.Unity.BlendModeMaterials.ReplacementMaterial", function () { return {"td":$n[5].BlendModeMaterials,"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"material","t":4,"rt":$n[1].Material,"sn":"material"},{"a":2,"n":"pageName","t":4,"rt":$n[0].String,"sn":"pageName"}]}; }, $n);
    /*Spine.Unity.BlendModeMaterials+ReplacementMaterial end.*/

    /*Spine.Unity.BlendModeMaterials+TemplateMaterials start.*/
    $m("Spine.Unity.BlendModeMaterials.TemplateMaterials", function () { return {"td":$n[5].BlendModeMaterials,"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"additiveTemplate","t":4,"rt":$n[1].Material,"sn":"additiveTemplate"},{"a":2,"n":"multiplyTemplate","t":4,"rt":$n[1].Material,"sn":"multiplyTemplate"},{"a":2,"n":"screenTemplate","t":4,"rt":$n[1].Material,"sn":"screenTemplate"}]}; }, $n);
    /*Spine.Unity.BlendModeMaterials+TemplateMaterials end.*/

    /*Spine.Unity.EventDataReferenceAsset start.*/
    $m("Spine.Unity.EventDataReferenceAsset", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Spine/EventData Reference Asset", order: 100
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"a":2,"n":"op_Implicit","is":true,"t":8,"pi":[{"n":"asset","pt":$n[5].EventDataReferenceAsset,"ps":0}],"sn":"op_Implicit","rt":$n[8].EventData,"p":[$n[5].EventDataReferenceAsset]},{"a":2,"n":"EventData","t":16,"rt":$n[8].EventData,"g":{"a":2,"n":"get_EventData","t":8,"rt":$n[8].EventData,"fg":"EventData"},"fn":"EventData"},{"a":1,"n":"QuietSkeletonData","is":true,"t":4,"rt":$n[0].Boolean,"sn":"QuietSkeletonData","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"eventData","t":4,"rt":$n[8].EventData,"sn":"eventData"},{"at":[new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineEvent("", "skeletonDataAsset", true, false, false)],"a":3,"n":"eventName","t":4,"rt":$n[0].String,"sn":"eventName"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"skeletonDataAsset","t":4,"rt":$n[5].SkeletonDataAsset,"sn":"skeletonDataAsset"}]}; }, $n);
    /*Spine.Unity.EventDataReferenceAsset end.*/

    /*Spine.Unity.OnDemandTextureLoader start.*/
    $m("Spine.Unity.OnDemandTextureLoader", function () { return {"nested":[Function],"att":1048705,"a":2,"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ab":true,"a":2,"n":"AssignPlaceholderTextures","t":8,"pi":[{"n":"modifiedMaterials","out":true,"pt":$n[2].IEnumerable$1(UnityEngine.Material),"ps":0}],"sn":"AssignPlaceholderTextures","rt":$n[0].Boolean,"p":[$n[2].IEnumerable$1(UnityEngine.Material)],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"ab":true,"a":2,"n":"AssignTargetTextures","t":8,"pi":[{"n":"modifiedMaterials","out":true,"pt":$n[2].IEnumerable$1(UnityEngine.Material),"ps":0}],"sn":"AssignTargetTextures","rt":$n[0].Boolean,"p":[$n[2].IEnumerable$1(UnityEngine.Material)],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"ab":true,"a":2,"n":"BeginCustomTextureLoading","t":8,"sn":"BeginCustomTextureLoading","rt":$n[0].Void},{"ab":true,"a":2,"n":"Clear","t":8,"pi":[{"n":"clearAtlasAsset","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"Clear","rt":$n[0].Void,"p":[$n[0].Boolean]},{"ab":true,"a":2,"n":"EndCustomTextureLoading","t":8,"sn":"EndCustomTextureLoading","rt":$n[0].Void},{"ab":true,"a":2,"n":"GetPlaceholderTextureName","t":8,"pi":[{"n":"originalTextureName","pt":$n[0].String,"ps":0}],"sn":"GetPlaceholderTextureName","rt":$n[0].String,"p":[$n[0].String]},{"v":true,"a":2,"n":"HasNullMainTexturesAssigned","t":8,"pi":[{"n":"nullTextureMaterials","out":true,"pt":$n[2].List$1(UnityEngine.Material),"ps":0}],"sn":"HasNullMainTexturesAssigned","rt":$n[0].Boolean,"p":[$n[2].List$1(UnityEngine.Material)],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"ab":true,"a":2,"n":"HasPlaceholderAssigned","t":8,"pi":[{"n":"material","pt":$n[1].Material,"ps":0}],"sn":"HasPlaceholderAssigned","rt":$n[0].Boolean,"p":[$n[1].Material],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"ab":true,"a":2,"n":"HasPlaceholderTexturesAssigned","t":8,"pi":[{"n":"placeholderMaterials","out":true,"pt":$n[2].List$1(UnityEngine.Material),"ps":0}],"sn":"HasPlaceholderTexturesAssigned","rt":$n[0].Boolean,"p":[$n[2].List$1(UnityEngine.Material)],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"OnTextureLoadFailed","t":8,"pi":[{"n":"material","pt":$n[1].Material,"ps":0},{"n":"textureIndex","pt":$n[0].Int32,"ps":1}],"sn":"OnTextureLoadFailed","rt":$n[0].Void,"p":[$n[1].Material,$n[0].Int32]},{"a":3,"n":"OnTextureLoaded","t":8,"pi":[{"n":"material","pt":$n[1].Material,"ps":0},{"n":"textureIndex","pt":$n[0].Int32,"ps":1}],"sn":"OnTextureLoaded","rt":$n[0].Void,"p":[$n[1].Material,$n[0].Int32]},{"a":3,"n":"OnTextureRequested","t":8,"pi":[{"n":"material","pt":$n[1].Material,"ps":0},{"n":"textureIndex","pt":$n[0].Int32,"ps":1}],"sn":"OnTextureRequested","rt":$n[0].Void,"p":[$n[1].Material,$n[0].Int32]},{"a":3,"n":"OnTextureUnloaded","t":8,"pi":[{"n":"material","pt":$n[1].Material,"ps":0},{"n":"textureIndex","pt":$n[0].Int32,"ps":1}],"sn":"OnTextureUnloaded","rt":$n[0].Void,"p":[$n[1].Material,$n[0].Int32]},{"ab":true,"a":2,"n":"RequestLoadMaterialTextures","t":8,"pi":[{"n":"material","pt":$n[1].Material,"ps":0},{"n":"overrideMaterial","ref":true,"pt":$n[1].Material,"ps":1}],"sn":"RequestLoadMaterialTextures","rt":$n[0].Void,"p":[$n[1].Material,$n[1].Material]},{"ab":true,"a":2,"n":"RequestLoadTexture","t":8,"pi":[{"n":"placeholderTexture","pt":$n[1].Texture,"ps":0},{"n":"replacementTexture","ref":true,"pt":$n[1].Texture,"ps":1},{"n":"onTextureLoaded","dv":null,"o":true,"pt":Function,"ps":2}],"sn":"RequestLoadTexture","rt":$n[0].Void,"p":[$n[1].Texture,$n[1].Texture,Function]},{"a":2,"n":"atlasAsset","t":4,"rt":$n[5].AtlasAssetBase,"sn":"atlasAsset"},{"a":2,"n":"TextureLoadFailed","t":2,"ad":{"a":2,"n":"add_TextureLoadFailed","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addTextureLoadFailed","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_TextureLoadFailed","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeTextureLoadFailed","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"TextureLoaded","t":2,"ad":{"a":2,"n":"add_TextureLoaded","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addTextureLoaded","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_TextureLoaded","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeTextureLoaded","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"TextureRequested","t":2,"ad":{"a":2,"n":"add_TextureRequested","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addTextureRequested","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_TextureRequested","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeTextureRequested","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"TextureUnloaded","t":2,"ad":{"a":2,"n":"add_TextureUnloaded","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addTextureUnloaded","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_TextureUnloaded","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeTextureUnloaded","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"onTextureLoadFailed","t":2,"ad":{"a":3,"n":"add_onTextureLoadFailed","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addonTextureLoadFailed","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove_onTextureLoadFailed","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeonTextureLoadFailed","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"onTextureLoaded","t":2,"ad":{"a":3,"n":"add_onTextureLoaded","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addonTextureLoaded","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove_onTextureLoaded","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeonTextureLoaded","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"onTextureRequested","t":2,"ad":{"a":3,"n":"add_onTextureRequested","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addonTextureRequested","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove_onTextureRequested","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeonTextureRequested","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"onTextureUnloaded","t":2,"ad":{"a":3,"n":"add_onTextureUnloaded","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addonTextureUnloaded","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove_onTextureUnloaded","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeonTextureUnloaded","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.OnDemandTextureLoader end.*/

    /*Spine.Unity.RegionlessAttachmentLoader start.*/
    $m("Spine.Unity.RegionlessAttachmentLoader", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"NewBoundingBoxAttachment","t":8,"pi":[{"n":"skin","pt":$n[8].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"NewBoundingBoxAttachment","rt":$n[8].BoundingBoxAttachment,"p":[$n[8].Skin,$n[0].String]},{"a":2,"n":"NewClippingAttachment","t":8,"pi":[{"n":"skin","pt":$n[8].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"NewClippingAttachment","rt":$n[8].ClippingAttachment,"p":[$n[8].Skin,$n[0].String]},{"a":2,"n":"NewMeshAttachment","t":8,"pi":[{"n":"skin","pt":$n[8].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"path","pt":$n[0].String,"ps":2},{"n":"sequence","pt":$n[8].Sequence,"ps":3}],"sn":"NewMeshAttachment","rt":$n[8].MeshAttachment,"p":[$n[8].Skin,$n[0].String,$n[0].String,$n[8].Sequence]},{"a":2,"n":"NewPathAttachment","t":8,"pi":[{"n":"skin","pt":$n[8].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"NewPathAttachment","rt":$n[8].PathAttachment,"p":[$n[8].Skin,$n[0].String]},{"a":2,"n":"NewPointAttachment","t":8,"pi":[{"n":"skin","pt":$n[8].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"NewPointAttachment","rt":$n[8].PointAttachment,"p":[$n[8].Skin,$n[0].String]},{"a":2,"n":"NewRegionAttachment","t":8,"pi":[{"n":"skin","pt":$n[8].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"path","pt":$n[0].String,"ps":2},{"n":"sequence","pt":$n[8].Sequence,"ps":3}],"sn":"NewRegionAttachment","rt":$n[8].RegionAttachment,"p":[$n[8].Skin,$n[0].String,$n[0].String,$n[8].Sequence]},{"a":1,"n":"EmptyRegion","is":true,"t":16,"rt":$n[8].AtlasRegion,"g":{"a":1,"n":"get_EmptyRegion","t":8,"rt":$n[8].AtlasRegion,"fg":"EmptyRegion","is":true},"fn":"EmptyRegion"},{"a":1,"n":"emptyRegion","is":true,"t":4,"rt":$n[8].AtlasRegion,"sn":"emptyRegion"}]}; }, $n);
    /*Spine.Unity.RegionlessAttachmentLoader end.*/

    /*Spine.Unity.SkeletonDataAsset start.*/
    $m("Spine.Unity.SkeletonDataAsset", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        fileName: "New SkeletonDataAsset", menuName: "Spine/SkeletonData Asset"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"CreateRuntimeInstance","is":true,"t":8,"pi":[{"n":"skeletonDataFile","pt":$n[1].TextAsset,"ps":0},{"n":"atlasAsset","pt":$n[5].AtlasAssetBase,"ps":1},{"n":"initialize","pt":$n[0].Boolean,"ps":2},{"n":"scale","dv":0.01,"o":true,"pt":$n[0].Single,"ps":3}],"sn":"CreateRuntimeInstance","rt":$n[5].SkeletonDataAsset,"p":[$n[1].TextAsset,$n[5].AtlasAssetBase,$n[0].Boolean,$n[0].Single]},{"a":2,"n":"CreateRuntimeInstance","is":true,"t":8,"pi":[{"n":"skeletonDataFile","pt":$n[1].TextAsset,"ps":0},{"n":"atlasAssets","pt":System.Array.type(Spine.Unity.AtlasAssetBase),"ps":1},{"n":"initialize","pt":$n[0].Boolean,"ps":2},{"n":"scale","dv":0.01,"o":true,"pt":$n[0].Single,"ps":3}],"sn":"CreateRuntimeInstance$1","rt":$n[5].SkeletonDataAsset,"p":[$n[1].TextAsset,System.Array.type(Spine.Unity.AtlasAssetBase),$n[0].Boolean,$n[0].Single]},{"a":2,"n":"FillStateData","t":8,"pi":[{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"FillStateData","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":2,"n":"GetAnimationStateData","t":8,"sn":"GetAnimationStateData","rt":$n[8].AnimationStateData},{"a":4,"n":"GetAtlasArray","t":8,"sn":"GetAtlasArray","rt":System.Array.type(Spine.Atlas)},{"a":2,"n":"GetSkeletonData","t":8,"pi":[{"n":"quiet","pt":$n[0].Boolean,"ps":0}],"sn":"GetSkeletonData","rt":$n[8].SkeletonData,"p":[$n[0].Boolean]},{"a":4,"n":"InitializeWithData","t":8,"pi":[{"n":"sd","pt":$n[8].SkeletonData,"ps":0}],"sn":"InitializeWithData","rt":$n[0].Void,"p":[$n[8].SkeletonData]},{"a":4,"n":"ReadSkeletonData","is":true,"t":8,"pi":[{"n":"bytes","pt":$n[0].Array.type(System.Byte),"ps":0},{"n":"attachmentLoader","pt":$n[8].AttachmentLoader,"ps":1},{"n":"scale","pt":$n[0].Single,"ps":2}],"sn":"ReadSkeletonData","rt":$n[8].SkeletonData,"p":[$n[0].Array.type(System.Byte),$n[8].AttachmentLoader,$n[0].Single]},{"a":4,"n":"ReadSkeletonData","is":true,"t":8,"pi":[{"n":"text","pt":$n[0].String,"ps":0},{"n":"attachmentLoader","pt":$n[8].AttachmentLoader,"ps":1},{"n":"scale","pt":$n[0].Single,"ps":2}],"sn":"ReadSkeletonData$1","rt":$n[8].SkeletonData,"p":[$n[0].String,$n[8].AttachmentLoader,$n[0].Single]},{"a":1,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"a":2,"n":"SetupRuntimeBlendModeMaterials","t":8,"pi":[{"n":"applyAdditiveMaterial","pt":$n[0].Boolean,"ps":0},{"n":"templateMaterials","pt":$n[5].BlendModeMaterials.TemplateMaterials,"ps":1}],"sn":"SetupRuntimeBlendModeMaterials","rt":$n[0].Void,"p":[$n[0].Boolean,$n[5].BlendModeMaterials.TemplateMaterials]},{"a":2,"n":"IsLoaded","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsLoaded","t":8,"rt":$n[0].Boolean,"fg":"IsLoaded","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsLoaded"},{"a":2,"n":"atlasAssets","t":4,"rt":System.Array.type(Spine.Unity.AtlasAssetBase),"sn":"atlasAssets"},{"a":2,"n":"blendModeMaterials","t":4,"rt":$n[5].BlendModeMaterials,"sn":"blendModeMaterials"},{"a":2,"n":"controller","t":4,"rt":$n[1].RuntimeAnimatorController,"sn":"controller"},{"a":2,"n":"defaultMix","t":4,"rt":$n[0].Single,"sn":"defaultMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"duration","t":4,"rt":$n[0].Array.type(System.Single),"sn":"duration"},{"at":[new Spine.Unity.SpineAnimation("", "", false, false, false)],"a":2,"n":"fromAnimation","t":4,"rt":$n[0].Array.type(System.String),"sn":"fromAnimation"},{"a":2,"n":"isUpgradingBlendModeMaterials","t":4,"rt":$n[0].Boolean,"sn":"isUpgradingBlendModeMaterials","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"scale","t":4,"rt":$n[0].Single,"sn":"scale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"skeletonData","t":4,"rt":$n[8].SkeletonData,"sn":"skeletonData"},{"at":[new UnityEngine.TooltipAttribute("Use SkeletonDataModifierAssets to apply changes to the SkeletonData after being loaded, such as apply blend mode Materials to Attachments under slots with special blend modes.")],"a":2,"n":"skeletonDataModifiers","t":4,"rt":$n[2].List$1(Spine.Unity.SkeletonDataModifierAsset),"sn":"skeletonDataModifiers"},{"a":2,"n":"skeletonJSON","t":4,"rt":$n[1].TextAsset,"sn":"skeletonJSON"},{"a":1,"n":"stateData","t":4,"rt":$n[8].AnimationStateData,"sn":"stateData"},{"at":[new Spine.Unity.SpineAnimation("", "", false, false, false)],"a":2,"n":"toAnimation","t":4,"rt":$n[0].Array.type(System.String),"sn":"toAnimation"}]}; }, $n);
    /*Spine.Unity.SkeletonDataAsset end.*/

    /*Spine.Unity.SkeletonDataCompatibility start.*/
    $m("Spine.Unity.SkeletonDataCompatibility", function () { return {"nested":[$n[5].SkeletonDataCompatibility.SourceType,$n[5].SkeletonDataCompatibility.VersionInfo,$n[5].SkeletonDataCompatibility.CompatibilityProblemInfo],"att":1048961,"a":2,"s":true}; }, $n);
    /*Spine.Unity.SkeletonDataCompatibility end.*/

    /*Spine.Unity.SkeletonDataCompatibility+SourceType start.*/
    $m("Spine.Unity.SkeletonDataCompatibility.SourceType", function () { return {"td":$n[5].SkeletonDataCompatibility,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Binary","is":true,"t":4,"rt":$n[5].SkeletonDataCompatibility.SourceType,"sn":"Binary","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonDataCompatibility.SourceType, System.Enum.toStringFn(Spine.Unity.SkeletonDataCompatibility.SourceType));}},{"a":2,"n":"Json","is":true,"t":4,"rt":$n[5].SkeletonDataCompatibility.SourceType,"sn":"Json","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonDataCompatibility.SourceType, System.Enum.toStringFn(Spine.Unity.SkeletonDataCompatibility.SourceType));}}]}; }, $n);
    /*Spine.Unity.SkeletonDataCompatibility+SourceType end.*/

    /*Spine.Unity.SkeletonDataCompatibility+VersionInfo start.*/
    $m("Spine.Unity.SkeletonDataCompatibility.VersionInfo", function () { return {"td":$n[5].SkeletonDataCompatibility,"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"rawVersion","t":4,"rt":$n[0].String,"sn":"rawVersion"},{"a":2,"n":"sourceType","t":4,"rt":$n[5].SkeletonDataCompatibility.SourceType,"sn":"sourceType","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonDataCompatibility.SourceType, System.Enum.toStringFn(Spine.Unity.SkeletonDataCompatibility.SourceType));}},{"a":2,"n":"version","t":4,"rt":$n[0].Array.type(System.Int32),"sn":"version"}]}; }, $n);
    /*Spine.Unity.SkeletonDataCompatibility+VersionInfo end.*/

    /*Spine.Unity.SkeletonDataCompatibility+CompatibilityProblemInfo start.*/
    $m("Spine.Unity.SkeletonDataCompatibility.CompatibilityProblemInfo", function () { return {"td":$n[5].SkeletonDataCompatibility,"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"DescriptionString","t":8,"sn":"DescriptionString","rt":$n[0].String},{"a":2,"n":"actualVersion","t":4,"rt":$n[5].SkeletonDataCompatibility.VersionInfo,"sn":"actualVersion"},{"a":2,"n":"compatibleVersions","t":4,"rt":$n[0].Array.type(System.Array.type(System.Int32)),"sn":"compatibleVersions"},{"a":2,"n":"explicitProblemDescription","t":4,"rt":$n[0].String,"sn":"explicitProblemDescription"}]}; }, $n);
    /*Spine.Unity.SkeletonDataCompatibility+CompatibilityProblemInfo end.*/

    /*Spine.Unity.SkeletonDataModifierAsset start.*/
    $m("Spine.Unity.SkeletonDataModifierAsset", function () { return {"att":1048705,"a":2,"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ab":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeletonData","pt":$n[8].SkeletonData,"ps":0}],"sn":"Apply","rt":$n[0].Void,"p":[$n[8].SkeletonData]}]}; }, $n);
    /*Spine.Unity.SkeletonDataModifierAsset end.*/

    /*Spine.Unity.SpineAtlasAsset start.*/
    $m("Spine.Unity.SpineAtlasAsset", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        fileName: "New Spine Atlas Asset", menuName: "Spine/Spine Atlas Asset"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"CreateRuntimeInstance","is":true,"t":8,"pi":[{"n":"atlasText","pt":$n[1].TextAsset,"ps":0},{"n":"materials","pt":System.Array.type(UnityEngine.Material),"ps":1},{"n":"initialize","pt":$n[0].Boolean,"ps":2},{"n":"newCustomTextureLoader","dv":null,"o":true,"pt":Function,"ps":3}],"sn":"CreateRuntimeInstance","rt":$n[5].SpineAtlasAsset,"p":[$n[1].TextAsset,System.Array.type(UnityEngine.Material),$n[0].Boolean,Function]},{"a":2,"n":"CreateRuntimeInstance","is":true,"t":8,"pi":[{"n":"atlasText","pt":$n[1].TextAsset,"ps":0},{"n":"textures","pt":System.Array.type(UnityEngine.Texture2D),"ps":1},{"n":"shader","pt":$n[1].Shader,"ps":2},{"n":"initialize","pt":$n[0].Boolean,"ps":3},{"n":"newCustomTextureLoader","dv":null,"o":true,"pt":Function,"ps":4}],"sn":"CreateRuntimeInstance$2","rt":$n[5].SpineAtlasAsset,"p":[$n[1].TextAsset,System.Array.type(UnityEngine.Texture2D),$n[1].Shader,$n[0].Boolean,Function]},{"a":2,"n":"CreateRuntimeInstance","is":true,"t":8,"pi":[{"n":"atlasText","pt":$n[1].TextAsset,"ps":0},{"n":"textures","pt":System.Array.type(UnityEngine.Texture2D),"ps":1},{"n":"materialPropertySource","pt":$n[1].Material,"ps":2},{"n":"initialize","pt":$n[0].Boolean,"ps":3},{"n":"newCustomTextureLoader","dv":null,"o":true,"pt":Function,"ps":4},{"n":"renameMaterial","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"CreateRuntimeInstance$1","rt":$n[5].SpineAtlasAsset,"p":[$n[1].TextAsset,System.Array.type(UnityEngine.Texture2D),$n[1].Material,$n[0].Boolean,Function,$n[0].Boolean]},{"a":2,"n":"GenerateMesh","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0},{"n":"mesh","pt":$n[1].Mesh,"ps":1},{"n":"material","out":true,"pt":$n[1].Material,"ps":2},{"n":"scale","dv":0.01,"o":true,"pt":$n[0].Single,"ps":3}],"sn":"GenerateMesh","rt":$n[1].Mesh,"p":[$n[0].String,$n[1].Mesh,$n[1].Material,$n[0].Single]},{"ov":true,"a":2,"n":"GetAtlas","t":8,"pi":[{"n":"onlyMetaData","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"GetAtlas","rt":$n[8].Atlas,"p":[$n[0].Boolean]},{"a":1,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"ov":true,"a":2,"n":"IsLoaded","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_IsLoaded","t":8,"rt":$n[0].Boolean,"fg":"IsLoaded","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsLoaded"},{"ov":true,"a":2,"n":"MaterialCount","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_MaterialCount","t":8,"rt":$n[0].Int32,"fg":"MaterialCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"MaterialCount"},{"ov":true,"a":2,"n":"Materials","t":16,"rt":$n[2].IEnumerable$1(UnityEngine.Material),"g":{"ov":true,"a":2,"n":"get_Materials","t":8,"rt":$n[2].IEnumerable$1(UnityEngine.Material),"fg":"Materials"},"fn":"Materials"},{"ov":true,"a":2,"n":"PrimaryMaterial","t":16,"rt":$n[1].Material,"g":{"ov":true,"a":2,"n":"get_PrimaryMaterial","t":8,"rt":$n[1].Material,"fg":"PrimaryMaterial"},"fn":"PrimaryMaterial"},{"a":3,"n":"atlas","t":4,"rt":$n[8].Atlas,"sn":"atlas"},{"a":2,"n":"atlasFile","t":4,"rt":$n[1].TextAsset,"sn":"atlasFile"},{"a":2,"n":"customTextureLoader","t":4,"rt":$n[8].TextureLoader,"sn":"customTextureLoader"},{"a":2,"n":"materials","t":4,"rt":System.Array.type(UnityEngine.Material),"sn":"materials"}]}; }, $n);
    /*Spine.Unity.SpineAtlasAsset end.*/

    /*Spine.Unity.NoOpTextureLoader start.*/
    $m("Spine.Unity.NoOpTextureLoader", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Load","t":8,"pi":[{"n":"page","pt":$n[8].AtlasPage,"ps":0},{"n":"path","pt":$n[0].String,"ps":1}],"sn":"Load","rt":$n[0].Void,"p":[$n[8].AtlasPage,$n[0].String]},{"a":2,"n":"Unload","t":8,"pi":[{"n":"texture","pt":$n[0].Object,"ps":0}],"sn":"Unload","rt":$n[0].Void,"p":[$n[0].Object]}]}; }, $n);
    /*Spine.Unity.NoOpTextureLoader end.*/

    /*Spine.Unity.MaterialsTextureLoader start.*/
    $m("Spine.Unity.MaterialsTextureLoader", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[5].SpineAtlasAsset],"pi":[{"n":"atlasAsset","pt":$n[5].SpineAtlasAsset,"ps":0}],"sn":"ctor"},{"a":2,"n":"Load","t":8,"pi":[{"n":"page","pt":$n[8].AtlasPage,"ps":0},{"n":"path","pt":$n[0].String,"ps":1}],"sn":"Load","rt":$n[0].Void,"p":[$n[8].AtlasPage,$n[0].String]},{"a":2,"n":"Unload","t":8,"pi":[{"n":"texture","pt":$n[0].Object,"ps":0}],"sn":"Unload","rt":$n[0].Void,"p":[$n[0].Object]},{"a":1,"n":"atlasAsset","t":4,"rt":$n[5].SpineAtlasAsset,"sn":"atlasAsset"}]}; }, $n);
    /*Spine.Unity.MaterialsTextureLoader end.*/

    /*Spine.Unity.SpineSpriteAtlasAsset start.*/
    $m("Spine.Unity.SpineSpriteAtlasAsset", function () { return {"nested":[$n[5].SpineSpriteAtlasAsset.SavedRegionInfo],"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        fileName: "New Spine SpriteAtlas Asset", menuName: "Spine/Spine SpriteAtlas Asset"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AccessPackedSprites","is":true,"t":8,"pi":[{"n":"spriteAtlas","pt":$n[10].SpriteAtlas,"ps":0}],"sn":"AccessPackedSprites","rt":System.Array.type(UnityEngine.Sprite),"p":[$n[10].SpriteAtlas]},{"a":2,"n":"AccessPackedTexture","is":true,"t":8,"pi":[{"n":"sprites","pt":System.Array.type(UnityEngine.Sprite),"ps":0}],"sn":"AccessPackedTexture","rt":$n[1].Texture2D,"p":[System.Array.type(UnityEngine.Sprite)]},{"a":3,"n":"AssignRegionsFromSavedRegions","t":8,"pi":[{"n":"sprites","pt":System.Array.type(UnityEngine.Sprite),"ps":0},{"n":"usedAtlas","pt":$n[8].Atlas,"ps":1}],"sn":"AssignRegionsFromSavedRegions","rt":$n[0].Void,"p":[System.Array.type(UnityEngine.Sprite),$n[8].Atlas]},{"ov":true,"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"CreateRuntimeInstance","is":true,"t":8,"pi":[{"n":"spriteAtlasFile","pt":$n[10].SpriteAtlas,"ps":0},{"n":"materials","pt":System.Array.type(UnityEngine.Material),"ps":1},{"n":"initialize","pt":$n[0].Boolean,"ps":2}],"sn":"CreateRuntimeInstance","rt":$n[5].SpineSpriteAtlasAsset,"p":[$n[10].SpriteAtlas,System.Array.type(UnityEngine.Material),$n[0].Boolean]},{"ov":true,"a":2,"n":"GetAtlas","t":8,"pi":[{"n":"onlyMetaData","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"GetAtlas","rt":$n[8].Atlas,"p":[$n[0].Boolean]},{"a":1,"n":"LoadAtlas","t":8,"pi":[{"n":"spriteAtlas","pt":$n[10].SpriteAtlas,"ps":0}],"sn":"LoadAtlas","rt":$n[8].Atlas,"p":[$n[10].SpriteAtlas]},{"a":1,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"ov":true,"a":2,"n":"IsLoaded","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_IsLoaded","t":8,"rt":$n[0].Boolean,"fg":"IsLoaded","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsLoaded"},{"ov":true,"a":2,"n":"MaterialCount","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_MaterialCount","t":8,"rt":$n[0].Int32,"fg":"MaterialCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"MaterialCount"},{"ov":true,"a":2,"n":"Materials","t":16,"rt":$n[2].IEnumerable$1(UnityEngine.Material),"g":{"ov":true,"a":2,"n":"get_Materials","t":8,"rt":$n[2].IEnumerable$1(UnityEngine.Material),"fg":"Materials"},"fn":"Materials"},{"ov":true,"a":2,"n":"PrimaryMaterial","t":16,"rt":$n[1].Material,"g":{"ov":true,"a":2,"n":"get_PrimaryMaterial","t":8,"rt":$n[1].Material,"fg":"PrimaryMaterial"},"fn":"PrimaryMaterial"},{"a":3,"n":"atlas","t":4,"rt":$n[8].Atlas,"sn":"atlas"},{"a":2,"n":"materials","t":4,"rt":System.Array.type(UnityEngine.Material),"sn":"materials"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"savedRegions","t":4,"rt":System.Array.type(Spine.Unity.SpineSpriteAtlasAsset.SavedRegionInfo),"sn":"savedRegions"},{"a":2,"n":"spriteAtlasFile","t":4,"rt":$n[10].SpriteAtlas,"sn":"spriteAtlasFile"},{"a":2,"n":"updateRegionsInPlayMode","t":4,"rt":$n[0].Boolean,"sn":"updateRegionsInPlayMode","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.SpineSpriteAtlasAsset end.*/

    /*Spine.Unity.SpineSpriteAtlasAsset+SavedRegionInfo start.*/
    $m("Spine.Unity.SpineSpriteAtlasAsset.SavedRegionInfo", function () { return {"td":$n[5].SpineSpriteAtlasAsset,"att":1056772,"a":3,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"height","t":4,"rt":$n[0].Single,"sn":"height","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"packingRotation","t":4,"rt":$n[1].SpritePackingRotation,"sn":"packingRotation","box":function ($v) { return Bridge.box($v, UnityEngine.SpritePackingRotation, System.Enum.toStringFn(UnityEngine.SpritePackingRotation));}},{"a":2,"n":"width","t":4,"rt":$n[0].Single,"sn":"width","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"x","t":4,"rt":$n[0].Single,"sn":"x","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"y","t":4,"rt":$n[0].Single,"sn":"y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.Unity.SpineSpriteAtlasAsset+SavedRegionInfo end.*/

    /*Spine.Unity.BoneFollower start.*/
    $m("Spine.Unity.BoneFollower", function () { return {"nested":[$n[5].BoneFollower.AxisOrientation],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.AddComponentMenu.ctor("Spine/BoneFollower"),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#BoneFollower")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"HandleRebuildRenderer","t":8,"pi":[{"n":"skeletonRenderer","pt":$n[5].SkeletonRenderer,"ps":0}],"sn":"HandleRebuildRenderer","rt":$n[0].Void,"p":[$n[5].SkeletonRenderer]},{"v":true,"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"v":true,"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"a":2,"n":"SetBone","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"SetBone","rt":$n[0].Boolean,"p":[$n[0].String],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"SkeletonRenderer","t":16,"rt":$n[5].SkeletonRenderer,"g":{"a":2,"n":"get_SkeletonRenderer","t":8,"rt":$n[5].SkeletonRenderer,"fg":"SkeletonRenderer"},"s":{"a":2,"n":"set_SkeletonRenderer","t":8,"p":[$n[5].SkeletonRenderer],"rt":$n[0].Void,"fs":"SkeletonRenderer"},"fn":"SkeletonRenderer"},{"a":2,"n":"bone","t":4,"rt":$n[8].Bone,"sn":"bone"},{"at":[new Spine.Unity.SpineBone("", "skeletonRenderer", true, false)],"a":2,"n":"boneName","t":4,"rt":$n[0].String,"sn":"boneName"},{"a":2,"n":"followBoneRotation","t":4,"rt":$n[0].Boolean,"sn":"followBoneRotation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Follows the target bone's local scale."),new UnityEngine.Serialization.FormerlySerializedAsAttribute("followScale")],"a":2,"n":"followLocalScale","t":4,"rt":$n[0].Boolean,"sn":"followLocalScale","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Includes the parent bone's lossy world scale. BoneFollower cannot inherit rotated/skewed scale because of UnityEngine.Transform property limitations.")],"a":2,"n":"followParentWorldScale","t":4,"rt":$n[0].Boolean,"sn":"followParentWorldScale","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Follows the skeleton's flip state by controlling this Transform's local scale.")],"a":2,"n":"followSkeletonFlip","t":4,"rt":$n[0].Boolean,"sn":"followSkeletonFlip","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"followXYPosition","t":4,"rt":$n[0].Boolean,"sn":"followXYPosition","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"followZPosition","t":4,"rt":$n[0].Boolean,"sn":"followZPosition","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("resetOnAwake")],"a":2,"n":"initializeOnAwake","t":4,"rt":$n[0].Boolean,"sn":"initializeOnAwake","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Applies when 'Follow Skeleton Flip' is disabled but 'Follow Bone Rotation' is enabled. When flipping the skeleton by scaling its Transform, this follower's rotation is adjusted instead of its scale to follow the bone orientation. When one of the axes is flipped,  only one axis can be followed, either the X or the Y axis, which is selected here.")],"a":2,"n":"maintainedAxisOrientation","t":4,"rt":$n[5].BoneFollower.AxisOrientation,"sn":"maintainedAxisOrientation","box":function ($v) { return Bridge.box($v, Spine.Unity.BoneFollower.AxisOrientation, System.Enum.toStringFn(Spine.Unity.BoneFollower.AxisOrientation));}},{"a":2,"n":"skeletonRenderer","t":4,"rt":$n[5].SkeletonRenderer,"sn":"skeletonRenderer"},{"a":1,"n":"skeletonTransform","t":4,"rt":$n[1].Transform,"sn":"skeletonTransform"},{"a":1,"n":"skeletonTransformIsParent","t":4,"rt":$n[0].Boolean,"sn":"skeletonTransformIsParent","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"valid","t":4,"rt":$n[0].Boolean,"sn":"valid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.BoneFollower end.*/

    /*Spine.Unity.BoneFollower+AxisOrientation start.*/
    $m("Spine.Unity.BoneFollower.AxisOrientation", function () { return {"td":$n[5].BoneFollower,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"XAxis","is":true,"t":4,"rt":$n[5].BoneFollower.AxisOrientation,"sn":"XAxis","box":function ($v) { return Bridge.box($v, Spine.Unity.BoneFollower.AxisOrientation, System.Enum.toStringFn(Spine.Unity.BoneFollower.AxisOrientation));}},{"a":2,"n":"YAxis","is":true,"t":4,"rt":$n[5].BoneFollower.AxisOrientation,"sn":"YAxis","box":function ($v) { return Bridge.box($v, Spine.Unity.BoneFollower.AxisOrientation, System.Enum.toStringFn(Spine.Unity.BoneFollower.AxisOrientation));}}]}; }, $n);
    /*Spine.Unity.BoneFollower+AxisOrientation end.*/

    /*Spine.Unity.BoneFollowerGraphic start.*/
    $m("Spine.Unity.BoneFollowerGraphic", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.RequireComponent.ctor(UnityEngine.RectTransform),new UnityEngine.DisallowMultipleComponent(),new UnityEngine.AddComponentMenu.ctor("Spine/UI/BoneFollowerGraphic"),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#BoneFollowerGraphic")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"v":true,"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"v":true,"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":2,"n":"SetBone","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"SetBone","rt":$n[0].Boolean,"p":[$n[0].String],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"SkeletonGraphic","t":16,"rt":$n[5].SkeletonGraphic,"g":{"a":2,"n":"get_SkeletonGraphic","t":8,"rt":$n[5].SkeletonGraphic,"fg":"SkeletonGraphic"},"s":{"a":2,"n":"set_SkeletonGraphic","t":8,"p":[$n[5].SkeletonGraphic],"rt":$n[0].Void,"fs":"SkeletonGraphic"},"fn":"SkeletonGraphic"},{"a":2,"n":"bone","t":4,"rt":$n[8].Bone,"sn":"bone"},{"at":[new Spine.Unity.SpineBone("", "skeletonGraphic", true, false)],"a":2,"n":"boneName","t":4,"rt":$n[0].String,"sn":"boneName"},{"a":2,"n":"followBoneRotation","t":4,"rt":$n[0].Boolean,"sn":"followBoneRotation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Follows the target bone's local scale.")],"a":2,"n":"followLocalScale","t":4,"rt":$n[0].Boolean,"sn":"followLocalScale","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Includes the parent bone's lossy world scale. BoneFollower cannot inherit rotated/skewed scale because of UnityEngine.Transform property limitations.")],"a":2,"n":"followParentWorldScale","t":4,"rt":$n[0].Boolean,"sn":"followParentWorldScale","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Follows the skeleton's flip state by controlling this Transform's local scale.")],"a":2,"n":"followSkeletonFlip","t":4,"rt":$n[0].Boolean,"sn":"followSkeletonFlip","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"followXYPosition","t":4,"rt":$n[0].Boolean,"sn":"followXYPosition","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"followZPosition","t":4,"rt":$n[0].Boolean,"sn":"followZPosition","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"initializeOnAwake","t":4,"rt":$n[0].Boolean,"sn":"initializeOnAwake","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Applies when 'Follow Skeleton Flip' is disabled but 'Follow Bone Rotation' is enabled. When flipping the skeleton by scaling its Transform, this follower's rotation is adjusted instead of its scale to follow the bone orientation. When one of the axes is flipped,  only one axis can be followed, either the X or the Y axis, which is selected here.")],"a":2,"n":"maintainedAxisOrientation","t":4,"rt":$n[5].BoneFollower.AxisOrientation,"sn":"maintainedAxisOrientation","box":function ($v) { return Bridge.box($v, Spine.Unity.BoneFollower.AxisOrientation, System.Enum.toStringFn(Spine.Unity.BoneFollower.AxisOrientation));}},{"a":2,"n":"skeletonGraphic","t":4,"rt":$n[5].SkeletonGraphic,"sn":"skeletonGraphic"},{"a":1,"n":"skeletonTransform","t":4,"rt":$n[1].Transform,"sn":"skeletonTransform"},{"a":1,"n":"skeletonTransformIsParent","t":4,"rt":$n[0].Boolean,"sn":"skeletonTransformIsParent","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"valid","t":4,"rt":$n[0].Boolean,"sn":"valid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.BoneFollowerGraphic end.*/

    /*Spine.Unity.BoundingBoxFollower start.*/
    $m("Spine.Unity.BoundingBoxFollower", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#BoundingBoxFollower")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"AddCollidersForSkin","t":8,"pi":[{"n":"skin","pt":$n[8].Skin,"ps":0},{"n":"slotIndex","pt":$n[0].Int32,"ps":1},{"n":"previousColliders","pt":System.Array.type(UnityEngine.PolygonCollider2D),"ps":2},{"n":"collidersCount","ref":true,"pt":$n[0].Int32,"ps":3}],"sn":"AddCollidersForSkin","rt":$n[0].Void,"p":[$n[8].Skin,$n[0].Int32,System.Array.type(UnityEngine.PolygonCollider2D),$n[0].Int32]},{"a":2,"n":"ClearState","t":8,"sn":"ClearState","rt":$n[0].Void},{"a":1,"n":"DisposeExcessCollidersAfter","t":8,"pi":[{"n":"requiredCount","pt":$n[0].Int32,"ps":0}],"sn":"DisposeExcessCollidersAfter","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":1,"n":"HandleRebuild","t":8,"pi":[{"n":"sr","pt":$n[5].SkeletonRenderer,"ps":0}],"sn":"HandleRebuild","rt":$n[0].Void,"p":[$n[5].SkeletonRenderer]},{"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":1,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":1,"n":"MatchAttachment","t":8,"pi":[{"n":"attachment","pt":$n[8].Attachment,"ps":0}],"sn":"MatchAttachment","rt":$n[0].Void,"p":[$n[8].Attachment]},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"CurrentAttachment","t":16,"rt":$n[8].BoundingBoxAttachment,"g":{"a":2,"n":"get_CurrentAttachment","t":8,"rt":$n[8].BoundingBoxAttachment,"fg":"CurrentAttachment"},"fn":"CurrentAttachment"},{"a":2,"n":"CurrentAttachmentName","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_CurrentAttachmentName","t":8,"rt":$n[0].String,"fg":"CurrentAttachmentName"},"fn":"CurrentAttachmentName"},{"a":2,"n":"CurrentCollider","t":16,"rt":$n[1].PolygonCollider2D,"g":{"a":2,"n":"get_CurrentCollider","t":8,"rt":$n[1].PolygonCollider2D,"fg":"CurrentCollider"},"fn":"CurrentCollider"},{"a":2,"n":"IsTrigger","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsTrigger","t":8,"rt":$n[0].Boolean,"fg":"IsTrigger","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsTrigger"},{"a":2,"n":"Slot","t":16,"rt":$n[8].Slot,"g":{"a":2,"n":"get_Slot","t":8,"rt":$n[8].Slot,"fg":"Slot"},"fn":"Slot"},{"a":4,"n":"DebugMessages","is":true,"t":4,"rt":$n[0].Boolean,"sn":"DebugMessages","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"clearStateOnDisable","t":4,"rt":$n[0].Boolean,"sn":"clearStateOnDisable","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"colliderTable","t":4,"rt":$n[2].Dictionary$2(Spine.BoundingBoxAttachment,UnityEngine.PolygonCollider2D),"sn":"colliderTable","ro":true},{"a":1,"n":"currentAttachment","t":4,"rt":$n[8].BoundingBoxAttachment,"sn":"currentAttachment"},{"a":1,"n":"currentAttachmentName","t":4,"rt":$n[0].String,"sn":"currentAttachmentName"},{"a":1,"n":"currentCollider","t":4,"rt":$n[1].PolygonCollider2D,"sn":"currentCollider"},{"a":2,"n":"isTrigger","t":4,"rt":$n[0].Boolean,"sn":"isTrigger","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"nameTable","t":4,"rt":$n[2].Dictionary$2(Spine.BoundingBoxAttachment,System.String),"sn":"nameTable","ro":true},{"a":2,"n":"skeletonRenderer","t":4,"rt":$n[5].SkeletonRenderer,"sn":"skeletonRenderer"},{"a":1,"n":"slot","t":4,"rt":$n[8].Slot,"sn":"slot"},{"at":[new Spine.Unity.SpineSlot("", "skeletonRenderer", true, true, false)],"a":2,"n":"slotName","t":4,"rt":$n[0].String,"sn":"slotName"},{"a":2,"n":"usedByComposite","t":4,"rt":$n[0].Boolean,"sn":"usedByComposite","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"usedByEffector","t":4,"rt":$n[0].Boolean,"sn":"usedByEffector","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.BoundingBoxFollower end.*/

    /*Spine.Unity.BoundingBoxFollowerGraphic start.*/
    $m("Spine.Unity.BoundingBoxFollowerGraphic", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#BoundingBoxFollowerGraphic")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"AddCollidersForSkin","t":8,"pi":[{"n":"skin","pt":$n[8].Skin,"ps":0},{"n":"slotIndex","pt":$n[0].Int32,"ps":1},{"n":"previousColliders","pt":System.Array.type(UnityEngine.PolygonCollider2D),"ps":2},{"n":"scale","pt":$n[0].Single,"ps":3},{"n":"collidersCount","ref":true,"pt":$n[0].Int32,"ps":4}],"sn":"AddCollidersForSkin","rt":$n[0].Void,"p":[$n[8].Skin,$n[0].Int32,System.Array.type(UnityEngine.PolygonCollider2D),$n[0].Single,$n[0].Int32]},{"a":2,"n":"ClearState","t":8,"sn":"ClearState","rt":$n[0].Void},{"a":1,"n":"DisposeExcessCollidersAfter","t":8,"pi":[{"n":"requiredCount","pt":$n[0].Int32,"ps":0}],"sn":"DisposeExcessCollidersAfter","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":1,"n":"HandleRebuild","t":8,"pi":[{"n":"sr","pt":$n[5].SkeletonGraphic,"ps":0}],"sn":"HandleRebuild","rt":$n[0].Void,"p":[$n[5].SkeletonGraphic]},{"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":1,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":1,"n":"MatchAttachment","t":8,"pi":[{"n":"attachment","pt":$n[8].Attachment,"ps":0}],"sn":"MatchAttachment","rt":$n[0].Void,"p":[$n[8].Attachment]},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"CurrentAttachment","t":16,"rt":$n[8].BoundingBoxAttachment,"g":{"a":2,"n":"get_CurrentAttachment","t":8,"rt":$n[8].BoundingBoxAttachment,"fg":"CurrentAttachment"},"fn":"CurrentAttachment"},{"a":2,"n":"CurrentAttachmentName","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_CurrentAttachmentName","t":8,"rt":$n[0].String,"fg":"CurrentAttachmentName"},"fn":"CurrentAttachmentName"},{"a":2,"n":"CurrentCollider","t":16,"rt":$n[1].PolygonCollider2D,"g":{"a":2,"n":"get_CurrentCollider","t":8,"rt":$n[1].PolygonCollider2D,"fg":"CurrentCollider"},"fn":"CurrentCollider"},{"a":2,"n":"IsTrigger","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsTrigger","t":8,"rt":$n[0].Boolean,"fg":"IsTrigger","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsTrigger"},{"a":2,"n":"Slot","t":16,"rt":$n[8].Slot,"g":{"a":2,"n":"get_Slot","t":8,"rt":$n[8].Slot,"fg":"Slot"},"fn":"Slot"},{"a":4,"n":"DebugMessages","is":true,"t":4,"rt":$n[0].Boolean,"sn":"DebugMessages","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"clearStateOnDisable","t":4,"rt":$n[0].Boolean,"sn":"clearStateOnDisable","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"colliderTable","t":4,"rt":$n[2].Dictionary$2(Spine.BoundingBoxAttachment,UnityEngine.PolygonCollider2D),"sn":"colliderTable","ro":true},{"a":1,"n":"currentAttachment","t":4,"rt":$n[8].BoundingBoxAttachment,"sn":"currentAttachment"},{"a":1,"n":"currentAttachmentName","t":4,"rt":$n[0].String,"sn":"currentAttachmentName"},{"a":1,"n":"currentCollider","t":4,"rt":$n[1].PolygonCollider2D,"sn":"currentCollider"},{"a":2,"n":"isTrigger","t":4,"rt":$n[0].Boolean,"sn":"isTrigger","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"nameTable","t":4,"rt":$n[2].Dictionary$2(Spine.BoundingBoxAttachment,System.String),"sn":"nameTable","ro":true},{"a":2,"n":"skeletonGraphic","t":4,"rt":$n[5].SkeletonGraphic,"sn":"skeletonGraphic"},{"a":1,"n":"slot","t":4,"rt":$n[8].Slot,"sn":"slot"},{"at":[new Spine.Unity.SpineSlot("", "skeletonGraphic", true, true, false)],"a":2,"n":"slotName","t":4,"rt":$n[0].String,"sn":"slotName"},{"a":2,"n":"usedByComposite","t":4,"rt":$n[0].Boolean,"sn":"usedByComposite","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"usedByEffector","t":4,"rt":$n[0].Boolean,"sn":"usedByEffector","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.BoundingBoxFollowerGraphic end.*/

    /*Spine.Unity.PointFollower start.*/
    $m("Spine.Unity.PointFollower", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.AddComponentMenu.ctor("Spine/Point Follower"),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#PointFollower")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"HandleRebuildRenderer","t":8,"pi":[{"n":"skeletonRenderer","pt":$n[5].SkeletonRenderer,"ps":0}],"sn":"HandleRebuildRenderer","rt":$n[0].Void,"p":[$n[5].SkeletonRenderer]},{"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"a":1,"n":"UpdateReferences","t":8,"sn":"UpdateReferences","rt":$n[0].Void},{"a":2,"n":"IsValid","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsValid","t":8,"rt":$n[0].Boolean,"fg":"IsValid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsValid"},{"a":2,"n":"SkeletonComponent","t":16,"rt":$n[5].ISkeletonComponent,"g":{"a":2,"n":"get_SkeletonComponent","t":8,"rt":$n[5].ISkeletonComponent,"fg":"SkeletonComponent"},"fn":"SkeletonComponent"},{"a":2,"n":"SkeletonRenderer","t":16,"rt":$n[5].SkeletonRenderer,"g":{"a":2,"n":"get_SkeletonRenderer","t":8,"rt":$n[5].SkeletonRenderer,"fg":"SkeletonRenderer"},"fn":"SkeletonRenderer"},{"a":1,"n":"bone","t":4,"rt":$n[8].Bone,"sn":"bone"},{"a":2,"n":"followRotation","t":4,"rt":$n[0].Boolean,"sn":"followRotation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"followSkeletonFlip","t":4,"rt":$n[0].Boolean,"sn":"followSkeletonFlip","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"followSkeletonZPosition","t":4,"rt":$n[0].Boolean,"sn":"followSkeletonZPosition","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"point","t":4,"rt":$n[8].PointAttachment,"sn":"point"},{"at":[new Spine.Unity.SpineAttachment(true, false, false, "slotName", "skeletonRenderer", "", true, true)],"a":2,"n":"pointAttachmentName","t":4,"rt":$n[0].String,"sn":"pointAttachmentName"},{"a":2,"n":"skeletonRenderer","t":4,"rt":$n[5].SkeletonRenderer,"sn":"skeletonRenderer"},{"a":1,"n":"skeletonTransform","t":4,"rt":$n[1].Transform,"sn":"skeletonTransform"},{"a":1,"n":"skeletonTransformIsParent","t":4,"rt":$n[0].Boolean,"sn":"skeletonTransformIsParent","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new Spine.Unity.SpineSlot("", "skeletonRenderer", false, true, false)],"a":2,"n":"slotName","t":4,"rt":$n[0].String,"sn":"slotName"},{"a":1,"n":"valid","t":4,"rt":$n[0].Boolean,"sn":"valid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.PointFollower end.*/

    /*Spine.Unity.SkeletonSubmeshGraphic start.*/
    $m("Spine.Unity.SkeletonSubmeshGraphic", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.ctor(UnityEngine.CanvasRenderer)],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":3,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"ov":true,"a":3,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"ov":true,"a":3,"n":"OnPopulateMesh","t":8,"pi":[{"n":"vh","pt":$n[4].VertexHelper,"ps":0}],"sn":"OnPopulateMesh","rt":$n[0].Void,"p":[$n[4].VertexHelper]},{"ov":true,"a":2,"n":"SetMaterialDirty","t":8,"sn":"SetMaterialDirty","rt":$n[0].Void},{"ov":true,"a":2,"n":"SetVerticesDirty","t":8,"sn":"SetVerticesDirty","rt":$n[0].Void}]}; }, $n);
    /*Spine.Unity.SkeletonSubmeshGraphic end.*/

    /*Spine.Unity.SkeletonMecanimRootMotion start.*/
    $m("Spine.Unity.SkeletonMecanimRootMotion", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonMecanimRootMotion")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":3,"n":"CalculateAnimationsMovementDelta","t":8,"sn":"CalculateAnimationsMovementDelta","rt":$n[1].Vector2},{"ov":true,"a":3,"n":"CalculateAnimationsRotationDelta","t":8,"sn":"CalculateAnimationsRotationDelta","rt":$n[0].Single,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"ov":true,"a":2,"n":"GetRemainingRootMotion","t":8,"pi":[{"n":"layerIndex","pt":$n[0].Int32,"ps":0}],"sn":"GetRemainingRootMotion","rt":$n[1].Vector2,"p":[$n[0].Int32]},{"ov":true,"a":2,"n":"GetRootMotionInfo","t":8,"pi":[{"n":"layerIndex","pt":$n[0].Int32,"ps":0}],"sn":"GetRootMotionInfo","rt":$n[5].SkeletonRootMotionBase.RootMotionInfo,"p":[$n[0].Int32]},{"ov":true,"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"a":1,"n":"OnClipApplied","t":8,"pi":[{"n":"animation","pt":$n[8].Animation,"ps":0},{"n":"layerIndex","pt":$n[0].Int32,"ps":1},{"n":"weight","pt":$n[0].Single,"ps":2},{"n":"time","pt":$n[0].Single,"ps":3},{"n":"lastTime","pt":$n[0].Single,"ps":4},{"n":"playsBackward","pt":$n[0].Boolean,"ps":5}],"sn":"OnClipApplied","rt":$n[0].Void,"p":[$n[8].Animation,$n[0].Int32,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"ov":true,"a":3,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"a":2,"n":"SkeletonMecanim","t":16,"rt":$n[5].SkeletonMecanim,"g":{"a":2,"n":"get_SkeletonMecanim","t":8,"rt":$n[5].SkeletonMecanim,"fg":"SkeletonMecanim"},"fn":"SkeletonMecanim"},{"a":1,"n":"DefaultMecanimLayerFlags","is":true,"t":4,"rt":$n[0].Int32,"sn":"DefaultMecanimLayerFlags","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"mecanimLayerFlags","t":4,"rt":$n[0].Int32,"sn":"mecanimLayerFlags","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"movementDelta","t":4,"rt":$n[1].Vector2,"sn":"movementDelta"},{"a":3,"n":"rotationDelta","t":4,"rt":$n[0].Single,"sn":"rotationDelta","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"skeletonMecanim","t":4,"rt":$n[5].SkeletonMecanim,"sn":"skeletonMecanim"}]}; }, $n);
    /*Spine.Unity.SkeletonMecanimRootMotion end.*/

    /*Spine.Unity.SkeletonRootMotion start.*/
    $m("Spine.Unity.SkeletonRootMotion", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonRootMotion")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"ApplyMixAlphaToDelta","t":8,"pi":[{"n":"currentDelta","ref":true,"pt":$n[0].Single,"ps":0},{"n":"next","pt":$n[8].TrackEntry,"ps":1},{"n":"track","pt":$n[8].TrackEntry,"ps":2}],"sn":"ApplyMixAlphaToDelta","rt":$n[0].Void,"p":[$n[0].Single,$n[8].TrackEntry,$n[8].TrackEntry]},{"a":1,"n":"ApplyMixAlphaToDelta","t":8,"pi":[{"n":"currentDelta","ref":true,"pt":$n[1].Vector2,"ps":0},{"n":"next","pt":$n[8].TrackEntry,"ps":1},{"n":"track","pt":$n[8].TrackEntry,"ps":2}],"sn":"ApplyMixAlphaToDelta$1","rt":$n[0].Void,"p":[$n[1].Vector2,$n[8].TrackEntry,$n[8].TrackEntry]},{"ov":true,"a":3,"n":"CalculateAnimationsMovementDelta","t":8,"sn":"CalculateAnimationsMovementDelta","rt":$n[1].Vector2},{"ov":true,"a":3,"n":"CalculateAnimationsRotationDelta","t":8,"sn":"CalculateAnimationsRotationDelta","rt":$n[0].Single,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"GetMixAlpha","t":8,"pi":[{"n":"cumulatedMixAlpha","ref":true,"pt":$n[0].Single,"ps":0},{"n":"next","pt":$n[8].TrackEntry,"ps":1},{"n":"track","pt":$n[8].TrackEntry,"ps":2}],"sn":"GetMixAlpha","rt":$n[0].Void,"p":[$n[0].Single,$n[8].TrackEntry,$n[8].TrackEntry]},{"ov":true,"a":2,"n":"GetRemainingRootMotion","t":8,"pi":[{"n":"trackIndex","pt":$n[0].Int32,"ps":0}],"sn":"GetRemainingRootMotion","rt":$n[1].Vector2,"p":[$n[0].Int32]},{"ov":true,"a":2,"n":"GetRootMotionInfo","t":8,"pi":[{"n":"trackIndex","pt":$n[0].Int32,"ps":0}],"sn":"GetRootMotionInfo","rt":$n[5].SkeletonRootMotionBase.RootMotionInfo,"p":[$n[0].Int32]},{"ov":true,"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"ov":true,"a":3,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"ov":true,"a":3,"n":"AdditionalScale","t":16,"rt":$n[0].Single,"g":{"ov":true,"a":3,"n":"get_AdditionalScale","t":8,"rt":$n[0].Single,"fg":"AdditionalScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"AdditionalScale"},{"a":1,"n":"DefaultAnimationTrackFlags","is":true,"t":4,"rt":$n[0].Int32,"sn":"DefaultAnimationTrackFlags","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"animationState","t":4,"rt":$n[8].AnimationState,"sn":"animationState"},{"a":2,"n":"animationTrackFlags","t":4,"rt":$n[0].Int32,"sn":"animationTrackFlags","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"skeletonGraphic","t":4,"rt":$n[5].SkeletonGraphic,"sn":"skeletonGraphic"}]}; }, $n);
    /*Spine.Unity.SkeletonRootMotion end.*/

    /*Spine.Unity.SkeletonRootMotionBase start.*/
    $m("Spine.Unity.SkeletonRootMotionBase", function () { return {"nested":[Function,$n[5].SkeletonRootMotionBase.RootMotionInfo],"att":1048705,"a":2,"at":[new UnityEngine.DefaultExecutionOrder(1)],"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AdjustRootMotionToDistance","t":8,"pi":[{"n":"distanceToTarget","pt":$n[1].Vector2,"ps":0},{"n":"trackIndex","dv":0,"o":true,"pt":$n[0].Int32,"ps":1},{"n":"adjustX","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"adjustY","dv":true,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"minX","dv":0.0,"o":true,"pt":$n[0].Single,"ps":4},{"n":"maxX","dv":3.40282347E+38,"o":true,"pt":$n[0].Single,"ps":5},{"n":"minY","dv":0.0,"o":true,"pt":$n[0].Single,"ps":6},{"n":"maxY","dv":3.40282347E+38,"o":true,"pt":$n[0].Single,"ps":7},{"n":"allowXTranslation","dv":false,"o":true,"pt":$n[0].Boolean,"ps":8},{"n":"allowYTranslation","dv":false,"o":true,"pt":$n[0].Boolean,"ps":9}],"sn":"AdjustRootMotionToDistance","rt":$n[0].Void,"p":[$n[1].Vector2,$n[0].Int32,$n[0].Boolean,$n[0].Boolean,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Boolean,$n[0].Boolean]},{"a":1,"n":"ApplyConstraintToPos","t":8,"pi":[{"n":"animation","pt":$n[8].Animation,"ps":0},{"n":"constraint","pt":$n[8].TransformConstraint,"ps":1},{"n":"constraintIndex","pt":$n[0].Int32,"ps":2},{"n":"time","pt":$n[0].Single,"ps":3},{"n":"useLastConstraintPos","pt":$n[0].Boolean,"ps":4},{"n":"pos","ref":true,"pt":$n[1].Vector2,"ps":5}],"sn":"ApplyConstraintToPos","rt":$n[0].Void,"p":[$n[8].Animation,$n[8].TransformConstraint,$n[0].Int32,$n[0].Single,$n[0].Boolean,$n[1].Vector2]},{"a":1,"n":"ApplyConstraintToRotation","t":8,"pi":[{"n":"animation","pt":$n[8].Animation,"ps":0},{"n":"constraint","pt":$n[8].TransformConstraint,"ps":1},{"n":"constraintIndex","pt":$n[0].Int32,"ps":2},{"n":"time","pt":$n[0].Single,"ps":3},{"n":"useLastConstraintRotation","pt":$n[0].Boolean,"ps":4},{"n":"rotation","ref":true,"pt":$n[0].Single,"ps":5}],"sn":"ApplyConstraintToRotation","rt":$n[0].Void,"p":[$n[8].Animation,$n[8].TransformConstraint,$n[0].Int32,$n[0].Single,$n[0].Boolean,$n[0].Single]},{"a":1,"n":"ApplyRootMotion","t":8,"pi":[{"n":"skeletonTranslationDelta","pt":$n[1].Vector2,"ps":0},{"n":"skeletonRotationDelta","pt":$n[0].Single,"ps":1},{"n":"parentBoneScale","pt":$n[1].Vector2,"ps":2},{"n":"skeletonAnimationUsesFixedUpdate","pt":$n[0].Boolean,"ps":3}],"sn":"ApplyRootMotion","rt":$n[0].Void,"p":[$n[1].Vector2,$n[0].Single,$n[1].Vector2,$n[0].Boolean]},{"a":1,"n":"ApplyTransformConstraints","t":8,"sn":"ApplyTransformConstraints","rt":$n[0].Void},{"ab":true,"a":3,"n":"CalculateAnimationsMovementDelta","t":8,"sn":"CalculateAnimationsMovementDelta","rt":$n[1].Vector2},{"v":true,"a":3,"n":"CalculateAnimationsRotationDelta","t":8,"sn":"CalculateAnimationsRotationDelta","rt":$n[0].Single,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"ClearEffectiveBoneOffsets","t":8,"pi":[{"n":"parentBoneScale","pt":$n[1].Vector2,"ps":0}],"sn":"ClearEffectiveBoneOffsets","rt":$n[0].Void,"p":[$n[1].Vector2]},{"a":1,"n":"ClearRigidbodyTempMovement","t":8,"sn":"ClearRigidbodyTempMovement","rt":$n[0].Void},{"a":3,"n":"FindRigidbodyComponent","t":8,"sn":"FindRigidbodyComponent","rt":$n[0].Void},{"a":1,"n":"FindTransformConstraintsAffectingBone","t":8,"sn":"FindTransformConstraintsAffectingBone","rt":$n[0].Void},{"v":true,"a":3,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"a":1,"n":"GatherTopLevelBones","t":8,"sn":"GatherTopLevelBones","rt":$n[0].Void},{"a":2,"n":"GetAnimationRootMotion","t":8,"pi":[{"n":"animation","pt":$n[8].Animation,"ps":0}],"sn":"GetAnimationRootMotion","rt":$n[1].Vector2,"p":[$n[8].Animation]},{"a":2,"n":"GetAnimationRootMotion","t":8,"pi":[{"n":"startTime","pt":$n[0].Single,"ps":0},{"n":"endTime","pt":$n[0].Single,"ps":1},{"n":"animation","pt":$n[8].Animation,"ps":2}],"sn":"GetAnimationRootMotion$1","rt":$n[1].Vector2,"p":[$n[0].Single,$n[0].Single,$n[8].Animation]},{"a":2,"n":"GetAnimationRootMotionInfo","t":8,"pi":[{"n":"animation","pt":$n[8].Animation,"ps":0},{"n":"currentTime","pt":$n[0].Single,"ps":1}],"sn":"GetAnimationRootMotionInfo","rt":$n[5].SkeletonRootMotionBase.RootMotionInfo,"p":[$n[8].Animation,$n[0].Single]},{"a":2,"n":"GetAnimationRootMotionRotation","t":8,"pi":[{"n":"animation","pt":$n[8].Animation,"ps":0}],"sn":"GetAnimationRootMotionRotation","rt":$n[0].Single,"p":[$n[8].Animation],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"GetAnimationRootMotionRotation","t":8,"pi":[{"n":"startTime","pt":$n[0].Single,"ps":0},{"n":"endTime","pt":$n[0].Single,"ps":1},{"n":"animation","pt":$n[8].Animation,"ps":2}],"sn":"GetAnimationRootMotionRotation$1","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single,$n[8].Animation],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"GetConstraintLastPosIndex","t":8,"pi":[{"n":"constraintIndex","pt":$n[0].Int32,"ps":0}],"sn":"GetConstraintLastPosIndex","rt":$n[0].Int32,"p":[$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"ab":true,"a":2,"n":"GetRemainingRootMotion","t":8,"pi":[{"n":"trackIndex","dv":0,"o":true,"pt":$n[0].Int32,"ps":0}],"sn":"GetRemainingRootMotion","rt":$n[1].Vector2,"p":[$n[0].Int32]},{"ab":true,"a":2,"n":"GetRootMotionInfo","t":8,"pi":[{"n":"trackIndex","dv":0,"o":true,"pt":$n[0].Int32,"ps":0}],"sn":"GetRootMotionInfo","rt":$n[5].SkeletonRootMotionBase.RootMotionInfo,"p":[$n[0].Int32]},{"a":1,"n":"GetScaleAffectingRootMotion","t":8,"sn":"GetScaleAffectingRootMotion","rt":$n[1].Vector2},{"a":1,"n":"GetScaleAffectingRootMotion","t":8,"pi":[{"n":"parentBoneScale","out":true,"pt":$n[1].Vector2,"ps":0}],"sn":"GetScaleAffectingRootMotion$1","rt":$n[1].Vector2,"p":[$n[1].Vector2]},{"a":1,"n":"GetSkeletonSpaceMovementDelta","t":8,"pi":[{"n":"boneLocalDelta","pt":$n[1].Vector2,"ps":0},{"n":"parentBoneScale","out":true,"pt":$n[1].Vector2,"ps":1},{"n":"totalScale","out":true,"pt":$n[1].Vector2,"ps":2}],"sn":"GetSkeletonSpaceMovementDelta","rt":$n[1].Vector2,"p":[$n[1].Vector2,$n[1].Vector2,$n[1].Vector2]},{"a":1,"n":"GetSkeletonSpaceRotationDelta","t":8,"pi":[{"n":"boneLocalDelta","pt":$n[0].Single,"ps":0},{"n":"totalScaleAffectingRootMotion","pt":$n[1].Vector2,"ps":1}],"sn":"GetSkeletonSpaceRotationDelta","rt":$n[0].Single,"p":[$n[0].Single,$n[1].Vector2],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"GetTimelineMovementDelta","t":8,"pi":[{"n":"startTime","pt":$n[0].Single,"ps":0},{"n":"endTime","pt":$n[0].Single,"ps":1},{"n":"xTimeline","pt":$n[8].TranslateXTimeline,"ps":2},{"n":"yTimeline","pt":$n[8].TranslateYTimeline,"ps":3},{"n":"animation","pt":$n[8].Animation,"ps":4}],"sn":"GetTimelineMovementDelta","rt":$n[1].Vector2,"p":[$n[0].Single,$n[0].Single,$n[8].TranslateXTimeline,$n[8].TranslateYTimeline,$n[8].Animation]},{"a":1,"n":"HandleUpdateLocal","t":8,"pi":[{"n":"animatedSkeletonComponent","pt":$n[5].ISkeletonAnimation,"ps":0}],"sn":"HandleUpdateLocal","rt":$n[0].Void,"p":[$n[5].ISkeletonAnimation]},{"v":true,"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"a":3,"n":"InitializeOnRebuild","t":8,"pi":[{"n":"animatedSkeletonComponent","pt":$n[5].ISkeletonAnimation,"ps":0}],"sn":"InitializeOnRebuild","rt":$n[0].Void,"p":[$n[5].ISkeletonAnimation]},{"v":true,"a":3,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"v":true,"a":3,"n":"PhysicsUpdate","t":8,"pi":[{"n":"skeletonAnimationUsesFixedUpdate","pt":$n[0].Boolean,"ps":0}],"sn":"PhysicsUpdate","rt":$n[0].Void,"p":[$n[0].Boolean]},{"v":true,"a":3,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"a":1,"n":"SetEffectiveBoneOffsetsTo","t":8,"pi":[{"n":"displacementSkeletonSpace","pt":$n[1].Vector2,"ps":0},{"n":"rotationSkeletonSpace","pt":$n[0].Single,"ps":1},{"n":"parentBoneScale","pt":$n[1].Vector2,"ps":2}],"sn":"SetEffectiveBoneOffsetsTo","rt":$n[0].Void,"p":[$n[1].Vector2,$n[0].Single,$n[1].Vector2]},{"a":2,"n":"SetRootMotionBone","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"SetRootMotionBone","rt":$n[0].Void,"p":[$n[0].String]},{"v":true,"a":3,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"UpdateLastConstraintPos","t":8,"pi":[{"n":"transformConstraintsItems","pt":System.Array.type(Spine.TransformConstraint),"ps":0}],"sn":"UpdateLastConstraintPos","rt":$n[0].Void,"p":[System.Array.type(Spine.TransformConstraint)]},{"a":1,"n":"UpdateLastConstraintRotation","t":8,"pi":[{"n":"transformConstraintsItems","pt":System.Array.type(Spine.TransformConstraint),"ps":0}],"sn":"UpdateLastConstraintRotation","rt":$n[0].Void,"p":[System.Array.type(Spine.TransformConstraint)]},{"a":2,"n":"AdditionalRigidbody2DMovement","t":16,"rt":$n[1].Vector2,"g":{"a":2,"n":"get_AdditionalRigidbody2DMovement","t":8,"rt":$n[1].Vector2,"fg":"AdditionalRigidbody2DMovement"},"s":{"a":2,"n":"set_AdditionalRigidbody2DMovement","t":8,"p":[$n[1].Vector2],"rt":$n[0].Void,"fs":"AdditionalRigidbody2DMovement"},"fn":"AdditionalRigidbody2DMovement"},{"v":true,"a":3,"n":"AdditionalScale","t":16,"rt":$n[0].Single,"g":{"v":true,"a":3,"n":"get_AdditionalScale","t":8,"rt":$n[0].Single,"fg":"AdditionalScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"AdditionalScale"},{"a":2,"n":"PreviousRigidbodyRootMotion2D","t":16,"rt":$n[1].Vector2,"g":{"a":2,"n":"get_PreviousRigidbodyRootMotion2D","t":8,"rt":$n[1].Vector2,"fg":"PreviousRigidbodyRootMotion2D"},"fn":"PreviousRigidbodyRootMotion2D"},{"a":2,"n":"PreviousRigidbodyRootMotion3D","t":16,"rt":$n[1].Vector3,"g":{"a":2,"n":"get_PreviousRigidbodyRootMotion3D","t":8,"rt":$n[1].Vector3,"fg":"PreviousRigidbodyRootMotion3D"},"fn":"PreviousRigidbodyRootMotion3D"},{"a":2,"n":"RootMotionBone","t":16,"rt":$n[8].Bone,"g":{"a":2,"n":"get_RootMotionBone","t":8,"rt":$n[8].Bone,"fg":"RootMotionBone"},"fn":"RootMotionBone"},{"a":3,"n":"SkeletonAnimationUsesFixedUpdate","t":16,"rt":$n[0].Boolean,"g":{"a":3,"n":"get_SkeletonAnimationUsesFixedUpdate","t":8,"rt":$n[0].Boolean,"fg":"SkeletonAnimationUsesFixedUpdate","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"SkeletonAnimationUsesFixedUpdate"},{"a":2,"n":"TargetSkeletonAnimationComponent","t":16,"rt":$n[5].ISkeletonAnimation,"g":{"a":2,"n":"get_TargetSkeletonAnimationComponent","t":8,"rt":$n[5].ISkeletonAnimation,"fg":"TargetSkeletonAnimationComponent"},"fn":"TargetSkeletonAnimationComponent"},{"a":2,"n":"TargetSkeletonComponent","t":16,"rt":$n[5].ISkeletonComponent,"g":{"a":2,"n":"get_TargetSkeletonComponent","t":8,"rt":$n[5].ISkeletonComponent,"fg":"TargetSkeletonComponent"},"fn":"TargetSkeletonComponent"},{"a":2,"n":"UsesRigidbody","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_UsesRigidbody","t":8,"rt":$n[0].Boolean,"fg":"UsesRigidbody","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"UsesRigidbody"},{"a":3,"n":"accumulatedUntilFixedUpdate","t":4,"rt":$n[0].Boolean,"sn":"accumulatedUntilFixedUpdate","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"additionalRigidbody2DMovement","t":4,"rt":$n[1].Vector2,"sn":"additionalRigidbody2DMovement"},{"a":2,"n":"applyRigidbody2DGravity","t":4,"rt":$n[0].Boolean,"sn":"applyRigidbody2DGravity","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"disableOnOverride","t":4,"rt":$n[0].Boolean,"sn":"disableOnOverride","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"initialOffset","t":4,"rt":$n[1].Vector2,"sn":"initialOffset"},{"a":3,"n":"initialOffsetRotation","t":4,"rt":$n[0].Single,"sn":"initialOffsetRotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":3,"n":"previousRigidbodyRootMotion","t":4,"rt":$n[1].Vector3,"sn":"previousRigidbodyRootMotion"},{"a":2,"n":"rigidBody","t":4,"rt":$n[1].Rigidbody,"sn":"rigidBody"},{"at":[new UnityEngine.HeaderAttribute("Optional")],"a":2,"n":"rigidBody2D","t":4,"rt":$n[1].Rigidbody2D,"sn":"rigidBody2D"},{"a":3,"n":"rigidbody2DRotation","t":4,"rt":$n[0].Single,"sn":"rigidbody2DRotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":3,"n":"rigidbodyDisplacement","t":4,"rt":$n[1].Vector3,"sn":"rigidbodyDisplacement"},{"a":3,"n":"rigidbodyLocalRotation","t":4,"rt":$n[1].Quaternion,"sn":"rigidbodyLocalRotation"},{"a":3,"n":"rootMotionBone","t":4,"rt":$n[8].Bone,"sn":"rootMotionBone"},{"a":3,"n":"rootMotionBoneIndex","t":4,"rt":$n[0].Int32,"sn":"rootMotionBoneIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new Spine.Unity.SpineBone("", "", true, false)],"a":2,"n":"rootMotionBoneName","t":4,"rt":$n[0].String,"sn":"rootMotionBoneName"},{"a":2,"n":"rootMotionScaleRotation","t":4,"rt":$n[0].Single,"sn":"rootMotionScaleRotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"rootMotionScaleX","t":4,"rt":$n[0].Single,"sn":"rootMotionScaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"rootMotionScaleY","t":4,"rt":$n[0].Single,"sn":"rootMotionScaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"rootMotionTranslateXPerY","t":4,"rt":$n[0].Single,"sn":"rootMotionTranslateXPerY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"rootMotionTranslateYPerX","t":4,"rt":$n[0].Single,"sn":"rootMotionTranslateYPerX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":3,"n":"skeletonComponent","t":4,"rt":$n[5].ISkeletonComponent,"sn":"skeletonComponent"},{"a":3,"n":"tempSkeletonDisplacement","t":4,"rt":$n[1].Vector2,"sn":"tempSkeletonDisplacement"},{"a":3,"n":"tempSkeletonRotation","t":4,"rt":$n[0].Single,"sn":"tempSkeletonRotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":3,"n":"topLevelBones","t":4,"rt":$n[2].List$1(Spine.Bone),"sn":"topLevelBones"},{"a":3,"n":"transformConstraintIndices","t":4,"rt":$n[2].List$1(System.Int32),"sn":"transformConstraintIndices"},{"a":3,"n":"transformConstraintLastPos","t":4,"rt":$n[2].List$1(UnityEngine.Vector2),"sn":"transformConstraintLastPos"},{"a":3,"n":"transformConstraintLastRotation","t":4,"rt":$n[2].List$1(System.Single),"sn":"transformConstraintLastRotation"},{"a":2,"n":"transformPositionX","t":4,"rt":$n[0].Boolean,"sn":"transformPositionX","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"transformPositionY","t":4,"rt":$n[0].Boolean,"sn":"transformPositionY","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"transformRotation","t":4,"rt":$n[0].Boolean,"sn":"transformRotation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"PhysicsUpdateRootMotionOverride","t":2,"ad":{"a":2,"n":"add_PhysicsUpdateRootMotionOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addPhysicsUpdateRootMotionOverride","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_PhysicsUpdateRootMotionOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removePhysicsUpdateRootMotionOverride","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"ProcessRootMotionOverride","t":2,"ad":{"a":2,"n":"add_ProcessRootMotionOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addProcessRootMotionOverride","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_ProcessRootMotionOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeProcessRootMotionOverride","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonRootMotionBase end.*/

    /*Spine.Unity.SkeletonRootMotionBase+RootMotionInfo start.*/
    $m("Spine.Unity.SkeletonRootMotionBase.RootMotionInfo", function () { return {"td":$n[5].SkeletonRootMotionBase,"att":1048842,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"current","t":4,"rt":$n[1].Vector2,"sn":"current"},{"a":2,"n":"end","t":4,"rt":$n[1].Vector2,"sn":"end"},{"a":2,"n":"mid","t":4,"rt":$n[1].Vector2,"sn":"mid"},{"a":2,"n":"start","t":4,"rt":$n[1].Vector2,"sn":"start"},{"a":2,"n":"timeIsPastMid","t":4,"rt":$n[0].Boolean,"sn":"timeIsPastMid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.SkeletonRootMotionBase+RootMotionInfo end.*/

    /*Spine.Unity.SkeletonAnimation start.*/
    $m("Spine.Unity.SkeletonAnimation", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.AddComponentMenu.ctor("Spine/SkeletonAnimation"),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonAnimation-Component")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddToGameObject","is":true,"t":8,"pi":[{"n":"gameObject","pt":$n[1].GameObject,"ps":0},{"n":"skeletonDataAsset","pt":$n[5].SkeletonDataAsset,"ps":1},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"AddToGameObject","rt":$n[5].SkeletonAnimation,"p":[$n[1].GameObject,$n[5].SkeletonDataAsset,$n[0].Boolean]},{"a":2,"n":"AfterAnimationApplied","t":8,"sn":"AfterAnimationApplied","rt":$n[0].Void},{"v":true,"a":2,"n":"ApplyAnimation","t":8,"sn":"ApplyAnimation","rt":$n[0].Void},{"ov":true,"a":2,"n":"ClearState","t":8,"sn":"ClearState","rt":$n[0].Void},{"v":true,"a":3,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"ov":true,"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","pt":$n[0].Boolean,"ps":0},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean,$n[0].Boolean]},{"ov":true,"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":2,"n":"NewSkeletonAnimationGameObject","is":true,"t":8,"pi":[{"n":"skeletonDataAsset","pt":$n[5].SkeletonDataAsset,"ps":0},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"NewSkeletonAnimationGameObject","rt":$n[5].SkeletonAnimation,"p":[$n[5].SkeletonDataAsset,$n[0].Boolean]},{"ov":true,"a":2,"n":"OnBecameVisible","t":8,"sn":"OnBecameVisible","rt":$n[0].Void},{"v":true,"a":3,"n":"Update","t":8,"sn":"Update$1","rt":$n[0].Void},{"a":2,"n":"Update","t":8,"pi":[{"n":"deltaTime","pt":$n[0].Single,"ps":0}],"sn":"Update","rt":$n[0].Void,"p":[$n[0].Single]},{"a":3,"n":"UpdateAnimationStatus","t":8,"pi":[{"n":"deltaTime","pt":$n[0].Single,"ps":0}],"sn":"UpdateAnimationStatus","rt":$n[0].Void,"p":[$n[0].Single]},{"a":2,"n":"AnimationName","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_AnimationName","t":8,"rt":$n[0].String,"fg":"AnimationName"},"s":{"a":2,"n":"set_AnimationName","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"AnimationName"},"fn":"AnimationName"},{"a":2,"n":"AnimationState","t":16,"rt":$n[8].AnimationState,"g":{"a":2,"n":"get_AnimationState","t":8,"rt":$n[8].AnimationState,"fg":"AnimationState"},"fn":"AnimationState"},{"a":2,"n":"UnscaledTime","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_UnscaledTime","t":8,"rt":$n[0].Boolean,"fg":"UnscaledTime","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_UnscaledTime","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"UnscaledTime"},"fn":"UnscaledTime"},{"a":2,"n":"UpdateTiming","t":16,"rt":$n[5].UpdateTiming,"g":{"a":2,"n":"get_UpdateTiming","t":8,"rt":$n[5].UpdateTiming,"fg":"UpdateTiming","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},"s":{"a":2,"n":"set_UpdateTiming","t":8,"p":[$n[5].UpdateTiming],"rt":$n[0].Void,"fs":"UpdateTiming"},"fn":"UpdateTiming"},{"at":[new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineAnimation("", "", true, false, false)],"a":1,"n":"_animationName","t":4,"rt":$n[0].String,"sn":"_animationName"},{"a":2,"n":"loop","t":4,"rt":$n[0].Boolean,"sn":"loop","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"state","t":4,"rt":$n[8].AnimationState,"sn":"state"},{"a":2,"n":"timeScale","t":4,"rt":$n[0].Single,"sn":"timeScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"unscaledTime","t":4,"rt":$n[0].Boolean,"sn":"unscaledTime","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"updateTiming","t":4,"rt":$n[5].UpdateTiming,"sn":"updateTiming","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},{"a":1,"n":"wasUpdatedAfterInit","t":4,"rt":$n[0].Boolean,"sn":"wasUpdatedAfterInit","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"BeforeApply","t":2,"ad":{"a":2,"n":"add_BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addBeforeApply","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeBeforeApply","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnAnimationRebuild","t":2,"ad":{"a":2,"n":"add_OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnAnimationRebuild","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnAnimationRebuild","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateComplete","t":2,"ad":{"a":2,"n":"add_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateComplete","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateComplete","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateLocal","t":2,"ad":{"a":2,"n":"add_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateLocal","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateLocal","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateWorld","t":2,"ad":{"a":2,"n":"add_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateWorld","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateWorld","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_BeforeApply","t":2,"ad":{"a":3,"n":"add__BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_BeforeApply","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_BeforeApply","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_OnAnimationRebuild","t":2,"ad":{"a":3,"n":"add__OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_OnAnimationRebuild","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_OnAnimationRebuild","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_UpdateComplete","t":2,"ad":{"a":3,"n":"add__UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_UpdateComplete","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_UpdateComplete","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_UpdateLocal","t":2,"ad":{"a":3,"n":"add__UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_UpdateLocal","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_UpdateLocal","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_UpdateWorld","t":2,"ad":{"a":3,"n":"add__UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_UpdateWorld","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_UpdateWorld","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonAnimation end.*/

    /*Spine.Unity.SkeletonGraphic start.*/
    $m("Spine.Unity.SkeletonGraphic", function () { return {"nested":[$n[5].SkeletonGraphic.LayoutMode,Function,Function,Function,Function],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.RequireComponent.$ctor1(UnityEngine.CanvasRenderer, UnityEngine.RectTransform),new UnityEngine.DisallowMultipleComponent(),new UnityEngine.AddComponentMenu.ctor("Spine/SkeletonGraphic (Unity UI Canvas)"),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonGraphic-Component")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddSkeletonGraphicComponent","is":true,"t":8,"pi":[{"n":"gameObject","pt":$n[1].GameObject,"ps":0},{"n":"skeletonDataAsset","pt":$n[5].SkeletonDataAsset,"ps":1},{"n":"material","pt":$n[1].Material,"ps":2}],"sn":"AddSkeletonGraphicComponent","rt":$n[5].SkeletonGraphic,"p":[$n[1].GameObject,$n[5].SkeletonDataAsset,$n[1].Material]},{"v":true,"a":2,"n":"AfterAnimationApplied","t":8,"sn":"AfterAnimationApplied","rt":$n[0].Void},{"v":true,"a":2,"n":"ApplyAnimation","t":8,"sn":"ApplyAnimation","rt":$n[0].Void},{"v":true,"a":2,"n":"ApplyTransformMovementToPhysics","t":8,"sn":"ApplyTransformMovementToPhysics","rt":$n[0].Void},{"ov":true,"a":3,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":3,"n":"DestroyMeshes","t":8,"sn":"DestroyMeshes","rt":$n[0].Void},{"a":3,"n":"DisableUnusedCanvasRenderers","t":8,"pi":[{"n":"usedCount","pt":$n[0].Int32,"ps":0},{"n":"isInRebuild","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"DisableUnusedCanvasRenderers","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Boolean]},{"a":3,"n":"DisposeMeshBuffers","t":8,"sn":"DisposeMeshBuffers","rt":$n[0].Void},{"a":3,"n":"EnsureCanvasRendererCount","t":8,"pi":[{"n":"targetCount","pt":$n[0].Int32,"ps":0}],"sn":"EnsureCanvasRendererCount","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":3,"n":"EnsureMeshesCount","t":8,"pi":[{"n":"targetCount","pt":$n[0].Int32,"ps":0}],"sn":"EnsureMeshesCount","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":3,"n":"EnsureSeparatorPartCount","t":8,"sn":"EnsureSeparatorPartCount","rt":$n[0].Void},{"a":3,"n":"EnsureUsedTexturesAndMaterialsCount","t":8,"pi":[{"n":"targetCount","pt":$n[0].Int32,"ps":0}],"sn":"EnsureUsedTexturesAndMaterialsCount","rt":$n[0].Void,"p":[$n[0].Int32]},{"v":true,"a":3,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"a":1,"n":"GetCurrentRectSize","t":8,"sn":"GetCurrentRectSize","rt":$n[1].Vector2},{"a":3,"n":"GetEffectiveLayoutMode","t":8,"pi":[{"n":"mode","pt":$n[5].SkeletonGraphic.LayoutMode,"ps":0}],"sn":"GetEffectiveLayoutMode","rt":$n[5].SkeletonGraphic.LayoutMode,"p":[$n[5].SkeletonGraphic.LayoutMode],"box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonGraphic.LayoutMode, System.Enum.toStringFn(Spine.Unity.SkeletonGraphic.LayoutMode));}},{"a":2,"n":"GetLastMesh","t":8,"sn":"GetLastMesh","rt":$n[1].Mesh},{"a":3,"n":"GetLayoutScale","t":8,"pi":[{"n":"mode","pt":$n[5].SkeletonGraphic.LayoutMode,"ps":0}],"sn":"GetLayoutScale","rt":$n[0].Single,"p":[$n[5].SkeletonGraphic.LayoutMode],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":3,"n":"GetPhysicsTransformPosition","t":8,"sn":"GetPhysicsTransformPosition","rt":$n[1].Vector2},{"a":3,"n":"GetPhysicsTransformRotation","t":8,"sn":"GetPhysicsTransformRotation","rt":$n[0].Single,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"HandleOnDemandLoading","t":8,"sn":"HandleOnDemandLoading","rt":$n[0].Void},{"a":2,"n":"HasMultipleSubmeshInstructions","t":8,"sn":"HasMultipleSubmeshInstructions","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"InitMeshBuffers","t":8,"sn":"InitMeshBuffers","rt":$n[0].Void},{"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","pt":$n[0].Boolean,"ps":0}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":3,"n":"MatchRectTransformMultipleRenderers","t":8,"sn":"MatchRectTransformMultipleRenderers","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"MatchRectTransformSingleRenderer","t":8,"sn":"MatchRectTransformSingleRenderer","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"MatchRectTransformWithBounds","t":8,"sn":"MatchRectTransformWithBounds","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"NewSkeletonGraphicGameObject","is":true,"t":8,"pi":[{"n":"skeletonDataAsset","pt":$n[5].SkeletonDataAsset,"ps":0},{"n":"parent","pt":$n[1].Transform,"ps":1},{"n":"material","pt":$n[1].Material,"ps":2}],"sn":"NewSkeletonGraphicGameObject","rt":$n[5].SkeletonGraphic,"p":[$n[5].SkeletonDataAsset,$n[1].Transform,$n[1].Material]},{"a":2,"n":"OnBecameInvisible","t":8,"sn":"OnBecameInvisible","rt":$n[0].Void},{"a":2,"n":"OnBecameVisible","t":8,"sn":"OnBecameVisible","rt":$n[0].Void},{"a":3,"n":"OnCullStateChanged","t":8,"pi":[{"n":"culled","pt":$n[0].Boolean,"ps":0}],"sn":"OnCullStateChanged","rt":$n[0].Void,"p":[$n[0].Boolean]},{"ov":true,"a":3,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"ov":true,"a":3,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":2,"n":"PrepareInstructionsAndRenderers","t":8,"pi":[{"n":"isInRebuild","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"PrepareInstructionsAndRenderers","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":3,"n":"PrepareRendererGameObjects","t":8,"pi":[{"n":"currentInstructions","pt":$n[5].SkeletonRendererInstruction,"ps":0},{"n":"isInRebuild","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"PrepareRendererGameObjects","rt":$n[0].Void,"p":[$n[5].SkeletonRendererInstruction,$n[0].Boolean]},{"a":2,"n":"ReapplySeparatorSlotNames","t":8,"sn":"ReapplySeparatorSlotNames","rt":$n[0].Void},{"ov":true,"a":2,"n":"Rebuild","t":8,"pi":[{"n":"update","pt":$n[4].CanvasUpdate,"ps":0}],"sn":"Rebuild","rt":$n[0].Void,"p":[$n[4].CanvasUpdate]},{"a":2,"n":"ResetLastPosition","t":8,"sn":"ResetLastPosition","rt":$n[0].Void},{"a":2,"n":"ResetLastPositionAndRotation","t":8,"sn":"ResetLastPositionAndRotation","rt":$n[0].Void},{"a":2,"n":"ResetLastRotation","t":8,"sn":"ResetLastRotation","rt":$n[0].Void},{"a":1,"n":"SetRectTransformBounds","t":8,"pi":[{"n":"combinedBounds","pt":$n[1].Bounds,"ps":0}],"sn":"SetRectTransformBounds","rt":$n[0].Void,"p":[$n[1].Bounds]},{"a":2,"n":"SetRectTransformSize","is":true,"t":8,"pi":[{"n":"targetRectTransform","pt":$n[1].RectTransform,"ps":0},{"n":"size","pt":$n[1].Vector2,"ps":1}],"sn":"SetRectTransformSize","rt":$n[0].Void,"p":[$n[1].RectTransform,$n[1].Vector2]},{"a":2,"n":"SetRectTransformSize","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Graphic,"ps":0},{"n":"size","pt":$n[1].Vector2,"ps":1}],"sn":"SetRectTransformSize$1","rt":$n[0].Void,"p":[$n[4].Graphic,$n[1].Vector2]},{"a":3,"n":"SyncSubmeshGraphicsWithCanvasRenderers","t":8,"sn":"SyncSubmeshGraphicsWithCanvasRenderers","rt":$n[0].Void},{"a":2,"n":"TrimRenderers","t":8,"sn":"TrimRenderers","rt":$n[0].Void},{"v":true,"a":2,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"v":true,"a":2,"n":"Update","t":8,"pi":[{"n":"deltaTime","pt":$n[0].Single,"ps":0}],"sn":"Update$1","rt":$n[0].Void,"p":[$n[0].Single]},{"a":3,"n":"UpdateAnimationStatus","t":8,"pi":[{"n":"deltaTime","pt":$n[0].Single,"ps":0}],"sn":"UpdateAnimationStatus","rt":$n[0].Void,"p":[$n[0].Single]},{"a":3,"n":"UpdateMaterialsMultipleCanvasRenderers","t":8,"pi":[{"n":"currentInstructions","pt":$n[5].SkeletonRendererInstruction,"ps":0}],"sn":"UpdateMaterialsMultipleCanvasRenderers","rt":$n[0].Void,"p":[$n[5].SkeletonRendererInstruction]},{"a":2,"n":"UpdateMesh","t":8,"sn":"UpdateMesh","rt":$n[0].Void},{"a":3,"n":"UpdateMeshMultipleCanvasRenderers","t":8,"pi":[{"n":"currentInstructions","pt":$n[5].SkeletonRendererInstruction,"ps":0}],"sn":"UpdateMeshMultipleCanvasRenderers","rt":$n[0].Void,"p":[$n[5].SkeletonRendererInstruction]},{"a":3,"n":"UpdateMeshSingleCanvasRenderer","t":8,"pi":[{"n":"currentInstructions","pt":$n[5].SkeletonRendererInstruction,"ps":0}],"sn":"UpdateMeshSingleCanvasRenderer","rt":$n[0].Void,"p":[$n[5].SkeletonRendererInstruction]},{"a":2,"n":"UpdateMeshToInstructions","t":8,"sn":"UpdateMeshToInstructions","rt":$n[0].Void},{"a":3,"n":"UpdateSeparatorPartParents","t":8,"sn":"UpdateSeparatorPartParents","rt":$n[0].Void},{"a":3,"n":"UpdateWorldTransform","t":8,"pi":[{"n":"physics","pt":$n[8].Skeleton.Physics,"ps":0}],"sn":"UpdateWorldTransform","rt":$n[0].Void,"p":[$n[8].Skeleton.Physics]},{"a":2,"n":"AnimationState","t":16,"rt":$n[8].AnimationState,"g":{"a":2,"n":"get_AnimationState","t":8,"rt":$n[8].AnimationState,"fg":"AnimationState"},"fn":"AnimationState"},{"a":2,"n":"CustomMaterialOverride","t":16,"rt":$n[2].Dictionary$2(UnityEngine.Texture,UnityEngine.Material),"g":{"a":2,"n":"get_CustomMaterialOverride","t":8,"rt":$n[2].Dictionary$2(UnityEngine.Texture,UnityEngine.Material),"fg":"CustomMaterialOverride"},"fn":"CustomMaterialOverride"},{"a":2,"n":"CustomTextureOverride","t":16,"rt":$n[2].Dictionary$2(UnityEngine.Texture,UnityEngine.Texture),"g":{"a":2,"n":"get_CustomTextureOverride","t":8,"rt":$n[2].Dictionary$2(UnityEngine.Texture,UnityEngine.Texture),"fg":"CustomTextureOverride"},"fn":"CustomTextureOverride"},{"a":2,"n":"IsValid","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsValid","t":8,"rt":$n[0].Boolean,"fg":"IsValid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsValid"},{"a":2,"n":"MaterialsMultipleCanvasRenderers","t":16,"rt":$n[8].ExposedList$1(UnityEngine.Material),"g":{"a":2,"n":"get_MaterialsMultipleCanvasRenderers","t":8,"rt":$n[8].ExposedList$1(UnityEngine.Material),"fg":"MaterialsMultipleCanvasRenderers"},"fn":"MaterialsMultipleCanvasRenderers"},{"a":2,"n":"MeshGenerator","t":16,"rt":$n[5].MeshGenerator,"g":{"a":2,"n":"get_MeshGenerator","t":8,"rt":$n[5].MeshGenerator,"fg":"MeshGenerator"},"fn":"MeshGenerator"},{"a":2,"n":"MeshOffset","t":16,"rt":$n[1].Vector2,"g":{"a":2,"n":"get_MeshOffset","t":8,"rt":$n[1].Vector2,"fg":"MeshOffset"},"fn":"MeshOffset"},{"a":2,"n":"MeshScale","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MeshScale","t":8,"rt":$n[0].Single,"fg":"MeshScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"MeshScale"},{"a":2,"n":"MeshesMultipleCanvasRenderers","t":16,"rt":$n[8].ExposedList$1(UnityEngine.Mesh),"g":{"a":2,"n":"get_MeshesMultipleCanvasRenderers","t":8,"rt":$n[8].ExposedList$1(UnityEngine.Mesh),"fg":"MeshesMultipleCanvasRenderers"},"fn":"MeshesMultipleCanvasRenderers"},{"a":2,"n":"OverrideTexture","t":16,"rt":$n[1].Texture,"g":{"a":2,"n":"get_OverrideTexture","t":8,"rt":$n[1].Texture,"fg":"OverrideTexture"},"s":{"a":2,"n":"set_OverrideTexture","t":8,"p":[$n[1].Texture],"rt":$n[0].Void,"fs":"OverrideTexture"},"fn":"OverrideTexture"},{"a":2,"n":"PhysicsMovementRelativeTo","t":16,"rt":$n[1].Transform,"g":{"a":2,"n":"get_PhysicsMovementRelativeTo","t":8,"rt":$n[1].Transform,"fg":"PhysicsMovementRelativeTo"},"s":{"a":2,"n":"set_PhysicsMovementRelativeTo","t":8,"p":[$n[1].Transform],"rt":$n[0].Void,"fs":"PhysicsMovementRelativeTo"},"fn":"PhysicsMovementRelativeTo"},{"a":2,"n":"PhysicsPositionInheritanceFactor","t":16,"rt":$n[1].Vector2,"g":{"a":2,"n":"get_PhysicsPositionInheritanceFactor","t":8,"rt":$n[1].Vector2,"fg":"PhysicsPositionInheritanceFactor"},"s":{"a":2,"n":"set_PhysicsPositionInheritanceFactor","t":8,"p":[$n[1].Vector2],"rt":$n[0].Void,"fs":"PhysicsPositionInheritanceFactor"},"fn":"PhysicsPositionInheritanceFactor"},{"a":2,"n":"PhysicsRotationInheritanceFactor","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_PhysicsRotationInheritanceFactor","t":8,"rt":$n[0].Single,"fg":"PhysicsRotationInheritanceFactor","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_PhysicsRotationInheritanceFactor","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"PhysicsRotationInheritanceFactor"},"fn":"PhysicsRotationInheritanceFactor"},{"a":2,"n":"SeparatorParts","t":16,"rt":$n[2].List$1(UnityEngine.Transform),"g":{"a":2,"n":"get_SeparatorParts","t":8,"rt":$n[2].List$1(UnityEngine.Transform),"fg":"SeparatorParts"},"fn":"SeparatorParts"},{"a":2,"n":"Skeleton","t":16,"rt":$n[8].Skeleton,"g":{"a":2,"n":"get_Skeleton","t":8,"rt":$n[8].Skeleton,"fg":"Skeleton"},"s":{"a":2,"n":"set_Skeleton","t":8,"p":[$n[8].Skeleton],"rt":$n[0].Void,"fs":"Skeleton"},"fn":"Skeleton"},{"a":2,"n":"SkeletonClipping","t":16,"rt":$n[8].SkeletonClipping,"g":{"a":2,"n":"get_SkeletonClipping","t":8,"rt":$n[8].SkeletonClipping,"fg":"SkeletonClipping"},"fn":"SkeletonClipping"},{"a":2,"n":"SkeletonData","t":16,"rt":$n[8].SkeletonData,"g":{"a":2,"n":"get_SkeletonData","t":8,"rt":$n[8].SkeletonData,"fg":"SkeletonData"},"fn":"SkeletonData"},{"a":2,"n":"SkeletonDataAsset","t":16,"rt":$n[5].SkeletonDataAsset,"g":{"a":2,"n":"get_SkeletonDataAsset","t":8,"rt":$n[5].SkeletonDataAsset,"fg":"SkeletonDataAsset"},"fn":"SkeletonDataAsset"},{"a":2,"n":"TexturesMultipleCanvasRenderers","t":16,"rt":$n[8].ExposedList$1(UnityEngine.Texture),"g":{"a":2,"n":"get_TexturesMultipleCanvasRenderers","t":8,"rt":$n[8].ExposedList$1(UnityEngine.Texture),"fg":"TexturesMultipleCanvasRenderers"},"fn":"TexturesMultipleCanvasRenderers"},{"a":2,"n":"UnscaledTime","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_UnscaledTime","t":8,"rt":$n[0].Boolean,"fg":"UnscaledTime","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_UnscaledTime","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"UnscaledTime"},"fn":"UnscaledTime"},{"a":2,"n":"UpdateMode","t":16,"rt":$n[5].UpdateMode,"g":{"a":2,"n":"get_UpdateMode","t":8,"rt":$n[5].UpdateMode,"fg":"UpdateMode","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},"s":{"a":2,"n":"set_UpdateMode","t":8,"p":[$n[5].UpdateMode],"rt":$n[0].Void,"fs":"UpdateMode"},"fn":"UpdateMode"},{"a":2,"n":"UpdateTiming","t":16,"rt":$n[5].UpdateTiming,"g":{"a":2,"n":"get_UpdateTiming","t":8,"rt":$n[5].UpdateTiming,"fg":"UpdateTiming","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},"s":{"a":2,"n":"set_UpdateTiming","t":8,"p":[$n[5].UpdateTiming],"rt":$n[0].Void,"fs":"UpdateTiming"},"fn":"UpdateTiming"},{"ov":true,"a":2,"n":"color","t":16,"rt":$n[1].Color,"g":{"ov":true,"a":2,"n":"get_color","t":8,"rt":$n[1].Color,"fg":"color"},"s":{"ov":true,"a":2,"n":"set_color","t":8,"p":[$n[1].Color],"rt":$n[0].Void,"fs":"color"},"fn":"color"},{"ov":true,"a":2,"n":"mainTexture","t":16,"rt":$n[1].Texture,"g":{"ov":true,"a":2,"n":"get_mainTexture","t":8,"rt":$n[1].Texture,"fg":"mainTexture"},"fn":"mainTexture"},{"a":3,"n":"EditReferenceRect","is":true,"t":4,"rt":$n[0].Boolean,"sn":"EditReferenceRect","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"SeparatorPartGameObjectName","is":true,"t":4,"rt":$n[0].String,"sn":"SeparatorPartGameObjectName"},{"a":2,"n":"additiveMaterial","t":4,"rt":$n[1].Material,"sn":"additiveMaterial"},{"a":2,"n":"allowMultipleCanvasRenderers","t":4,"rt":$n[0].Boolean,"sn":"allowMultipleCanvasRenderers","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"baseTexture","t":4,"rt":$n[1].Texture,"sn":"baseTexture"},{"a":2,"n":"canvasRenderers","t":4,"rt":$n[2].List$1(UnityEngine.CanvasRenderer),"sn":"canvasRenderers"},{"a":1,"n":"currentInstructions","t":4,"rt":$n[5].SkeletonRendererInstruction,"sn":"currentInstructions"},{"a":1,"n":"customMaterialOverride","t":4,"rt":$n[2].Dictionary$2(UnityEngine.Texture,UnityEngine.Material),"sn":"customMaterialOverride","ro":true},{"a":1,"n":"customTextureOverride","t":4,"rt":$n[2].Dictionary$2(UnityEngine.Texture,UnityEngine.Texture),"sn":"customTextureOverride","ro":true},{"a":2,"n":"disableMeshAssignmentOnOverride","t":4,"rt":$n[0].Boolean,"sn":"disableMeshAssignmentOnOverride","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"enableSeparatorSlots","t":4,"rt":$n[0].Boolean,"sn":"enableSeparatorSlots","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"freeze","t":4,"rt":$n[0].Boolean,"sn":"freeze","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"initialFlipX","t":4,"rt":$n[0].Boolean,"sn":"initialFlipX","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"initialFlipY","t":4,"rt":$n[0].Boolean,"sn":"initialFlipY","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new Spine.Unity.SpineSkin("", "skeletonDataAsset", false, false, true, false)],"a":2,"n":"initialSkinName","t":4,"rt":$n[0].String,"sn":"initialSkinName"},{"a":3,"n":"lastPosition","t":4,"rt":$n[1].Vector2,"sn":"lastPosition"},{"a":3,"n":"lastRotation","t":4,"rt":$n[0].Single,"sn":"lastRotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"layoutScale","t":4,"rt":$n[0].Single,"sn":"layoutScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"layoutScaleMode","t":4,"rt":$n[5].SkeletonGraphic.LayoutMode,"sn":"layoutScaleMode","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonGraphic.LayoutMode, System.Enum.toStringFn(Spine.Unity.SkeletonGraphic.LayoutMode));}},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("m_Color"),new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_SkeletonColor","t":4,"rt":$n[1].Color,"sn":"m_SkeletonColor"},{"a":1,"n":"meshBuffers","t":4,"rt":$n[5].DoubleBuffered$1(Spine.Unity.MeshRendererBuffers.SmartMesh),"sn":"meshBuffers"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"meshGenerator","t":4,"rt":$n[5].MeshGenerator,"sn":"meshGenerator"},{"a":3,"n":"meshOffset","t":4,"rt":$n[1].Vector2,"sn":"meshOffset"},{"a":3,"n":"meshScale","t":4,"rt":$n[0].Single,"sn":"meshScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"meshes","t":4,"rt":$n[8].ExposedList$1(UnityEngine.Mesh),"sn":"meshes","ro":true},{"a":2,"n":"multiplyMaterial","t":4,"rt":$n[1].Material,"sn":"multiplyMaterial"},{"a":1,"n":"overrideTexture","t":4,"rt":$n[1].Texture,"sn":"overrideTexture"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"physicsMovementRelativeTo","t":4,"rt":$n[1].Transform,"sn":"physicsMovementRelativeTo"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"physicsPositionInheritanceFactor","t":4,"rt":$n[1].Vector2,"sn":"physicsPositionInheritanceFactor"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"physicsRotationInheritanceFactor","t":4,"rt":$n[0].Single,"sn":"physicsRotationInheritanceFactor","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"pivotOffset","t":4,"rt":$n[1].Vector2,"sn":"pivotOffset"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"referenceScale","t":4,"rt":$n[0].Single,"sn":"referenceScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"referenceSize","t":4,"rt":$n[1].Vector2,"sn":"referenceSize"},{"a":2,"n":"screenMaterial","t":4,"rt":$n[1].Material,"sn":"screenMaterial"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"separatorParts","t":4,"rt":$n[2].List$1(UnityEngine.Transform),"sn":"separatorParts"},{"at":[new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineSlot("", "", false, true, false)],"a":3,"n":"separatorSlotNames","t":4,"rt":$n[0].Array.type(System.String),"sn":"separatorSlotNames"},{"a":2,"n":"separatorSlots","t":4,"rt":$n[2].List$1(Spine.Slot),"sn":"separatorSlots","ro":true},{"a":3,"n":"skeleton","t":4,"rt":$n[8].Skeleton,"sn":"skeleton"},{"a":2,"n":"skeletonDataAsset","t":4,"rt":$n[5].SkeletonDataAsset,"sn":"skeletonDataAsset"},{"at":[new Spine.Unity.SpineAnimation("", "skeletonDataAsset", true, false, false)],"a":2,"n":"startingAnimation","t":4,"rt":$n[0].String,"sn":"startingAnimation"},{"a":2,"n":"startingLoop","t":4,"rt":$n[0].Boolean,"sn":"startingLoop","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"state","t":4,"rt":$n[8].AnimationState,"sn":"state"},{"a":3,"n":"submeshGraphics","t":4,"rt":$n[2].List$1(Spine.Unity.SkeletonSubmeshGraphic),"sn":"submeshGraphics"},{"a":2,"n":"timeScale","t":4,"rt":$n[0].Single,"sn":"timeScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"unscaledTime","t":4,"rt":$n[0].Boolean,"sn":"unscaledTime","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"updateMode","t":4,"rt":$n[5].UpdateMode,"sn":"updateMode","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"updateSeparatorPartLocation","t":4,"rt":$n[0].Boolean,"sn":"updateSeparatorPartLocation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"updateSeparatorPartScale","t":4,"rt":$n[0].Boolean,"sn":"updateSeparatorPartScale","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"updateTiming","t":4,"rt":$n[5].UpdateTiming,"sn":"updateTiming","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},{"a":2,"n":"updateWhenInvisible","t":4,"rt":$n[5].UpdateMode,"sn":"updateWhenInvisible","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":1,"n":"usedMaterials","t":4,"rt":$n[8].ExposedList$1(UnityEngine.Material),"sn":"usedMaterials","ro":true},{"a":3,"n":"usedRenderersCount","t":4,"rt":$n[0].Int32,"sn":"usedRenderersCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"usedTextures","t":4,"rt":$n[8].ExposedList$1(UnityEngine.Texture),"sn":"usedTextures","ro":true},{"a":1,"n":"wasUpdatedAfterInit","t":4,"rt":$n[0].Boolean,"sn":"wasUpdatedAfterInit","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"AssignMeshOverrideMultipleRenderers","t":2,"ad":{"a":2,"n":"add_AssignMeshOverrideMultipleRenderers","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addAssignMeshOverrideMultipleRenderers","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_AssignMeshOverrideMultipleRenderers","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeAssignMeshOverrideMultipleRenderers","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"AssignMeshOverrideSingleRenderer","t":2,"ad":{"a":2,"n":"add_AssignMeshOverrideSingleRenderer","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addAssignMeshOverrideSingleRenderer","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_AssignMeshOverrideSingleRenderer","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeAssignMeshOverrideSingleRenderer","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"BeforeApply","t":2,"ad":{"a":2,"n":"add_BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addBeforeApply","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeBeforeApply","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnAnimationRebuild","t":2,"ad":{"a":2,"n":"add_OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnAnimationRebuild","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnAnimationRebuild","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnInstructionsPrepared","t":2,"ad":{"a":2,"n":"add_OnInstructionsPrepared","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnInstructionsPrepared","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnInstructionsPrepared","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnInstructionsPrepared","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnMeshAndMaterialsUpdated","t":2,"ad":{"a":2,"n":"add_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnPostProcessVertices","t":2,"ad":{"a":2,"n":"add_OnPostProcessVertices","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnPostProcessVertices","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnPostProcessVertices","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnPostProcessVertices","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnRebuild","t":2,"ad":{"a":2,"n":"add_OnRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnRebuild","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnRebuild","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateComplete","t":2,"ad":{"a":2,"n":"add_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateComplete","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateComplete","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateLocal","t":2,"ad":{"a":2,"n":"add_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateLocal","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateLocal","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateWorld","t":2,"ad":{"a":2,"n":"add_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateWorld","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateWorld","rt":$n[0].Void,"p":[Function]}},{"a":1,"n":"assignMeshOverrideMultiple","t":2,"ad":{"a":1,"n":"add_assignMeshOverrideMultiple","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addassignMeshOverrideMultiple","rt":$n[0].Void,"p":[Function]},"r":{"a":1,"n":"remove_assignMeshOverrideMultiple","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeassignMeshOverrideMultiple","rt":$n[0].Void,"p":[Function]}},{"a":1,"n":"assignMeshOverrideSingle","t":2,"ad":{"a":1,"n":"add_assignMeshOverrideSingle","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addassignMeshOverrideSingle","rt":$n[0].Void,"p":[Function]},"r":{"a":1,"n":"remove_assignMeshOverrideSingle","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeassignMeshOverrideSingle","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonGraphic end.*/

    /*Spine.Unity.SkeletonGraphic+LayoutMode start.*/
    $m("Spine.Unity.SkeletonGraphic.LayoutMode", function () { return {"td":$n[5].SkeletonGraphic,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"EnvelopeParent","is":true,"t":4,"rt":$n[5].SkeletonGraphic.LayoutMode,"sn":"EnvelopeParent","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonGraphic.LayoutMode, System.Enum.toStringFn(Spine.Unity.SkeletonGraphic.LayoutMode));}},{"a":2,"n":"FitInParent","is":true,"t":4,"rt":$n[5].SkeletonGraphic.LayoutMode,"sn":"FitInParent","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonGraphic.LayoutMode, System.Enum.toStringFn(Spine.Unity.SkeletonGraphic.LayoutMode));}},{"a":2,"n":"HeightControlsWidth","is":true,"t":4,"rt":$n[5].SkeletonGraphic.LayoutMode,"sn":"HeightControlsWidth","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonGraphic.LayoutMode, System.Enum.toStringFn(Spine.Unity.SkeletonGraphic.LayoutMode));}},{"a":2,"n":"None","is":true,"t":4,"rt":$n[5].SkeletonGraphic.LayoutMode,"sn":"None","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonGraphic.LayoutMode, System.Enum.toStringFn(Spine.Unity.SkeletonGraphic.LayoutMode));}},{"a":2,"n":"WidthControlsHeight","is":true,"t":4,"rt":$n[5].SkeletonGraphic.LayoutMode,"sn":"WidthControlsHeight","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonGraphic.LayoutMode, System.Enum.toStringFn(Spine.Unity.SkeletonGraphic.LayoutMode));}}]}; }, $n);
    /*Spine.Unity.SkeletonGraphic+LayoutMode end.*/

    /*Spine.Unity.SkeletonMecanim start.*/
    $m("Spine.Unity.SkeletonMecanim", function () { return {"nested":[$n[5].SkeletonMecanim.MecanimTranslator],"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.ctor(UnityEngine.Animator),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonMecanim-Component")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"v":true,"a":2,"n":"AfterAnimationApplied","t":8,"sn":"AfterAnimationApplied","rt":$n[0].Void},{"v":true,"a":2,"n":"ApplyAnimation","t":8,"sn":"ApplyAnimation","rt":$n[0].Void},{"v":true,"a":2,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"ov":true,"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","pt":$n[0].Boolean,"ps":0},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean,$n[0].Boolean]},{"ov":true,"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"ov":true,"a":2,"n":"OnBecameVisible","t":8,"sn":"OnBecameVisible","rt":$n[0].Void},{"v":true,"a":2,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"v":true,"a":2,"n":"Update","t":8,"pi":[{"n":"deltaTime","pt":$n[0].Single,"ps":0}],"sn":"Update$1","rt":$n[0].Void,"p":[$n[0].Single]},{"a":3,"n":"UpdateAnimation","t":8,"pi":[{"n":"deltaTime","pt":$n[0].Single,"ps":0}],"sn":"UpdateAnimation","rt":$n[0].Void,"p":[$n[0].Single]},{"a":2,"n":"Translator","t":16,"rt":$n[5].SkeletonMecanim.MecanimTranslator,"g":{"a":2,"n":"get_Translator","t":8,"rt":$n[5].SkeletonMecanim.MecanimTranslator,"fg":"Translator"},"fn":"Translator"},{"a":2,"n":"UpdateTiming","t":16,"rt":$n[5].UpdateTiming,"g":{"a":2,"n":"get_UpdateTiming","t":8,"rt":$n[5].UpdateTiming,"fg":"UpdateTiming","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},"s":{"a":2,"n":"set_UpdateTiming","t":8,"p":[$n[5].UpdateTiming],"rt":$n[0].Void,"fs":"UpdateTiming"},"fn":"UpdateTiming"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"translator","t":4,"rt":$n[5].SkeletonMecanim.MecanimTranslator,"sn":"translator"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"updateTiming","t":4,"rt":$n[5].UpdateTiming,"sn":"updateTiming","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},{"a":1,"n":"wasUpdatedAfterInit","t":4,"rt":$n[0].Boolean,"sn":"wasUpdatedAfterInit","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"BeforeApply","t":2,"ad":{"a":2,"n":"add_BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addBeforeApply","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeBeforeApply","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnAnimationRebuild","t":2,"ad":{"a":2,"n":"add_OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnAnimationRebuild","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnAnimationRebuild","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateComplete","t":2,"ad":{"a":2,"n":"add_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateComplete","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateComplete","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateLocal","t":2,"ad":{"a":2,"n":"add_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateLocal","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateLocal","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateWorld","t":2,"ad":{"a":2,"n":"add_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateWorld","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateWorld","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_BeforeApply","t":2,"ad":{"a":3,"n":"add__BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_BeforeApply","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_BeforeApply","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_OnAnimationRebuild","t":2,"ad":{"a":3,"n":"add__OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_OnAnimationRebuild","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_OnAnimationRebuild","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_UpdateComplete","t":2,"ad":{"a":3,"n":"add__UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_UpdateComplete","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_UpdateComplete","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_UpdateLocal","t":2,"ad":{"a":3,"n":"add__UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_UpdateLocal","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_UpdateLocal","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_UpdateWorld","t":2,"ad":{"a":3,"n":"add__UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_UpdateWorld","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_UpdateWorld","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonMecanim end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator start.*/
    $m("Spine.Unity.SkeletonMecanim.MecanimTranslator", function () { return {"td":$n[5].SkeletonMecanim,"nested":[Function,$n[5].SkeletonMecanim.MecanimTranslator.MixMode,$n[5].SkeletonMecanim.MecanimTranslator.ClipInfos,$n[5].SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer,$n[5].SkeletonMecanim.MecanimTranslator.IntEqualityComparer],"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"AnimationTime","is":true,"t":8,"pi":[{"n":"normalizedTime","pt":$n[0].Single,"ps":0},{"n":"clipLength","pt":$n[0].Single,"ps":1},{"n":"loop","pt":$n[0].Boolean,"ps":2},{"n":"reversed","pt":$n[0].Boolean,"ps":3}],"sn":"AnimationTime","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single,$n[0].Boolean,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0}],"sn":"Apply","rt":$n[0].Void,"p":[$n[8].Skeleton]},{"a":1,"n":"ApplyAnimation","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"info","pt":$n[1].AnimatorClipInfo,"ps":1},{"n":"stateInfo","pt":$n[1].AnimatorStateInfo,"ps":2},{"n":"layerIndex","pt":$n[0].Int32,"ps":3},{"n":"layerWeight","pt":$n[0].Single,"ps":4},{"n":"layerBlendMode","pt":$n[8].MixBlend,"ps":5},{"n":"useClipWeight1","dv":false,"o":true,"pt":$n[0].Boolean,"ps":6}],"sn":"ApplyAnimation","rt":$n[0].Boolean,"p":[$n[8].Skeleton,$n[1].AnimatorClipInfo,$n[1].AnimatorStateInfo,$n[0].Int32,$n[0].Single,$n[8].MixBlend,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"ApplyInterruptionAnimation","t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"interpolateWeightTo1","pt":$n[0].Boolean,"ps":1},{"n":"info","pt":$n[1].AnimatorClipInfo,"ps":2},{"n":"stateInfo","pt":$n[1].AnimatorStateInfo,"ps":3},{"n":"layerIndex","pt":$n[0].Int32,"ps":4},{"n":"layerWeight","pt":$n[0].Single,"ps":5},{"n":"layerBlendMode","pt":$n[8].MixBlend,"ps":6},{"n":"interruptingClipTimeAddition","pt":$n[0].Single,"ps":7},{"n":"useClipWeight1","dv":false,"o":true,"pt":$n[0].Boolean,"ps":8}],"sn":"ApplyInterruptionAnimation","rt":$n[0].Boolean,"p":[$n[8].Skeleton,$n[0].Boolean,$n[1].AnimatorClipInfo,$n[1].AnimatorStateInfo,$n[0].Int32,$n[0].Single,$n[8].MixBlend,$n[0].Single,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"ClearClipInfosForLayers","t":8,"sn":"ClearClipInfosForLayers","rt":$n[0].Void},{"a":2,"n":"GetActiveAnimationAndTime","t":8,"pi":[{"n":"layer","pt":$n[0].Int32,"ps":0}],"sn":"GetActiveAnimationAndTime","rt":$n[2].KeyValuePair$2(Spine.Animation,System.Single),"p":[$n[0].Int32]},{"a":1,"n":"GetAnimation","t":8,"pi":[{"n":"clip","pt":$n[1].AnimationClip,"ps":0}],"sn":"GetAnimation","rt":$n[8].Animation,"p":[$n[1].AnimationClip]},{"a":1,"n":"GetAnimatorClipInfos","t":8,"pi":[{"n":"layer","pt":$n[0].Int32,"ps":0},{"n":"isInterruptionActive","out":true,"pt":$n[0].Boolean,"ps":1},{"n":"clipInfoCount","out":true,"pt":$n[0].Int32,"ps":2},{"n":"nextClipInfoCount","out":true,"pt":$n[0].Int32,"ps":3},{"n":"interruptingClipInfoCount","out":true,"pt":$n[0].Int32,"ps":4},{"n":"clipInfo","out":true,"pt":$n[2].IList$1(UnityEngine.AnimatorClipInfo),"ps":5},{"n":"nextClipInfo","out":true,"pt":$n[2].IList$1(UnityEngine.AnimatorClipInfo),"ps":6},{"n":"interruptingClipInfo","out":true,"pt":$n[2].IList$1(UnityEngine.AnimatorClipInfo),"ps":7},{"n":"shallInterpolateWeightTo1","out":true,"pt":$n[0].Boolean,"ps":8}],"sn":"GetAnimatorClipInfos","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Boolean,$n[0].Int32,$n[0].Int32,$n[0].Int32,$n[2].IList$1(UnityEngine.AnimatorClipInfo),$n[2].IList$1(UnityEngine.AnimatorClipInfo),$n[2].IList$1(UnityEngine.AnimatorClipInfo),$n[0].Boolean]},{"a":1,"n":"GetAnimatorStateInfos","t":8,"pi":[{"n":"layer","pt":$n[0].Int32,"ps":0},{"n":"isInterruptionActive","out":true,"pt":$n[0].Boolean,"ps":1},{"n":"stateInfo","out":true,"pt":$n[1].AnimatorStateInfo,"ps":2},{"n":"nextStateInfo","out":true,"pt":$n[1].AnimatorStateInfo,"ps":3},{"n":"interruptingStateInfo","out":true,"pt":$n[1].AnimatorStateInfo,"ps":4},{"n":"interruptingClipTimeAddition","out":true,"pt":$n[0].Single,"ps":5}],"sn":"GetAnimatorStateInfos","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Boolean,$n[1].AnimatorStateInfo,$n[1].AnimatorStateInfo,$n[1].AnimatorStateInfo,$n[0].Single]},{"a":1,"n":"GetMixMode","t":8,"pi":[{"n":"layer","pt":$n[0].Int32,"ps":0},{"n":"layerBlendMode","pt":$n[8].MixBlend,"ps":1}],"sn":"GetMixMode","rt":$n[5].SkeletonMecanim.MecanimTranslator.MixMode,"p":[$n[0].Int32,$n[8].MixBlend],"box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode, System.Enum.toStringFn(Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode));}},{"a":1,"n":"GetStateUpdatesFromAnimator","t":8,"pi":[{"n":"layer","pt":$n[0].Int32,"ps":0}],"sn":"GetStateUpdatesFromAnimator","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":1,"n":"InitClipInfosForLayers","t":8,"sn":"InitClipInfosForLayers","rt":$n[0].Void},{"a":2,"n":"Initialize","t":8,"pi":[{"n":"animator","pt":$n[1].Animator,"ps":0},{"n":"skeletonDataAsset","pt":$n[5].SkeletonDataAsset,"ps":1}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[1].Animator,$n[5].SkeletonDataAsset]},{"a":1,"n":"OnClipAppliedCallback","t":8,"pi":[{"n":"clip","pt":$n[8].Animation,"ps":0},{"n":"stateInfo","pt":$n[1].AnimatorStateInfo,"ps":1},{"n":"layerIndex","pt":$n[0].Int32,"ps":2},{"n":"time","pt":$n[0].Single,"ps":3},{"n":"isLooping","pt":$n[0].Boolean,"ps":4},{"n":"weight","pt":$n[0].Single,"ps":5}],"sn":"OnClipAppliedCallback","rt":$n[0].Void,"p":[$n[8].Animation,$n[1].AnimatorStateInfo,$n[0].Int32,$n[0].Single,$n[0].Boolean,$n[0].Single]},{"a":1,"n":"ToSpineAnimationTime","is":true,"t":8,"pi":[{"n":"normalizedTime","pt":$n[0].Single,"ps":0},{"n":"clipLength","pt":$n[0].Single,"ps":1},{"n":"loop","pt":$n[0].Boolean,"ps":2},{"n":"reversed","pt":$n[0].Boolean,"ps":3}],"sn":"ToSpineAnimationTime","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single,$n[0].Boolean,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Animator","t":16,"rt":$n[1].Animator,"g":{"a":2,"n":"get_Animator","t":8,"rt":$n[1].Animator,"fg":"Animator"},"fn":"Animator"},{"a":2,"n":"MecanimLayerCount","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_MecanimLayerCount","t":8,"rt":$n[0].Int32,"fg":"MecanimLayerCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"MecanimLayerCount"},{"a":2,"n":"MecanimLayerNames","t":16,"rt":$n[0].Array.type(System.String),"g":{"a":2,"n":"get_MecanimLayerNames","t":8,"rt":$n[0].Array.type(System.String),"fg":"MecanimLayerNames"},"fn":"MecanimLayerNames"},{"a":1,"n":"WeightEpsilon","is":true,"t":4,"rt":$n[0].Single,"sn":"WeightEpsilon","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"animationTable","t":4,"rt":$n[2].Dictionary$2(System.Int32,Spine.Animation),"sn":"animationTable","ro":true},{"a":1,"n":"animator","t":4,"rt":$n[1].Animator,"sn":"animator"},{"a":2,"n":"autoReset","t":4,"rt":$n[0].Boolean,"sn":"autoReset","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"clipNameHashCodeTable","t":4,"rt":$n[2].Dictionary$2(UnityEngine.AnimationClip,System.Int32),"sn":"clipNameHashCodeTable","ro":true},{"a":2,"n":"layerBlendModes","t":4,"rt":System.Array.type(Spine.MixBlend),"sn":"layerBlendModes"},{"a":3,"n":"layerClipInfos","t":4,"rt":System.Array.type(Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos),"sn":"layerClipInfos"},{"a":2,"n":"layerMixModes","t":4,"rt":System.Array.type(Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode),"sn":"layerMixModes"},{"a":1,"n":"previousAnimations","t":4,"rt":$n[2].List$1(Spine.Animation),"sn":"previousAnimations","ro":true},{"a":2,"n":"useCustomMixMode","t":4,"rt":$n[0].Boolean,"sn":"useCustomMixMode","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"OnClipApplied","t":2,"ad":{"a":2,"n":"add_OnClipApplied","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnClipApplied","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnClipApplied","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnClipApplied","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_OnClipApplied","t":2,"ad":{"a":3,"n":"add__OnClipApplied","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_OnClipApplied","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__OnClipApplied","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_OnClipApplied","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+MixMode start.*/
    $m("Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode", function () { return {"td":$n[5].SkeletonMecanim.MecanimTranslator,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AlwaysMix","is":true,"t":4,"rt":$n[5].SkeletonMecanim.MecanimTranslator.MixMode,"sn":"AlwaysMix","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode, System.Enum.toStringFn(Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode));}},{"a":2,"n":"Hard","is":true,"t":4,"rt":$n[5].SkeletonMecanim.MecanimTranslator.MixMode,"sn":"Hard","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode, System.Enum.toStringFn(Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode));}},{"a":2,"n":"MixNext","is":true,"t":4,"rt":$n[5].SkeletonMecanim.MecanimTranslator.MixMode,"sn":"MixNext","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode, System.Enum.toStringFn(Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode));}}]}; }, $n);
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+MixMode end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+ClipInfos start.*/
    $m("Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos", function () { return {"td":$n[5].SkeletonMecanim.MecanimTranslator,"att":1048580,"a":3,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"clipInfoCount","t":4,"rt":$n[0].Int32,"sn":"clipInfoCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"clipInfos","t":4,"rt":$n[2].List$1(UnityEngine.AnimatorClipInfo),"sn":"clipInfos","ro":true},{"a":2,"n":"interruptingClipInfoCount","t":4,"rt":$n[0].Int32,"sn":"interruptingClipInfoCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"interruptingClipInfos","t":4,"rt":$n[2].List$1(UnityEngine.AnimatorClipInfo),"sn":"interruptingClipInfos","ro":true},{"a":2,"n":"interruptingClipTimeAddition","t":4,"rt":$n[0].Single,"sn":"interruptingClipTimeAddition","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"interruptingStateInfo","t":4,"rt":$n[1].AnimatorStateInfo,"sn":"interruptingStateInfo"},{"a":2,"n":"isInterruptionActive","t":4,"rt":$n[0].Boolean,"sn":"isInterruptionActive","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"isLastFrameOfInterruption","t":4,"rt":$n[0].Boolean,"sn":"isLastFrameOfInterruption","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"nextClipInfoCount","t":4,"rt":$n[0].Int32,"sn":"nextClipInfoCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"nextClipInfos","t":4,"rt":$n[2].List$1(UnityEngine.AnimatorClipInfo),"sn":"nextClipInfos","ro":true},{"a":2,"n":"nextStateInfo","t":4,"rt":$n[1].AnimatorStateInfo,"sn":"nextStateInfo"},{"a":2,"n":"stateInfo","t":4,"rt":$n[1].AnimatorStateInfo,"sn":"stateInfo"}]}; }, $n);
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+ClipInfos end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer start.*/
    $m("Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer", function () { return {"td":$n[5].SkeletonMecanim.MecanimTranslator,"att":1048579,"a":1,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Equals","t":8,"pi":[{"n":"x","pt":$n[1].AnimationClip,"ps":0},{"n":"y","pt":$n[1].AnimationClip,"ps":1}],"sn":"equals2","rt":$n[0].Boolean,"p":[$n[1].AnimationClip,$n[1].AnimationClip],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"GetHashCode","t":8,"pi":[{"n":"o","pt":$n[1].AnimationClip,"ps":0}],"sn":"getHashCode2","rt":$n[0].Int32,"p":[$n[1].AnimationClip],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"Instance","is":true,"t":4,"rt":$n[2].IEqualityComparer$1(UnityEngine.AnimationClip),"sn":"Instance","ro":true}]}; }, $n);
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer start.*/
    $m("Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer", function () { return {"td":$n[5].SkeletonMecanim.MecanimTranslator,"att":1048579,"a":1,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Equals","t":8,"pi":[{"n":"x","pt":$n[0].Int32,"ps":0},{"n":"y","pt":$n[0].Int32,"ps":1}],"sn":"equals2","rt":$n[0].Boolean,"p":[$n[0].Int32,$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"GetHashCode","t":8,"pi":[{"n":"o","pt":$n[0].Int32,"ps":0}],"sn":"getHashCode2","rt":$n[0].Int32,"p":[$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"Instance","is":true,"t":4,"rt":$n[2].IEqualityComparer$1(System.Int32),"sn":"Instance","ro":true}]}; }, $n);
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer end.*/

    /*Spine.Unity.SkeletonRenderer start.*/
    $m("Spine.Unity.SkeletonRenderer", function () { return {"nested":[$n[5].SkeletonRenderer.SpriteMaskInteractionMaterials,Function,Function],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.RequireComponent.ctor(UnityEngine.MeshRenderer),new UnityEngine.DisallowMultipleComponent(),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonRenderer-Component")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddSpineComponent","is":true,"t":8,"pi":[{"n":"gameObject","pt":$n[1].GameObject,"ps":0},{"n":"skeletonDataAsset","pt":$n[5].SkeletonDataAsset,"ps":1},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2}],"tpc":1,"tprm":["T"],"sn":"AddSpineComponent","rt":System.Object,"p":[$n[1].GameObject,$n[5].SkeletonDataAsset,$n[0].Boolean]},{"v":true,"a":2,"n":"ApplyTransformMovementToPhysics","t":8,"sn":"ApplyTransformMovementToPhysics","rt":$n[0].Void},{"a":1,"n":"AssignSpriteMaskMaterials","t":8,"sn":"AssignSpriteMaskMaterials","rt":$n[0].Void},{"v":true,"a":2,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"v":true,"a":2,"n":"ClearState","t":8,"sn":"ClearState","rt":$n[0].Void},{"a":2,"n":"EnsureMeshGeneratorCapacity","t":8,"pi":[{"n":"minimumVertexCount","pt":$n[0].Int32,"ps":0}],"sn":"EnsureMeshGeneratorCapacity","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"FindAndApplySeparatorSlots","t":8,"pi":[{"n":"slotNamePredicate","pt":Function,"ps":0},{"n":"clearExistingSeparators","dv":true,"o":true,"pt":$n[0].Boolean,"ps":1},{"n":"updateStringArray","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"FindAndApplySeparatorSlots","rt":$n[0].Void,"p":[Function,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"FindAndApplySeparatorSlots","t":8,"pi":[{"n":"startsWith","pt":$n[0].String,"ps":0},{"n":"clearExistingSeparators","dv":true,"o":true,"pt":$n[0].Boolean,"ps":1},{"n":"updateStringArray","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"FindAndApplySeparatorSlots$1","rt":$n[0].Void,"p":[$n[0].String,$n[0].Boolean,$n[0].Boolean]},{"a":3,"n":"GetPhysicsTransformPosition","t":8,"sn":"GetPhysicsTransformPosition","rt":$n[1].Vector3},{"a":3,"n":"GetPhysicsTransformRotation","t":8,"sn":"GetPhysicsTransformRotation","rt":$n[0].Single,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"HandleOnDemandLoading","t":8,"sn":"HandleOnDemandLoading","rt":$n[0].Void},{"a":1,"n":"InitSpriteMaskMaterialsForMaskType","t":8,"pi":[{"n":"maskFunction","pt":$n[11].CompareFunction,"ps":0},{"n":"materialsToFill","ref":true,"pt":System.Array.type(UnityEngine.Material),"ps":1}],"sn":"InitSpriteMaskMaterialsForMaskType","rt":$n[0].Boolean,"p":[$n[11].CompareFunction,System.Array.type(UnityEngine.Material)],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"InitSpriteMaskMaterialsInsideMask","t":8,"sn":"InitSpriteMaskMaterialsInsideMask","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"InitSpriteMaskMaterialsOutsideMask","t":8,"sn":"InitSpriteMaskMaterialsOutsideMask","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"v":true,"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","pt":$n[0].Boolean,"ps":0},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean,$n[0].Boolean]},{"v":true,"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"v":true,"a":2,"n":"LateUpdateMesh","t":8,"sn":"LateUpdateMesh","rt":$n[0].Void},{"a":2,"n":"NewSpineGameObject","is":true,"t":8,"pi":[{"n":"skeletonDataAsset","pt":$n[5].SkeletonDataAsset,"ps":0},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"tpc":1,"tprm":["T"],"sn":"NewSpineGameObject","rt":System.Object,"p":[$n[5].SkeletonDataAsset,$n[0].Boolean]},{"a":2,"n":"OnBecameInvisible","t":8,"sn":"OnBecameInvisible","rt":$n[0].Void},{"v":true,"a":2,"n":"OnBecameVisible","t":8,"sn":"OnBecameVisible","rt":$n[0].Void},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":2,"n":"ReapplySeparatorSlotNames","t":8,"sn":"ReapplySeparatorSlotNames","rt":$n[0].Void},{"a":2,"n":"ResetLastPosition","t":8,"sn":"ResetLastPosition","rt":$n[0].Void},{"a":2,"n":"ResetLastPositionAndRotation","t":8,"sn":"ResetLastPositionAndRotation","rt":$n[0].Void},{"a":2,"n":"ResetLastRotation","t":8,"sn":"ResetLastRotation","rt":$n[0].Void},{"a":1,"n":"SetMaterialSettingsToFixDrawOrder","t":8,"sn":"SetMaterialSettingsToFixDrawOrder","rt":$n[0].Void},{"a":2,"n":"SetMeshSettings","t":8,"pi":[{"n":"settings","pt":$n[5].MeshGenerator.Settings,"ps":0}],"sn":"SetMeshSettings","rt":$n[0].Void,"p":[$n[5].MeshGenerator.Settings]},{"v":true,"a":3,"n":"UpdateWorldTransform","t":8,"pi":[{"n":"physics","pt":$n[8].Skeleton.Physics,"ps":0}],"sn":"UpdateWorldTransform","rt":$n[0].Void,"p":[$n[8].Skeleton.Physics]},{"a":2,"n":"CustomMaterialOverride","t":16,"rt":$n[2].Dictionary$2(UnityEngine.Material,UnityEngine.Material),"g":{"a":2,"n":"get_CustomMaterialOverride","t":8,"rt":$n[2].Dictionary$2(UnityEngine.Material,UnityEngine.Material),"fg":"CustomMaterialOverride"},"fn":"CustomMaterialOverride"},{"a":2,"n":"CustomSlotMaterials","t":16,"rt":$n[2].Dictionary$2(Spine.Slot,UnityEngine.Material),"g":{"a":2,"n":"get_CustomSlotMaterials","t":8,"rt":$n[2].Dictionary$2(Spine.Slot,UnityEngine.Material),"fg":"CustomSlotMaterials"},"fn":"CustomSlotMaterials"},{"a":2,"n":"PhysicsMovementRelativeTo","t":16,"rt":$n[1].Transform,"g":{"a":2,"n":"get_PhysicsMovementRelativeTo","t":8,"rt":$n[1].Transform,"fg":"PhysicsMovementRelativeTo"},"s":{"a":2,"n":"set_PhysicsMovementRelativeTo","t":8,"p":[$n[1].Transform],"rt":$n[0].Void,"fs":"PhysicsMovementRelativeTo"},"fn":"PhysicsMovementRelativeTo"},{"a":2,"n":"PhysicsPositionInheritanceFactor","t":16,"rt":$n[1].Vector2,"g":{"a":2,"n":"get_PhysicsPositionInheritanceFactor","t":8,"rt":$n[1].Vector2,"fg":"PhysicsPositionInheritanceFactor"},"s":{"a":2,"n":"set_PhysicsPositionInheritanceFactor","t":8,"p":[$n[1].Vector2],"rt":$n[0].Void,"fs":"PhysicsPositionInheritanceFactor"},"fn":"PhysicsPositionInheritanceFactor"},{"a":2,"n":"PhysicsRotationInheritanceFactor","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_PhysicsRotationInheritanceFactor","t":8,"rt":$n[0].Single,"fg":"PhysicsRotationInheritanceFactor","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_PhysicsRotationInheritanceFactor","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"PhysicsRotationInheritanceFactor"},"fn":"PhysicsRotationInheritanceFactor"},{"a":2,"n":"Skeleton","t":16,"rt":$n[8].Skeleton,"g":{"a":2,"n":"get_Skeleton","t":8,"rt":$n[8].Skeleton,"fg":"Skeleton"},"fn":"Skeleton"},{"a":2,"n":"SkeletonClipping","t":16,"rt":$n[8].SkeletonClipping,"g":{"a":2,"n":"get_SkeletonClipping","t":8,"rt":$n[8].SkeletonClipping,"fg":"SkeletonClipping"},"fn":"SkeletonClipping"},{"a":2,"n":"SkeletonDataAsset","t":16,"rt":$n[5].SkeletonDataAsset,"g":{"a":2,"n":"get_SkeletonDataAsset","t":8,"rt":$n[5].SkeletonDataAsset,"fg":"SkeletonDataAsset"},"fn":"SkeletonDataAsset"},{"a":2,"n":"UpdateMode","t":16,"rt":$n[5].UpdateMode,"g":{"a":2,"n":"get_UpdateMode","t":8,"rt":$n[5].UpdateMode,"fg":"UpdateMode","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},"s":{"a":2,"n":"set_UpdateMode","t":8,"p":[$n[5].UpdateMode],"rt":$n[0].Void,"fs":"UpdateMode"},"fn":"UpdateMode"},{"a":2,"n":"STENCIL_COMP_MASKINTERACTION_NONE","is":true,"t":4,"rt":$n[11].CompareFunction,"sn":"STENCIL_COMP_MASKINTERACTION_NONE","box":function ($v) { return Bridge.box($v, UnityEngine.Rendering.CompareFunction, System.Enum.toStringFn(UnityEngine.Rendering.CompareFunction));}},{"a":2,"n":"STENCIL_COMP_MASKINTERACTION_VISIBLE_INSIDE","is":true,"t":4,"rt":$n[11].CompareFunction,"sn":"STENCIL_COMP_MASKINTERACTION_VISIBLE_INSIDE","box":function ($v) { return Bridge.box($v, UnityEngine.Rendering.CompareFunction, System.Enum.toStringFn(UnityEngine.Rendering.CompareFunction));}},{"a":2,"n":"STENCIL_COMP_MASKINTERACTION_VISIBLE_OUTSIDE","is":true,"t":4,"rt":$n[11].CompareFunction,"sn":"STENCIL_COMP_MASKINTERACTION_VISIBLE_OUTSIDE","box":function ($v) { return Bridge.box($v, UnityEngine.Rendering.CompareFunction, System.Enum.toStringFn(UnityEngine.Rendering.CompareFunction));}},{"a":2,"n":"STENCIL_COMP_PARAM_ID","is":true,"t":4,"rt":$n[0].Int32,"sn":"STENCIL_COMP_PARAM_ID","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"SUBMESH_DUMMY_PARAM_ID","is":true,"t":4,"rt":$n[0].Int32,"sn":"SUBMESH_DUMMY_PARAM_ID","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("calculateNormals")],"a":2,"n":"addNormals","t":4,"rt":$n[0].Boolean,"sn":"addNormals","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"calculateTangents","t":4,"rt":$n[0].Boolean,"sn":"calculateTangents","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"clearStateOnDisable","t":4,"rt":$n[0].Boolean,"sn":"clearStateOnDisable","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"currentInstructions","t":4,"rt":$n[5].SkeletonRendererInstruction,"sn":"currentInstructions","ro":true},{"a":1,"n":"customMaterialOverride","t":4,"rt":$n[2].Dictionary$2(UnityEngine.Material,UnityEngine.Material),"sn":"customMaterialOverride","ro":true},{"a":1,"n":"customSlotMaterials","t":4,"rt":$n[2].Dictionary$2(Spine.Slot,UnityEngine.Material),"sn":"customSlotMaterials","ro":true},{"a":2,"n":"disableRenderingOnOverride","t":4,"rt":$n[0].Boolean,"sn":"disableRenderingOnOverride","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"fixDrawOrder","t":4,"rt":$n[0].Boolean,"sn":"fixDrawOrder","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"immutableTriangles","t":4,"rt":$n[0].Boolean,"sn":"immutableTriangles","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"initialFlipX","t":4,"rt":$n[0].Boolean,"sn":"initialFlipX","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"initialFlipY","t":4,"rt":$n[0].Boolean,"sn":"initialFlipY","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new Spine.Unity.SpineSkin("", "", false, false, true, false)],"a":2,"n":"initialSkinName","t":4,"rt":$n[0].String,"sn":"initialSkinName"},{"a":3,"n":"lastPosition","t":4,"rt":$n[1].Vector3,"sn":"lastPosition"},{"a":3,"n":"lastRotation","t":4,"rt":$n[0].Single,"sn":"lastRotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"maskInteraction","t":4,"rt":$n[1].SpriteMaskInteraction,"sn":"maskInteraction","box":function ($v) { return Bridge.box($v, UnityEngine.SpriteMaskInteraction, System.Enum.toStringFn(UnityEngine.SpriteMaskInteraction));}},{"a":2,"n":"maskMaterials","t":4,"rt":$n[5].SkeletonRenderer.SpriteMaskInteractionMaterials,"sn":"maskMaterials"},{"a":1,"n":"meshFilter","t":4,"rt":$n[1].MeshFilter,"sn":"meshFilter"},{"a":1,"n":"meshGenerator","t":4,"rt":$n[5].MeshGenerator,"sn":"meshGenerator","ro":true},{"a":1,"n":"meshRenderer","t":4,"rt":$n[1].MeshRenderer,"sn":"meshRenderer"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"physicsMovementRelativeTo","t":4,"rt":$n[1].Transform,"sn":"physicsMovementRelativeTo"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"physicsPositionInheritanceFactor","t":4,"rt":$n[1].Vector2,"sn":"physicsPositionInheritanceFactor"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"physicsRotationInheritanceFactor","t":4,"rt":$n[0].Single,"sn":"physicsRotationInheritanceFactor","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"pmaVertexColors","t":4,"rt":$n[0].Boolean,"sn":"pmaVertexColors","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"rendererBuffers","t":4,"rt":$n[5].MeshRendererBuffers,"sn":"rendererBuffers","ro":true},{"a":1,"n":"reusedPropertyBlock","t":4,"rt":$n[1].MaterialPropertyBlock,"sn":"reusedPropertyBlock"},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("submeshSeparators"),new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineSlot("", "", false, true, false)],"a":3,"n":"separatorSlotNames","t":4,"rt":$n[0].Array.type(System.String),"sn":"separatorSlotNames"},{"a":2,"n":"separatorSlots","t":4,"rt":$n[2].List$1(Spine.Slot),"sn":"separatorSlots","ro":true},{"a":2,"n":"singleSubmesh","t":4,"rt":$n[0].Boolean,"sn":"singleSubmesh","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"skeleton","t":4,"rt":$n[8].Skeleton,"sn":"skeleton"},{"a":2,"n":"skeletonDataAsset","t":4,"rt":$n[5].SkeletonDataAsset,"sn":"skeletonDataAsset"},{"a":2,"n":"tintBlack","t":4,"rt":$n[0].Boolean,"sn":"tintBlack","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"updateMode","t":4,"rt":$n[5].UpdateMode,"sn":"updateMode","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"updateWhenInvisible","t":4,"rt":$n[5].UpdateMode,"sn":"updateWhenInvisible","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"useClipping","t":4,"rt":$n[0].Boolean,"sn":"useClipping","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"valid","t":4,"rt":$n[0].Boolean,"sn":"valid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.RangeAttribute(-0.1, 0.0)],"a":2,"n":"zSpacing","t":4,"rt":$n[0].Single,"sn":"zSpacing","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"GenerateMeshOverride","t":2,"ad":{"a":2,"n":"add_GenerateMeshOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addGenerateMeshOverride","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_GenerateMeshOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeGenerateMeshOverride","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnMeshAndMaterialsUpdated","t":2,"ad":{"a":2,"n":"add_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnPostProcessVertices","t":2,"ad":{"a":2,"n":"add_OnPostProcessVertices","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnPostProcessVertices","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnPostProcessVertices","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnPostProcessVertices","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnRebuild","t":2,"ad":{"a":2,"n":"add_OnRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnRebuild","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnRebuild","rt":$n[0].Void,"p":[Function]}},{"a":1,"n":"generateMeshOverride","t":2,"ad":{"a":1,"n":"add_generateMeshOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addgenerateMeshOverride","rt":$n[0].Void,"p":[Function]},"r":{"a":1,"n":"remove_generateMeshOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removegenerateMeshOverride","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonRenderer end.*/

    /*Spine.Unity.SkeletonRenderer+SpriteMaskInteractionMaterials start.*/
    $m("Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials", function () { return {"td":$n[5].SkeletonRenderer,"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AnyMaterialCreated","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_AnyMaterialCreated","t":8,"rt":$n[0].Boolean,"fg":"AnyMaterialCreated","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"AnyMaterialCreated"},{"a":2,"n":"materialsInsideMask","t":4,"rt":System.Array.type(UnityEngine.Material),"sn":"materialsInsideMask"},{"a":2,"n":"materialsMaskDisabled","t":4,"rt":System.Array.type(UnityEngine.Material),"sn":"materialsMaskDisabled"},{"a":2,"n":"materialsOutsideMask","t":4,"rt":System.Array.type(UnityEngine.Material),"sn":"materialsOutsideMask"}]}; }, $n);
    /*Spine.Unity.SkeletonRenderer+SpriteMaskInteractionMaterials end.*/

    /*Spine.Unity.SkeletonGraphicCustomMaterials start.*/
    $m("Spine.Unity.SkeletonGraphicCustomMaterials", function () { return {"nested":[$n[5].SkeletonGraphicCustomMaterials.AtlasMaterialOverride,$n[5].SkeletonGraphicCustomMaterials.AtlasTextureOverride],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonGraphicCustomMaterials")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"RemoveCustomMaterialOverrides","t":8,"sn":"RemoveCustomMaterialOverrides","rt":$n[0].Void},{"a":1,"n":"RemoveCustomTextureOverrides","t":8,"sn":"RemoveCustomTextureOverrides","rt":$n[0].Void},{"a":1,"n":"SetCustomMaterialOverrides","t":8,"sn":"SetCustomMaterialOverrides","rt":$n[0].Void},{"a":1,"n":"SetCustomTextureOverrides","t":8,"sn":"SetCustomTextureOverrides","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"customMaterialOverrides","t":4,"rt":$n[2].List$1(Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride),"sn":"customMaterialOverrides"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"customTextureOverrides","t":4,"rt":$n[2].List$1(Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride),"sn":"customTextureOverrides"},{"a":2,"n":"skeletonGraphic","t":4,"rt":$n[5].SkeletonGraphic,"sn":"skeletonGraphic"}]}; }, $n);
    /*Spine.Unity.SkeletonGraphicCustomMaterials end.*/

    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasMaterialOverride start.*/
    $m("Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride", function () { return {"td":$n[5].SkeletonGraphicCustomMaterials,"att":1057034,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Equals","t":8,"pi":[{"n":"other","pt":$n[5].SkeletonGraphicCustomMaterials.AtlasMaterialOverride,"ps":0}],"sn":"equalsT","rt":$n[0].Boolean,"p":[$n[5].SkeletonGraphicCustomMaterials.AtlasMaterialOverride],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"originalTexture","t":4,"rt":$n[1].Texture,"sn":"originalTexture"},{"a":2,"n":"overrideEnabled","t":4,"rt":$n[0].Boolean,"sn":"overrideEnabled","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"replacementMaterial","t":4,"rt":$n[1].Material,"sn":"replacementMaterial"}]}; }, $n);
    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasMaterialOverride end.*/

    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasTextureOverride start.*/
    $m("Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride", function () { return {"td":$n[5].SkeletonGraphicCustomMaterials,"att":1057034,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Equals","t":8,"pi":[{"n":"other","pt":$n[5].SkeletonGraphicCustomMaterials.AtlasTextureOverride,"ps":0}],"sn":"equalsT","rt":$n[0].Boolean,"p":[$n[5].SkeletonGraphicCustomMaterials.AtlasTextureOverride],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"originalTexture","t":4,"rt":$n[1].Texture,"sn":"originalTexture"},{"a":2,"n":"overrideEnabled","t":4,"rt":$n[0].Boolean,"sn":"overrideEnabled","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"replacementTexture","t":4,"rt":$n[1].Texture,"sn":"replacementTexture"}]}; }, $n);
    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasTextureOverride end.*/

    /*Spine.Unity.SkeletonRendererCustomMaterials start.*/
    $m("Spine.Unity.SkeletonRendererCustomMaterials", function () { return {"nested":[$n[5].SkeletonRendererCustomMaterials.SlotMaterialOverride,$n[5].SkeletonRendererCustomMaterials.AtlasMaterialOverride],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonRendererCustomMaterials")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"RemoveCustomMaterialOverrides","t":8,"sn":"RemoveCustomMaterialOverrides","rt":$n[0].Void},{"a":1,"n":"RemoveCustomSlotMaterials","t":8,"sn":"RemoveCustomSlotMaterials","rt":$n[0].Void},{"a":1,"n":"SetCustomMaterialOverrides","t":8,"sn":"SetCustomMaterialOverrides","rt":$n[0].Void},{"a":1,"n":"SetCustomSlotMaterials","t":8,"sn":"SetCustomSlotMaterials","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"customMaterialOverrides","t":4,"rt":$n[2].List$1(Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride),"sn":"customMaterialOverrides"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"customSlotMaterials","t":4,"rt":$n[2].List$1(Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride),"sn":"customSlotMaterials"},{"a":2,"n":"skeletonRenderer","t":4,"rt":$n[5].SkeletonRenderer,"sn":"skeletonRenderer"}]}; }, $n);
    /*Spine.Unity.SkeletonRendererCustomMaterials end.*/

    /*Spine.Unity.SkeletonRendererCustomMaterials+SlotMaterialOverride start.*/
    $m("Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride", function () { return {"td":$n[5].SkeletonRendererCustomMaterials,"att":1057034,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Equals","t":8,"pi":[{"n":"other","pt":$n[5].SkeletonRendererCustomMaterials.SlotMaterialOverride,"ps":0}],"sn":"equalsT","rt":$n[0].Boolean,"p":[$n[5].SkeletonRendererCustomMaterials.SlotMaterialOverride],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"material","t":4,"rt":$n[1].Material,"sn":"material"},{"a":2,"n":"overrideDisabled","t":4,"rt":$n[0].Boolean,"sn":"overrideDisabled","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new Spine.Unity.SpineSlot("", "", false, true, false)],"a":2,"n":"slotName","t":4,"rt":$n[0].String,"sn":"slotName"}]}; }, $n);
    /*Spine.Unity.SkeletonRendererCustomMaterials+SlotMaterialOverride end.*/

    /*Spine.Unity.SkeletonRendererCustomMaterials+AtlasMaterialOverride start.*/
    $m("Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride", function () { return {"td":$n[5].SkeletonRendererCustomMaterials,"att":1057034,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Equals","t":8,"pi":[{"n":"other","pt":$n[5].SkeletonRendererCustomMaterials.AtlasMaterialOverride,"ps":0}],"sn":"equalsT","rt":$n[0].Boolean,"p":[$n[5].SkeletonRendererCustomMaterials.AtlasMaterialOverride],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"originalMaterial","t":4,"rt":$n[1].Material,"sn":"originalMaterial"},{"a":2,"n":"overrideDisabled","t":4,"rt":$n[0].Boolean,"sn":"overrideDisabled","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"replacementMaterial","t":4,"rt":$n[1].Material,"sn":"replacementMaterial"}]}; }, $n);
    /*Spine.Unity.SkeletonRendererCustomMaterials+AtlasMaterialOverride end.*/

    /*Spine.Unity.SkeletonPartsRenderer start.*/
    $m("Spine.Unity.SkeletonPartsRenderer", function () { return {"nested":[Function],"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.$ctor1(UnityEngine.MeshRenderer, UnityEngine.MeshFilter),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonRenderSeparator")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"ClearMesh","t":8,"sn":"ClearMesh","rt":$n[0].Void},{"a":1,"n":"LazyIntialize","t":8,"sn":"LazyIntialize","rt":$n[0].Void},{"a":2,"n":"NewPartsRendererGameObject","is":true,"t":8,"pi":[{"n":"parent","pt":$n[1].Transform,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"sortingOrder","dv":0,"o":true,"pt":$n[0].Int32,"ps":2}],"sn":"NewPartsRendererGameObject","rt":$n[5].SkeletonPartsRenderer,"p":[$n[1].Transform,$n[0].String,$n[0].Int32]},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"a":2,"n":"RenderParts","t":8,"pi":[{"n":"instructions","pt":$n[8].ExposedList$1(Spine.Unity.SubmeshInstruction),"ps":0},{"n":"startSubmesh","pt":$n[0].Int32,"ps":1},{"n":"endSubmesh","pt":$n[0].Int32,"ps":2}],"sn":"RenderParts","rt":$n[0].Void,"p":[$n[8].ExposedList$1(Spine.Unity.SubmeshInstruction),$n[0].Int32,$n[0].Int32]},{"a":2,"n":"SetPropertyBlock","t":8,"pi":[{"n":"block","pt":$n[1].MaterialPropertyBlock,"ps":0}],"sn":"SetPropertyBlock","rt":$n[0].Void,"p":[$n[1].MaterialPropertyBlock]},{"a":2,"n":"MeshFilter","t":16,"rt":$n[1].MeshFilter,"g":{"a":2,"n":"get_MeshFilter","t":8,"rt":$n[1].MeshFilter,"fg":"MeshFilter"},"fn":"MeshFilter"},{"a":2,"n":"MeshGenerator","t":16,"rt":$n[5].MeshGenerator,"g":{"a":2,"n":"get_MeshGenerator","t":8,"rt":$n[5].MeshGenerator,"fg":"MeshGenerator"},"fn":"MeshGenerator"},{"a":2,"n":"MeshRenderer","t":16,"rt":$n[1].MeshRenderer,"g":{"a":2,"n":"get_MeshRenderer","t":8,"rt":$n[1].MeshRenderer,"fg":"MeshRenderer"},"fn":"MeshRenderer"},{"a":1,"n":"buffers","t":4,"rt":$n[5].MeshRendererBuffers,"sn":"buffers"},{"a":1,"n":"currentInstructions","t":4,"rt":$n[5].SkeletonRendererInstruction,"sn":"currentInstructions"},{"a":1,"n":"meshFilter","t":4,"rt":$n[1].MeshFilter,"sn":"meshFilter"},{"a":1,"n":"meshGenerator","t":4,"rt":$n[5].MeshGenerator,"sn":"meshGenerator"},{"a":1,"n":"meshRenderer","t":4,"rt":$n[1].MeshRenderer,"sn":"meshRenderer"},{"a":2,"n":"OnMeshAndMaterialsUpdated","t":2,"ad":{"a":2,"n":"add_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonPartsRenderer end.*/

    /*Spine.Unity.SkeletonRenderSeparator start.*/
    $m("Spine.Unity.SkeletonRenderSeparator", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonRenderSeparator")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddPartsRenderer","t":8,"pi":[{"n":"sortingOrderIncrement","dv":5,"o":true,"pt":$n[0].Int32,"ps":0},{"n":"name","dv":null,"o":true,"pt":$n[0].String,"ps":1}],"sn":"AddPartsRenderer","rt":$n[5].SkeletonPartsRenderer,"p":[$n[0].Int32,$n[0].String]},{"a":2,"n":"AddToSkeletonRenderer","is":true,"t":8,"pi":[{"n":"skeletonRenderer","pt":$n[5].SkeletonRenderer,"ps":0},{"n":"sortingLayerID","dv":0,"o":true,"pt":$n[0].Int32,"ps":1},{"n":"extraPartsRenderers","dv":0,"o":true,"pt":$n[0].Int32,"ps":2},{"n":"sortingOrderIncrement","dv":5,"o":true,"pt":$n[0].Int32,"ps":3},{"n":"baseSortingOrder","dv":0,"o":true,"pt":$n[0].Int32,"ps":4},{"n":"addMinimumPartsRenderers","dv":true,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"AddToSkeletonRenderer","rt":$n[5].SkeletonRenderSeparator,"p":[$n[5].SkeletonRenderer,$n[0].Int32,$n[0].Int32,$n[0].Int32,$n[0].Int32,$n[0].Boolean]},{"a":3,"n":"ClearPartsRendererMeshes","t":8,"sn":"ClearPartsRendererMeshes","rt":$n[0].Void},{"a":1,"n":"HandleRender","t":8,"pi":[{"n":"instruction","pt":$n[5].SkeletonRendererInstruction,"ps":0}],"sn":"HandleRender","rt":$n[0].Void,"p":[$n[5].SkeletonRendererInstruction]},{"a":2,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":2,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":2,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":2,"n":"UpdateVisibility","t":8,"sn":"UpdateVisibility","rt":$n[0].Void},{"a":2,"n":"SkeletonRenderer","t":16,"rt":$n[5].SkeletonRenderer,"g":{"a":2,"n":"get_SkeletonRenderer","t":8,"rt":$n[5].SkeletonRenderer,"fg":"SkeletonRenderer"},"s":{"a":2,"n":"set_SkeletonRenderer","t":8,"p":[$n[5].SkeletonRenderer],"rt":$n[0].Void,"fs":"SkeletonRenderer"},"fn":"SkeletonRenderer"},{"a":2,"n":"DefaultSortingOrderIncrement","is":true,"t":4,"rt":$n[0].Int32,"sn":"DefaultSortingOrderIncrement","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"copiedBlock","t":4,"rt":$n[1].MaterialPropertyBlock,"sn":"copiedBlock"},{"at":[new UnityEngine.TooltipAttribute("Copies MeshRenderer flags into each parts renderer")],"a":2,"n":"copyMeshRendererFlags","t":4,"rt":$n[0].Boolean,"sn":"copyMeshRendererFlags","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"copyPropertyBlock","t":4,"rt":$n[0].Boolean,"sn":"copyPropertyBlock","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"isVisible","t":4,"rt":$n[0].Boolean,"sn":"isVisible","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"mainMeshRenderer","t":4,"rt":$n[1].MeshRenderer,"sn":"mainMeshRenderer"},{"a":2,"n":"partsRenderers","t":4,"rt":$n[2].List$1(Spine.Unity.SkeletonPartsRenderer),"sn":"partsRenderers"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"skeletonRenderer","t":4,"rt":$n[5].SkeletonRenderer,"sn":"skeletonRenderer"},{"a":2,"n":"OnMeshAndMaterialsUpdated","t":2,"ad":{"a":2,"n":"add_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonRenderSeparator end.*/

    /*Spine.Unity.ActivateBasedOnFlipDirection start.*/
    $m("Spine.Unity.ActivateBasedOnFlipDirection", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"CompensateMovementAfterFlipX","t":8,"pi":[{"n":"toActivate","pt":$n[1].Transform,"ps":0},{"n":"toDeactivate","pt":$n[1].Transform,"ps":1}],"sn":"CompensateMovementAfterFlipX","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Transform]},{"a":1,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"a":1,"n":"HandleFlip","t":8,"pi":[{"n":"isFlippedX","pt":$n[0].Boolean,"ps":0}],"sn":"HandleFlip","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":1,"n":"ResetJointPositions","t":8,"pi":[{"n":"joints","pt":System.Array.type(UnityEngine.HingeJoint2D),"ps":0}],"sn":"ResetJointPositions","rt":$n[0].Void,"p":[System.Array.type(UnityEngine.HingeJoint2D)]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"activeOnFlippedX","t":4,"rt":$n[1].GameObject,"sn":"activeOnFlippedX"},{"a":2,"n":"activeOnNormalX","t":4,"rt":$n[1].GameObject,"sn":"activeOnNormalX"},{"a":1,"n":"jointsFlippedX","t":4,"rt":System.Array.type(UnityEngine.HingeJoint2D),"sn":"jointsFlippedX"},{"a":1,"n":"jointsNormalX","t":4,"rt":System.Array.type(UnityEngine.HingeJoint2D),"sn":"jointsNormalX"},{"a":1,"n":"skeletonComponent","t":4,"rt":$n[5].ISkeletonComponent,"sn":"skeletonComponent"},{"a":2,"n":"skeletonGraphic","t":4,"rt":$n[5].SkeletonGraphic,"sn":"skeletonGraphic"},{"a":2,"n":"skeletonRenderer","t":4,"rt":$n[5].SkeletonRenderer,"sn":"skeletonRenderer"},{"a":1,"n":"wasFlippedXBefore","t":4,"rt":$n[0].Boolean,"sn":"wasFlippedXBefore","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.ActivateBasedOnFlipDirection end.*/

    /*Spine.Unity.SkeletonUtility start.*/
    $m("Spine.Unity.SkeletonUtility", function () { return {"nested":[Function],"att":1048833,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.RequireComponent.ctor(Spine.Unity.ISkeletonAnimation),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonUtility")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddBoneRigidbody2D","is":true,"t":8,"pi":[{"n":"gameObject","pt":$n[1].GameObject,"ps":0},{"n":"isKinematic","dv":true,"o":true,"pt":$n[0].Boolean,"ps":1},{"n":"gravityScale","dv":0.0,"o":true,"pt":$n[0].Single,"ps":2}],"sn":"AddBoneRigidbody2D","rt":$n[1].Rigidbody2D,"p":[$n[1].GameObject,$n[0].Boolean,$n[0].Single]},{"a":2,"n":"AddBoundingBoxAsComponent","is":true,"t":8,"pi":[{"n":"box","pt":$n[8].BoundingBoxAttachment,"ps":0},{"n":"slot","pt":$n[8].Slot,"ps":1},{"n":"gameObject","pt":$n[1].GameObject,"ps":2},{"n":"isTrigger","dv":true,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"AddBoundingBoxAsComponent","rt":$n[1].PolygonCollider2D,"p":[$n[8].BoundingBoxAttachment,$n[8].Slot,$n[1].GameObject,$n[0].Boolean]},{"a":2,"n":"AddBoundingBoxGameObject","is":true,"t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0},{"n":"box","pt":$n[8].BoundingBoxAttachment,"ps":1},{"n":"slot","pt":$n[8].Slot,"ps":2},{"n":"parent","pt":$n[1].Transform,"ps":3},{"n":"isTrigger","dv":true,"o":true,"pt":$n[0].Boolean,"ps":4}],"sn":"AddBoundingBoxGameObject$1","rt":$n[1].PolygonCollider2D,"p":[$n[0].String,$n[8].BoundingBoxAttachment,$n[8].Slot,$n[1].Transform,$n[0].Boolean]},{"a":2,"n":"AddBoundingBoxGameObject","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"skinName","pt":$n[0].String,"ps":1},{"n":"slotName","pt":$n[0].String,"ps":2},{"n":"attachmentName","pt":$n[0].String,"ps":3},{"n":"parent","pt":$n[1].Transform,"ps":4},{"n":"isTrigger","dv":true,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"AddBoundingBoxGameObject","rt":$n[1].PolygonCollider2D,"p":[$n[8].Skeleton,$n[0].String,$n[0].String,$n[0].String,$n[1].Transform,$n[0].Boolean]},{"a":2,"n":"CollectBones","t":8,"sn":"CollectBones","rt":$n[0].Void},{"a":2,"n":"GetBoneRoot","t":8,"sn":"GetBoneRoot","rt":$n[1].Transform},{"a":2,"n":"GetBoundingBoxBounds","is":true,"t":8,"pi":[{"n":"boundingBox","pt":$n[8].BoundingBoxAttachment,"ps":0},{"n":"depth","dv":0.0,"o":true,"pt":$n[0].Single,"ps":1}],"sn":"GetBoundingBoxBounds","rt":$n[1].Bounds,"p":[$n[8].BoundingBoxAttachment,$n[0].Single]},{"a":1,"n":"HandleRendererReset","t":8,"pi":[{"n":"g","pt":$n[5].SkeletonGraphic,"ps":0}],"sn":"HandleRendererReset","rt":$n[0].Void,"p":[$n[5].SkeletonGraphic]},{"a":1,"n":"HandleRendererReset","t":8,"pi":[{"n":"r","pt":$n[5].SkeletonRenderer,"ps":0}],"sn":"HandleRendererReset$1","rt":$n[0].Void,"p":[$n[5].SkeletonRenderer]},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":2,"n":"RegisterBone","t":8,"pi":[{"n":"bone","pt":$n[5].SkeletonUtilityBone,"ps":0}],"sn":"RegisterBone","rt":$n[0].Void,"p":[$n[5].SkeletonUtilityBone]},{"a":2,"n":"RegisterConstraint","t":8,"pi":[{"n":"constraint","pt":$n[5].SkeletonUtilityConstraint,"ps":0}],"sn":"RegisterConstraint","rt":$n[0].Void,"p":[$n[5].SkeletonUtilityConstraint]},{"a":1,"n":"ResubscribeDependentEvents","t":8,"sn":"ResubscribeDependentEvents","rt":$n[0].Void},{"a":2,"n":"ResubscribeEvents","t":8,"sn":"ResubscribeEvents","rt":$n[0].Void},{"a":1,"n":"ResubscribeIndependentEvents","t":8,"sn":"ResubscribeIndependentEvents","rt":$n[0].Void},{"a":2,"n":"SetColliderPointsLocal","is":true,"t":8,"pi":[{"n":"collider","pt":$n[1].PolygonCollider2D,"ps":0},{"n":"slot","pt":$n[8].Slot,"ps":1},{"n":"box","pt":$n[8].BoundingBoxAttachment,"ps":2},{"n":"scale","dv":1.0,"o":true,"pt":$n[0].Single,"ps":3}],"sn":"SetColliderPointsLocal","rt":$n[0].Void,"p":[$n[1].PolygonCollider2D,$n[8].Slot,$n[8].BoundingBoxAttachment,$n[0].Single]},{"a":2,"n":"SpawnBone","t":8,"pi":[{"n":"bone","pt":$n[8].Bone,"ps":0},{"n":"parent","pt":$n[1].Transform,"ps":1},{"n":"mode","pt":$n[5].SkeletonUtilityBone.Mode,"ps":2},{"n":"pos","pt":$n[0].Boolean,"ps":3},{"n":"rot","pt":$n[0].Boolean,"ps":4},{"n":"sca","pt":$n[0].Boolean,"ps":5}],"sn":"SpawnBone","rt":$n[1].GameObject,"p":[$n[8].Bone,$n[1].Transform,$n[5].SkeletonUtilityBone.Mode,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"SpawnBoneRecursively","t":8,"pi":[{"n":"bone","pt":$n[8].Bone,"ps":0},{"n":"parent","pt":$n[1].Transform,"ps":1},{"n":"mode","pt":$n[5].SkeletonUtilityBone.Mode,"ps":2},{"n":"pos","pt":$n[0].Boolean,"ps":3},{"n":"rot","pt":$n[0].Boolean,"ps":4},{"n":"sca","pt":$n[0].Boolean,"ps":5}],"sn":"SpawnBoneRecursively","rt":$n[1].GameObject,"p":[$n[8].Bone,$n[1].Transform,$n[5].SkeletonUtilityBone.Mode,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"SpawnHierarchy","t":8,"pi":[{"n":"mode","pt":$n[5].SkeletonUtilityBone.Mode,"ps":0},{"n":"pos","pt":$n[0].Boolean,"ps":1},{"n":"rot","pt":$n[0].Boolean,"ps":2},{"n":"sca","pt":$n[0].Boolean,"ps":3}],"sn":"SpawnHierarchy","rt":$n[1].GameObject,"p":[$n[5].SkeletonUtilityBone.Mode,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"SpawnRoot","t":8,"pi":[{"n":"mode","pt":$n[5].SkeletonUtilityBone.Mode,"ps":0},{"n":"pos","pt":$n[0].Boolean,"ps":1},{"n":"rot","pt":$n[0].Boolean,"ps":2},{"n":"sca","pt":$n[0].Boolean,"ps":3}],"sn":"SpawnRoot","rt":$n[1].GameObject,"p":[$n[5].SkeletonUtilityBone.Mode,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"UnregisterBone","t":8,"pi":[{"n":"bone","pt":$n[5].SkeletonUtilityBone,"ps":0}],"sn":"UnregisterBone","rt":$n[0].Void,"p":[$n[5].SkeletonUtilityBone]},{"a":2,"n":"UnregisterConstraint","t":8,"pi":[{"n":"constraint","pt":$n[5].SkeletonUtilityConstraint,"ps":0}],"sn":"UnregisterConstraint","rt":$n[0].Void,"p":[$n[5].SkeletonUtilityConstraint]},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":1,"n":"UpdateAllBones","t":8,"pi":[{"n":"phase","pt":$n[5].SkeletonUtilityBone.UpdatePhase,"ps":0}],"sn":"UpdateAllBones","rt":$n[0].Void,"p":[$n[5].SkeletonUtilityBone.UpdatePhase]},{"a":1,"n":"UpdateComplete","t":8,"pi":[{"n":"anim","pt":$n[5].ISkeletonAnimation,"ps":0}],"sn":"UpdateComplete","rt":$n[0].Void,"p":[$n[5].ISkeletonAnimation]},{"a":1,"n":"UpdateLocal","t":8,"pi":[{"n":"anim","pt":$n[5].ISkeletonAnimation,"ps":0}],"sn":"UpdateLocal","rt":$n[0].Void,"p":[$n[5].ISkeletonAnimation]},{"a":1,"n":"UpdateToMeshScaleAndOffset","t":8,"pi":[{"n":"ignoredParameter","pt":$n[5].MeshGeneratorBuffers,"ps":0}],"sn":"UpdateToMeshScaleAndOffset","rt":$n[0].Void,"p":[$n[5].MeshGeneratorBuffers]},{"a":1,"n":"UpdateWorld","t":8,"pi":[{"n":"anim","pt":$n[5].ISkeletonAnimation,"ps":0}],"sn":"UpdateWorld","rt":$n[0].Void,"p":[$n[5].ISkeletonAnimation]},{"a":2,"n":"IsValid","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsValid","t":8,"rt":$n[0].Boolean,"fg":"IsValid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsValid"},{"a":2,"n":"PositionOffset","t":16,"rt":$n[1].Vector2,"g":{"a":2,"n":"get_PositionOffset","t":8,"rt":$n[1].Vector2,"fg":"PositionOffset"},"fn":"PositionOffset"},{"a":2,"n":"PositionScale","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_PositionScale","t":8,"rt":$n[0].Single,"fg":"PositionScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"PositionScale"},{"a":2,"n":"Skeleton","t":16,"rt":$n[8].Skeleton,"g":{"a":2,"n":"get_Skeleton","t":8,"rt":$n[8].Skeleton,"fg":"Skeleton"},"fn":"Skeleton"},{"a":2,"n":"SkeletonComponent","t":16,"rt":$n[5].ISkeletonComponent,"g":{"a":2,"n":"get_SkeletonComponent","t":8,"rt":$n[5].ISkeletonComponent,"fg":"SkeletonComponent"},"fn":"SkeletonComponent"},{"a":2,"n":"boneComponents","t":4,"rt":$n[2].List$1(Spine.Unity.SkeletonUtilityBone),"sn":"boneComponents"},{"a":2,"n":"boneRoot","t":4,"rt":$n[1].Transform,"sn":"boneRoot"},{"a":2,"n":"constraintComponents","t":4,"rt":$n[2].List$1(Spine.Unity.SkeletonUtilityConstraint),"sn":"constraintComponents"},{"a":2,"n":"flipBy180DegreeRotation","t":4,"rt":$n[0].Boolean,"sn":"flipBy180DegreeRotation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"hasConstraints","t":4,"rt":$n[0].Boolean,"sn":"hasConstraints","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"hasOverrideBones","t":4,"rt":$n[0].Boolean,"sn":"hasOverrideBones","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"lastPositionScale","t":4,"rt":$n[0].Single,"sn":"lastPositionScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"needToReprocessBones","t":4,"rt":$n[0].Boolean,"sn":"needToReprocessBones","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"positionOffset","t":4,"rt":$n[1].Vector2,"sn":"positionOffset"},{"a":1,"n":"positionScale","t":4,"rt":$n[0].Single,"sn":"positionScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"skeletonAnimation","t":4,"rt":$n[5].ISkeletonAnimation,"sn":"skeletonAnimation"},{"a":1,"n":"skeletonComponent","t":4,"rt":$n[5].ISkeletonComponent,"sn":"skeletonComponent"},{"at":[new UnityEngine.HideInInspector()],"a":2,"n":"skeletonGraphic","t":4,"rt":$n[5].SkeletonGraphic,"sn":"skeletonGraphic"},{"at":[new UnityEngine.HideInInspector()],"a":2,"n":"skeletonRenderer","t":4,"rt":$n[5].SkeletonRenderer,"sn":"skeletonRenderer"},{"a":2,"n":"OnReset","t":2,"ad":{"a":2,"n":"add_OnReset","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnReset","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnReset","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnReset","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonUtility end.*/

    /*Spine.Unity.SkeletonUtilityBone start.*/
    $m("Spine.Unity.SkeletonUtilityBone", function () { return {"nested":[$n[5].SkeletonUtilityBone.Mode,$n[5].SkeletonUtilityBone.UpdatePhase],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.AddComponentMenu.ctor("Spine/SkeletonUtilityBone"),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonUtilityBone")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddBoundingBox","t":8,"pi":[{"n":"skinName","pt":$n[0].String,"ps":0},{"n":"slotName","pt":$n[0].String,"ps":1},{"n":"attachmentName","pt":$n[0].String,"ps":2}],"sn":"AddBoundingBox","rt":$n[0].Void,"p":[$n[0].String,$n[0].String,$n[0].String]},{"a":2,"n":"BoneTransformModeIncompatible","is":true,"t":8,"pi":[{"n":"bone","pt":$n[8].Bone,"ps":0}],"sn":"BoneTransformModeIncompatible","rt":$n[0].Boolean,"p":[$n[8].Bone],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"DoUpdate","t":8,"pi":[{"n":"phase","pt":$n[5].SkeletonUtilityBone.UpdatePhase,"ps":0}],"sn":"DoUpdate","rt":$n[0].Void,"p":[$n[5].SkeletonUtilityBone.UpdatePhase]},{"a":1,"n":"HandleOnReset","t":8,"sn":"HandleOnReset","rt":$n[0].Void},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":2,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"a":2,"n":"IncompatibleTransformMode","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IncompatibleTransformMode","t":8,"rt":$n[0].Boolean,"fg":"IncompatibleTransformMode","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IncompatibleTransformMode"},{"a":2,"n":"bone","t":4,"rt":$n[8].Bone,"sn":"bone"},{"a":2,"n":"boneName","t":4,"rt":$n[0].String,"sn":"boneName"},{"a":1,"n":"cachedTransform","t":4,"rt":$n[1].Transform,"sn":"cachedTransform"},{"a":2,"n":"hierarchy","t":4,"rt":$n[5].SkeletonUtility,"sn":"hierarchy"},{"a":1,"n":"incompatibleTransformMode","t":4,"rt":$n[0].Boolean,"sn":"incompatibleTransformMode","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"mode","t":4,"rt":$n[5].SkeletonUtilityBone.Mode,"sn":"mode","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonUtilityBone.Mode, System.Enum.toStringFn(Spine.Unity.SkeletonUtilityBone.Mode));}},{"at":[new UnityEngine.RangeAttribute(0.0, 1.0)],"a":2,"n":"overrideAlpha","t":4,"rt":$n[0].Single,"sn":"overrideAlpha","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"parentReference","t":4,"rt":$n[1].Transform,"sn":"parentReference"},{"a":2,"n":"position","t":4,"rt":$n[0].Boolean,"sn":"position","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"rotation","t":4,"rt":$n[0].Boolean,"sn":"rotation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"scale","t":4,"rt":$n[0].Boolean,"sn":"scale","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"skeletonTransform","t":4,"rt":$n[1].Transform,"sn":"skeletonTransform"},{"a":2,"n":"transformLerpComplete","t":4,"rt":$n[0].Boolean,"sn":"transformLerpComplete","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"valid","t":4,"rt":$n[0].Boolean,"sn":"valid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"zPosition","t":4,"rt":$n[0].Boolean,"sn":"zPosition","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.SkeletonUtilityBone end.*/

    /*Spine.Unity.SkeletonUtilityBone+Mode start.*/
    $m("Spine.Unity.SkeletonUtilityBone.Mode", function () { return {"td":$n[5].SkeletonUtilityBone,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Follow","is":true,"t":4,"rt":$n[5].SkeletonUtilityBone.Mode,"sn":"Follow","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonUtilityBone.Mode, System.Enum.toStringFn(Spine.Unity.SkeletonUtilityBone.Mode));}},{"a":2,"n":"Override","is":true,"t":4,"rt":$n[5].SkeletonUtilityBone.Mode,"sn":"Override","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonUtilityBone.Mode, System.Enum.toStringFn(Spine.Unity.SkeletonUtilityBone.Mode));}}]}; }, $n);
    /*Spine.Unity.SkeletonUtilityBone+Mode end.*/

    /*Spine.Unity.SkeletonUtilityBone+UpdatePhase start.*/
    $m("Spine.Unity.SkeletonUtilityBone.UpdatePhase", function () { return {"td":$n[5].SkeletonUtilityBone,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Complete","is":true,"t":4,"rt":$n[5].SkeletonUtilityBone.UpdatePhase,"sn":"Complete","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonUtilityBone.UpdatePhase, System.Enum.toStringFn(Spine.Unity.SkeletonUtilityBone.UpdatePhase));}},{"a":2,"n":"Local","is":true,"t":4,"rt":$n[5].SkeletonUtilityBone.UpdatePhase,"sn":"Local","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonUtilityBone.UpdatePhase, System.Enum.toStringFn(Spine.Unity.SkeletonUtilityBone.UpdatePhase));}},{"a":2,"n":"World","is":true,"t":4,"rt":$n[5].SkeletonUtilityBone.UpdatePhase,"sn":"World","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonUtilityBone.UpdatePhase, System.Enum.toStringFn(Spine.Unity.SkeletonUtilityBone.UpdatePhase));}}]}; }, $n);
    /*Spine.Unity.SkeletonUtilityBone+UpdatePhase end.*/

    /*Spine.Unity.SkeletonUtilityConstraint start.*/
    $m("Spine.Unity.SkeletonUtilityConstraint", function () { return {"att":1048705,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.RequireComponent.ctor(Spine.Unity.SkeletonUtilityBone),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonUtilityConstraint")],"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ab":true,"a":2,"n":"DoUpdate","t":8,"sn":"DoUpdate","rt":$n[0].Void},{"v":true,"a":3,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"v":true,"a":3,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":3,"n":"bone","t":4,"rt":$n[5].SkeletonUtilityBone,"sn":"bone"},{"a":3,"n":"hierarchy","t":4,"rt":$n[5].SkeletonUtility,"sn":"hierarchy"}]}; }, $n);
    /*Spine.Unity.SkeletonUtilityConstraint end.*/

    /*Spine.Unity.UpdateMode start.*/
    $m("Spine.Unity.UpdateMode", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"EverythingExceptMesh","is":true,"t":4,"rt":$n[5].UpdateMode,"sn":"EverythingExceptMesh","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"FullUpdate","is":true,"t":4,"rt":$n[5].UpdateMode,"sn":"FullUpdate","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"Nothing","is":true,"t":4,"rt":$n[5].UpdateMode,"sn":"Nothing","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"OnlyAnimationStatus","is":true,"t":4,"rt":$n[5].UpdateMode,"sn":"OnlyAnimationStatus","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"OnlyEventTimelines","is":true,"t":4,"rt":$n[5].UpdateMode,"sn":"OnlyEventTimelines","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}}]}; }, $n);
    /*Spine.Unity.UpdateMode end.*/

    /*Spine.Unity.UpdateTiming start.*/
    $m("Spine.Unity.UpdateTiming", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"InFixedUpdate","is":true,"t":4,"rt":$n[5].UpdateTiming,"sn":"InFixedUpdate","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},{"a":2,"n":"InLateUpdate","is":true,"t":4,"rt":$n[5].UpdateTiming,"sn":"InLateUpdate","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},{"a":2,"n":"InUpdate","is":true,"t":4,"rt":$n[5].UpdateTiming,"sn":"InUpdate","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},{"a":2,"n":"ManualUpdate","is":true,"t":4,"rt":$n[5].UpdateTiming,"sn":"ManualUpdate","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}}]}; }, $n);
    /*Spine.Unity.UpdateTiming end.*/

    /*Spine.Unity.ISpineComponent start.*/
    $m("Spine.Unity.ISpineComponent", function () { return {"att":1048737,"a":2}; }, $n);
    /*Spine.Unity.ISpineComponent end.*/

    /*Spine.Unity.ISpineComponentExtensions start.*/
    $m("Spine.Unity.ISpineComponentExtensions", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"IsNullOrDestroyed","is":true,"t":8,"pi":[{"n":"component","pt":$n[5].ISpineComponent,"ps":0}],"sn":"IsNullOrDestroyed","rt":$n[0].Boolean,"p":[$n[5].ISpineComponent],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.ISpineComponentExtensions end.*/

    /*Spine.Unity.ISkeletonAnimation start.*/
    $m("Spine.Unity.ISkeletonAnimation", function () { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"Skeleton","t":16,"rt":$n[8].Skeleton,"g":{"ab":true,"a":2,"n":"get_Skeleton","t":8,"rt":$n[8].Skeleton,"fg":"Spine$Unity$ISkeletonAnimation$Skeleton"},"fn":"Spine$Unity$ISkeletonAnimation$Skeleton"},{"ab":true,"a":2,"n":"UpdateTiming","t":16,"rt":$n[5].UpdateTiming,"g":{"ab":true,"a":2,"n":"get_UpdateTiming","t":8,"rt":$n[5].UpdateTiming,"fg":"Spine$Unity$ISkeletonAnimation$UpdateTiming","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},"s":{"ab":true,"a":2,"n":"set_UpdateTiming","t":8,"p":[$n[5].UpdateTiming],"rt":$n[0].Void,"fs":"Spine$Unity$ISkeletonAnimation$UpdateTiming"},"fn":"Spine$Unity$ISkeletonAnimation$UpdateTiming"},{"ab":true,"a":2,"n":"OnAnimationRebuild","t":2,"ad":{"ab":true,"a":2,"n":"add_OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$addOnAnimationRebuild","rt":$n[0].Void,"p":[Function]},"r":{"ab":true,"a":2,"n":"remove_OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$removeOnAnimationRebuild","rt":$n[0].Void,"p":[Function]}},{"ab":true,"a":2,"n":"UpdateComplete","t":2,"ad":{"ab":true,"a":2,"n":"add_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$addUpdateComplete","rt":$n[0].Void,"p":[Function]},"r":{"ab":true,"a":2,"n":"remove_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$removeUpdateComplete","rt":$n[0].Void,"p":[Function]}},{"ab":true,"a":2,"n":"UpdateLocal","t":2,"ad":{"ab":true,"a":2,"n":"add_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$addUpdateLocal","rt":$n[0].Void,"p":[Function]},"r":{"ab":true,"a":2,"n":"remove_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$removeUpdateLocal","rt":$n[0].Void,"p":[Function]}},{"ab":true,"a":2,"n":"UpdateWorld","t":2,"ad":{"ab":true,"a":2,"n":"add_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$addUpdateWorld","rt":$n[0].Void,"p":[Function]},"r":{"ab":true,"a":2,"n":"remove_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$removeUpdateWorld","rt":$n[0].Void,"p":[Function]}},{"a":1,"backing":true,"n":"<Skeleton>k__BackingField","t":4,"rt":$n[8].Skeleton,"sn":"Spine$Unity$ISkeletonAnimation$Skeleton"},{"a":1,"backing":true,"n":"<UpdateTiming>k__BackingField","t":4,"rt":$n[5].UpdateTiming,"sn":"Spine$Unity$ISkeletonAnimation$UpdateTiming","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}}]}; }, $n);
    /*Spine.Unity.ISkeletonAnimation end.*/

    /*Spine.Unity.IHasSkeletonDataAsset start.*/
    $m("Spine.Unity.IHasSkeletonDataAsset", function () { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"SkeletonDataAsset","t":16,"rt":$n[5].SkeletonDataAsset,"g":{"ab":true,"a":2,"n":"get_SkeletonDataAsset","t":8,"rt":$n[5].SkeletonDataAsset,"fg":"Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset"},"fn":"Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset"},{"a":1,"backing":true,"n":"<SkeletonDataAsset>k__BackingField","t":4,"rt":$n[5].SkeletonDataAsset,"sn":"Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset"}]}; }, $n);
    /*Spine.Unity.IHasSkeletonDataAsset end.*/

    /*Spine.Unity.ISkeletonComponent start.*/
    $m("Spine.Unity.ISkeletonComponent", function () { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"Skeleton","t":16,"rt":$n[8].Skeleton,"g":{"ab":true,"a":2,"n":"get_Skeleton","t":8,"rt":$n[8].Skeleton,"fg":"Spine$Unity$ISkeletonComponent$Skeleton"},"fn":"Spine$Unity$ISkeletonComponent$Skeleton"},{"ab":true,"a":2,"n":"SkeletonDataAsset","t":16,"rt":$n[5].SkeletonDataAsset,"g":{"ab":true,"a":2,"n":"get_SkeletonDataAsset","t":8,"rt":$n[5].SkeletonDataAsset,"fg":"Spine$Unity$ISkeletonComponent$SkeletonDataAsset"},"fn":"Spine$Unity$ISkeletonComponent$SkeletonDataAsset"},{"a":1,"backing":true,"n":"<Skeleton>k__BackingField","t":4,"rt":$n[8].Skeleton,"sn":"Spine$Unity$ISkeletonComponent$Skeleton"},{"a":1,"backing":true,"n":"<SkeletonDataAsset>k__BackingField","t":4,"rt":$n[5].SkeletonDataAsset,"sn":"Spine$Unity$ISkeletonComponent$SkeletonDataAsset"}]}; }, $n);
    /*Spine.Unity.ISkeletonComponent end.*/

    /*Spine.Unity.IAnimationStateComponent start.*/
    $m("Spine.Unity.IAnimationStateComponent", function () { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"AnimationState","t":16,"rt":$n[8].AnimationState,"g":{"ab":true,"a":2,"n":"get_AnimationState","t":8,"rt":$n[8].AnimationState,"fg":"Spine$Unity$IAnimationStateComponent$AnimationState"},"fn":"Spine$Unity$IAnimationStateComponent$AnimationState"},{"ab":true,"a":2,"n":"UnscaledTime","t":16,"rt":$n[0].Boolean,"g":{"ab":true,"a":2,"n":"get_UnscaledTime","t":8,"rt":$n[0].Boolean,"fg":"Spine$Unity$IAnimationStateComponent$UnscaledTime","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"ab":true,"a":2,"n":"set_UnscaledTime","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"Spine$Unity$IAnimationStateComponent$UnscaledTime"},"fn":"Spine$Unity$IAnimationStateComponent$UnscaledTime"},{"a":1,"backing":true,"n":"<AnimationState>k__BackingField","t":4,"rt":$n[8].AnimationState,"sn":"Spine$Unity$IAnimationStateComponent$AnimationState"},{"a":1,"backing":true,"n":"<UnscaledTime>k__BackingField","t":4,"rt":$n[0].Boolean,"sn":"Spine$Unity$IAnimationStateComponent$UnscaledTime","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.IAnimationStateComponent end.*/

    /*Spine.Unity.IHasSkeletonRenderer start.*/
    $m("Spine.Unity.IHasSkeletonRenderer", function () { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"SkeletonRenderer","t":16,"rt":$n[5].SkeletonRenderer,"g":{"ab":true,"a":2,"n":"get_SkeletonRenderer","t":8,"rt":$n[5].SkeletonRenderer,"fg":"Spine$Unity$IHasSkeletonRenderer$SkeletonRenderer"},"fn":"Spine$Unity$IHasSkeletonRenderer$SkeletonRenderer"},{"a":1,"backing":true,"n":"<SkeletonRenderer>k__BackingField","t":4,"rt":$n[5].SkeletonRenderer,"sn":"Spine$Unity$IHasSkeletonRenderer$SkeletonRenderer"}]}; }, $n);
    /*Spine.Unity.IHasSkeletonRenderer end.*/

    /*Spine.Unity.IHasSkeletonComponent start.*/
    $m("Spine.Unity.IHasSkeletonComponent", function () { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"SkeletonComponent","t":16,"rt":$n[5].ISkeletonComponent,"g":{"ab":true,"a":2,"n":"get_SkeletonComponent","t":8,"rt":$n[5].ISkeletonComponent,"fg":"Spine$Unity$IHasSkeletonComponent$SkeletonComponent"},"fn":"Spine$Unity$IHasSkeletonComponent$SkeletonComponent"},{"a":1,"backing":true,"n":"<SkeletonComponent>k__BackingField","t":4,"rt":$n[5].ISkeletonComponent,"sn":"Spine$Unity$IHasSkeletonComponent$SkeletonComponent"}]}; }, $n);
    /*Spine.Unity.IHasSkeletonComponent end.*/

    /*Spine.Unity.DoubleBuffered$1 start.*/
    $m("Spine.Unity.DoubleBuffered$1", function (T) { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"GetCurrent","t":8,"sn":"GetCurrent","rt":T},{"a":2,"n":"GetNext","t":8,"sn":"GetNext","rt":T},{"a":1,"n":"a","t":4,"rt":T,"sn":"a","ro":true},{"a":1,"n":"b","t":4,"rt":T,"sn":"b","ro":true},{"a":1,"n":"usingA","t":4,"rt":$n[0].Boolean,"sn":"usingA","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.DoubleBuffered$1 end.*/

    /*Spine.Unity.MeshGeneratorBuffers start.*/
    $m("Spine.Unity.MeshGeneratorBuffers", function () { return {"att":1048841,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"uv2Buffer","t":16,"rt":System.Array.type(UnityEngine.Vector2),"g":{"a":2,"n":"get_uv2Buffer","t":8,"rt":System.Array.type(UnityEngine.Vector2),"fg":"uv2Buffer"},"fn":"uv2Buffer"},{"a":2,"n":"uv3Buffer","t":16,"rt":System.Array.type(UnityEngine.Vector2),"g":{"a":2,"n":"get_uv3Buffer","t":8,"rt":System.Array.type(UnityEngine.Vector2),"fg":"uv3Buffer"},"fn":"uv3Buffer"},{"a":2,"n":"colorBuffer","t":4,"rt":System.Array.type(UnityEngine.Color32),"sn":"colorBuffer"},{"a":2,"n":"meshGenerator","t":4,"rt":$n[5].MeshGenerator,"sn":"meshGenerator"},{"a":2,"n":"uvBuffer","t":4,"rt":System.Array.type(UnityEngine.Vector2),"sn":"uvBuffer"},{"a":2,"n":"vertexBuffer","t":4,"rt":System.Array.type(UnityEngine.Vector3),"sn":"vertexBuffer"},{"a":2,"n":"vertexCount","t":4,"rt":$n[0].Int32,"sn":"vertexCount","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.Unity.MeshGeneratorBuffers end.*/

    /*Spine.Unity.MeshGenerator start.*/
    $m("Spine.Unity.MeshGenerator", function () { return {"nested":[$n[5].MeshGenerator.Settings],"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"AddAttachmentTintBlack","t":8,"pi":[{"n":"r2","pt":$n[0].Single,"ps":0},{"n":"g2","pt":$n[0].Single,"ps":1},{"n":"b2","pt":$n[0].Single,"ps":2},{"n":"a","pt":$n[0].Single,"ps":3},{"n":"vertexCount","pt":$n[0].Int32,"ps":4}],"sn":"AddAttachmentTintBlack","rt":$n[0].Void,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Int32]},{"a":2,"n":"AddSubmesh","t":8,"pi":[{"n":"instruction","pt":$n[5].SubmeshInstruction,"ps":0},{"n":"updateTriangles","dv":true,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"AddSubmesh","rt":$n[0].Void,"p":[$n[5].SubmeshInstruction,$n[0].Boolean]},{"a":2,"n":"Begin","t":8,"sn":"Begin","rt":$n[0].Void},{"a":2,"n":"BuildMesh","t":8,"pi":[{"n":"instruction","pt":$n[5].SkeletonRendererInstruction,"ps":0},{"n":"updateTriangles","pt":$n[0].Boolean,"ps":1}],"sn":"BuildMesh","rt":$n[0].Void,"p":[$n[5].SkeletonRendererInstruction,$n[0].Boolean]},{"a":2,"n":"BuildMeshWithArrays","t":8,"pi":[{"n":"instruction","pt":$n[5].SkeletonRendererInstruction,"ps":0},{"n":"updateTriangles","pt":$n[0].Boolean,"ps":1}],"sn":"BuildMeshWithArrays","rt":$n[0].Void,"p":[$n[5].SkeletonRendererInstruction,$n[0].Boolean]},{"a":2,"n":"EnsureVertexCapacity","t":8,"pi":[{"n":"minimumVertexCount","pt":$n[0].Int32,"ps":0},{"n":"inlcudeTintBlack","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1},{"n":"includeTangents","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"includeNormals","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"EnsureVertexCapacity","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"FillLateVertexData","t":8,"pi":[{"n":"mesh","pt":$n[1].Mesh,"ps":0}],"sn":"FillLateVertexData","rt":$n[0].Void,"p":[$n[1].Mesh]},{"a":2,"n":"FillMeshLocal","is":true,"t":8,"pi":[{"n":"mesh","pt":$n[1].Mesh,"ps":0},{"n":"regionAttachment","pt":$n[8].RegionAttachment,"ps":1}],"sn":"FillMeshLocal$1","rt":$n[0].Void,"p":[$n[1].Mesh,$n[8].RegionAttachment]},{"a":2,"n":"FillMeshLocal","is":true,"t":8,"pi":[{"n":"mesh","pt":$n[1].Mesh,"ps":0},{"n":"meshAttachment","pt":$n[8].MeshAttachment,"ps":1},{"n":"skeletonData","pt":$n[8].SkeletonData,"ps":2}],"sn":"FillMeshLocal","rt":$n[0].Void,"p":[$n[1].Mesh,$n[8].MeshAttachment,$n[8].SkeletonData]},{"a":2,"n":"FillTriangles","t":8,"pi":[{"n":"mesh","pt":$n[1].Mesh,"ps":0}],"sn":"FillTriangles","rt":$n[0].Void,"p":[$n[1].Mesh]},{"a":2,"n":"FillVertexData","t":8,"pi":[{"n":"mesh","pt":$n[1].Mesh,"ps":0}],"sn":"FillVertexData","rt":$n[0].Void,"p":[$n[1].Mesh]},{"a":2,"n":"GenerateSingleSubmeshInstruction","is":true,"t":8,"pi":[{"n":"instructionOutput","pt":$n[5].SkeletonRendererInstruction,"ps":0},{"n":"skeleton","pt":$n[8].Skeleton,"ps":1},{"n":"material","pt":$n[1].Material,"ps":2}],"sn":"GenerateSingleSubmeshInstruction","rt":$n[0].Void,"p":[$n[5].SkeletonRendererInstruction,$n[8].Skeleton,$n[1].Material]},{"a":2,"n":"GenerateSkeletonRendererInstruction","is":true,"t":8,"pi":[{"n":"instructionOutput","pt":$n[5].SkeletonRendererInstruction,"ps":0},{"n":"skeleton","pt":$n[8].Skeleton,"ps":1},{"n":"customSlotMaterials","pt":$n[2].Dictionary$2(Spine.Slot,UnityEngine.Material),"ps":2},{"n":"separatorSlots","pt":$n[2].List$1(Spine.Slot),"ps":3},{"n":"generateMeshOverride","pt":$n[0].Boolean,"ps":4},{"n":"immutableTriangles","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"GenerateSkeletonRendererInstruction","rt":$n[0].Void,"p":[$n[5].SkeletonRendererInstruction,$n[8].Skeleton,$n[2].Dictionary$2(Spine.Slot,UnityEngine.Material),$n[2].List$1(Spine.Slot),$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"GetMeshBounds","t":8,"sn":"GetMeshBounds","rt":$n[1].Bounds},{"a":1,"n":"PrepareOptionalUVBuffer","t":8,"pi":[{"n":"uvBuffer","ref":true,"pt":$n[8].ExposedList$1(UnityEngine.Vector2),"ps":0},{"n":"vertexCount","pt":$n[0].Int32,"ps":1}],"sn":"PrepareOptionalUVBuffer","rt":$n[0].Void,"p":[$n[8].ExposedList$1(UnityEngine.Vector2),$n[0].Int32]},{"a":2,"n":"RequiresMultipleSubmeshesByDrawOrder","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0}],"sn":"RequiresMultipleSubmeshesByDrawOrder","rt":$n[0].Boolean,"p":[$n[8].Skeleton],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"ResizeOptionalUVBuffer","t":8,"pi":[{"n":"uvBuffer","ref":true,"pt":$n[8].ExposedList$1(UnityEngine.Vector2),"ps":0},{"n":"vertexCount","pt":$n[0].Int32,"ps":1}],"sn":"ResizeOptionalUVBuffer","rt":$n[0].Void,"p":[$n[8].ExposedList$1(UnityEngine.Vector2),$n[0].Int32]},{"a":2,"n":"ScaleAndOffsetVertexData","t":8,"pi":[{"n":"scale","pt":$n[0].Single,"ps":0},{"n":"offset2D","pt":$n[1].Vector2,"ps":1}],"sn":"ScaleAndOffsetVertexData","rt":$n[0].Void,"p":[$n[0].Single,$n[1].Vector2]},{"a":2,"n":"ScaleVertexData","t":8,"pi":[{"n":"scale","pt":$n[0].Single,"ps":0}],"sn":"ScaleVertexData","rt":$n[0].Void,"p":[$n[0].Single]},{"a":4,"n":"SolveTangents2DBuffer","is":true,"t":8,"pi":[{"n":"tangents","pt":System.Array.type(UnityEngine.Vector4),"ps":0},{"n":"tempTanBuffer","pt":System.Array.type(UnityEngine.Vector2),"ps":1},{"n":"vertexCount","pt":$n[0].Int32,"ps":2}],"sn":"SolveTangents2DBuffer","rt":$n[0].Void,"p":[System.Array.type(UnityEngine.Vector4),System.Array.type(UnityEngine.Vector2),$n[0].Int32]},{"a":4,"n":"SolveTangents2DEnsureSize","is":true,"t":8,"pi":[{"n":"tangentBuffer","ref":true,"pt":System.Array.type(UnityEngine.Vector4),"ps":0},{"n":"tempTanBuffer","ref":true,"pt":System.Array.type(UnityEngine.Vector2),"ps":1},{"n":"vertexCount","pt":$n[0].Int32,"ps":2},{"n":"vertexBufferLength","pt":$n[0].Int32,"ps":3}],"sn":"SolveTangents2DEnsureSize","rt":$n[0].Void,"p":[System.Array.type(UnityEngine.Vector4),System.Array.type(UnityEngine.Vector2),$n[0].Int32,$n[0].Int32]},{"a":4,"n":"SolveTangents2DTriangles","is":true,"t":8,"pi":[{"n":"tempTanBuffer","pt":System.Array.type(UnityEngine.Vector2),"ps":0},{"n":"triangles","pt":$n[0].Array.type(System.Int32),"ps":1},{"n":"triangleCount","pt":$n[0].Int32,"ps":2},{"n":"vertices","pt":System.Array.type(UnityEngine.Vector3),"ps":3},{"n":"uvs","pt":System.Array.type(UnityEngine.Vector2),"ps":4},{"n":"vertexCount","pt":$n[0].Int32,"ps":5}],"sn":"SolveTangents2DTriangles","rt":$n[0].Void,"p":[System.Array.type(UnityEngine.Vector2),$n[0].Array.type(System.Int32),$n[0].Int32,System.Array.type(UnityEngine.Vector3),System.Array.type(UnityEngine.Vector2),$n[0].Int32]},{"a":2,"n":"SubmeshIndexCount","t":8,"pi":[{"n":"submeshIndex","pt":$n[0].Int32,"ps":0}],"sn":"SubmeshIndexCount","rt":$n[0].Int32,"p":[$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"TrimExcess","t":8,"sn":"TrimExcess","rt":$n[0].Void},{"a":2,"n":"TryReplaceMaterials","is":true,"t":8,"pi":[{"n":"workingSubmeshInstructions","pt":$n[8].ExposedList$1(Spine.Unity.SubmeshInstruction),"ps":0},{"n":"customMaterialOverride","pt":$n[2].Dictionary$2(UnityEngine.Material,UnityEngine.Material),"ps":1}],"sn":"TryReplaceMaterials","rt":$n[0].Void,"p":[$n[8].ExposedList$1(Spine.Unity.SubmeshInstruction),$n[2].Dictionary$2(UnityEngine.Material,UnityEngine.Material)]},{"a":2,"n":"Buffers","t":16,"rt":$n[5].MeshGeneratorBuffers,"g":{"a":2,"n":"get_Buffers","t":8,"rt":$n[5].MeshGeneratorBuffers,"fg":"Buffers"},"fn":"Buffers"},{"a":2,"n":"SkeletonClipping","t":16,"rt":$n[8].SkeletonClipping,"g":{"a":2,"n":"get_SkeletonClipping","t":8,"rt":$n[8].SkeletonClipping,"fg":"SkeletonClipping"},"fn":"SkeletonClipping"},{"a":2,"n":"UV2","t":16,"rt":System.Array.type(UnityEngine.Vector2),"g":{"a":2,"n":"get_UV2","t":8,"rt":System.Array.type(UnityEngine.Vector2),"fg":"UV2"},"fn":"UV2"},{"a":2,"n":"UV3","t":16,"rt":System.Array.type(UnityEngine.Vector2),"g":{"a":2,"n":"get_UV3","t":8,"rt":System.Array.type(UnityEngine.Vector2),"fg":"UV3"},"fn":"UV3"},{"a":2,"n":"VertexCount","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_VertexCount","t":8,"rt":$n[0].Int32,"fg":"VertexCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"VertexCount"},{"a":1,"n":"AttachmentColors32","is":true,"t":4,"rt":$n[2].List$1(UnityEngine.Color32),"sn":"AttachmentColors32"},{"a":1,"n":"AttachmentIndices","is":true,"t":4,"rt":$n[2].List$1(System.Int32),"sn":"AttachmentIndices"},{"a":1,"n":"AttachmentUVs","is":true,"t":4,"rt":$n[2].List$1(UnityEngine.Vector2),"sn":"AttachmentUVs"},{"a":1,"n":"AttachmentVerts","is":true,"t":4,"rt":$n[2].List$1(UnityEngine.Vector3),"sn":"AttachmentVerts"},{"a":1,"n":"BoundsMaxDefault","is":true,"t":4,"rt":$n[0].Single,"sn":"BoundsMaxDefault","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"BoundsMinDefault","is":true,"t":4,"rt":$n[0].Single,"sn":"BoundsMinDefault","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"clipper","t":4,"rt":$n[8].SkeletonClipping,"sn":"clipper"},{"a":3,"n":"colorBuffer","t":4,"rt":$n[8].ExposedList$1(UnityEngine.Color32),"sn":"colorBuffer","ro":true},{"a":1,"n":"meshBoundsMax","t":4,"rt":$n[1].Vector2,"sn":"meshBoundsMax"},{"a":1,"n":"meshBoundsMin","t":4,"rt":$n[1].Vector2,"sn":"meshBoundsMin"},{"a":1,"n":"meshBoundsThickness","t":4,"rt":$n[0].Single,"sn":"meshBoundsThickness","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"normals","t":4,"rt":System.Array.type(UnityEngine.Vector3),"sn":"normals"},{"a":1,"n":"regionTriangles","t":4,"rt":$n[0].Array.type(System.Int32),"sn":"regionTriangles"},{"a":2,"n":"settings","t":4,"rt":$n[5].MeshGenerator.Settings,"sn":"settings"},{"a":1,"n":"submeshIndex","t":4,"rt":$n[0].Int32,"sn":"submeshIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"submeshes","t":4,"rt":$n[8].ExposedList$1(Spine.ExposedList$1(System.Int32)),"sn":"submeshes","ro":true},{"a":1,"n":"tangents","t":4,"rt":System.Array.type(UnityEngine.Vector4),"sn":"tangents"},{"a":1,"n":"tempTanBuffer","t":4,"rt":System.Array.type(UnityEngine.Vector2),"sn":"tempTanBuffer"},{"a":1,"n":"tempVerts","t":4,"rt":$n[0].Array.type(System.Single),"sn":"tempVerts"},{"a":1,"n":"uv2","t":4,"rt":$n[8].ExposedList$1(UnityEngine.Vector2),"sn":"uv2"},{"a":1,"n":"uv3","t":4,"rt":$n[8].ExposedList$1(UnityEngine.Vector2),"sn":"uv3"},{"a":3,"n":"uvBuffer","t":4,"rt":$n[8].ExposedList$1(UnityEngine.Vector2),"sn":"uvBuffer","ro":true},{"a":3,"n":"vertexBuffer","t":4,"rt":$n[8].ExposedList$1(UnityEngine.Vector3),"sn":"vertexBuffer","ro":true}]}; }, $n);
    /*Spine.Unity.MeshGenerator end.*/

    /*Spine.Unity.MeshGenerator+Settings start.*/
    $m("Spine.Unity.MeshGenerator.Settings", function () { return {"td":$n[5].MeshGenerator,"att":1057034,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Default","is":true,"t":16,"rt":$n[5].MeshGenerator.Settings,"g":{"a":2,"n":"get_Default","t":8,"rt":$n[5].MeshGenerator.Settings,"fg":"Default","is":true},"fn":"Default"},{"a":2,"n":"addNormals","t":4,"rt":$n[0].Boolean,"sn":"addNormals","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"calculateTangents","t":4,"rt":$n[0].Boolean,"sn":"calculateTangents","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("canvasGroupTintBlack"),new UnityEngine.TooltipAttribute("Enable when using SkeletonGraphic under a CanvasGroup. When enabled, PMA Vertex Color alpha value is stored at uv2.g instead of color.a to capture CanvasGroup modifying color.a. Also helps to detect correct parameter setting combinations.")],"a":2,"n":"canvasGroupCompatible","t":4,"rt":$n[0].Boolean,"sn":"canvasGroupCompatible","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"immutableTriangles","t":4,"rt":$n[0].Boolean,"sn":"immutableTriangles","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"pmaVertexColors","t":4,"rt":$n[0].Boolean,"sn":"pmaVertexColors","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"tintBlack","t":4,"rt":$n[0].Boolean,"sn":"tintBlack","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"useClipping","t":4,"rt":$n[0].Boolean,"sn":"useClipping","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.RangeAttribute(-0.1, 0.0)],"a":2,"n":"zSpacing","t":4,"rt":$n[0].Single,"sn":"zSpacing","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.Unity.MeshGenerator+Settings end.*/

    /*Spine.Unity.MeshRendererBuffers start.*/
    $m("Spine.Unity.MeshRendererBuffers", function () { return {"nested":[$n[5].MeshRendererBuffers.SmartMesh],"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"Dispose","t":8,"sn":"Dispose","rt":$n[0].Void},{"a":2,"n":"GetNextMesh","t":8,"sn":"GetNextMesh","rt":$n[5].MeshRendererBuffers.SmartMesh},{"a":2,"n":"GetUpdatedSharedMaterialsArray","t":8,"sn":"GetUpdatedSharedMaterialsArray","rt":System.Array.type(UnityEngine.Material)},{"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"a":2,"n":"MaterialsChangedInLastUpdate","t":8,"sn":"MaterialsChangedInLastUpdate","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"UpdateSharedMaterials","t":8,"pi":[{"n":"instructions","pt":$n[8].ExposedList$1(Spine.Unity.SubmeshInstruction),"ps":0}],"sn":"UpdateSharedMaterials","rt":$n[0].Void,"p":[$n[8].ExposedList$1(Spine.Unity.SubmeshInstruction)]},{"a":1,"n":"doubleBufferedMesh","t":4,"rt":$n[5].DoubleBuffered$1(Spine.Unity.MeshRendererBuffers.SmartMesh),"sn":"doubleBufferedMesh"},{"a":4,"n":"sharedMaterials","t":4,"rt":System.Array.type(UnityEngine.Material),"sn":"sharedMaterials"},{"a":4,"n":"submeshMaterials","t":4,"rt":$n[8].ExposedList$1(UnityEngine.Material),"sn":"submeshMaterials","ro":true}]}; }, $n);
    /*Spine.Unity.MeshRendererBuffers end.*/

    /*Spine.Unity.MeshRendererBuffers+SmartMesh start.*/
    $m("Spine.Unity.MeshRendererBuffers.SmartMesh", function () { return {"td":$n[5].MeshRendererBuffers,"att":1048578,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"Dispose","t":8,"sn":"Dispose","rt":$n[0].Void},{"a":2,"n":"instructionUsed","t":4,"rt":$n[5].SkeletonRendererInstruction,"sn":"instructionUsed"},{"a":2,"n":"mesh","t":4,"rt":$n[1].Mesh,"sn":"mesh"}]}; }, $n);
    /*Spine.Unity.MeshRendererBuffers+SmartMesh end.*/

    /*Spine.Unity.SkeletonRendererInstruction start.*/
    $m("Spine.Unity.SkeletonRendererInstruction", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"Dispose","t":8,"sn":"Dispose","rt":$n[0].Void},{"a":2,"n":"GeometryNotEqual","is":true,"t":8,"pi":[{"n":"a","pt":$n[5].SkeletonRendererInstruction,"ps":0},{"n":"b","pt":$n[5].SkeletonRendererInstruction,"ps":1}],"sn":"GeometryNotEqual","rt":$n[0].Boolean,"p":[$n[5].SkeletonRendererInstruction,$n[5].SkeletonRendererInstruction],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"Set","t":8,"pi":[{"n":"other","pt":$n[5].SkeletonRendererInstruction,"ps":0}],"sn":"Set","rt":$n[0].Void,"p":[$n[5].SkeletonRendererInstruction]},{"a":2,"n":"SetWithSubset","t":8,"pi":[{"n":"instructions","pt":$n[8].ExposedList$1(Spine.Unity.SubmeshInstruction),"ps":0},{"n":"startSubmesh","pt":$n[0].Int32,"ps":1},{"n":"endSubmesh","pt":$n[0].Int32,"ps":2}],"sn":"SetWithSubset","rt":$n[0].Void,"p":[$n[8].ExposedList$1(Spine.Unity.SubmeshInstruction),$n[0].Int32,$n[0].Int32]},{"a":2,"n":"attachments","t":4,"rt":$n[8].ExposedList$1(Spine.Attachment),"sn":"attachments","ro":true},{"a":2,"n":"hasActiveClipping","t":4,"rt":$n[0].Boolean,"sn":"hasActiveClipping","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"immutableTriangles","t":4,"rt":$n[0].Boolean,"sn":"immutableTriangles","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"rawVertexCount","t":4,"rt":$n[0].Int32,"sn":"rawVertexCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"submeshInstructions","t":4,"rt":$n[8].ExposedList$1(Spine.Unity.SubmeshInstruction),"sn":"submeshInstructions","ro":true}]}; }, $n);
    /*Spine.Unity.SkeletonRendererInstruction end.*/

    /*Spine.Unity.SpineMesh start.*/
    $m("Spine.Unity.SpineMesh", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"NewSkeletonMesh","is":true,"t":8,"sn":"NewSkeletonMesh","rt":$n[1].Mesh},{"a":4,"n":"MeshHideflags","is":true,"t":4,"rt":$n[1].HideFlags,"sn":"MeshHideflags","box":function ($v) { return Bridge.box($v, UnityEngine.HideFlags, System.Enum.toStringFn(UnityEngine.HideFlags));}}]}; }, $n);
    /*Spine.Unity.SpineMesh end.*/

    /*Spine.Unity.SubmeshInstruction start.*/
    $m("Spine.Unity.SubmeshInstruction", function () { return {"att":1048841,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"SlotCount","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_SlotCount","t":8,"rt":$n[0].Int32,"fg":"SlotCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"SlotCount"},{"a":2,"n":"endSlot","t":4,"rt":$n[0].Int32,"sn":"endSlot","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"forceSeparate","t":4,"rt":$n[0].Boolean,"sn":"forceSeparate","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"hasClipping","t":4,"rt":$n[0].Boolean,"sn":"hasClipping","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"hasPMAAdditiveSlot","t":4,"rt":$n[0].Boolean,"sn":"hasPMAAdditiveSlot","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"material","t":4,"rt":$n[1].Material,"sn":"material"},{"a":2,"n":"preActiveClippingSlotSource","t":4,"rt":$n[0].Int32,"sn":"preActiveClippingSlotSource","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"rawFirstVertexIndex","t":4,"rt":$n[0].Int32,"sn":"rawFirstVertexIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"rawTriangleCount","t":4,"rt":$n[0].Int32,"sn":"rawTriangleCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"rawVertexCount","t":4,"rt":$n[0].Int32,"sn":"rawVertexCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"skeleton","t":4,"rt":$n[8].Skeleton,"sn":"skeleton"},{"a":2,"n":"startSlot","t":4,"rt":$n[0].Int32,"sn":"startSlot","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.Unity.SubmeshInstruction end.*/

    /*Spine.Unity.BlendModeMaterialsAsset start.*/
    $m("Spine.Unity.BlendModeMaterialsAsset", function () { return {"nested":[$n[5].BlendModeMaterialsAsset.AtlasMaterialCache],"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Spine/SkeletonData Modifiers/Blend Mode Materials", order: 200
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeletonData","pt":$n[8].SkeletonData,"ps":0}],"sn":"Apply","rt":$n[0].Void,"p":[$n[8].SkeletonData]},{"a":2,"n":"ApplyMaterials","is":true,"t":8,"pi":[{"n":"skeletonData","pt":$n[8].SkeletonData,"ps":0},{"n":"multiplyTemplate","pt":$n[1].Material,"ps":1},{"n":"screenTemplate","pt":$n[1].Material,"ps":2},{"n":"additiveTemplate","pt":$n[1].Material,"ps":3},{"n":"includeAdditiveSlots","pt":$n[0].Boolean,"ps":4}],"sn":"ApplyMaterials","rt":$n[0].Void,"p":[$n[8].SkeletonData,$n[1].Material,$n[1].Material,$n[1].Material,$n[0].Boolean]},{"a":2,"n":"additiveMaterialTemplate","t":4,"rt":$n[1].Material,"sn":"additiveMaterialTemplate"},{"a":2,"n":"applyAdditiveMaterial","t":4,"rt":$n[0].Boolean,"sn":"applyAdditiveMaterial","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"multiplyMaterialTemplate","t":4,"rt":$n[1].Material,"sn":"multiplyMaterialTemplate"},{"a":2,"n":"screenMaterialTemplate","t":4,"rt":$n[1].Material,"sn":"screenMaterialTemplate"}]}; }, $n);
    /*Spine.Unity.BlendModeMaterialsAsset end.*/

    /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache start.*/
    $m("Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache", function () { return {"td":$n[5].BlendModeMaterialsAsset,"att":1048579,"a":1,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"CloneAtlasRegionWithMaterial","t":8,"pi":[{"n":"originalRegion","pt":$n[8].AtlasRegion,"ps":0},{"n":"materialTemplate","pt":$n[1].Material,"ps":1}],"sn":"CloneAtlasRegionWithMaterial","rt":$n[8].AtlasRegion,"p":[$n[8].AtlasRegion,$n[1].Material]},{"a":2,"n":"Dispose","t":8,"sn":"Dispose","rt":$n[0].Void},{"a":1,"n":"GetAtlasPageWithMaterial","t":8,"pi":[{"n":"originalPage","pt":$n[8].AtlasPage,"ps":0},{"n":"materialTemplate","pt":$n[1].Material,"ps":1}],"sn":"GetAtlasPageWithMaterial","rt":$n[8].AtlasPage,"p":[$n[8].AtlasPage,$n[1].Material]},{"a":1,"n":"cache","t":4,"rt":$n[2].Dictionary$2(System.Collections.Generic.KeyValuePair$2(Spine.AtlasPage,UnityEngine.Material),Spine.AtlasPage),"sn":"cache","ro":true}]}; }, $n);
    /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache end.*/

    /*Spine.Unity.SpineAttributeBase start.*/
    $m("Spine.Unity.SpineAttributeBase", function () { return {"att":1048705,"a":2,"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"avoidGenericMenu","t":4,"rt":$n[0].Boolean,"sn":"avoidGenericMenu","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"dataField","t":4,"rt":$n[0].String,"sn":"dataField"},{"a":2,"n":"fallbackToTextField","t":4,"rt":$n[0].Boolean,"sn":"fallbackToTextField","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"includeNone","t":4,"rt":$n[0].Boolean,"sn":"includeNone","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"startsWith","t":4,"rt":$n[0].String,"sn":"startsWith"}]}; }, $n);
    /*Spine.Unity.SpineAttributeBase end.*/

    /*Spine.Unity.SpineBone start.*/
    $m("Spine.Unity.SpineBone", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ctor"},{"a":2,"n":"GetBone","is":true,"t":8,"pi":[{"n":"boneName","pt":$n[0].String,"ps":0},{"n":"renderer","pt":$n[5].SkeletonRenderer,"ps":1}],"sn":"getBone","rt":$n[8].Bone,"p":[$n[0].String,$n[5].SkeletonRenderer]},{"a":2,"n":"GetBoneData","is":true,"t":8,"pi":[{"n":"boneName","pt":$n[0].String,"ps":0},{"n":"skeletonDataAsset","pt":$n[5].SkeletonDataAsset,"ps":1}],"sn":"getBoneData","rt":$n[8].BoneData,"p":[$n[0].String,$n[5].SkeletonDataAsset]}]}; }, $n);
    /*Spine.Unity.SpineBone end.*/

    /*Spine.Unity.SpineSlot start.*/
    $m("Spine.Unity.SpineSlot", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"containsBoundingBoxes","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4}],"sn":"ctor"},{"a":2,"n":"containsBoundingBoxes","t":4,"rt":$n[0].Boolean,"sn":"containsBoundingBoxes","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.SpineSlot end.*/

    /*Spine.Unity.SpineAnimation start.*/
    $m("Spine.Unity.SpineAnimation", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"avoidGenericMenu","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4}],"sn":"ctor"}]}; }, $n);
    /*Spine.Unity.SpineAnimation end.*/

    /*Spine.Unity.SpineEvent start.*/
    $m("Spine.Unity.SpineEvent", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"audioOnly","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4}],"sn":"ctor"},{"a":2,"n":"audioOnly","t":4,"rt":$n[0].Boolean,"sn":"audioOnly","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.SpineEvent end.*/

    /*Spine.Unity.SpineIkConstraint start.*/
    $m("Spine.Unity.SpineIkConstraint", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ctor"}]}; }, $n);
    /*Spine.Unity.SpineIkConstraint end.*/

    /*Spine.Unity.SpineTransformConstraint start.*/
    $m("Spine.Unity.SpineTransformConstraint", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ctor"}]}; }, $n);
    /*Spine.Unity.SpineTransformConstraint end.*/

    /*Spine.Unity.SpinePathConstraint start.*/
    $m("Spine.Unity.SpinePathConstraint", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ctor"}]}; }, $n);
    /*Spine.Unity.SpinePathConstraint end.*/

    /*Spine.Unity.SpineSkin start.*/
    $m("Spine.Unity.SpineSkin", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"defaultAsEmptyString","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4},{"n":"avoidGenericMenu","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"ctor"},{"a":2,"n":"defaultAsEmptyString","t":4,"rt":$n[0].Boolean,"sn":"defaultAsEmptyString","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.SpineSkin end.*/

    /*Spine.Unity.SpineAttachment start.*/
    $m("Spine.Unity.SpineAttachment", function () { return {"nested":[$n[5].SpineAttachment.Hierarchy],"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Boolean,$n[0].Boolean,$n[0].Boolean,$n[0].String,$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"currentSkinOnly","dv":true,"o":true,"pt":$n[0].Boolean,"ps":0},{"n":"returnAttachmentPath","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1},{"n":"placeholdersOnly","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"slotField","dv":"","o":true,"pt":$n[0].String,"ps":3},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":4},{"n":"skinField","dv":"","o":true,"pt":$n[0].String,"ps":5},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":6},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":7}],"sn":"ctor"},{"a":2,"n":"GetAttachment","is":true,"t":8,"pi":[{"n":"attachmentPath","pt":$n[0].String,"ps":0},{"n":"skeletonData","pt":$n[8].SkeletonData,"ps":1}],"sn":"getAttachment","rt":$n[8].Attachment,"p":[$n[0].String,$n[8].SkeletonData]},{"a":2,"n":"GetAttachment","is":true,"t":8,"pi":[{"n":"attachmentPath","pt":$n[0].String,"ps":0},{"n":"skeletonDataAsset","pt":$n[5].SkeletonDataAsset,"ps":1}],"sn":"getAttachment$1","rt":$n[8].Attachment,"p":[$n[0].String,$n[5].SkeletonDataAsset]},{"a":2,"n":"GetHierarchy","is":true,"t":8,"pi":[{"n":"fullPath","pt":$n[0].String,"ps":0}],"sn":"getHierarchy","rt":$n[5].SpineAttachment.Hierarchy,"p":[$n[0].String]},{"a":2,"n":"currentSkinOnly","t":4,"rt":$n[0].Boolean,"sn":"currentSkinOnly","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"placeholdersOnly","t":4,"rt":$n[0].Boolean,"sn":"placeholdersOnly","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"returnAttachmentPath","t":4,"rt":$n[0].Boolean,"sn":"returnAttachmentPath","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"skinField","t":4,"rt":$n[0].String,"sn":"skinField"},{"a":2,"n":"slotField","t":4,"rt":$n[0].String,"sn":"slotField"}]}; }, $n);
    /*Spine.Unity.SpineAttachment end.*/

    /*Spine.Unity.SpineAttachment+Hierarchy start.*/
    $m("Spine.Unity.SpineAttachment.Hierarchy", function () { return {"td":$n[5].SpineAttachment,"att":1048842,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"fullPath","pt":$n[0].String,"ps":0}],"sn":"$ctor1"},{"a":2,"n":"name","t":4,"rt":$n[0].String,"sn":"name"},{"a":2,"n":"skin","t":4,"rt":$n[0].String,"sn":"skin"},{"a":2,"n":"slot","t":4,"rt":$n[0].String,"sn":"slot"}]}; }, $n);
    /*Spine.Unity.SpineAttachment+Hierarchy end.*/

    /*Spine.Unity.SpineAtlasRegion start.*/
    $m("Spine.Unity.SpineAtlasRegion", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"atlasAssetField","dv":"","o":true,"pt":$n[0].String,"ps":0}],"sn":"ctor"},{"a":2,"n":"atlasAssetField","t":4,"rt":$n[0].String,"sn":"atlasAssetField"}]}; }, $n);
    /*Spine.Unity.SpineAtlasRegion end.*/

    /*Spine.Unity.SkeletonExtensions start.*/
    $m("Spine.Unity.SkeletonExtensions", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"GetColor","is":true,"t":8,"pi":[{"n":"a","pt":$n[8].MeshAttachment,"ps":0}],"sn":"GetColor","rt":$n[1].Color,"p":[$n[8].MeshAttachment]},{"a":2,"n":"GetColor","is":true,"t":8,"pi":[{"n":"a","pt":$n[8].RegionAttachment,"ps":0}],"sn":"GetColor$1","rt":$n[1].Color,"p":[$n[8].RegionAttachment]},{"a":2,"n":"GetColor","is":true,"t":8,"pi":[{"n":"s","pt":$n[8].Skeleton,"ps":0}],"sn":"GetColor$2","rt":$n[1].Color,"p":[$n[8].Skeleton]},{"a":2,"n":"GetColor","is":true,"t":8,"pi":[{"n":"s","pt":$n[8].Slot,"ps":0}],"sn":"GetColor$3","rt":$n[1].Color,"p":[$n[8].Slot]},{"a":2,"n":"GetColorTintBlack","is":true,"t":8,"pi":[{"n":"s","pt":$n[8].Slot,"ps":0}],"sn":"GetColorTintBlack","rt":$n[1].Color,"p":[$n[8].Slot]},{"a":2,"n":"GetLocalPosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[8].Bone,"ps":0}],"sn":"GetLocalPosition","rt":$n[1].Vector2,"p":[$n[8].Bone]},{"a":2,"n":"GetLocalQuaternion","is":true,"t":8,"pi":[{"n":"bone","pt":$n[8].Bone,"ps":0}],"sn":"GetLocalQuaternion","rt":$n[1].Quaternion,"p":[$n[8].Bone]},{"a":2,"n":"GetLocalScale","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0}],"sn":"GetLocalScale","rt":$n[1].Vector2,"p":[$n[8].Skeleton]},{"a":2,"n":"GetLocalVertices","is":true,"t":8,"pi":[{"n":"va","pt":$n[8].VertexAttachment,"ps":0},{"n":"slot","pt":$n[8].Slot,"ps":1},{"n":"buffer","pt":System.Array.type(UnityEngine.Vector2),"ps":2}],"sn":"GetLocalVertices","rt":System.Array.type(UnityEngine.Vector2),"p":[$n[8].VertexAttachment,$n[8].Slot,System.Array.type(UnityEngine.Vector2)]},{"a":2,"n":"GetMaterial","is":true,"t":8,"pi":[{"n":"a","pt":$n[8].Attachment,"ps":0}],"sn":"GetMaterial","rt":$n[1].Material,"p":[$n[8].Attachment]},{"a":2,"n":"GetMatrix4x4","is":true,"t":8,"pi":[{"n":"bone","pt":$n[8].Bone,"ps":0}],"sn":"GetMatrix4x4","rt":$n[1].Matrix4x4,"p":[$n[8].Bone]},{"a":2,"n":"GetQuaternion","is":true,"t":8,"pi":[{"n":"bone","pt":$n[8].Bone,"ps":0}],"sn":"GetQuaternion","rt":$n[1].Quaternion,"p":[$n[8].Bone]},{"a":2,"n":"GetSkeletonSpacePosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[8].Bone,"ps":0}],"sn":"GetSkeletonSpacePosition","rt":$n[1].Vector2,"p":[$n[8].Bone]},{"a":2,"n":"GetSkeletonSpacePosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[8].Bone,"ps":0},{"n":"boneLocal","pt":$n[1].Vector2,"ps":1}],"sn":"GetSkeletonSpacePosition$1","rt":$n[1].Vector2,"p":[$n[8].Bone,$n[1].Vector2]},{"a":2,"n":"GetWorldPosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[8].Bone,"ps":0},{"n":"spineGameObjectTransform","pt":$n[1].Transform,"ps":1}],"sn":"GetWorldPosition","rt":$n[1].Vector3,"p":[$n[8].Bone,$n[1].Transform]},{"a":2,"n":"GetWorldPosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[8].Bone,"ps":0},{"n":"spineGameObjectTransform","pt":$n[1].Transform,"ps":1},{"n":"positionScale","pt":$n[0].Single,"ps":2}],"sn":"GetWorldPosition$1","rt":$n[1].Vector3,"p":[$n[8].Bone,$n[1].Transform,$n[0].Single]},{"a":2,"n":"GetWorldPosition","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[8].PointAttachment,"ps":0},{"n":"bone","pt":$n[8].Bone,"ps":1},{"n":"spineGameObjectTransform","pt":$n[1].Transform,"ps":2}],"sn":"GetWorldPosition$3","rt":$n[1].Vector3,"p":[$n[8].PointAttachment,$n[8].Bone,$n[1].Transform]},{"a":2,"n":"GetWorldPosition","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[8].PointAttachment,"ps":0},{"n":"slot","pt":$n[8].Slot,"ps":1},{"n":"spineGameObjectTransform","pt":$n[1].Transform,"ps":2}],"sn":"GetWorldPosition$4","rt":$n[1].Vector3,"p":[$n[8].PointAttachment,$n[8].Slot,$n[1].Transform]},{"a":2,"n":"GetWorldPosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[8].Bone,"ps":0},{"n":"spineGameObjectTransform","pt":$n[1].Transform,"ps":1},{"n":"positionScale","pt":$n[0].Single,"ps":2},{"n":"positionOffset","pt":$n[1].Vector2,"ps":3}],"sn":"GetWorldPosition$2","rt":$n[1].Vector3,"p":[$n[8].Bone,$n[1].Transform,$n[0].Single,$n[1].Vector2]},{"a":2,"n":"GetWorldToLocalMatrix","is":true,"t":8,"pi":[{"n":"bone","pt":$n[8].Bone,"ps":0},{"n":"ia","out":true,"pt":$n[0].Single,"ps":1},{"n":"ib","out":true,"pt":$n[0].Single,"ps":2},{"n":"ic","out":true,"pt":$n[0].Single,"ps":3},{"n":"id","out":true,"pt":$n[0].Single,"ps":4}],"sn":"GetWorldToLocalMatrix","rt":$n[0].Void,"p":[$n[8].Bone,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single]},{"a":2,"n":"GetWorldVertices","is":true,"t":8,"pi":[{"n":"a","pt":$n[8].VertexAttachment,"ps":0},{"n":"slot","pt":$n[8].Slot,"ps":1},{"n":"buffer","pt":System.Array.type(UnityEngine.Vector2),"ps":2}],"sn":"GetWorldVertices","rt":System.Array.type(UnityEngine.Vector2),"p":[$n[8].VertexAttachment,$n[8].Slot,System.Array.type(UnityEngine.Vector2)]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[8].MeshAttachment,"ps":0},{"n":"color","pt":$n[1].Color,"ps":1}],"sn":"SetColor","rt":$n[0].Void,"p":[$n[8].MeshAttachment,$n[1].Color]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[8].MeshAttachment,"ps":0},{"n":"color","pt":$n[1].Color32,"ps":1}],"sn":"SetColor$1","rt":$n[0].Void,"p":[$n[8].MeshAttachment,$n[1].Color32]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[8].RegionAttachment,"ps":0},{"n":"color","pt":$n[1].Color,"ps":1}],"sn":"SetColor$2","rt":$n[0].Void,"p":[$n[8].RegionAttachment,$n[1].Color]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[8].RegionAttachment,"ps":0},{"n":"color","pt":$n[1].Color32,"ps":1}],"sn":"SetColor$3","rt":$n[0].Void,"p":[$n[8].RegionAttachment,$n[1].Color32]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"color","pt":$n[1].Color,"ps":1}],"sn":"SetColor$4","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[1].Color]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"color","pt":$n[1].Color32,"ps":1}],"sn":"SetColor$5","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[1].Color32]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"slot","pt":$n[8].Slot,"ps":0},{"n":"color","pt":$n[1].Color,"ps":1}],"sn":"SetColor$6","rt":$n[0].Void,"p":[$n[8].Slot,$n[1].Color]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"slot","pt":$n[8].Slot,"ps":0},{"n":"color","pt":$n[1].Color32,"ps":1}],"sn":"SetColor$7","rt":$n[0].Void,"p":[$n[8].Slot,$n[1].Color32]},{"a":2,"n":"SetLocalPosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[8].Bone,"ps":0},{"n":"position","pt":$n[1].Vector2,"ps":1}],"sn":"SetLocalPosition","rt":$n[0].Void,"p":[$n[8].Bone,$n[1].Vector2]},{"a":2,"n":"SetLocalPosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[8].Bone,"ps":0},{"n":"position","pt":$n[1].Vector3,"ps":1}],"sn":"SetLocalPosition$1","rt":$n[0].Void,"p":[$n[8].Bone,$n[1].Vector3]},{"a":2,"n":"SetLocalScale","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[8].Skeleton,"ps":0},{"n":"scale","pt":$n[1].Vector2,"ps":1}],"sn":"SetLocalScale","rt":$n[0].Void,"p":[$n[8].Skeleton,$n[1].Vector2]},{"a":2,"n":"SetPositionSkeletonSpace","is":true,"t":8,"pi":[{"n":"bone","pt":$n[8].Bone,"ps":0},{"n":"skeletonSpacePosition","pt":$n[1].Vector2,"ps":1}],"sn":"SetPositionSkeletonSpace","rt":$n[1].Vector2,"p":[$n[8].Bone,$n[1].Vector2]},{"a":2,"n":"WorldToLocal","is":true,"t":8,"pi":[{"n":"bone","pt":$n[8].Bone,"ps":0},{"n":"worldPosition","pt":$n[1].Vector2,"ps":1}],"sn":"WorldToLocal","rt":$n[1].Vector2,"p":[$n[8].Bone,$n[1].Vector2]},{"a":1,"n":"ByteToFloat","is":true,"t":4,"rt":$n[0].Single,"sn":"ByteToFloat","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.Unity.SkeletonExtensions end.*/

    /*Spine.Unity.WaitForSpineAnimation start.*/
    $m("Spine.Unity.WaitForSpineAnimation", function () { return {"nested":[$n[5].WaitForSpineAnimation.AnimationEventTypes],"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[8].TrackEntry,$n[5].WaitForSpineAnimation.AnimationEventTypes],"pi":[{"n":"trackEntry","pt":$n[8].TrackEntry,"ps":0},{"n":"eventsToWaitFor","pt":$n[5].WaitForSpineAnimation.AnimationEventTypes,"ps":1}],"sn":"ctor"},{"a":1,"n":"HandleComplete","t":8,"pi":[{"n":"trackEntry","pt":$n[8].TrackEntry,"ps":0}],"sn":"HandleComplete","rt":$n[0].Void,"p":[$n[8].TrackEntry]},{"a":2,"n":"NowWaitFor","t":8,"pi":[{"n":"trackEntry","pt":$n[8].TrackEntry,"ps":0},{"n":"eventsToWaitFor","pt":$n[5].WaitForSpineAnimation.AnimationEventTypes,"ps":1}],"sn":"NowWaitFor","rt":$n[5].WaitForSpineAnimation,"p":[$n[8].TrackEntry,$n[5].WaitForSpineAnimation.AnimationEventTypes]},{"a":3,"n":"SafeSubscribe","t":8,"pi":[{"n":"trackEntry","pt":$n[8].TrackEntry,"ps":0},{"n":"eventsToWaitFor","pt":$n[5].WaitForSpineAnimation.AnimationEventTypes,"ps":1}],"sn":"SafeSubscribe","rt":$n[0].Void,"p":[$n[8].TrackEntry,$n[5].WaitForSpineAnimation.AnimationEventTypes]},{"a":1,"n":"m_WasFired","t":4,"rt":$n[0].Boolean,"sn":"m_WasFired","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.WaitForSpineAnimation end.*/

    /*Spine.Unity.WaitForSpineAnimation+AnimationEventTypes start.*/
    $m("Spine.Unity.WaitForSpineAnimation.AnimationEventTypes", function () { return {"td":$n[5].WaitForSpineAnimation,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Complete","is":true,"t":4,"rt":$n[5].WaitForSpineAnimation.AnimationEventTypes,"sn":"Complete","box":function ($v) { return Bridge.box($v, Spine.Unity.WaitForSpineAnimation.AnimationEventTypes, System.Enum.toStringFn(Spine.Unity.WaitForSpineAnimation.AnimationEventTypes));}},{"a":2,"n":"Dispose","is":true,"t":4,"rt":$n[5].WaitForSpineAnimation.AnimationEventTypes,"sn":"Dispose","box":function ($v) { return Bridge.box($v, Spine.Unity.WaitForSpineAnimation.AnimationEventTypes, System.Enum.toStringFn(Spine.Unity.WaitForSpineAnimation.AnimationEventTypes));}},{"a":2,"n":"End","is":true,"t":4,"rt":$n[5].WaitForSpineAnimation.AnimationEventTypes,"sn":"End","box":function ($v) { return Bridge.box($v, Spine.Unity.WaitForSpineAnimation.AnimationEventTypes, System.Enum.toStringFn(Spine.Unity.WaitForSpineAnimation.AnimationEventTypes));}},{"a":2,"n":"Interrupt","is":true,"t":4,"rt":$n[5].WaitForSpineAnimation.AnimationEventTypes,"sn":"Interrupt","box":function ($v) { return Bridge.box($v, Spine.Unity.WaitForSpineAnimation.AnimationEventTypes, System.Enum.toStringFn(Spine.Unity.WaitForSpineAnimation.AnimationEventTypes));}},{"a":2,"n":"Start","is":true,"t":4,"rt":$n[5].WaitForSpineAnimation.AnimationEventTypes,"sn":"Start","box":function ($v) { return Bridge.box($v, Spine.Unity.WaitForSpineAnimation.AnimationEventTypes, System.Enum.toStringFn(Spine.Unity.WaitForSpineAnimation.AnimationEventTypes));}}]}; }, $n);
    /*Spine.Unity.WaitForSpineAnimation+AnimationEventTypes end.*/

    /*Spine.Unity.WaitForSpineAnimationComplete start.*/
    $m("Spine.Unity.WaitForSpineAnimationComplete", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[8].TrackEntry,$n[0].Boolean],"pi":[{"n":"trackEntry","pt":$n[8].TrackEntry,"ps":0},{"n":"includeEndEvent","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"ctor"},{"a":2,"n":"NowWaitFor","t":8,"pi":[{"n":"trackEntry","pt":$n[8].TrackEntry,"ps":0},{"n":"includeEndEvent","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"NowWaitFor$1","rt":$n[5].WaitForSpineAnimationComplete,"p":[$n[8].TrackEntry,$n[0].Boolean]}]}; }, $n);
    /*Spine.Unity.WaitForSpineAnimationComplete end.*/

    /*Spine.Unity.WaitForSpineAnimationEnd start.*/
    $m("Spine.Unity.WaitForSpineAnimationEnd", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[8].TrackEntry],"pi":[{"n":"trackEntry","pt":$n[8].TrackEntry,"ps":0}],"sn":"ctor"},{"a":2,"n":"NowWaitFor","t":8,"pi":[{"n":"trackEntry","pt":$n[8].TrackEntry,"ps":0}],"sn":"NowWaitFor$1","rt":$n[5].WaitForSpineAnimationEnd,"p":[$n[8].TrackEntry]}]}; }, $n);
    /*Spine.Unity.WaitForSpineAnimationEnd end.*/

    /*Spine.Unity.WaitForSpineEvent start.*/
    $m("Spine.Unity.WaitForSpineEvent", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[8].AnimationState,$n[8].EventData,$n[0].Boolean],"pi":[{"n":"state","pt":$n[8].AnimationState,"ps":0},{"n":"eventDataReference","pt":$n[8].EventData,"ps":1},{"n":"unsubscribeAfterFiring","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[8].AnimationState,$n[0].String,$n[0].Boolean],"pi":[{"n":"state","pt":$n[8].AnimationState,"ps":0},{"n":"eventName","pt":$n[0].String,"ps":1},{"n":"unsubscribeAfterFiring","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"$ctor1"},{"a":2,"n":".ctor","t":1,"p":[$n[5].SkeletonAnimation,$n[8].EventData,$n[0].Boolean],"pi":[{"n":"skeletonAnimation","pt":$n[5].SkeletonAnimation,"ps":0},{"n":"eventDataReference","pt":$n[8].EventData,"ps":1},{"n":"unsubscribeAfterFiring","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"$ctor2"},{"a":2,"n":".ctor","t":1,"p":[$n[5].SkeletonAnimation,$n[0].String,$n[0].Boolean],"pi":[{"n":"skeletonAnimation","pt":$n[5].SkeletonAnimation,"ps":0},{"n":"eventName","pt":$n[0].String,"ps":1},{"n":"unsubscribeAfterFiring","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"$ctor3"},{"a":1,"n":"Clear","t":8,"pi":[{"n":"state","pt":$n[8].AnimationState,"ps":0}],"sn":"Clear","rt":$n[0].Void,"p":[$n[8].AnimationState]},{"a":1,"n":"HandleAnimationStateEvent","t":8,"pi":[{"n":"trackEntry","pt":$n[8].TrackEntry,"ps":0},{"n":"e","pt":$n[8].Event,"ps":1}],"sn":"HandleAnimationStateEvent","rt":$n[0].Void,"p":[$n[8].TrackEntry,$n[8].Event]},{"a":1,"n":"HandleAnimationStateEventByName","t":8,"pi":[{"n":"trackEntry","pt":$n[8].TrackEntry,"ps":0},{"n":"e","pt":$n[8].Event,"ps":1}],"sn":"HandleAnimationStateEventByName","rt":$n[0].Void,"p":[$n[8].TrackEntry,$n[8].Event]},{"a":2,"n":"NowWaitFor","t":8,"pi":[{"n":"state","pt":$n[8].AnimationState,"ps":0},{"n":"eventDataReference","pt":$n[8].EventData,"ps":1},{"n":"unsubscribeAfterFiring","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"NowWaitFor","rt":$n[5].WaitForSpineEvent,"p":[$n[8].AnimationState,$n[8].EventData,$n[0].Boolean]},{"a":2,"n":"NowWaitFor","t":8,"pi":[{"n":"state","pt":$n[8].AnimationState,"ps":0},{"n":"eventName","pt":$n[0].String,"ps":1},{"n":"unsubscribeAfterFiring","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"NowWaitFor$1","rt":$n[5].WaitForSpineEvent,"p":[$n[8].AnimationState,$n[0].String,$n[0].Boolean]},{"a":1,"n":"Subscribe","t":8,"pi":[{"n":"state","pt":$n[8].AnimationState,"ps":0},{"n":"eventDataReference","pt":$n[8].EventData,"ps":1},{"n":"unsubscribe","pt":$n[0].Boolean,"ps":2}],"sn":"Subscribe","rt":$n[0].Void,"p":[$n[8].AnimationState,$n[8].EventData,$n[0].Boolean]},{"a":1,"n":"SubscribeByName","t":8,"pi":[{"n":"state","pt":$n[8].AnimationState,"ps":0},{"n":"eventName","pt":$n[0].String,"ps":1},{"n":"unsubscribe","pt":$n[0].Boolean,"ps":2}],"sn":"SubscribeByName","rt":$n[0].Void,"p":[$n[8].AnimationState,$n[0].String,$n[0].Boolean]},{"a":2,"n":"WillUnsubscribeAfterFiring","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_WillUnsubscribeAfterFiring","t":8,"rt":$n[0].Boolean,"fg":"WillUnsubscribeAfterFiring","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_WillUnsubscribeAfterFiring","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"WillUnsubscribeAfterFiring"},"fn":"WillUnsubscribeAfterFiring"},{"a":1,"n":"m_AnimationState","t":4,"rt":$n[8].AnimationState,"sn":"m_AnimationState"},{"a":1,"n":"m_EventName","t":4,"rt":$n[0].String,"sn":"m_EventName"},{"a":1,"n":"m_TargetEvent","t":4,"rt":$n[8].EventData,"sn":"m_TargetEvent"},{"a":1,"n":"m_WasFired","t":4,"rt":$n[0].Boolean,"sn":"m_WasFired","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"m_unsubscribeAfterFiring","t":4,"rt":$n[0].Boolean,"sn":"m_unsubscribeAfterFiring","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.WaitForSpineEvent end.*/

    /*Spine.Unity.WaitForSpineTrackEntryEnd start.*/
    $m("Spine.Unity.WaitForSpineTrackEntryEnd", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[8].TrackEntry],"pi":[{"n":"trackEntry","pt":$n[8].TrackEntry,"ps":0}],"sn":"ctor"},{"a":1,"n":"HandleEnd","t":8,"pi":[{"n":"trackEntry","pt":$n[8].TrackEntry,"ps":0}],"sn":"HandleEnd","rt":$n[0].Void,"p":[$n[8].TrackEntry]},{"a":2,"n":"NowWaitFor","t":8,"pi":[{"n":"trackEntry","pt":$n[8].TrackEntry,"ps":0}],"sn":"NowWaitFor","rt":$n[5].WaitForSpineTrackEntryEnd,"p":[$n[8].TrackEntry]},{"a":1,"n":"SafeSubscribe","t":8,"pi":[{"n":"trackEntry","pt":$n[8].TrackEntry,"ps":0}],"sn":"SafeSubscribe","rt":$n[0].Void,"p":[$n[8].TrackEntry]},{"a":1,"n":"m_WasFired","t":4,"rt":$n[0].Boolean,"sn":"m_WasFired","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.WaitForSpineTrackEntryEnd end.*/

    /*Spine.Unity.AnimationTools.TimelineExtensions start.*/
    $m("Spine.Unity.AnimationTools.TimelineExtensions", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"Evaluate","is":true,"t":8,"pi":[{"n":"timeline","pt":$n[8].RotateTimeline,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"skeletonData","dv":null,"o":true,"pt":$n[8].SkeletonData,"ps":2}],"sn":"Evaluate","rt":$n[0].Single,"p":[$n[8].RotateTimeline,$n[0].Single,$n[8].SkeletonData],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Evaluate","is":true,"t":8,"pi":[{"n":"timeline","pt":$n[8].TranslateTimeline,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"skeletonData","dv":null,"o":true,"pt":$n[8].SkeletonData,"ps":2}],"sn":"Evaluate$1","rt":$n[1].Vector2,"p":[$n[8].TranslateTimeline,$n[0].Single,$n[8].SkeletonData]},{"a":2,"n":"Evaluate","is":true,"t":8,"pi":[{"n":"xTimeline","pt":$n[8].TranslateXTimeline,"ps":0},{"n":"yTimeline","pt":$n[8].TranslateYTimeline,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"skeletonData","dv":null,"o":true,"pt":$n[8].SkeletonData,"ps":3}],"sn":"Evaluate$2","rt":$n[1].Vector2,"p":[$n[8].TranslateXTimeline,$n[8].TranslateYTimeline,$n[0].Single,$n[8].SkeletonData]},{"a":2,"n":"EvaluateRotateMix","is":true,"t":8,"pi":[{"n":"timeline","pt":$n[8].TransformConstraintTimeline,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1}],"sn":"EvaluateRotateMix","rt":$n[0].Single,"p":[$n[8].TransformConstraintTimeline,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"EvaluateTranslateXYMix","is":true,"t":8,"pi":[{"n":"timeline","pt":$n[8].TransformConstraintTimeline,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1}],"sn":"EvaluateTranslateXYMix","rt":$n[1].Vector2,"p":[$n[8].TransformConstraintTimeline,$n[0].Single]},{"a":2,"n":"FindTimelineForBone","is":true,"t":8,"pi":[{"n":"a","pt":$n[8].Animation,"ps":0},{"n":"boneIndex","pt":$n[0].Int32,"ps":1}],"tpc":1,"tprm":["T"],"sn":"FindTimelineForBone","rt":System.Object,"p":[$n[8].Animation,$n[0].Int32]},{"a":2,"n":"FindTransformConstraintTimeline","is":true,"t":8,"pi":[{"n":"a","pt":$n[8].Animation,"ps":0},{"n":"transformConstraintIndex","pt":$n[0].Int32,"ps":1}],"sn":"FindTransformConstraintTimeline","rt":$n[8].TransformConstraintTimeline,"p":[$n[8].Animation,$n[0].Int32]},{"a":2,"n":"FindTranslateTimelineForBone","is":true,"t":8,"pi":[{"n":"a","pt":$n[8].Animation,"ps":0},{"n":"boneIndex","pt":$n[0].Int32,"ps":1}],"sn":"FindTranslateTimelineForBone","rt":$n[8].TranslateTimeline,"p":[$n[8].Animation,$n[0].Int32]}]}; }, $n);
    /*Spine.Unity.AnimationTools.TimelineExtensions end.*/

    /*Spine.Unity.AttachmentTools.AtlasUtilities start.*/
    $m("Spine.Unity.AttachmentTools.AtlasUtilities", function () { return {"nested":[$n[12].AtlasUtilities.IntAndAtlasRegionKey],"att":1048961,"a":2,"s":true,"m":[{"a":1,"n":"AddRegionTexturesToPack","is":true,"t":8,"pi":[{"n":"numTextureParamsToRepack","pt":$n[0].Int32,"ps":0},{"n":"region","pt":$n[8].AtlasRegion,"ps":1},{"n":"textureFormat","pt":$n[1].TextureFormat,"ps":2},{"n":"mipmaps","pt":$n[0].Boolean,"ps":3},{"n":"additionalTextureFormats","pt":System.Array.type(UnityEngine.TextureFormat),"ps":4},{"n":"additionalTexturePropertyIDsToCopy","pt":$n[0].Array.type(System.Int32),"ps":5},{"n":"additionalTextureIsLinear","pt":$n[0].Array.type(System.Boolean),"ps":6}],"sn":"AddRegionTexturesToPack","rt":$n[0].Void,"p":[$n[0].Int32,$n[8].AtlasRegion,$n[1].TextureFormat,$n[0].Boolean,System.Array.type(UnityEngine.TextureFormat),$n[0].Array.type(System.Int32),$n[0].Array.type(System.Boolean)]},{"a":2,"n":"ClearCache","is":true,"t":8,"sn":"ClearCache","rt":$n[0].Void},{"a":1,"n":"CopyTexture","is":true,"t":8,"pi":[{"n":"source","pt":$n[1].Texture2D,"ps":0},{"n":"sourceRect","pt":$n[1].Rect,"ps":1},{"n":"destination","pt":$n[1].Texture2D,"ps":2}],"sn":"CopyTexture","rt":$n[0].Void,"p":[$n[1].Texture2D,$n[1].Rect,$n[1].Texture2D]},{"a":1,"n":"CopyTextureApplyPMA","is":true,"t":8,"pi":[{"n":"source","pt":$n[1].Texture2D,"ps":0},{"n":"sourceRect","pt":$n[1].Rect,"ps":1},{"n":"destination","pt":$n[1].Texture2D,"ps":2}],"sn":"CopyTextureApplyPMA","rt":$n[0].Void,"p":[$n[1].Texture2D,$n[1].Rect,$n[1].Texture2D]},{"a":1,"n":"CopyTextureAttributesFrom","is":true,"t":8,"pi":[{"n":"destination","pt":$n[1].Texture2D,"ps":0},{"n":"source","pt":$n[1].Texture2D,"ps":1}],"sn":"CopyTextureAttributesFrom","rt":$n[0].Void,"p":[$n[1].Texture2D,$n[1].Texture2D]},{"a":1,"n":"GetClone","is":true,"t":8,"pi":[{"n":"t","pt":$n[1].Texture2D,"ps":0},{"n":"textureFormat","dv":4,"o":true,"pt":$n[1].TextureFormat,"ps":1},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"linear","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"applyPMA","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4}],"sn":"GetClone","rt":$n[1].Texture2D,"p":[$n[1].Texture2D,$n[1].TextureFormat,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":1,"n":"GetMainTexture","is":true,"t":8,"pi":[{"n":"region","pt":$n[8].AtlasRegion,"ps":0}],"sn":"GetMainTexture","rt":$n[1].Texture2D,"p":[$n[8].AtlasRegion]},{"a":2,"n":"GetRepackedAttachments","is":true,"t":8,"pi":[{"n":"sourceAttachments","pt":$n[2].List$1(Spine.Attachment),"ps":0},{"n":"outputAttachments","pt":$n[2].List$1(Spine.Attachment),"ps":1},{"n":"materialPropertySource","pt":$n[1].Material,"ps":2},{"n":"outputMaterial","out":true,"pt":$n[1].Material,"ps":3},{"n":"outputTexture","out":true,"pt":$n[1].Texture2D,"ps":4},{"n":"maxAtlasSize","dv":1024,"o":true,"pt":$n[0].Int32,"ps":5},{"n":"padding","dv":2,"o":true,"pt":$n[0].Int32,"ps":6},{"n":"textureFormat","dv":4,"o":true,"pt":$n[1].TextureFormat,"ps":7},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":8},{"n":"newAssetName","dv":"Repacked Attachments","o":true,"pt":$n[0].String,"ps":9},{"n":"clearCache","dv":false,"o":true,"pt":$n[0].Boolean,"ps":10},{"n":"useOriginalNonrenderables","dv":true,"o":true,"pt":$n[0].Boolean,"ps":11},{"n":"additionalTexturePropertyIDsToCopy","dv":null,"o":true,"pt":$n[0].Array.type(System.Int32),"ps":12},{"n":"additionalOutputTextures","dv":null,"o":true,"pt":System.Array.type(UnityEngine.Texture2D),"ps":13},{"n":"additionalTextureFormats","dv":null,"o":true,"pt":System.Array.type(UnityEngine.TextureFormat),"ps":14},{"n":"additionalTextureIsLinear","dv":null,"o":true,"pt":$n[0].Array.type(System.Boolean),"ps":15}],"sn":"GetRepackedAttachments","rt":$n[0].Void,"p":[$n[2].List$1(Spine.Attachment),$n[2].List$1(Spine.Attachment),$n[1].Material,$n[1].Material,$n[1].Texture2D,$n[0].Int32,$n[0].Int32,$n[1].TextureFormat,$n[0].Boolean,$n[0].String,$n[0].Boolean,$n[0].Boolean,$n[0].Array.type(System.Int32),System.Array.type(UnityEngine.Texture2D),System.Array.type(UnityEngine.TextureFormat),$n[0].Array.type(System.Boolean)]},{"a":2,"n":"GetRepackedAttachments","is":true,"t":8,"pi":[{"n":"sourceAttachments","pt":$n[2].List$1(Spine.Attachment),"ps":0},{"n":"outputAttachments","pt":$n[2].List$1(Spine.Attachment),"ps":1},{"n":"shader","pt":$n[1].Shader,"ps":2},{"n":"outputMaterial","out":true,"pt":$n[1].Material,"ps":3},{"n":"outputTexture","out":true,"pt":$n[1].Texture2D,"ps":4},{"n":"maxAtlasSize","dv":1024,"o":true,"pt":$n[0].Int32,"ps":5},{"n":"padding","dv":2,"o":true,"pt":$n[0].Int32,"ps":6},{"n":"textureFormat","dv":4,"o":true,"pt":$n[1].TextureFormat,"ps":7},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":8},{"n":"newAssetName","dv":"Repacked Attachments","o":true,"pt":$n[0].String,"ps":9},{"n":"materialPropertySource","dv":null,"o":true,"pt":$n[1].Material,"ps":10},{"n":"clearCache","dv":false,"o":true,"pt":$n[0].Boolean,"ps":11},{"n":"useOriginalNonrenderables","dv":true,"o":true,"pt":$n[0].Boolean,"ps":12},{"n":"additionalTexturePropertyIDsToCopy","dv":null,"o":true,"pt":$n[0].Array.type(System.Int32),"ps":13},{"n":"additionalOutputTextures","dv":null,"o":true,"pt":System.Array.type(UnityEngine.Texture2D),"ps":14},{"n":"additionalTextureFormats","dv":null,"o":true,"pt":System.Array.type(UnityEngine.TextureFormat),"ps":15},{"n":"additionalTextureIsLinear","dv":null,"o":true,"pt":$n[0].Array.type(System.Boolean),"ps":16}],"sn":"GetRepackedAttachments$1","rt":$n[0].Void,"p":[$n[2].List$1(Spine.Attachment),$n[2].List$1(Spine.Attachment),$n[1].Shader,$n[1].Material,$n[1].Texture2D,$n[0].Int32,$n[0].Int32,$n[1].TextureFormat,$n[0].Boolean,$n[0].String,$n[1].Material,$n[0].Boolean,$n[0].Boolean,$n[0].Array.type(System.Int32),System.Array.type(UnityEngine.Texture2D),System.Array.type(UnityEngine.TextureFormat),$n[0].Array.type(System.Boolean)]},{"a":2,"n":"GetRepackedSkin","is":true,"t":8,"pi":[{"n":"o","pt":$n[8].Skin,"ps":0},{"n":"newName","pt":$n[0].String,"ps":1},{"n":"materialPropertySource","pt":$n[1].Material,"ps":2},{"n":"outputMaterial","out":true,"pt":$n[1].Material,"ps":3},{"n":"outputTexture","out":true,"pt":$n[1].Texture2D,"ps":4},{"n":"maxAtlasSize","dv":1024,"o":true,"pt":$n[0].Int32,"ps":5},{"n":"padding","dv":2,"o":true,"pt":$n[0].Int32,"ps":6},{"n":"textureFormat","dv":4,"o":true,"pt":$n[1].TextureFormat,"ps":7},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":8},{"n":"useOriginalNonrenderables","dv":true,"o":true,"pt":$n[0].Boolean,"ps":9},{"n":"clearCache","dv":false,"o":true,"pt":$n[0].Boolean,"ps":10},{"n":"additionalTexturePropertyIDsToCopy","dv":null,"o":true,"pt":$n[0].Array.type(System.Int32),"ps":11},{"n":"additionalOutputTextures","dv":null,"o":true,"pt":System.Array.type(UnityEngine.Texture2D),"ps":12},{"n":"additionalTextureFormats","dv":null,"o":true,"pt":System.Array.type(UnityEngine.TextureFormat),"ps":13},{"n":"additionalTextureIsLinear","dv":null,"o":true,"pt":$n[0].Array.type(System.Boolean),"ps":14}],"sn":"GetRepackedSkin","rt":$n[8].Skin,"p":[$n[8].Skin,$n[0].String,$n[1].Material,$n[1].Material,$n[1].Texture2D,$n[0].Int32,$n[0].Int32,$n[1].TextureFormat,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean,$n[0].Array.type(System.Int32),System.Array.type(UnityEngine.Texture2D),System.Array.type(UnityEngine.TextureFormat),$n[0].Array.type(System.Boolean)]},{"a":2,"n":"GetRepackedSkin","is":true,"t":8,"pi":[{"n":"o","pt":$n[8].Skin,"ps":0},{"n":"newName","pt":$n[0].String,"ps":1},{"n":"shader","pt":$n[1].Shader,"ps":2},{"n":"outputMaterial","out":true,"pt":$n[1].Material,"ps":3},{"n":"outputTexture","out":true,"pt":$n[1].Texture2D,"ps":4},{"n":"maxAtlasSize","dv":1024,"o":true,"pt":$n[0].Int32,"ps":5},{"n":"padding","dv":2,"o":true,"pt":$n[0].Int32,"ps":6},{"n":"textureFormat","dv":4,"o":true,"pt":$n[1].TextureFormat,"ps":7},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":8},{"n":"materialPropertySource","dv":null,"o":true,"pt":$n[1].Material,"ps":9},{"n":"clearCache","dv":false,"o":true,"pt":$n[0].Boolean,"ps":10},{"n":"useOriginalNonrenderables","dv":true,"o":true,"pt":$n[0].Boolean,"ps":11},{"n":"additionalTexturePropertyIDsToCopy","dv":null,"o":true,"pt":$n[0].Array.type(System.Int32),"ps":12},{"n":"additionalOutputTextures","dv":null,"o":true,"pt":System.Array.type(UnityEngine.Texture2D),"ps":13},{"n":"additionalTextureFormats","dv":null,"o":true,"pt":System.Array.type(UnityEngine.TextureFormat),"ps":14},{"n":"additionalTextureIsLinear","dv":null,"o":true,"pt":$n[0].Array.type(System.Boolean),"ps":15}],"sn":"GetRepackedSkin$1","rt":$n[8].Skin,"p":[$n[8].Skin,$n[0].String,$n[1].Shader,$n[1].Material,$n[1].Texture2D,$n[0].Int32,$n[0].Int32,$n[1].TextureFormat,$n[0].Boolean,$n[1].Material,$n[0].Boolean,$n[0].Boolean,$n[0].Array.type(System.Int32),System.Array.type(UnityEngine.Texture2D),System.Array.type(UnityEngine.TextureFormat),$n[0].Array.type(System.Boolean)]},{"a":1,"n":"GetSpineAtlasRect","is":true,"t":8,"pi":[{"n":"region","pt":$n[8].AtlasRegion,"ps":0},{"n":"includeRotate","dv":true,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"GetSpineAtlasRect","rt":$n[1].Rect,"p":[$n[8].AtlasRegion,$n[0].Boolean]},{"a":1,"n":"GetTexture","is":true,"t":8,"pi":[{"n":"region","pt":$n[8].AtlasRegion,"ps":0},{"n":"texturePropertyId","pt":$n[0].Int32,"ps":1}],"sn":"GetTexture","rt":$n[1].Texture2D,"p":[$n[8].AtlasRegion,$n[0].Int32]},{"a":1,"n":"GetTexture","is":true,"t":8,"pi":[{"n":"region","pt":$n[8].AtlasRegion,"ps":0},{"n":"texturePropertyName","pt":$n[0].String,"ps":1}],"sn":"GetTexture$1","rt":$n[1].Texture2D,"p":[$n[8].AtlasRegion,$n[0].String]},{"a":1,"n":"GetUnityRect","is":true,"t":8,"pi":[{"n":"region","pt":$n[8].AtlasRegion,"ps":0}],"sn":"GetUnityRect","rt":$n[1].Rect,"p":[$n[8].AtlasRegion]},{"a":1,"n":"GetUnityRect","is":true,"t":8,"pi":[{"n":"region","pt":$n[8].AtlasRegion,"ps":0},{"n":"textureHeight","pt":$n[0].Int32,"ps":1}],"sn":"GetUnityRect$1","rt":$n[1].Rect,"p":[$n[8].AtlasRegion,$n[0].Int32]},{"at":[new UnityEngine.RuntimeInitializeOnLoadMethodAttribute.$ctor1(4)],"a":1,"n":"Init","is":true,"t":8,"sn":"Init","rt":$n[0].Void},{"a":1,"n":"InverseLerp","is":true,"t":8,"pi":[{"n":"a","pt":$n[0].Single,"ps":0},{"n":"b","pt":$n[0].Single,"ps":1},{"n":"value","pt":$n[0].Single,"ps":2}],"sn":"InverseLerp","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"IsRenderable","is":true,"t":8,"pi":[{"n":"a","pt":$n[8].Attachment,"ps":0}],"sn":"IsRenderable","rt":$n[0].Boolean,"p":[$n[8].Attachment],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"SpineUnityFlipRect","is":true,"t":8,"pi":[{"n":"rect","pt":$n[1].Rect,"ps":0},{"n":"textureHeight","pt":$n[0].Int32,"ps":1}],"sn":"SpineUnityFlipRect","rt":$n[1].Rect,"p":[$n[1].Rect,$n[0].Int32]},{"a":1,"n":"TextureRectToUVRect","is":true,"t":8,"pi":[{"n":"textureRect","pt":$n[1].Rect,"ps":0},{"n":"texWidth","pt":$n[0].Int32,"ps":1},{"n":"texHeight","pt":$n[0].Int32,"ps":2}],"sn":"TextureRectToUVRect","rt":$n[1].Rect,"p":[$n[1].Rect,$n[0].Int32,$n[0].Int32]},{"a":2,"n":"ToAtlasRegion","is":true,"t":8,"pi":[{"n":"s","pt":$n[1].Sprite,"ps":0},{"n":"page","pt":$n[8].AtlasPage,"ps":1}],"sn":"ToAtlasRegion","rt":$n[8].AtlasRegion,"p":[$n[1].Sprite,$n[8].AtlasPage]},{"a":4,"n":"ToAtlasRegion","is":true,"t":8,"pi":[{"n":"s","pt":$n[1].Sprite,"ps":0},{"n":"isolatedTexture","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"ToAtlasRegion$4","rt":$n[8].AtlasRegion,"p":[$n[1].Sprite,$n[0].Boolean]},{"a":2,"n":"ToAtlasRegion","is":true,"t":8,"pi":[{"n":"s","pt":$n[1].Sprite,"ps":0},{"n":"material","pt":$n[1].Material,"ps":1}],"sn":"ToAtlasRegion$1","rt":$n[8].AtlasRegion,"p":[$n[1].Sprite,$n[1].Material]},{"a":2,"n":"ToAtlasRegion","is":true,"t":8,"pi":[{"n":"t","pt":$n[1].Texture2D,"ps":0},{"n":"materialPropertySource","pt":$n[1].Material,"ps":1},{"n":"scale","dv":0.01,"o":true,"pt":$n[0].Single,"ps":2}],"sn":"ToAtlasRegion$2","rt":$n[8].AtlasRegion,"p":[$n[1].Texture2D,$n[1].Material,$n[0].Single]},{"a":2,"n":"ToAtlasRegion","is":true,"t":8,"pi":[{"n":"t","pt":$n[1].Texture2D,"ps":0},{"n":"shader","pt":$n[1].Shader,"ps":1},{"n":"scale","dv":0.01,"o":true,"pt":$n[0].Single,"ps":2},{"n":"materialPropertySource","dv":null,"o":true,"pt":$n[1].Material,"ps":3}],"sn":"ToAtlasRegion$3","rt":$n[8].AtlasRegion,"p":[$n[1].Texture2D,$n[1].Shader,$n[0].Single,$n[1].Material]},{"a":2,"n":"ToAtlasRegionPMAClone","is":true,"t":8,"pi":[{"n":"s","pt":$n[1].Sprite,"ps":0},{"n":"materialPropertySource","pt":$n[1].Material,"ps":1},{"n":"textureFormat","dv":4,"o":true,"pt":$n[1].TextureFormat,"ps":2},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ToAtlasRegionPMAClone","rt":$n[8].AtlasRegion,"p":[$n[1].Sprite,$n[1].Material,$n[1].TextureFormat,$n[0].Boolean]},{"a":2,"n":"ToAtlasRegionPMAClone","is":true,"t":8,"pi":[{"n":"t","pt":$n[1].Texture2D,"ps":0},{"n":"materialPropertySource","pt":$n[1].Material,"ps":1},{"n":"textureFormat","dv":4,"o":true,"pt":$n[1].TextureFormat,"ps":2},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ToAtlasRegionPMAClone$2","rt":$n[8].AtlasRegion,"p":[$n[1].Texture2D,$n[1].Material,$n[1].TextureFormat,$n[0].Boolean]},{"a":2,"n":"ToAtlasRegionPMAClone","is":true,"t":8,"pi":[{"n":"s","pt":$n[1].Sprite,"ps":0},{"n":"shader","pt":$n[1].Shader,"ps":1},{"n":"textureFormat","dv":4,"o":true,"pt":$n[1].TextureFormat,"ps":2},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"materialPropertySource","dv":null,"o":true,"pt":$n[1].Material,"ps":4}],"sn":"ToAtlasRegionPMAClone$1","rt":$n[8].AtlasRegion,"p":[$n[1].Sprite,$n[1].Shader,$n[1].TextureFormat,$n[0].Boolean,$n[1].Material]},{"a":2,"n":"ToAtlasRegionPMAClone","is":true,"t":8,"pi":[{"n":"t","pt":$n[1].Texture2D,"ps":0},{"n":"shader","pt":$n[1].Shader,"ps":1},{"n":"textureFormat","dv":4,"o":true,"pt":$n[1].TextureFormat,"ps":2},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"materialPropertySource","dv":null,"o":true,"pt":$n[1].Material,"ps":4}],"sn":"ToAtlasRegionPMAClone$3","rt":$n[8].AtlasRegion,"p":[$n[1].Texture2D,$n[1].Shader,$n[1].TextureFormat,$n[0].Boolean,$n[1].Material]},{"a":2,"n":"ToSpineAtlasPage","is":true,"t":8,"pi":[{"n":"m","pt":$n[1].Material,"ps":0}],"sn":"ToSpineAtlasPage","rt":$n[8].AtlasPage,"p":[$n[1].Material]},{"a":2,"n":"ToSprite","is":true,"t":8,"pi":[{"n":"ar","pt":$n[8].AtlasRegion,"ps":0},{"n":"pixelsPerUnit","dv":100.0,"o":true,"pt":$n[0].Single,"ps":1}],"sn":"ToSprite","rt":$n[1].Sprite,"p":[$n[8].AtlasRegion,$n[0].Single]},{"a":1,"n":"ToTexture","is":true,"t":8,"pi":[{"n":"s","pt":$n[1].Sprite,"ps":0},{"n":"textureFormat","dv":4,"o":true,"pt":$n[1].TextureFormat,"ps":1},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"linear","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"applyPMA","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4}],"sn":"ToTexture$1","rt":$n[1].Texture2D,"p":[$n[1].Sprite,$n[1].TextureFormat,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"ToTexture","is":true,"t":8,"pi":[{"n":"ar","pt":$n[8].AtlasRegion,"ps":0},{"n":"textureFormat","dv":4,"o":true,"pt":$n[1].TextureFormat,"ps":1},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"texturePropertyId","dv":0,"o":true,"pt":$n[0].Int32,"ps":3},{"n":"linear","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4},{"n":"applyPMA","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"ToTexture","rt":$n[1].Texture2D,"p":[$n[8].AtlasRegion,$n[1].TextureFormat,$n[0].Boolean,$n[0].Int32,$n[0].Boolean,$n[0].Boolean]},{"a":1,"n":"UVRectToAtlasRegion","is":true,"t":8,"pi":[{"n":"uvRect","pt":$n[1].Rect,"ps":0},{"n":"referenceRegion","pt":$n[8].AtlasRegion,"ps":1},{"n":"page","pt":$n[8].AtlasPage,"ps":2}],"sn":"UVRectToAtlasRegion","rt":$n[8].AtlasRegion,"p":[$n[1].Rect,$n[8].AtlasRegion,$n[8].AtlasPage]},{"a":1,"n":"UVRectToTextureRect","is":true,"t":8,"pi":[{"n":"uvRect","pt":$n[1].Rect,"ps":0},{"n":"texWidth","pt":$n[0].Int32,"ps":1},{"n":"texHeight","pt":$n[0].Int32,"ps":2}],"sn":"UVRectToTextureRect","rt":$n[1].Rect,"p":[$n[1].Rect,$n[0].Int32,$n[0].Int32]},{"a":1,"n":"CachedRegionTextures","is":true,"t":4,"rt":$n[2].Dictionary$2(Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey,UnityEngine.Texture2D),"sn":"CachedRegionTextures"},{"a":1,"n":"CachedRegionTexturesList","is":true,"t":4,"rt":$n[2].List$1(UnityEngine.Texture2D),"sn":"CachedRegionTexturesList"},{"a":4,"n":"DefaultMipmapBias","is":true,"t":4,"rt":$n[0].Single,"sn":"DefaultMipmapBias","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"DefaultScale","is":true,"t":4,"rt":$n[0].Single,"sn":"DefaultScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"NonrenderingRegion","is":true,"t":4,"rt":$n[0].Int32,"sn":"NonrenderingRegion","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"SpineTextureFormat","is":true,"t":4,"rt":$n[1].TextureFormat,"sn":"SpineTextureFormat","box":function ($v) { return Bridge.box($v, UnityEngine.TextureFormat, System.Enum.toStringFn(UnityEngine.TextureFormat));}},{"a":4,"n":"UseMipMaps","is":true,"t":4,"rt":$n[0].Boolean,"sn":"UseMipMaps","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"existingRegions","is":true,"t":4,"rt":$n[2].Dictionary$2(Spine.AtlasRegion,System.Int32),"sn":"existingRegions","ro":true},{"a":1,"n":"inoutAttachments","is":true,"t":4,"rt":$n[2].List$1(Spine.Attachment),"sn":"inoutAttachments"},{"a":1,"n":"originalRegions","is":true,"t":4,"rt":$n[2].List$1(Spine.AtlasRegion),"sn":"originalRegions","ro":true},{"a":1,"n":"regionIndices","is":true,"t":4,"rt":$n[2].List$1(System.Int32),"sn":"regionIndices","ro":true},{"a":1,"n":"repackedRegions","is":true,"t":4,"rt":$n[2].List$1(Spine.AtlasRegion),"sn":"repackedRegions","ro":true},{"a":1,"n":"texturesToPackAtParam","is":true,"t":4,"rt":System.Array.type(System.Collections.Generic.List$1(UnityEngine.Texture2D)),"sn":"texturesToPackAtParam"}]}; }, $n);
    /*Spine.Unity.AttachmentTools.AtlasUtilities end.*/

    /*Spine.Unity.AttachmentTools.AtlasUtilities+IntAndAtlasRegionKey start.*/
    $m("Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey", function () { return {"td":$n[12].AtlasUtilities,"att":1048843,"a":1,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[8].AtlasRegion],"pi":[{"n":"i","pt":$n[0].Int32,"ps":0},{"n":"region","pt":$n[8].AtlasRegion,"ps":1}],"sn":"$ctor1"},{"ov":true,"a":2,"n":"GetHashCode","t":8,"sn":"getHashCode","rt":$n[0].Int32,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"i","t":4,"rt":$n[0].Int32,"sn":"i","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"region","t":4,"rt":$n[8].AtlasRegion,"sn":"region"}]}; }, $n);
    /*Spine.Unity.AttachmentTools.AtlasUtilities+IntAndAtlasRegionKey end.*/

    /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions start.*/
    $m("Spine.Unity.AttachmentTools.AttachmentCloneExtensions", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"GetRemappedClone","is":true,"t":8,"pi":[{"n":"o","pt":$n[8].Attachment,"ps":0},{"n":"atlasRegion","pt":$n[8].AtlasRegion,"ps":1},{"n":"cloneMeshAsLinked","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"useOriginalRegionSize","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"scale","dv":0.01,"o":true,"pt":$n[0].Single,"ps":4}],"sn":"GetRemappedClone","rt":$n[8].Attachment,"p":[$n[8].Attachment,$n[8].AtlasRegion,$n[0].Boolean,$n[0].Boolean,$n[0].Single]},{"a":2,"n":"GetRemappedClone","is":true,"t":8,"pi":[{"n":"o","pt":$n[8].Attachment,"ps":0},{"n":"sprite","pt":$n[1].Sprite,"ps":1},{"n":"sourceMaterial","pt":$n[1].Material,"ps":2},{"n":"premultiplyAlpha","dv":true,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"cloneMeshAsLinked","dv":true,"o":true,"pt":$n[0].Boolean,"ps":4},{"n":"useOriginalRegionSize","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5},{"n":"pivotShiftsMeshUVCoords","dv":true,"o":true,"pt":$n[0].Boolean,"ps":6},{"n":"useOriginalRegionScale","dv":false,"o":true,"pt":$n[0].Boolean,"ps":7},{"n":"pmaCloneTextureFormat","dv":4,"o":true,"pt":$n[1].TextureFormat,"ps":8},{"n":"pmaCloneMipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":9}],"sn":"GetRemappedClone$1","rt":$n[8].Attachment,"p":[$n[8].Attachment,$n[1].Sprite,$n[1].Material,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean,$n[1].TextureFormat,$n[0].Boolean]}]}; }, $n);
    /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions end.*/

    /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions start.*/
    $m("Spine.Unity.AttachmentTools.AttachmentRegionExtensions", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"SetPositionOffset","is":true,"t":8,"pi":[{"n":"regionAttachment","pt":$n[8].RegionAttachment,"ps":0},{"n":"offset","pt":$n[1].Vector2,"ps":1}],"sn":"SetPositionOffset$1","rt":$n[0].Void,"p":[$n[8].RegionAttachment,$n[1].Vector2]},{"a":2,"n":"SetPositionOffset","is":true,"t":8,"pi":[{"n":"regionAttachment","pt":$n[8].RegionAttachment,"ps":0},{"n":"x","pt":$n[0].Single,"ps":1},{"n":"y","pt":$n[0].Single,"ps":2}],"sn":"SetPositionOffset","rt":$n[0].Void,"p":[$n[8].RegionAttachment,$n[0].Single,$n[0].Single]},{"a":2,"n":"SetRotation","is":true,"t":8,"pi":[{"n":"regionAttachment","pt":$n[8].RegionAttachment,"ps":0},{"n":"rotation","pt":$n[0].Single,"ps":1}],"sn":"SetRotation","rt":$n[0].Void,"p":[$n[8].RegionAttachment,$n[0].Single]},{"a":2,"n":"SetScale","is":true,"t":8,"pi":[{"n":"regionAttachment","pt":$n[8].RegionAttachment,"ps":0},{"n":"scale","pt":$n[1].Vector2,"ps":1}],"sn":"SetScale$1","rt":$n[0].Void,"p":[$n[8].RegionAttachment,$n[1].Vector2]},{"a":2,"n":"SetScale","is":true,"t":8,"pi":[{"n":"regionAttachment","pt":$n[8].RegionAttachment,"ps":0},{"n":"x","pt":$n[0].Single,"ps":1},{"n":"y","pt":$n[0].Single,"ps":2}],"sn":"SetScale","rt":$n[0].Void,"p":[$n[8].RegionAttachment,$n[0].Single,$n[0].Single]},{"a":2,"n":"ToRegionAttachment","is":true,"t":8,"pi":[{"n":"sprite","pt":$n[1].Sprite,"ps":0},{"n":"page","pt":$n[8].AtlasPage,"ps":1},{"n":"rotation","dv":0.0,"o":true,"pt":$n[0].Single,"ps":2}],"sn":"ToRegionAttachment$1","rt":$n[8].RegionAttachment,"p":[$n[1].Sprite,$n[8].AtlasPage,$n[0].Single]},{"a":2,"n":"ToRegionAttachment","is":true,"t":8,"pi":[{"n":"sprite","pt":$n[1].Sprite,"ps":0},{"n":"material","pt":$n[1].Material,"ps":1},{"n":"rotation","dv":0.0,"o":true,"pt":$n[0].Single,"ps":2}],"sn":"ToRegionAttachment$2","rt":$n[8].RegionAttachment,"p":[$n[1].Sprite,$n[1].Material,$n[0].Single]},{"a":2,"n":"ToRegionAttachment","is":true,"t":8,"pi":[{"n":"region","pt":$n[8].AtlasRegion,"ps":0},{"n":"attachmentName","pt":$n[0].String,"ps":1},{"n":"scale","dv":0.01,"o":true,"pt":$n[0].Single,"ps":2},{"n":"rotation","dv":0.0,"o":true,"pt":$n[0].Single,"ps":3}],"sn":"ToRegionAttachment","rt":$n[8].RegionAttachment,"p":[$n[8].AtlasRegion,$n[0].String,$n[0].Single,$n[0].Single]},{"a":2,"n":"ToRegionAttachmentPMAClone","is":true,"t":8,"pi":[{"n":"sprite","pt":$n[1].Sprite,"ps":0},{"n":"materialPropertySource","pt":$n[1].Material,"ps":1},{"n":"textureFormat","dv":4,"o":true,"pt":$n[1].TextureFormat,"ps":2},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"rotation","dv":0.0,"o":true,"pt":$n[0].Single,"ps":4}],"sn":"ToRegionAttachmentPMAClone","rt":$n[8].RegionAttachment,"p":[$n[1].Sprite,$n[1].Material,$n[1].TextureFormat,$n[0].Boolean,$n[0].Single]},{"a":2,"n":"ToRegionAttachmentPMAClone","is":true,"t":8,"pi":[{"n":"sprite","pt":$n[1].Sprite,"ps":0},{"n":"shader","pt":$n[1].Shader,"ps":1},{"n":"textureFormat","dv":4,"o":true,"pt":$n[1].TextureFormat,"ps":2},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"materialPropertySource","dv":null,"o":true,"pt":$n[1].Material,"ps":4},{"n":"rotation","dv":0.0,"o":true,"pt":$n[0].Single,"ps":5}],"sn":"ToRegionAttachmentPMAClone$1","rt":$n[8].RegionAttachment,"p":[$n[1].Sprite,$n[1].Shader,$n[1].TextureFormat,$n[0].Boolean,$n[1].Material,$n[0].Single]}]}; }, $n);
    /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions end.*/

    /*DG.Tweening.DOTweenModuleAudio start.*/
    $m("DG.Tweening.DOTweenModuleAudio", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOComplete","is":true,"t":8,"pi":[{"n":"target","pt":$n[13].AudioMixer,"ps":0},{"n":"withCallbacks","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"DOComplete","rt":$n[0].Int32,"p":[$n[13].AudioMixer,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].AudioSource,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade","rt":$n[14].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[1].AudioSource,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFlip","is":true,"t":8,"pi":[{"n":"target","pt":$n[13].AudioMixer,"ps":0}],"sn":"DOFlip","rt":$n[0].Int32,"p":[$n[13].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOGoto","is":true,"t":8,"pi":[{"n":"target","pt":$n[13].AudioMixer,"ps":0},{"n":"to","pt":$n[0].Single,"ps":1},{"n":"andPlay","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"DOGoto","rt":$n[0].Int32,"p":[$n[13].AudioMixer,$n[0].Single,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOKill","is":true,"t":8,"pi":[{"n":"target","pt":$n[13].AudioMixer,"ps":0},{"n":"complete","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"DOKill","rt":$n[0].Int32,"p":[$n[13].AudioMixer,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOPause","is":true,"t":8,"pi":[{"n":"target","pt":$n[13].AudioMixer,"ps":0}],"sn":"DOPause","rt":$n[0].Int32,"p":[$n[13].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOPitch","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].AudioSource,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOPitch","rt":$n[14].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[1].AudioSource,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOPlay","is":true,"t":8,"pi":[{"n":"target","pt":$n[13].AudioMixer,"ps":0}],"sn":"DOPlay","rt":$n[0].Int32,"p":[$n[13].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOPlayBackwards","is":true,"t":8,"pi":[{"n":"target","pt":$n[13].AudioMixer,"ps":0}],"sn":"DOPlayBackwards","rt":$n[0].Int32,"p":[$n[13].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOPlayForward","is":true,"t":8,"pi":[{"n":"target","pt":$n[13].AudioMixer,"ps":0}],"sn":"DOPlayForward","rt":$n[0].Int32,"p":[$n[13].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DORestart","is":true,"t":8,"pi":[{"n":"target","pt":$n[13].AudioMixer,"ps":0}],"sn":"DORestart","rt":$n[0].Int32,"p":[$n[13].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DORewind","is":true,"t":8,"pi":[{"n":"target","pt":$n[13].AudioMixer,"ps":0}],"sn":"DORewind","rt":$n[0].Int32,"p":[$n[13].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOSetFloat","is":true,"t":8,"pi":[{"n":"target","pt":$n[13].AudioMixer,"ps":0},{"n":"floatName","pt":$n[0].String,"ps":1},{"n":"endValue","pt":$n[0].Single,"ps":2},{"n":"duration","pt":$n[0].Single,"ps":3}],"sn":"DOSetFloat","rt":$n[14].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[13].AudioMixer,$n[0].String,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOSmoothRewind","is":true,"t":8,"pi":[{"n":"target","pt":$n[13].AudioMixer,"ps":0}],"sn":"DOSmoothRewind","rt":$n[0].Int32,"p":[$n[13].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOTogglePause","is":true,"t":8,"pi":[{"n":"target","pt":$n[13].AudioMixer,"ps":0}],"sn":"DOTogglePause","rt":$n[0].Int32,"p":[$n[13].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*DG.Tweening.DOTweenModuleAudio end.*/

    /*DG.Tweening.DOTweenModulePhysics start.*/
    $m("DG.Tweening.DOTweenModulePhysics", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOJump","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody,"ps":0},{"n":"endValue","pt":$n[1].Vector3,"ps":1},{"n":"jumpPower","pt":$n[0].Single,"ps":2},{"n":"numJumps","pt":$n[0].Int32,"ps":3},{"n":"duration","pt":$n[0].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"DOJump","rt":$n[15].Sequence,"p":[$n[1].Rigidbody,$n[1].Vector3,$n[0].Single,$n[0].Int32,$n[0].Single,$n[0].Boolean]},{"a":4,"n":"DOLocalPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody,"ps":0},{"n":"path","pt":$n[16].Path,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"pathMode","dv":1,"o":true,"pt":$n[15].PathMode,"ps":3}],"sn":"DOLocalPath$1","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[1].Rigidbody,$n[16].Path,$n[0].Single,$n[15].PathMode]},{"a":2,"n":"DOLocalPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody,"ps":0},{"n":"path","pt":System.Array.type(UnityEngine.Vector3),"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"pathType","dv":0,"o":true,"pt":$n[15].PathType,"ps":3},{"n":"pathMode","dv":1,"o":true,"pt":$n[15].PathMode,"ps":4},{"n":"resolution","dv":10,"o":true,"pt":$n[0].Int32,"ps":5},{"n":"gizmoColor","dv":null,"o":true,"pt":$n[0].Nullable$1(UnityEngine.Color),"ps":6}],"sn":"DOLocalPath","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[1].Rigidbody,System.Array.type(UnityEngine.Vector3),$n[0].Single,$n[15].PathType,$n[15].PathMode,$n[0].Int32,$n[0].Nullable$1(UnityEngine.Color)]},{"a":2,"n":"DOLookAt","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody,"ps":0},{"n":"towards","pt":$n[1].Vector3,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"axisConstraint","dv":0,"o":true,"pt":$n[15].AxisConstraint,"ps":3},{"n":"up","dv":null,"o":true,"pt":$n[0].Nullable$1(UnityEngine.Vector3),"ps":4}],"sn":"DOLookAt","rt":$n[14].TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions),"p":[$n[1].Rigidbody,$n[1].Vector3,$n[0].Single,$n[15].AxisConstraint,$n[0].Nullable$1(UnityEngine.Vector3)]},{"a":2,"n":"DOMove","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody,"ps":0},{"n":"endValue","pt":$n[1].Vector3,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMove","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].Rigidbody,$n[1].Vector3,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOMoveX","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMoveX","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].Rigidbody,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOMoveY","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMoveY","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].Rigidbody,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOMoveZ","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMoveZ","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].Rigidbody,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":4,"n":"DOPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody,"ps":0},{"n":"path","pt":$n[16].Path,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"pathMode","dv":1,"o":true,"pt":$n[15].PathMode,"ps":3}],"sn":"DOPath$1","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[1].Rigidbody,$n[16].Path,$n[0].Single,$n[15].PathMode]},{"a":2,"n":"DOPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody,"ps":0},{"n":"path","pt":System.Array.type(UnityEngine.Vector3),"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"pathType","dv":0,"o":true,"pt":$n[15].PathType,"ps":3},{"n":"pathMode","dv":1,"o":true,"pt":$n[15].PathMode,"ps":4},{"n":"resolution","dv":10,"o":true,"pt":$n[0].Int32,"ps":5},{"n":"gizmoColor","dv":null,"o":true,"pt":$n[0].Nullable$1(UnityEngine.Color),"ps":6}],"sn":"DOPath","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[1].Rigidbody,System.Array.type(UnityEngine.Vector3),$n[0].Single,$n[15].PathType,$n[15].PathMode,$n[0].Int32,$n[0].Nullable$1(UnityEngine.Color)]},{"a":2,"n":"DORotate","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody,"ps":0},{"n":"endValue","pt":$n[1].Vector3,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"mode","dv":0,"o":true,"pt":$n[15].RotateMode,"ps":3}],"sn":"DORotate","rt":$n[14].TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions),"p":[$n[1].Rigidbody,$n[1].Vector3,$n[0].Single,$n[15].RotateMode]}]}; }, $n);
    /*DG.Tweening.DOTweenModulePhysics end.*/

    /*DG.Tweening.DOTweenModulePhysics2D start.*/
    $m("DG.Tweening.DOTweenModulePhysics2D", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOJump","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody2D,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"jumpPower","pt":$n[0].Single,"ps":2},{"n":"numJumps","pt":$n[0].Int32,"ps":3},{"n":"duration","pt":$n[0].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"DOJump","rt":$n[15].Sequence,"p":[$n[1].Rigidbody2D,$n[1].Vector2,$n[0].Single,$n[0].Int32,$n[0].Single,$n[0].Boolean]},{"a":4,"n":"DOLocalPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody2D,"ps":0},{"n":"path","pt":$n[16].Path,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"pathMode","dv":1,"o":true,"pt":$n[15].PathMode,"ps":3}],"sn":"DOLocalPath$1","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[1].Rigidbody2D,$n[16].Path,$n[0].Single,$n[15].PathMode]},{"a":2,"n":"DOLocalPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody2D,"ps":0},{"n":"path","pt":System.Array.type(UnityEngine.Vector2),"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"pathType","dv":0,"o":true,"pt":$n[15].PathType,"ps":3},{"n":"pathMode","dv":1,"o":true,"pt":$n[15].PathMode,"ps":4},{"n":"resolution","dv":10,"o":true,"pt":$n[0].Int32,"ps":5},{"n":"gizmoColor","dv":null,"o":true,"pt":$n[0].Nullable$1(UnityEngine.Color),"ps":6}],"sn":"DOLocalPath","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[1].Rigidbody2D,System.Array.type(UnityEngine.Vector2),$n[0].Single,$n[15].PathType,$n[15].PathMode,$n[0].Int32,$n[0].Nullable$1(UnityEngine.Color)]},{"a":2,"n":"DOMove","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody2D,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMove","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].Rigidbody2D,$n[1].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOMoveX","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody2D,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMoveX","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].Rigidbody2D,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOMoveY","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody2D,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMoveY","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].Rigidbody2D,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":4,"n":"DOPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody2D,"ps":0},{"n":"path","pt":$n[16].Path,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"pathMode","dv":1,"o":true,"pt":$n[15].PathMode,"ps":3}],"sn":"DOPath$1","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[1].Rigidbody2D,$n[16].Path,$n[0].Single,$n[15].PathMode]},{"a":2,"n":"DOPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody2D,"ps":0},{"n":"path","pt":System.Array.type(UnityEngine.Vector2),"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"pathType","dv":0,"o":true,"pt":$n[15].PathType,"ps":3},{"n":"pathMode","dv":1,"o":true,"pt":$n[15].PathMode,"ps":4},{"n":"resolution","dv":10,"o":true,"pt":$n[0].Int32,"ps":5},{"n":"gizmoColor","dv":null,"o":true,"pt":$n[0].Nullable$1(UnityEngine.Color),"ps":6}],"sn":"DOPath","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[1].Rigidbody2D,System.Array.type(UnityEngine.Vector2),$n[0].Single,$n[15].PathType,$n[15].PathMode,$n[0].Int32,$n[0].Nullable$1(UnityEngine.Color)]},{"a":2,"n":"DORotate","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody2D,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DORotate","rt":$n[14].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[1].Rigidbody2D,$n[0].Single,$n[0].Single]}]}; }, $n);
    /*DG.Tweening.DOTweenModulePhysics2D end.*/

    /*DG.Tweening.DOTweenModuleSprite start.*/
    $m("DG.Tweening.DOTweenModuleSprite", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOBlendableColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].SpriteRenderer,"ps":0},{"n":"endValue","pt":$n[1].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOBlendableColor","rt":$n[15].Tweener,"p":[$n[1].SpriteRenderer,$n[1].Color,$n[0].Single]},{"a":2,"n":"DOColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].SpriteRenderer,"ps":0},{"n":"endValue","pt":$n[1].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOColor","rt":$n[14].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[1].SpriteRenderer,$n[1].Color,$n[0].Single]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].SpriteRenderer,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade","rt":$n[14].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[1].SpriteRenderer,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOGradientColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].SpriteRenderer,"ps":0},{"n":"gradient","pt":pc.ColorGradient,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOGradientColor","rt":$n[15].Sequence,"p":[$n[1].SpriteRenderer,pc.ColorGradient,$n[0].Single]}]}; }, $n);
    /*DG.Tweening.DOTweenModuleSprite end.*/

    /*DG.Tweening.DOTweenModuleUI start.*/
    $m("DG.Tweening.DOTweenModuleUI", function () { return {"nested":[$n[15].DOTweenModuleUI.Utils],"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOAnchorMax","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorMax","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[1].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorMin","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorMin","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[1].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPos","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[1].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPos3D","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[1].Vector3,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPos3D","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[1].Vector3,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPos3DX","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPos3DX","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPos3DY","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPos3DY","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPos3DZ","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPos3DZ","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPosX","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPosX","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPosY","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPosY","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOBlendableColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Graphic,"ps":0},{"n":"endValue","pt":$n[1].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOBlendableColor","rt":$n[15].Tweener,"p":[$n[4].Graphic,$n[1].Color,$n[0].Single]},{"a":2,"n":"DOBlendableColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Image,"ps":0},{"n":"endValue","pt":$n[1].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOBlendableColor$1","rt":$n[15].Tweener,"p":[$n[4].Image,$n[1].Color,$n[0].Single]},{"a":2,"n":"DOBlendableColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Text,"ps":0},{"n":"endValue","pt":$n[1].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOBlendableColor$2","rt":$n[15].Tweener,"p":[$n[4].Text,$n[1].Color,$n[0].Single]},{"a":2,"n":"DOColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Graphic,"ps":0},{"n":"endValue","pt":$n[1].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOColor","rt":$n[14].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[4].Graphic,$n[1].Color,$n[0].Single]},{"a":2,"n":"DOColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Image,"ps":0},{"n":"endValue","pt":$n[1].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOColor$1","rt":$n[14].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[4].Image,$n[1].Color,$n[0].Single]},{"a":2,"n":"DOColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Outline,"ps":0},{"n":"endValue","pt":$n[1].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOColor$2","rt":$n[14].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[4].Outline,$n[1].Color,$n[0].Single]},{"a":2,"n":"DOColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Text,"ps":0},{"n":"endValue","pt":$n[1].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOColor$3","rt":$n[14].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[4].Text,$n[1].Color,$n[0].Single]},{"a":2,"n":"DOCounter","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Text,"ps":0},{"n":"fromValue","pt":$n[0].Int32,"ps":1},{"n":"endValue","pt":$n[0].Int32,"ps":2},{"n":"duration","pt":$n[0].Single,"ps":3},{"n":"addThousandsSeparator","dv":true,"o":true,"pt":$n[0].Boolean,"ps":4},{"n":"culture","dv":null,"o":true,"pt":$n[17].CultureInfo,"ps":5}],"sn":"DOCounter","rt":$n[14].TweenerCore$3(System.Int32,System.Int32,DG.Tweening.Plugins.Options.NoOptions),"p":[$n[4].Text,$n[0].Int32,$n[0].Int32,$n[0].Single,$n[0].Boolean,$n[17].CultureInfo]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].CanvasGroup,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade","rt":$n[14].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[1].CanvasGroup,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Graphic,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade$1","rt":$n[14].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[4].Graphic,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Image,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade$2","rt":$n[14].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[4].Image,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Outline,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade$3","rt":$n[14].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[4].Outline,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Text,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade$4","rt":$n[14].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[4].Text,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFillAmount","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Image,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFillAmount","rt":$n[14].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[4].Image,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFlexibleSize","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].LayoutElement,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOFlexibleSize","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[4].LayoutElement,$n[1].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOGradientColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Image,"ps":0},{"n":"gradient","pt":pc.ColorGradient,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOGradientColor","rt":$n[15].Sequence,"p":[$n[4].Image,pc.ColorGradient,$n[0].Single]},{"a":2,"n":"DOHorizontalNormalizedPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].ScrollRect,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOHorizontalNormalizedPos","rt":$n[15].Tweener,"p":[$n[4].ScrollRect,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOJumpAnchorPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"jumpPower","pt":$n[0].Single,"ps":2},{"n":"numJumps","pt":$n[0].Int32,"ps":3},{"n":"duration","pt":$n[0].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"DOJumpAnchorPos","rt":$n[15].Sequence,"p":[$n[1].RectTransform,$n[1].Vector2,$n[0].Single,$n[0].Int32,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOMinSize","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].LayoutElement,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMinSize","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[4].LayoutElement,$n[1].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DONormalizedPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].ScrollRect,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DONormalizedPos","rt":$n[15].Tweener,"p":[$n[4].ScrollRect,$n[1].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOPivot","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOPivot","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[1].Vector2,$n[0].Single]},{"a":2,"n":"DOPivotX","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOPivotX","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOPivotY","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOPivotY","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOPreferredSize","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].LayoutElement,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOPreferredSize","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[4].LayoutElement,$n[1].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOPunchAnchorPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"punch","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"vibrato","dv":10,"o":true,"pt":$n[0].Int32,"ps":3},{"n":"elasticity","dv":1.0,"o":true,"pt":$n[0].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"DOPunchAnchorPos","rt":$n[15].Tweener,"p":[$n[1].RectTransform,$n[1].Vector2,$n[0].Single,$n[0].Int32,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOScale","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Outline,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOScale","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[4].Outline,$n[1].Vector2,$n[0].Single]},{"a":2,"n":"DOShakeAnchorPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"duration","pt":$n[0].Single,"ps":1},{"n":"strength","dv":100.0,"o":true,"pt":$n[0].Single,"ps":2},{"n":"vibrato","dv":10,"o":true,"pt":$n[0].Int32,"ps":3},{"n":"randomness","dv":90.0,"o":true,"pt":$n[0].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5},{"n":"fadeOut","dv":true,"o":true,"pt":$n[0].Boolean,"ps":6},{"n":"randomnessMode","dv":0,"o":true,"pt":$n[15].ShakeRandomnessMode,"ps":7}],"sn":"DOShakeAnchorPos","rt":$n[15].Tweener,"p":[$n[1].RectTransform,$n[0].Single,$n[0].Single,$n[0].Int32,$n[0].Single,$n[0].Boolean,$n[0].Boolean,$n[15].ShakeRandomnessMode]},{"a":2,"n":"DOShakeAnchorPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"duration","pt":$n[0].Single,"ps":1},{"n":"strength","pt":$n[1].Vector2,"ps":2},{"n":"vibrato","dv":10,"o":true,"pt":$n[0].Int32,"ps":3},{"n":"randomness","dv":90.0,"o":true,"pt":$n[0].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5},{"n":"fadeOut","dv":true,"o":true,"pt":$n[0].Boolean,"ps":6},{"n":"randomnessMode","dv":0,"o":true,"pt":$n[15].ShakeRandomnessMode,"ps":7}],"sn":"DOShakeAnchorPos$1","rt":$n[15].Tweener,"p":[$n[1].RectTransform,$n[0].Single,$n[1].Vector2,$n[0].Int32,$n[0].Single,$n[0].Boolean,$n[0].Boolean,$n[15].ShakeRandomnessMode]},{"a":2,"n":"DOShapeCircle","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"center","pt":$n[1].Vector2,"ps":1},{"n":"endValueDegrees","pt":$n[0].Single,"ps":2},{"n":"duration","pt":$n[0].Single,"ps":3},{"n":"relativeCenter","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"DOShapeCircle","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.CircleOptions),"p":[$n[1].RectTransform,$n[1].Vector2,$n[0].Single,$n[0].Single,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"DOSizeDelta","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOSizeDelta","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[1].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOText","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Text,"ps":0},{"n":"endValue","pt":$n[0].String,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"richTextEnabled","dv":true,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"scrambleMode","dv":0,"o":true,"pt":$n[15].ScrambleMode,"ps":4},{"n":"scrambleChars","dv":null,"o":true,"pt":$n[0].String,"ps":5}],"sn":"DOText","rt":$n[14].TweenerCore$3(System.String,System.String,DG.Tweening.Plugins.Options.StringOptions),"p":[$n[4].Text,$n[0].String,$n[0].Single,$n[0].Boolean,$n[15].ScrambleMode,$n[0].String]},{"a":2,"n":"DOValue","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].Slider,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOValue","rt":$n[14].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[4].Slider,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOVerticalNormalizedPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[4].ScrollRect,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOVerticalNormalizedPos","rt":$n[15].Tweener,"p":[$n[4].ScrollRect,$n[0].Single,$n[0].Single,$n[0].Boolean]}]}; }, $n);
    /*DG.Tweening.DOTweenModuleUI end.*/

    /*DG.Tweening.DOTweenModuleUI+Utils start.*/
    $m("DG.Tweening.DOTweenModuleUI.Utils", function () { return {"td":$n[15].DOTweenModuleUI,"att":1048962,"a":2,"s":true,"m":[{"a":2,"n":"SwitchToRectTransform","is":true,"t":8,"pi":[{"n":"from","pt":$n[1].RectTransform,"ps":0},{"n":"to","pt":$n[1].RectTransform,"ps":1}],"sn":"SwitchToRectTransform","rt":$n[1].Vector2,"p":[$n[1].RectTransform,$n[1].RectTransform]}]}; }, $n);
    /*DG.Tweening.DOTweenModuleUI+Utils end.*/

    /*DG.Tweening.DOTweenModuleUnityVersion start.*/
    $m("DG.Tweening.DOTweenModuleUnityVersion", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOGradientColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Material,"ps":0},{"n":"gradient","pt":pc.ColorGradient,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOGradientColor","rt":$n[15].Sequence,"p":[$n[1].Material,pc.ColorGradient,$n[0].Single]},{"a":2,"n":"DOGradientColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Material,"ps":0},{"n":"gradient","pt":pc.ColorGradient,"ps":1},{"n":"property","pt":$n[0].String,"ps":2},{"n":"duration","pt":$n[0].Single,"ps":3}],"sn":"DOGradientColor$1","rt":$n[15].Sequence,"p":[$n[1].Material,pc.ColorGradient,$n[0].String,$n[0].Single]},{"a":2,"n":"DOOffset","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Material,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"propertyID","pt":$n[0].Int32,"ps":2},{"n":"duration","pt":$n[0].Single,"ps":3}],"sn":"DOOffset","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].Material,$n[1].Vector2,$n[0].Int32,$n[0].Single]},{"a":2,"n":"DOTiling","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Material,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"propertyID","pt":$n[0].Int32,"ps":2},{"n":"duration","pt":$n[0].Single,"ps":3}],"sn":"DOTiling","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].Material,$n[1].Vector2,$n[0].Int32,$n[0].Single]},{"a":2,"n":"WaitForCompletion","is":true,"t":8,"pi":[{"n":"t","pt":$n[15].Tween,"ps":0},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":1}],"sn":"WaitForCompletion","rt":$n[1].CustomYieldInstruction,"p":[$n[15].Tween,$n[0].Boolean]},{"a":2,"n":"WaitForElapsedLoops","is":true,"t":8,"pi":[{"n":"t","pt":$n[15].Tween,"ps":0},{"n":"elapsedLoops","pt":$n[0].Int32,"ps":1},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":2}],"sn":"WaitForElapsedLoops","rt":$n[1].CustomYieldInstruction,"p":[$n[15].Tween,$n[0].Int32,$n[0].Boolean]},{"a":2,"n":"WaitForKill","is":true,"t":8,"pi":[{"n":"t","pt":$n[15].Tween,"ps":0},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":1}],"sn":"WaitForKill","rt":$n[1].CustomYieldInstruction,"p":[$n[15].Tween,$n[0].Boolean]},{"a":2,"n":"WaitForPosition","is":true,"t":8,"pi":[{"n":"t","pt":$n[15].Tween,"ps":0},{"n":"position","pt":$n[0].Single,"ps":1},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":2}],"sn":"WaitForPosition","rt":$n[1].CustomYieldInstruction,"p":[$n[15].Tween,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"WaitForRewind","is":true,"t":8,"pi":[{"n":"t","pt":$n[15].Tween,"ps":0},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":1}],"sn":"WaitForRewind","rt":$n[1].CustomYieldInstruction,"p":[$n[15].Tween,$n[0].Boolean]},{"a":2,"n":"WaitForStart","is":true,"t":8,"pi":[{"n":"t","pt":$n[15].Tween,"ps":0},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":1}],"sn":"WaitForStart","rt":$n[1].CustomYieldInstruction,"p":[$n[15].Tween,$n[0].Boolean]}]}; }, $n);
    /*DG.Tweening.DOTweenModuleUnityVersion end.*/

    /*DG.Tweening.DOTweenCYInstruction start.*/
    $m("DG.Tweening.DOTweenCYInstruction", function () { return {"nested":[$n[15].DOTweenCYInstruction.WaitForCompletion,$n[15].DOTweenCYInstruction.WaitForRewind,$n[15].DOTweenCYInstruction.WaitForKill,$n[15].DOTweenCYInstruction.WaitForElapsedLoops,$n[15].DOTweenCYInstruction.WaitForPosition,$n[15].DOTweenCYInstruction.WaitForStart],"att":1048961,"a":2,"s":true}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForCompletion start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForCompletion", function () { return {"td":$n[15].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[15].Tween],"pi":[{"n":"tween","pt":$n[15].Tween,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"t","t":4,"rt":$n[15].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForCompletion end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForRewind start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForRewind", function () { return {"td":$n[15].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[15].Tween],"pi":[{"n":"tween","pt":$n[15].Tween,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"t","t":4,"rt":$n[15].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForRewind end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForKill start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForKill", function () { return {"td":$n[15].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[15].Tween],"pi":[{"n":"tween","pt":$n[15].Tween,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"t","t":4,"rt":$n[15].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForKill end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForElapsedLoops start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops", function () { return {"td":$n[15].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[15].Tween,$n[0].Int32],"pi":[{"n":"tween","pt":$n[15].Tween,"ps":0},{"n":"elapsedLoops","pt":$n[0].Int32,"ps":1}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"elapsedLoops","t":4,"rt":$n[0].Int32,"sn":"elapsedLoops","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"t","t":4,"rt":$n[15].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForElapsedLoops end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForPosition start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForPosition", function () { return {"td":$n[15].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[15].Tween,$n[0].Single],"pi":[{"n":"tween","pt":$n[15].Tween,"ps":0},{"n":"position","pt":$n[0].Single,"ps":1}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"position","t":4,"rt":$n[0].Single,"sn":"position","ro":true,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"t","t":4,"rt":$n[15].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForPosition end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForStart start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForStart", function () { return {"td":$n[15].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[15].Tween],"pi":[{"n":"tween","pt":$n[15].Tween,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"t","t":4,"rt":$n[15].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForStart end.*/

    /*DG.Tweening.DOTweenModuleUtils start.*/
    $m("DG.Tweening.DOTweenModuleUtils", function () { return {"nested":[$n[15].DOTweenModuleUtils.Physics],"att":1048961,"a":2,"s":true,"m":[{"at":[new UnityEngine.Scripting.PreserveAttribute()],"a":2,"n":"Init","is":true,"t":8,"sn":"Init","rt":$n[0].Void},{"at":[new UnityEngine.Scripting.PreserveAttribute()],"a":1,"n":"Preserver","is":true,"t":8,"sn":"Preserver","rt":$n[0].Void},{"a":1,"n":"_initialized","is":true,"t":4,"rt":$n[0].Boolean,"sn":"_initialized","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*DG.Tweening.DOTweenModuleUtils end.*/

    /*DG.Tweening.DOTweenModuleUtils+Physics start.*/
    $m("DG.Tweening.DOTweenModuleUtils.Physics", function () { return {"td":$n[15].DOTweenModuleUtils,"att":1048962,"a":2,"s":true,"m":[{"at":[new UnityEngine.Scripting.PreserveAttribute()],"a":2,"n":"CreateDOTweenPathTween","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].MonoBehaviour,"ps":0},{"n":"tweenRigidbody","pt":$n[0].Boolean,"ps":1},{"n":"isLocal","pt":$n[0].Boolean,"ps":2},{"n":"path","pt":$n[16].Path,"ps":3},{"n":"duration","pt":$n[0].Single,"ps":4},{"n":"pathMode","pt":$n[15].PathMode,"ps":5}],"sn":"CreateDOTweenPathTween","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[1].MonoBehaviour,$n[0].Boolean,$n[0].Boolean,$n[16].Path,$n[0].Single,$n[15].PathMode]},{"at":[new UnityEngine.Scripting.PreserveAttribute()],"a":2,"n":"HasRigidbody","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Component,"ps":0}],"sn":"HasRigidbody","rt":$n[0].Boolean,"p":[$n[1].Component],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"HasRigidbody2D","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Component,"ps":0}],"sn":"HasRigidbody2D","rt":$n[0].Boolean,"p":[$n[1].Component],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"SetOrientationOnPath","is":true,"t":8,"pi":[{"n":"options","pt":$n[18].PathOptions,"ps":0},{"n":"t","pt":$n[15].Tween,"ps":1},{"n":"newRot","pt":$n[1].Quaternion,"ps":2},{"n":"trans","pt":$n[1].Transform,"ps":3}],"sn":"SetOrientationOnPath","rt":$n[0].Void,"p":[$n[18].PathOptions,$n[15].Tween,$n[1].Quaternion,$n[1].Transform]}]}; }, $n);
    /*DG.Tweening.DOTweenModuleUtils+Physics end.*/

    }});
